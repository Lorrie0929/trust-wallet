(() => {
  var t, e, r = {
      143: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha224 = e.sha256 = void 0;
        const n = r(54050),
          i = r(17412),
          o = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
          s = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
          a = new Uint32Array(64);
        class u extends n.HashMD {
          constructor() {
            super(64, 32, 8, !1), this.A = 0 | s[0], this.B = 0 | s[1], this.C = 0 | s[2], this.D = 0 | s[3], this.E = 0 | s[4], this.F = 0 | s[5], this.G = 0 | s[6], this.H = 0 | s[7]
          }
          get() {
            const {
              A: t,
              B: e,
              C: r,
              D: n,
              E: i,
              F: o,
              G: s,
              H: a
            } = this;
            return [t, e, r, n, i, o, s, a]
          }
          set(t, e, r, n, i, o, s, a) {
            this.A = 0 | t, this.B = 0 | e, this.C = 0 | r, this.D = 0 | n, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
          }
          process(t, e) {
            for (let r = 0; 16 > r; r++, e += 4) a[r] = t.getUint32(e, !1);
            for (let t = 16; 64 > t; t++) {
              const e = a[t - 15],
                r = a[t - 2],
                n = (0, i.rotr)(e, 7) ^ (0, i.rotr)(e, 18) ^ e >>> 3,
                o = (0, i.rotr)(r, 17) ^ (0, i.rotr)(r, 19) ^ r >>> 10;
              a[t] = o + a[t - 7] + n + a[t - 16] | 0
            }
            let {
              A: r,
              B: s,
              C: u,
              D: c,
              E: f,
              F: l,
              G: h,
              H: d
            } = this;
            for (let t = 0; 64 > t; t++) {
              const e = d + ((0, i.rotr)(f, 6) ^ (0, i.rotr)(f, 11) ^ (0, i.rotr)(f, 25)) + (0, n.Chi)(f, l, h) + o[t] + a[t] | 0,
                p = ((0, i.rotr)(r, 2) ^ (0, i.rotr)(r, 13) ^ (0, i.rotr)(r, 22)) + (0, n.Maj)(r, s, u) | 0;
              d = h, h = l, l = f, f = c + e | 0, c = u, u = s, s = r, r = e + p | 0
            }
            r = r + this.A | 0, s = s + this.B | 0, u = u + this.C | 0, c = c + this.D | 0, f = f + this.E | 0, l = l + this.F | 0, h = h + this.G | 0, d = d + this.H | 0, this.set(r, s, u, c, f, l, h, d)
          }
          roundClean() {
            a.fill(0)
          }
          destroy() {
            this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
          }
        }
        class c extends u {
          constructor() {
            super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28
          }
        }
        e.sha256 = (0, i.wrapConstructor)(() => new u), e.sha224 = (0, i.wrapConstructor)(() => new c)
      },
      251: (t, e) => {
        e.read = function(t, e, r, n, i) {
          var o, s, a = 8 * i - n - 1,
            u = (1 << a) - 1,
            c = u >> 1,
            f = -7,
            l = r ? i - 1 : 0,
            h = r ? -1 : 1,
            d = t[e + l];
          for (l += h, o = d & (1 << -f) - 1, d >>= -f, f += a; f > 0; o = 256 * o + t[e + l], l += h, f -= 8);
          for (s = o & (1 << -f) - 1, o >>= -f, f += n; f > 0; s = 256 * s + t[e + l], l += h, f -= 8);
          if (0 === o) o = 1 - c;
          else {
            if (o === u) return s ? NaN : 1 / 0 * (d ? -1 : 1);
            s += Math.pow(2, n), o -= c
          }
          return (d ? -1 : 1) * s * Math.pow(2, o - n)
        }, e.write = function(t, e, r, n, i, o) {
          var s, a, u, c = 8 * o - i - 1,
            f = (1 << c) - 1,
            l = f >> 1,
            h = 23 === i ? 5.960464477539062e-8 : 0,
            d = n ? 0 : o - 1,
            p = n ? 1 : -1,
            b = 0 > e || 0 === e && 0 > 1 / e ? 1 : 0;
          for (isNaN(e = Math.abs(e)) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, s = f) : (1 > e * (u = Math.pow(2, -(s = Math.floor(Math.log(e) / Math.LN2)))) && (s--, u *= 2), (e += 1 > s + l ? h * Math.pow(2, 1 - l) : h / u) * u >= 2 && (s++, u /= 2), f > s + l ? 1 > s + l ? (a = e * Math.pow(2, l - 1) * Math.pow(2, i), s = 0) : (a = (e * u - 1) * Math.pow(2, i), s += l) : (a = 0, s = f)); i >= 8; t[r + d] = 255 & a, d += p, a /= 256, i -= 8);
          for (s = s << i | a, c += i; c > 0; t[r + d] = 255 & s, d += p, s /= 256, c -= 8);
          t[r + d - p] |= 128 * b
        }
      },
      270: (t, e, r) => {
        const n = r(53908),
          i = r(78311);
        t.exports = (t, e, r) => {
          let o = null,
            s = null,
            a = null;
          try {
            a = new i(e, r)
          } catch {
            return null
          }
          return t.forEach(t => {
            a.test(t) && (!o || 1 === s.compare(t)) && (o = t, s = new n(o, r))
          }), o
        }
      },
      410: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), t.replace(RegExp("[".concat(e, "]+"), "g"), "")
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      457: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.crypto = void 0, e.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0
      },
      464: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionActionPhase = e.loadTransactionActionPhase = void 0;
        const n = r(62312),
          i = r(92577);
        e.loadTransactionActionPhase = function(t) {
          return {
            success: t.loadBit(),
            valid: t.loadBit(),
            noFunds: t.loadBit(),
            statusChange: (0, n.loadAccountStatusChange)(t),
            totalFwdFees: t.loadBit() ? t.loadCoins() : void 0,
            totalActionFees: t.loadBit() ? t.loadCoins() : void 0,
            resultCode: t.loadInt(32),
            resultArg: t.loadBit() ? t.loadInt(32) : void 0,
            totalActions: t.loadUint(16),
            specActions: t.loadUint(16),
            skippedActions: t.loadUint(16),
            messagesCreated: t.loadUint(16),
            actionListHash: t.loadUintBig(256),
            totalMessageSize: (0, i.loadStorageUsed)(t)
          }
        }, e.storeTransactionActionPhase = function(t) {
          return e => {
            e.storeBit(t.success), e.storeBit(t.valid), e.storeBit(t.noFunds), e.store((0, n.storeAccountStatusChange)(t.statusChange)), e.storeMaybeCoins(t.totalFwdFees), e.storeMaybeCoins(t.totalActionFees), e.storeInt(t.resultCode, 32), e.storeMaybeInt(t.resultArg, 32), e.storeUint(t.totalActions, 16), e.storeUint(t.specActions, 16), e.storeUint(t.skippedActions, 16), e.storeUint(t.messagesCreated, 16), e.storeUint(t.actionListHash, 256), e.store((0, i.storeStorageUsed)(t.totalMessageSize))
          }
        }
      },
      561: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, n.default)(t);
          var r = e ? "\\x00-\\x09\\x0B\\x0C\\x0E-\\x1F\\x7F" : "\\x00-\\x1F\\x7F";
          return (0, i.default)(t, r)
        };
        var n = o(r(83399)),
          i = o(r(410));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      601: (t, e, r) => {
        "use strict";
        e.I0 = e.DH = e.NX = e.u8 = e.cY = void 0, e.av = e.O6 = e.w3 = e.Wg = void 0;
        const n = r(48287);

        function i(t) {
          if (!(t instanceof Uint8Array)) throw new TypeError("b must be a Uint8Array")
        }

        function o(t) {
          return i(t), n.Buffer.from(t.buffer, t.byteOffset, t.length)
        }
        class s {
          constructor(t, e) {
            if (!Number.isInteger(t)) throw new TypeError("span must be an integer");
            this.span = t, this.property = e
          }
          makeDestinationObject() {
            return {}
          }
          getSpan(t, e) {
            if (0 > this.span) throw new RangeError("indeterminate span");
            return this.span
          }
          replicate(t) {
            const e = Object.create(this.constructor.prototype);
            return Object.assign(e, this), e.property = t, e
          }
          fromArray(t) {}
        }
        class a extends s {
          isCount() {
            throw Error("ExternalLayout is abstract")
          }
        }
        class u extends a {
          constructor(t, e = 0, r) {
            if (!(t instanceof s)) throw new TypeError("layout must be a Layout");
            if (!Number.isInteger(e)) throw new TypeError("offset must be integer or undefined");
            super(t.span, r || t.property), this.layout = t, this.offset = e
          }
          isCount() {
            return this.layout instanceof c || this.layout instanceof f
          }
          decode(t, e = 0) {
            return this.layout.decode(t, e + this.offset)
          }
          encode(t, e, r = 0) {
            return this.layout.encode(t, e, r + this.offset)
          }
        }
        class c extends s {
          constructor(t, e) {
            if (super(t, e), this.span > 6) throw new RangeError("span must not exceed 6 bytes")
          }
          decode(t, e = 0) {
            return o(t).readUIntLE(e, this.span)
          }
          encode(t, e, r = 0) {
            return o(e).writeUIntLE(t, r, this.span), this.span
          }
        }
        class f extends s {
          constructor(t, e) {
            if (super(t, e), this.span > 6) throw new RangeError("span must not exceed 6 bytes")
          }
          decode(t, e = 0) {
            return o(t).readUIntBE(e, this.span)
          }
          encode(t, e, r = 0) {
            return o(e).writeUIntBE(t, r, this.span), this.span
          }
        }
        const l = 4294967296;

        function h(t) {
          const e = Math.floor(t / l);
          return {
            hi32: e,
            lo32: t - e * l
          }
        }

        function d(t, e) {
          return t * l + e
        }
        class p extends s {
          constructor(t) {
            super(8, t)
          }
          decode(t, e = 0) {
            const r = o(t),
              n = r.readUInt32LE(e);
            return d(r.readUInt32LE(e + 4), n)
          }
          encode(t, e, r = 0) {
            const n = h(t),
              i = o(e);
            return i.writeUInt32LE(n.lo32, r), i.writeUInt32LE(n.hi32, r + 4), 8
          }
        }
        class b extends s {
          constructor(t) {
            super(8, t)
          }
          decode(t, e = 0) {
            const r = o(t),
              n = r.readUInt32LE(e);
            return d(r.readInt32LE(e + 4), n)
          }
          encode(t, e, r = 0) {
            const n = h(t),
              i = o(e);
            return i.writeUInt32LE(n.lo32, r), i.writeInt32LE(n.hi32, r + 4), 8
          }
        }
        class m extends s {
          constructor(t, e, r) {
            if (!(t instanceof s)) throw new TypeError("elementLayout must be a Layout");
            if (!(e instanceof a && e.isCount() || Number.isInteger(e) && e >= 0)) throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
            let n = -1;
            !(e instanceof a) && t.span > 0 && (n = e * t.span), super(n, r), this.elementLayout = t, this.count = e
          }
          getSpan(t, e = 0) {
            if (this.span >= 0) return this.span;
            let r = 0,
              n = this.count;
            if (n instanceof a && (n = n.decode(t, e)), this.elementLayout.span > 0) r = n * this.elementLayout.span;
            else {
              let i = 0;
              for (; n > i;) r += this.elementLayout.getSpan(t, e + r), ++i
            }
            return r
          }
          decode(t, e = 0) {
            const r = [];
            let n = 0,
              i = this.count;
            for (i instanceof a && (i = i.decode(t, e)); i > n;) r.push(this.elementLayout.decode(t, e)), e += this.elementLayout.getSpan(t, e), n += 1;
            return r
          }
          encode(t, e, r = 0) {
            const n = this.elementLayout,
              i = t.reduce((t, i) => t + n.encode(i, e, r + t), 0);
            return this.count instanceof a && this.count.encode(t.length, e, r), i
          }
        }
        class y extends s {
          constructor(t, e, r) {
            if (!Array.isArray(t) || !t.reduce((t, e) => t && e instanceof s, !0)) throw new TypeError("fields must be array of Layout instances");
            "boolean" == typeof e && void 0 === r && (r = e, e = void 0);
            for (const e of t)
              if (0 > e.span && void 0 === e.property) throw Error("fields cannot contain unnamed variable-length layout");
            let n = -1;
            try {
              n = t.reduce((t, e) => t + e.getSpan(), 0)
            } catch {}
            super(n, e), this.fields = t, this.decodePrefixes = !!r
          }
          getSpan(t, e = 0) {
            if (this.span >= 0) return this.span;
            let r = 0;
            try {
              r = this.fields.reduce((r, n) => {
                const i = n.getSpan(t, e);
                return e += i, r + i
              }, 0)
            } catch {
              throw new RangeError("indeterminate span")
            }
            return r
          }
          decode(t, e = 0) {
            i(t);
            const r = this.makeDestinationObject();
            for (const n of this.fields)
              if (void 0 !== n.property && (r[n.property] = n.decode(t, e)), e += n.getSpan(t, e), this.decodePrefixes && t.length === e) break;
            return r
          }
          encode(t, e, r = 0) {
            const n = r;
            let i = 0,
              o = 0;
            for (const n of this.fields) {
              let s = n.span;
              if (o = s > 0 ? s : 0, void 0 !== n.property) {
                const i = t[n.property];
                void 0 !== i && (o = n.encode(i, e, r), 0 > s && (s = n.getSpan(e, r)))
              }
              i = r, r += s
            }
            return i + o - n
          }
          fromArray(t) {
            const e = this.makeDestinationObject();
            for (const r of this.fields) void 0 !== r.property && t.length > 0 && (e[r.property] = t.shift());
            return e
          }
          layoutFor(t) {
            if ("string" != typeof t) throw new TypeError("property must be string");
            for (const e of this.fields)
              if (e.property === t) return e
          }
          offsetOf(t) {
            if ("string" != typeof t) throw new TypeError("property must be string");
            let e = 0;
            for (const r of this.fields) {
              if (r.property === t) return e;
              0 > r.span ? e = -1 : e >= 0 && (e += r.span)
            }
          }
        }
        class g extends s {
          constructor(t, e) {
            if (!(t instanceof a && t.isCount() || Number.isInteger(t) && t >= 0)) throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
            let r = -1;
            t instanceof a || (r = t), super(r, e), this.length = t
          }
          getSpan(t, e) {
            let r = this.span;
            return 0 > r && (r = this.length.decode(t, e)), r
          }
          decode(t, e = 0) {
            let r = this.span;
            return 0 > r && (r = this.length.decode(t, e)), o(t).slice(e, e + r)
          }
          encode(t, e, r) {
            let n = this.length;
            if (this.length instanceof a && (n = t.length), !(t instanceof Uint8Array && n === t.length)) throw new TypeError(function(t, e) {
              return e.property ? t + "[" + e.property + "]" : t
            }("Blob.encode", this) + " requires (length " + n + ") Uint8Array as src");
            if (r + n > e.length) throw new RangeError("encoding overruns Uint8Array");
            const i = o(t);
            return o(e).write(i.toString("hex"), r, n, "hex"), this.length instanceof a && this.length.encode(n, e, r), n
          }
        }
        e.cY = (t, e, r) => new u(t, e, r), e.u8 = t => new c(1, t), e.NX = t => new c(2, t), e.DH = t => new c(4, t), e.I0 = t => new p(t), e.Wg = t => new b(t), e.w3 = (t, e, r) => new y(t, e, r), e.O6 = (t, e, r) => new m(t, e, r), e.av = (t, e) => new g(t, e)
      },
      920: (t, e, r) => {
        "use strict";
        var n = r(69675),
          i = r(58859),
          o = r(14803),
          s = r(80507),
          a = r(72271) || s || o;
        t.exports = function() {
          var t, e = {
            assert: function(t) {
              if (!e.has(t)) throw new n("Side channel does not contain " + i(t))
            },
            delete: function(e) {
              return !!t && t.delete(e)
            },
            get: function(e) {
              return t && t.get(e)
            },
            has: function(e) {
              return !!t && t.has(e)
            },
            set: function(e, r) {
              t || (t = a()), t.set(e, r)
            }
          };
          return e
        }
      },
      1093: t => {
        "use strict";
        var e = {}.toString;
        t.exports = function(t) {
          var r = e.call(t),
            n = "[object Arguments]" === r;
          return n || (n = "[object Array]" !== r && null !== t && "object" == typeof t && "number" == typeof t.length && t.length >= 0 && "[object Function]" === e.call(t.callee)), n
        }
      },
      1189: (t, e, r) => {
        "use strict";
        var n = [].slice,
          i = r(1093),
          o = Object.keys,
          s = o ? function(t) {
            return o(t)
          } : r(28875),
          a = Object.keys;
        s.shim = function() {
          if (Object.keys) {
            var t = function() {
              var t = Object.keys(arguments);
              return t && t.length === arguments.length
            }(1, 2);
            t || (Object.keys = function(t) {
              return i(t) ? a(n.call(t)) : a(t)
            })
          } else Object.keys = s;
          return Object.keys || s
        }, t.exports = s
      },
      1201: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.number = e.getBigInt = e.assertNumberLength = e.getLength = e.isSigned = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(76291),
          s = /^u?int(?<length>[0-9]*)?$/u;
        e.isSigned = t => !t.startsWith("u"), e.getLength = t => {
          if ("int" === t || "uint" === t) return 256;
          const e = t.match(s);
          (0, n.assert)(e?.groups?.length, new i.ParserError(`Invalid number type. Expected a number type, but received "${t}".`));
          const r = parseInt(e.groups.length, 10);
          return (0, n.assert)(r >= 8 && 256 >= r, new i.ParserError(`Invalid number length. Expected a number between 8 and 256, but received "${t}".`)), (0, n.assert)(r % 8 == 0, new i.ParserError(`Invalid number length. Expected a multiple of 8, but received "${t}".`)), r
        }, e.assertNumberLength = (t, r) => {
          const o = (0, e.getLength)(r),
            s = BigInt(2) ** BigInt(o - ((0, e.isSigned)(r) ? 1 : 0)) - BigInt(1);
          (0, e.isSigned)(r) ? (0, n.assert)(t >= -(s + BigInt(1)) && s >= t, new i.ParserError(`Number "${t}" is out of range for type "${r}".`)) : (0, n.assert)(s >= t, new i.ParserError(`Number "${t}" is out of range for type "${r}".`))
        }, e.getBigInt = t => {
          try {
            return (0, n.createBigInt)(t)
          } catch {
            throw new i.ParserError(`Invalid number. Expected a valid number value, but received "${t}".`)
          }
        }, e.number = {
          isDynamic: !1,
          isType: t => s.test(t),
          getByteLength: () => 32,
          encode({
            type: t,
            buffer: r,
            value: i,
            packed: s
          }) {
            const a = (0, e.getBigInt)(i);
            if ((0, e.assertNumberLength)(a, t), (0, e.isSigned)(t)) {
              if (s) {
                const i = (0, e.getLength)(t) / 8;
                return (0, n.concatBytes)([r, (0, n.signedBigIntToBytes)(a, i)])
              }
              return (0, n.concatBytes)([r, (0, o.padStart)((0, n.signedBigIntToBytes)(a, 32))])
            }
            if (s) {
              const i = (0, e.getLength)(t) / 8;
              return (0, n.concatBytes)([r, (0, o.padStart)((0, n.bigIntToBytes)(a), i)])
            }
            return (0, n.concatBytes)([r, (0, o.padStart)((0, n.bigIntToBytes)(a))])
          },
          decode({
            type: t,
            value: r
          }) {
            const i = r.subarray(0, 32);
            if ((0, e.isSigned)(t)) {
              const r = (0, n.bytesToSignedBigInt)(i);
              return (0, e.assertNumberLength)(r, t), r
            }
            const o = (0, n.bytesToBigInt)(i);
            return (0, e.assertNumberLength)(o, t), o
          }
        }
      },
      1307: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.safeSignVerify = e.safeSign = e.getMethodId = e.base32Encode = e.base32Decode = e.crc32c = e.crc16 = e.fromNano = e.toNano = e.ComputeError = e.openContract = e.TupleBuilder = e.TupleReader = e.serializeTuple = e.parseTuple = e.generateMerkleUpdate = e.generateMerkleProofDirect = e.generateMerkleProof = e.exoticPruned = e.exoticMerkleUpdate = e.convertToMerkleProof = e.exoticMerkleProof = e.Dictionary = e.Cell = e.CellType = e.Slice = e.beginCell = e.Builder = e.BitBuilder = e.BitReader = e.BitString = e.contractAddress = e.ADNLAddress = e.ExternalAddress = e.address = e.Address = void 0;
        var o = r(3512);
        Object.defineProperty(e, "Address", {
          enumerable: !0,
          get: function() {
            return o.Address
          }
        }), Object.defineProperty(e, "address", {
          enumerable: !0,
          get: function() {
            return o.address
          }
        });
        var s = r(71629);
        Object.defineProperty(e, "ExternalAddress", {
          enumerable: !0,
          get: function() {
            return s.ExternalAddress
          }
        });
        var a = r(4061);
        Object.defineProperty(e, "ADNLAddress", {
          enumerable: !0,
          get: function() {
            return a.ADNLAddress
          }
        });
        var u = r(88986);
        Object.defineProperty(e, "contractAddress", {
          enumerable: !0,
          get: function() {
            return u.contractAddress
          }
        });
        var c = r(62386);
        Object.defineProperty(e, "BitString", {
          enumerable: !0,
          get: function() {
            return c.BitString
          }
        });
        var f = r(53528);
        Object.defineProperty(e, "BitReader", {
          enumerable: !0,
          get: function() {
            return f.BitReader
          }
        });
        var l = r(49924);
        Object.defineProperty(e, "BitBuilder", {
          enumerable: !0,
          get: function() {
            return l.BitBuilder
          }
        });
        var h = r(65871);
        Object.defineProperty(e, "Builder", {
          enumerable: !0,
          get: function() {
            return h.Builder
          }
        }), Object.defineProperty(e, "beginCell", {
          enumerable: !0,
          get: function() {
            return h.beginCell
          }
        });
        var d = r(56906);
        Object.defineProperty(e, "Slice", {
          enumerable: !0,
          get: function() {
            return d.Slice
          }
        });
        var p = r(34654);
        Object.defineProperty(e, "CellType", {
          enumerable: !0,
          get: function() {
            return p.CellType
          }
        });
        var b = r(66902);
        Object.defineProperty(e, "Cell", {
          enumerable: !0,
          get: function() {
            return b.Cell
          }
        });
        var m = r(97590);
        Object.defineProperty(e, "Dictionary", {
          enumerable: !0,
          get: function() {
            return m.Dictionary
          }
        });
        var y = r(31459);
        Object.defineProperty(e, "exoticMerkleProof", {
          enumerable: !0,
          get: function() {
            return y.exoticMerkleProof
          }
        }), Object.defineProperty(e, "convertToMerkleProof", {
          enumerable: !0,
          get: function() {
            return y.convertToMerkleProof
          }
        });
        var g = r(91408);
        Object.defineProperty(e, "exoticMerkleUpdate", {
          enumerable: !0,
          get: function() {
            return g.exoticMerkleUpdate
          }
        });
        var v = r(79499);
        Object.defineProperty(e, "exoticPruned", {
          enumerable: !0,
          get: function() {
            return v.exoticPruned
          }
        });
        var w = r(78981);
        Object.defineProperty(e, "generateMerkleProof", {
          enumerable: !0,
          get: function() {
            return w.generateMerkleProof
          }
        }), Object.defineProperty(e, "generateMerkleProofDirect", {
          enumerable: !0,
          get: function() {
            return w.generateMerkleProofDirect
          }
        });
        var A = r(42230);
        Object.defineProperty(e, "generateMerkleUpdate", {
          enumerable: !0,
          get: function() {
            return A.generateMerkleUpdate
          }
        });
        var T = r(21640);
        Object.defineProperty(e, "parseTuple", {
          enumerable: !0,
          get: function() {
            return T.parseTuple
          }
        }), Object.defineProperty(e, "serializeTuple", {
          enumerable: !0,
          get: function() {
            return T.serializeTuple
          }
        });
        var E = r(21155);
        Object.defineProperty(e, "TupleReader", {
          enumerable: !0,
          get: function() {
            return E.TupleReader
          }
        });
        var P = r(44117);
        Object.defineProperty(e, "TupleBuilder", {
          enumerable: !0,
          get: function() {
            return P.TupleBuilder
          }
        }), i(r(73814), e);
        var k = r(84742);
        Object.defineProperty(e, "openContract", {
          enumerable: !0,
          get: function() {
            return k.openContract
          }
        });
        var x = r(55121);
        Object.defineProperty(e, "ComputeError", {
          enumerable: !0,
          get: function() {
            return x.ComputeError
          }
        });
        var I = r(97070);
        Object.defineProperty(e, "toNano", {
          enumerable: !0,
          get: function() {
            return I.toNano
          }
        }), Object.defineProperty(e, "fromNano", {
          enumerable: !0,
          get: function() {
            return I.fromNano
          }
        });
        var S = r(92960);
        Object.defineProperty(e, "crc16", {
          enumerable: !0,
          get: function() {
            return S.crc16
          }
        });
        var O = r(29429);
        Object.defineProperty(e, "crc32c", {
          enumerable: !0,
          get: function() {
            return O.crc32c
          }
        });
        var B = r(53721);
        Object.defineProperty(e, "base32Decode", {
          enumerable: !0,
          get: function() {
            return B.base32Decode
          }
        }), Object.defineProperty(e, "base32Encode", {
          enumerable: !0,
          get: function() {
            return B.base32Encode
          }
        });
        var W = r(65149);
        Object.defineProperty(e, "getMethodId", {
          enumerable: !0,
          get: function() {
            return W.getMethodId
          }
        });
        var M = r(90109);
        Object.defineProperty(e, "safeSign", {
          enumerable: !0,
          get: function() {
            return M.safeSign
          }
        }), Object.defineProperty(e, "safeSignVerify", {
          enumerable: !0,
          get: function() {
            return M.safeSignVerify
          }
        })
      },
      1697: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : o;
          return (0, i.default)(t), e.loose ? a.includes(t.toLowerCase()) : s.includes(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            loose: !1
          },
          s = ["true", "false", "1", "0"],
          a = [].concat(s, ["yes", "no"]);
        t.exports = e.default, t.exports.default = e.default
      },
      2056: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, n.default)(t), 0 === ((e = (0, i.default)(e, s)).ignore_whitespace ? t.trim().length : t.length)
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = {
          ignore_whitespace: !1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      2955: (t, e, r) => {
        "use strict";
        var n, i = r(65606);

        function o(t, e, r) {
          return e = function(t) {
            var e = function(t) {
              if ("object" != typeof t || null === t) return t;
              var e = t[Symbol.toPrimitive];
              if (void 0 !== e) {
                var r = e.call(t, "string");
                if ("object" != typeof r) return r;
                throw new TypeError("@@toPrimitive must return a primitive value.")
              }
              return t + ""
            }(t);
            return "symbol" == typeof e ? e : e + ""
          }(e), e in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : t[e] = r, t
        }
        var s = r(86238),
          a = Symbol("lastResolve"),
          u = Symbol("lastReject"),
          c = Symbol("error"),
          f = Symbol("ended"),
          l = Symbol("lastPromise"),
          h = Symbol("handlePromise"),
          d = Symbol("stream");

        function p(t, e) {
          return {
            value: t,
            done: e
          }
        }

        function b(t) {
          var e = t[a];
          if (null !== e) {
            var r = t[d].read();
            null !== r && (t[l] = null, t[a] = null, t[u] = null, e(p(r, !1)))
          }
        }

        function m(t) {
          i.nextTick(b, t)
        }
        var y = Object.getPrototypeOf(function() {}),
          g = Object.setPrototypeOf((o(n = {
            get stream() {
              return this[d]
            },
            next: function() {
              var t = this,
                e = this[c];
              if (null !== e) return Promise.reject(e);
              if (this[f]) return Promise.resolve(p(void 0, !0));
              if (this[d].destroyed) return new Promise(function(e, r) {
                i.nextTick(function() {
                  t[c] ? r(t[c]) : e(p(void 0, !0))
                })
              });
              var r, n = this[l];
              if (n) r = new Promise(function(t, e) {
                return function(r, n) {
                  t.then(function() {
                    e[f] ? r(p(void 0, !0)) : e[h](r, n)
                  }, n)
                }
              }(n, this));
              else {
                var o = this[d].read();
                if (null !== o) return Promise.resolve(p(o, !1));
                r = new Promise(this[h])
              }
              return this[l] = r, r
            }
          }, Symbol.asyncIterator, function() {
            return this
          }), o(n, "return", function() {
            var t = this;
            return new Promise(function(e, r) {
              t[d].destroy(null, function(t) {
                t ? r(t) : e(p(void 0, !0))
              })
            })
          }), n), y);
        t.exports = function(t) {
          var e, r = Object.create(g, (o(e = {}, d, {
            value: t,
            writable: !0
          }), o(e, a, {
            value: null,
            writable: !0
          }), o(e, u, {
            value: null,
            writable: !0
          }), o(e, c, {
            value: null,
            writable: !0
          }), o(e, f, {
            value: t.rt.endEmitted,
            writable: !0
          }), o(e, h, {
            value: function(t, e) {
              var n = r[d].read();
              n ? (r[l] = null, r[a] = null, r[u] = null, t(p(n, !1))) : (r[a] = t, r[u] = e)
            },
            writable: !0
          }), e));
          return r[l] = null, s(t, function(t) {
            if (t && "ERR_STREAM_PREMATURE_CLOSE" !== t.code) {
              var e = r[u];
              return null !== e && (r[l] = null, r[a] = null, r[u] = null, e(t)), void(r[c] = t)
            }
            var n = r[a];
            null !== n && (r[l] = null, r[a] = null, r[u] = null, n(p(void 0, !0))), r[f] = !0
          }), t.on("readable", m.bind(null, r)), r
        }
      },
      3196: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function t(e, r) {
          return (0, i.default)(e), null != r && r.eui && (r.eui = r.eui + ""), null != r && r.no_colons || null != r && r.no_separators ? "48" === r.eui ? s.test(e) : "64" === r.eui ? c.test(e) : s.test(e) || c.test(e) : "48" === r?.eui ? o.test(e) || a.test(e) : "64" === r?.eui ? u.test(e) || f.test(e) : t(e, {
            eui: "48"
          }) || t(e, {
            eui: "64"
          })
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){4}([0-9a-fA-F]{2})$/,
          s = /^([0-9a-fA-F]){12}$/,
          a = /^([0-9a-fA-F]{4}\.){2}([0-9a-fA-F]{4})$/,
          u = /^(?:[0-9a-fA-F]{2}([-:\s]))([0-9a-fA-F]{2}\1){6}([0-9a-fA-F]{2})$/,
          c = /^([0-9a-fA-F]){16}$/,
          f = /^([0-9a-fA-F]{4}\.){3}([0-9a-fA-F]{4})$/;
        t.exports = e.default, t.exports.default = e.default
      },
      3273: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV1R3 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey)
          }
          constructor(t, e) {
            this.workchain = t, this.publicKey = e;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEAXwAAuv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVLW4bkI=", "base64"))[0],
              o = (0, i.beginCell)().storeUint(0, 32).storeBuffer(e).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(t, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            let e = i.SendMode.PAY_GAS_SEPARATELY;
            return null !== t.sendMode && void 0 !== t.sendMode && (e = t.sendMode), (0, o.createWalletTransferV1)({
              seqno: t.seqno,
              sendMode: e,
              secretKey: t.secretKey,
              message: t.message
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    message: (0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV1R3 = s
      },
      3512: function(t, e, r) {
        "use strict";
        var n, i = r(48287).Buffer,
          o = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.address = e.Address = void 0;
        const s = o(r(29107)),
          a = r(92960);

        function u(t) {
          if ("string" == typeof t && !c.isFriendly(t)) throw Error("Unknown address type");
          const e = i.isBuffer(t) ? t : i.from(t, "base64");
          if (36 !== e.length) throw Error("Unknown address type: byte length is not equal to 36");
          const r = e.subarray(0, 34),
            n = e.subarray(34, 36),
            o = (0, a.crc16)(r);
          if (o[0] !== n[0] || o[1] !== n[1]) throw Error("Invalid checksum: " + t);
          let s = r[0],
            u = !1,
            f = !1;
          if (128 & s && (u = !0, s ^= 128), 17 !== s && 81 !== s) throw "Unknown address tag";
          f = 17 === s;
          let l = null;
          return l = 255 === r[1] ? -1 : r[1], {
            isTestOnly: u,
            isBounceable: f,
            workchain: l,
            hashPart: r.subarray(2, 34)
          }
        }
        class c {
          static isAddress(t) {
            return t instanceof c
          }
          static isFriendly(t) {
            return !(48 !== t.length || !/^[A-Za-z0-9+/_-]+$/.test(t))
          }
          static isRaw(t) {
            if (-1 === t.indexOf(":")) return !1;
            let [e, r] = t.split(":");
            return !(!Number.isInteger(parseFloat(e)) || !/[a-f0-9]+/.test(r.toLowerCase()) || 64 !== r.length)
          }
          static normalize(t) {
            return "string" == typeof t ? c.parse(t).toString() : t.toString()
          }
          static parse(t) {
            if (c.isFriendly(t)) return this.parseFriendly(t).address;
            if (c.isRaw(t)) return this.parseRaw(t);
            throw Error("Unknown address type: " + t)
          }
          static parseRaw(t) {
            let e = parseInt(t.split(":")[0]),
              r = i.from(t.split(":")[1], "hex");
            return new c(e, r)
          }
          static parseFriendly(t) {
            if (i.isBuffer(t)) {
              let e = u(t);
              return {
                isBounceable: e.isBounceable,
                isTestOnly: e.isTestOnly,
                address: new c(e.workchain, e.hashPart)
              }
            } {
              let e = u(t.replace(/\-/g, "+").replace(/_/g, "/"));
              return {
                isBounceable: e.isBounceable,
                isTestOnly: e.isTestOnly,
                address: new c(e.workchain, e.hashPart)
              }
            }
          }
          constructor(t, e) {
            if (this.toRawString = () => this.workChain + ":" + this.hash.toString("hex"), this.toRaw = () => {
                const t = i.alloc(36);
                return t.set(this.hash), t.set([this.workChain, this.workChain, this.workChain, this.workChain], 32), t
              }, this.toStringBuffer = t => {
                let e = !(!t || void 0 === t.testOnly) && t.testOnly,
                  r = !t || void 0 === t.bounceable || t.bounceable ? 17 : 81;
                e && (r |= 128);
                const n = i.alloc(34);
                n[0] = r, n[1] = this.workChain, n.set(this.hash, 2);
                const o = i.alloc(36);
                return o.set(n), o.set((0, a.crc16)(n), 34), o
              }, this.toString = t => {
                let e = !t || void 0 === t.urlSafe || t.urlSafe,
                  r = this.toStringBuffer(t);
                return e ? r.toString("base64").replace(/\+/g, "-").replace(/\//g, "_") : r.toString("base64")
              }, this[n] = () => this.toString(), 32 !== e.length) throw Error("Invalid address hash length: " + e.length);
            this.workChain = t, this.hash = e, Object.freeze(this)
          }
          equals(t) {
            return t.workChain === this.workChain && t.hash.equals(this.hash)
          }
        }
        e.Address = c, n = s.default, e.address = function(t) {
          return c.parse(t)
        }
      },
      3918: (t, e, r) => {
        "use strict";
        var n = r(65606);

        function i(t, e) {
          var r = Object.keys(t);
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(t);
            e && (n = n.filter(function(e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable
            })), r.push.apply(r, n)
          }
          return r
        }

        function o(t) {
          for (var e = 1; arguments.length > e; e++) {
            var r = null != arguments[e] ? arguments[e] : {};
            e % 2 ? i(Object(r), !0).forEach(function(e) {
              s(t, e, r[e])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : i(Object(r)).forEach(function(e) {
              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
            })
          }
          return t
        }

        function s(t, e, r) {
          return (e = a(e)) in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : t[e] = r, t
        }

        function a(t) {
          var e = function(t) {
            if ("object" !== b(t) || null === t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
              var r = e.call(t, "string");
              if ("object" !== b(r)) return r;
              throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return t + ""
          }(t);
          return "symbol" === b(e) ? e : e + ""
        }

        function u(t, e) {
          if (e && ("object" === b(e) || "function" == typeof e)) return e;
          if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
          return c(t)
        }

        function c(t) {
          if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          return t
        }

        function f(t) {
          var e = "function" == typeof Map ? new Map : void 0;
          return f = function(t) {
            if (null === t || ! function(t) {
                return -1 !== Function.toString.call(t).indexOf("[native code]")
              }(t)) return t;
            if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
            if ("u" > typeof e) {
              if (e.has(t)) return e.get(t);
              e.set(t, r)
            }

            function r() {
              return l(t, arguments, p(this).constructor)
            }
            return r.prototype = Object.create(t.prototype, {
              constructor: {
                value: r,
                enumerable: !1,
                writable: !0,
                configurable: !0
              }
            }), d(r, t)
          }, f(t)
        }

        function l(t, e, r) {
          return (l = h() ? Reflect.construct.bind() : function(t, e, r) {
            var n = [null];
            n.push.apply(n, e);
            var i = new(Function.bind.apply(t, n));
            return r && d(i, r.prototype), i
          }).apply(null, arguments)
        }

        function h() {
          if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
          if ("function" == typeof Proxy) return !0;
          try {
            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
          } catch {
            return !1
          }
        }

        function d(t, e) {
          return (d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
            return t.__proto__ = e, t
          })(t, e)
        }

        function p(t) {
          return (p = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
          })(t)
        }

        function b(t) {
          return (b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        var m = r(40537).inspect,
          y = r(69597).codes.ERR_INVALID_ARG_TYPE;

        function g(t, e, r) {
          return (void 0 === r || r > t.length) && (r = t.length), t.substring(r - e.length, r) === e
        }
        var v = "",
          w = "",
          A = "",
          T = "",
          E = {
            deepStrictEqual: "Expected values to be strictly deep-equal:",
            strictEqual: "Expected values to be strictly equal:",
            strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
            deepEqual: "Expected values to be loosely deep-equal:",
            equal: "Expected values to be loosely equal:",
            notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
            notStrictEqual: 'Expected "actual" to be strictly unequal to:',
            notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
            notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
            notEqual: 'Expected "actual" to be loosely unequal to:',
            notIdentical: "Values identical but not reference-equal:"
          };

        function P(t) {
          var e = Object.keys(t),
            r = Object.create(Object.getPrototypeOf(t));
          return e.forEach(function(e) {
            r[e] = t[e]
          }), Object.defineProperty(r, "message", {
            value: t.message
          }), r
        }

        function k(t) {
          return m(t, {
            compact: !1,
            customInspect: !1,
            depth: 1e3,
            maxArrayLength: 1 / 0,
            showHidden: !1,
            breakLength: 1 / 0,
            showProxy: !1,
            sorted: !0,
            getters: !0
          })
        }
        var x = function(t, e) {
          ! function(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
              constructor: {
                value: t,
                writable: !0,
                configurable: !0
              }
            }), Object.defineProperty(t, "prototype", {
              writable: !1
            }), e && d(t, e)
          }(i, t);
          var r = function(t) {
            var e = h();
            return function() {
              var r, n = p(t);
              if (e) {
                var i = p(this).constructor;
                r = Reflect.construct(n, arguments, i)
              } else r = n.apply(this, arguments);
              return u(this, r)
            }
          }(i);

          function i(t) {
            var e;
            if (function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
              }(this, i), "object" !== b(t) || null === t) throw new y("options", "Object", t);
            var o = t.message,
              s = t.operator,
              a = t.stackStartFn,
              f = t.actual,
              l = t.expected,
              h = Error.stackTraceLimit;
            if (Error.stackTraceLimit = 0, null != o) e = r.call(this, o + "");
            else if (n.stderr && n.stderr.isTTY && (n.stderr && n.stderr.getColorDepth && 1 !== n.stderr.getColorDepth() ? (v = "[34m", w = "[32m", T = "[39m", A = "[31m") : (v = "", w = "", T = "", A = "")), "object" === b(f) && null !== f && "object" === b(l) && null !== l && "stack" in f && f instanceof Error && "stack" in l && l instanceof Error && (f = P(f), l = P(l)), "deepStrictEqual" === s || "strictEqual" === s) e = r.call(this, function(t, e, r) {
              var i = "",
                o = "",
                s = 0,
                a = "",
                u = !1,
                c = k(t),
                f = c.split("\n"),
                l = k(e).split("\n"),
                h = 0,
                d = "";
              if ("strictEqual" === r && "object" === b(t) && "object" === b(e) && null !== t && null !== e && (r = "strictEqualObject"), 1 === f.length && 1 === l.length && f[0] !== l[0]) {
                var p = f[0].length + l[0].length;
                if (p > 10) {
                  if ("strictEqualObject" !== r && (n.stderr && n.stderr.isTTY ? n.stderr.columns : 80) > p) {
                    for (; f[0][h] === l[0][h];) h++;
                    h > 2 && (d = "\n  ".concat(function(t, e) {
                      if (e = Math.floor(e), 0 == t.length || 0 == e) return "";
                      var r = t.length * e;
                      for (e = Math.floor(Math.log(e) / Math.log(2)); e;) t += t, e--;
                      return t + t.substring(0, r - t.length)
                    }(" ", h), "^"), h = 0)
                  }
                } else if (!("object" === b(t) && null !== t || "object" === b(e) && null !== e || 0 === t && 0 === e)) return "".concat(E[r], "\n\n") + "".concat(f[0], " !== ").concat(l[0], "\n")
              }
              for (var m = f[f.length - 1], y = l[l.length - 1]; m === y && (2 > h++ ? a = "\n  ".concat(m).concat(a) : i = m, f.pop(), l.pop(), 0 !== f.length && 0 !== l.length);) m = f[f.length - 1], y = l[l.length - 1];
              var P = Math.max(f.length, l.length);
              if (0 === P) {
                var x = c.split("\n");
                if (x.length > 30)
                  for (x[26] = "".concat(v, "...").concat(T); x.length > 27;) x.pop();
                return "".concat(E.notIdentical, "\n\n").concat(x.join("\n"), "\n")
              }
              h > 3 && (a = "\n".concat(v, "...").concat(T).concat(a), u = !0), "" !== i && (a = "\n  ".concat(i).concat(a), i = "");
              var I = 0,
                S = E[r] + "\n".concat(w, "+ actual").concat(T, " ").concat(A, "- expected").concat(T),
                O = " ".concat(v, "...").concat(T, " Lines skipped");
              for (h = 0; P > h; h++) {
                var B = h - s;
                if (f.length < h + 1) B > 1 && h > 2 && (B > 4 ? (o += "\n".concat(v, "...").concat(T), u = !0) : B > 3 && (o += "\n  ".concat(l[h - 2]), I++), o += "\n  ".concat(l[h - 1]), I++), s = h, i += "\n".concat(A, "-").concat(T, " ").concat(l[h]), I++;
                else if (l.length < h + 1) B > 1 && h > 2 && (B > 4 ? (o += "\n".concat(v, "...").concat(T), u = !0) : B > 3 && (o += "\n  ".concat(f[h - 2]), I++), o += "\n  ".concat(f[h - 1]), I++), s = h, o += "\n".concat(w, "+").concat(T, " ").concat(f[h]), I++;
                else {
                  var W = l[h],
                    M = f[h],
                    C = M !== W && (!g(M, ",") || M.slice(0, -1) !== W);
                  C && g(W, ",") && W.slice(0, -1) === M && (C = !1, M += ","), C ? (B > 1 && h > 2 && (B > 4 ? (o += "\n".concat(v, "...").concat(T), u = !0) : B > 3 && (o += "\n  ".concat(f[h - 2]), I++), o += "\n  ".concat(f[h - 1]), I++), s = h, o += "\n".concat(w, "+").concat(T, " ").concat(M), i += "\n".concat(A, "-").concat(T, " ").concat(W), I += 2) : (o += i, i = "", (1 === B || 0 === h) && (o += "\n  ".concat(M), I++))
                }
                if (I > 20 && P - 2 > h) return "".concat(S).concat(O, "\n").concat(o, "\n").concat(v, "...").concat(T).concat(i, "\n") + "".concat(v, "...").concat(T)
              }
              return "".concat(S).concat(u ? O : "", "\n").concat(o).concat(i).concat(a).concat(d)
            }(f, l, s));
            else if ("notDeepStrictEqual" === s || "notStrictEqual" === s) {
              var d = E[s],
                p = k(f).split("\n");
              if ("notStrictEqual" === s && "object" === b(f) && null !== f && (d = E.notStrictEqualObject), p.length > 30)
                for (p[26] = "".concat(v, "...").concat(T); p.length > 27;) p.pop();
              e = 1 === p.length ? r.call(this, "".concat(d, " ").concat(p[0])) : r.call(this, "".concat(d, "\n\n").concat(p.join("\n"), "\n"))
            } else {
              var m = k(f),
                x = "",
                I = E[s];
              "notDeepEqual" === s || "notEqual" === s ? (m = "".concat(E[s], "\n\n").concat(m)).length > 1024 && (m = "".concat(m.slice(0, 1021), "...")) : (x = "".concat(k(l)), m.length > 512 && (m = "".concat(m.slice(0, 509), "...")), x.length > 512 && (x = "".concat(x.slice(0, 509), "...")), "deepEqual" === s || "equal" === s ? m = "".concat(I, "\n\n").concat(m, "\n\nshould equal\n\n") : x = " ".concat(s, " ").concat(x)), e = r.call(this, "".concat(m).concat(x))
            }
            return Error.stackTraceLimit = h, e.generatedMessage = !o, Object.defineProperty(c(e), "name", {
              value: "AssertionError [ERR_ASSERTION]",
              enumerable: !1,
              writable: !0,
              configurable: !0
            }), e.code = "ERR_ASSERTION", e.actual = f, e.expected = l, e.operator = s, Error.captureStackTrace && Error.captureStackTrace(c(e), a), e.stack, e.name = "AssertionError", u(e)
          }
          return function(t, e) {
            e && function(t, e) {
              for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, a(n.key), n)
              }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
              writable: !1
            })
          }(i, [{
            key: "toString",
            value: function() {
              return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message)
            }
          }, {
            key: e,
            value: function(t, e) {
              return m(this, o(o({}, e), {}, {
                customInspect: !1,
                depth: 0
              }))
            }
          }]), i
        }(f(Error), m.custom);
        t.exports = x
      },
      4061: function(t, e, r) {
        "use strict";
        var n, i = r(48287).Buffer,
          o = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ADNLAddress = void 0;
        const s = o(r(29107)),
          a = r(53721),
          u = r(92960);
        class c {
          static parseFriendly(t) {
            if (55 !== t.length) throw Error("Invalid address");
            t = "f" + t;
            let e = (0, a.base32Decode)(t);
            if (45 !== e[0]) throw Error("Invalid address");
            let r = e.slice(33);
            if (!(0, u.crc16)(e.slice(0, 33)).equals(r)) throw Error("Invalid address");
            return new c(e.slice(1, 33))
          }
          static parseRaw(t) {
            const e = i.from(t, "base64");
            return new c(e)
          }
          constructor(t) {
            if (this.toRaw = () => this.address.toString("hex").toUpperCase(), this.toString = () => {
                let t = i.concat([i.from([45]), this.address]),
                  e = (0, u.crc16)(t);
                return t = i.concat([t, e]), (0, a.base32Encode)(t).slice(1)
              }, this[n] = () => this.toString(), 32 !== t.length) throw Error("Invalid address");
            this.address = t
          }
          equals(t) {
            return this.address.equals(t.address)
          }
        }
        e.ADNLAddress = c, n = s.default
      },
      4436: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wordlist = void 0, e.wordlist = ["abandon", "ability", "able", "about", "above", "absent", "absorb", "abstract", "absurd", "abuse", "access", "accident", "account", "accuse", "achieve", "acid", "acoustic", "acquire", "across", "act", "action", "actor", "actress", "actual", "adapt", "add", "addict", "address", "adjust", "admit", "adult", "advance", "advice", "aerobic", "affair", "afford", "afraid", "again", "age", "agent", "agree", "ahead", "aim", "air", "airport", "aisle", "alarm", "album", "alcohol", "alert", "alien", "all", "alley", "allow", "almost", "alone", "alpha", "already", "also", "alter", "always", "amateur", "amazing", "among", "amount", "amused", "analyst", "anchor", "ancient", "anger", "angle", "angry", "animal", "ankle", "announce", "annual", "another", "answer", "antenna", "antique", "anxiety", "any", "apart", "apology", "appear", "apple", "approve", "april", "arch", "arctic", "area", "arena", "argue", "arm", "armed", "armor", "army", "around", "arrange", "arrest", "arrive", "arrow", "art", "artefact", "artist", "artwork", "ask", "aspect", "assault", "asset", "assist", "assume", "asthma", "athlete", "atom", "attack", "attend", "attitude", "attract", "auction", "audit", "august", "aunt", "author", "auto", "autumn", "average", "avocado", "avoid", "awake", "aware", "away", "awesome", "awful", "awkward", "axis", "baby", "bachelor", "bacon", "badge", "bag", "balance", "balcony", "ball", "bamboo", "banana", "banner", "bar", "barely", "bargain", "barrel", "base", "basic", "basket", "battle", "beach", "bean", "beauty", "because", "become", "beef", "before", "begin", "behave", "behind", "believe", "below", "belt", "bench", "benefit", "best", "betray", "better", "between", "beyond", "bicycle", "bid", "bike", "bind", "biology", "bird", "birth", "bitter", "black", "blade", "blame", "blanket", "blast", "bleak", "bless", "blind", "blood", "blossom", "blouse", "blue", "blur", "blush", "board", "boat", "body", "boil", "bomb", "bone", "bonus", "book", "boost", "border", "boring", "borrow", "boss", "bottom", "bounce", "box", "boy", "bracket", "brain", "brand", "brass", "brave", "bread", "breeze", "brick", "bridge", "brief", "bright", "bring", "brisk", "broccoli", "broken", "bronze", "broom", "brother", "brown", "brush", "bubble", "buddy", "budget", "buffalo", "build", "bulb", "bulk", "bullet", "bundle", "bunker", "burden", "burger", "burst", "bus", "business", "busy", "butter", "buyer", "buzz", "cabbage", "cabin", "cable", "cactus", "cage", "cake", "call", "calm", "camera", "camp", "can", "canal", "cancel", "candy", "cannon", "canoe", "canvas", "canyon", "capable", "capital", "captain", "car", "carbon", "card", "cargo", "carpet", "carry", "cart", "case", "cash", "casino", "castle", "casual", "cat", "catalog", "catch", "category", "cattle", "caught", "cause", "caution", "cave", "ceiling", "celery", "cement", "census", "century", "cereal", "certain", "chair", "chalk", "champion", "change", "chaos", "chapter", "charge", "chase", "chat", "cheap", "check", "cheese", "chef", "cherry", "chest", "chicken", "chief", "child", "chimney", "choice", "choose", "chronic", "chuckle", "chunk", "churn", "cigar", "cinnamon", "circle", "citizen", "city", "civil", "claim", "clap", "clarify", "claw", "clay", "clean", "clerk", "clever", "click", "client", "cliff", "climb", "clinic", "clip", "clock", "clog", "close", "cloth", "cloud", "clown", "club", "clump", "cluster", "clutch", "coach", "coast", "coconut", "code", "coffee", "coil", "coin", "collect", "color", "column", "combine", "come", "comfort", "comic", "common", "company", "concert", "conduct", "confirm", "congress", "connect", "consider", "control", "convince", "cook", "cool", "copper", "copy", "coral", "core", "corn", "correct", "cost", "cotton", "couch", "country", "couple", "course", "cousin", "cover", "coyote", "crack", "cradle", "craft", "cram", "crane", "crash", "crater", "crawl", "crazy", "cream", "credit", "creek", "crew", "cricket", "crime", "crisp", "critic", "crop", "cross", "crouch", "crowd", "crucial", "cruel", "cruise", "crumble", "crunch", "crush", "cry", "crystal", "cube", "culture", "cup", "cupboard", "curious", "current", "curtain", "curve", "cushion", "custom", "cute", "cycle", "dad", "damage", "damp", "dance", "danger", "daring", "dash", "daughter", "dawn", "day", "deal", "debate", "debris", "decade", "december", "decide", "decline", "decorate", "decrease", "deer", "defense", "define", "defy", "degree", "delay", "deliver", "demand", "demise", "denial", "dentist", "deny", "depart", "depend", "deposit", "depth", "deputy", "derive", "describe", "desert", "design", "desk", "despair", "destroy", "detail", "detect", "develop", "device", "devote", "diagram", "dial", "diamond", "diary", "dice", "diesel", "diet", "differ", "digital", "dignity", "dilemma", "dinner", "dinosaur", "direct", "dirt", "disagree", "discover", "disease", "dish", "dismiss", "disorder", "display", "distance", "divert", "divide", "divorce", "dizzy", "doctor", "document", "dog", "doll", "dolphin", "domain", "donate", "donkey", "donor", "door", "dose", "double", "dove", "draft", "dragon", "drama", "drastic", "draw", "dream", "dress", "drift", "drill", "drink", "drip", "drive", "drop", "drum", "dry", "duck", "dumb", "dune", "during", "dust", "dutch", "duty", "dwarf", "dynamic", "eager", "eagle", "early", "earn", "earth", "easily", "east", "easy", "echo", "ecology", "economy", "edge", "edit", "educate", "effort", "egg", "eight", "either", "elbow", "elder", "electric", "elegant", "element", "elephant", "elevator", "elite", "else", "embark", "embody", "embrace", "emerge", "emotion", "employ", "empower", "empty", "enable", "enact", "end", "endless", "endorse", "enemy", "energy", "enforce", "engage", "engine", "enhance", "enjoy", "enlist", "enough", "enrich", "enroll", "ensure", "enter", "entire", "entry", "envelope", "episode", "equal", "equip", "era", "erase", "erode", "erosion", "error", "erupt", "escape", "essay", "essence", "estate", "eternal", "ethics", "evidence", "evil", "evoke", "evolve", "exact", "example", "excess", "exchange", "excite", "exclude", "excuse", "execute", "exercise", "exhaust", "exhibit", "exile", "exist", "exit", "exotic", "expand", "expect", "expire", "explain", "expose", "express", "extend", "extra", "eye", "eyebrow", "fabric", "face", "faculty", "fade", "faint", "faith", "fall", "false", "fame", "family", "famous", "fan", "fancy", "fantasy", "farm", "fashion", "fat", "fatal", "father", "fatigue", "fault", "favorite", "feature", "february", "federal", "fee", "feed", "feel", "female", "fence", "festival", "fetch", "fever", "few", "fiber", "fiction", "field", "figure", "file", "film", "filter", "final", "find", "fine", "finger", "finish", "fire", "firm", "first", "fiscal", "fish", "fit", "fitness", "fix", "flag", "flame", "flash", "flat", "flavor", "flee", "flight", "flip", "float", "flock", "floor", "flower", "fluid", "flush", "fly", "foam", "focus", "fog", "foil", "fold", "follow", "food", "foot", "force", "forest", "forget", "fork", "fortune", "forum", "forward", "fossil", "foster", "found", "fox", "fragile", "frame", "frequent", "fresh", "friend", "fringe", "frog", "front", "frost", "frown", "frozen", "fruit", "fuel", "fun", "funny", "furnace", "fury", "future", "gadget", "gain", "galaxy", "gallery", "game", "gap", "garage", "garbage", "garden", "garlic", "garment", "gas", "gasp", "gate", "gather", "gauge", "gaze", "general", "genius", "genre", "gentle", "genuine", "gesture", "ghost", "giant", "gift", "giggle", "ginger", "giraffe", "girl", "give", "glad", "glance", "glare", "glass", "glide", "glimpse", "globe", "gloom", "glory", "glove", "glow", "glue", "goat", "goddess", "gold", "good", "goose", "gorilla", "gospel", "gossip", "govern", "gown", "grab", "grace", "grain", "grant", "grape", "grass", "gravity", "great", "green", "grid", "grief", "grit", "grocery", "group", "grow", "grunt", "guard", "guess", "guide", "guilt", "guitar", "gun", "gym", "habit", "hair", "half", "hammer", "hamster", "hand", "happy", "harbor", "hard", "harsh", "harvest", "hat", "have", "hawk", "hazard", "head", "health", "heart", "heavy", "hedgehog", "height", "hello", "helmet", "help", "hen", "hero", "hidden", "high", "hill", "hint", "hip", "hire", "history", "hobby", "hockey", "hold", "hole", "holiday", "hollow", "home", "honey", "hood", "hope", "horn", "horror", "horse", "hospital", "host", "hotel", "hour", "hover", "hub", "huge", "human", "humble", "humor", "hundred", "hungry", "hunt", "hurdle", "hurry", "hurt", "husband", "hybrid", "ice", "icon", "idea", "identify", "idle", "ignore", "ill", "illegal", "illness", "image", "imitate", "immense", "immune", "impact", "impose", "improve", "impulse", "inch", "include", "income", "increase", "index", "indicate", "indoor", "industry", "infant", "inflict", "inform", "inhale", "inherit", "initial", "inject", "injury", "inmate", "inner", "innocent", "input", "inquiry", "insane", "insect", "inside", "inspire", "install", "intact", "interest", "into", "invest", "invite", "involve", "iron", "island", "isolate", "issue", "item", "ivory", "jacket", "jaguar", "jar", "jazz", "jealous", "jeans", "jelly", "jewel", "job", "join", "joke", "journey", "joy", "judge", "juice", "jump", "jungle", "junior", "junk", "just", "kangaroo", "keen", "keep", "ketchup", "key", "kick", "kid", "kidney", "kind", "kingdom", "kiss", "kit", "kitchen", "kite", "kitten", "kiwi", "knee", "knife", "knock", "know", "lab", "label", "labor", "ladder", "lady", "lake", "lamp", "language", "laptop", "large", "later", "latin", "laugh", "laundry", "lava", "law", "lawn", "lawsuit", "layer", "lazy", "leader", "leaf", "learn", "leave", "lecture", "left", "leg", "legal", "legend", "leisure", "lemon", "lend", "length", "lens", "leopard", "lesson", "letter", "level", "liar", "liberty", "library", "license", "life", "lift", "light", "like", "limb", "limit", "link", "lion", "liquid", "list", "little", "live", "lizard", "load", "loan", "lobster", "local", "lock", "logic", "lonely", "long", "loop", "lottery", "loud", "lounge", "love", "loyal", "lucky", "luggage", "lumber", "lunar", "lunch", "luxury", "lyrics", "machine", "mad", "magic", "magnet", "maid", "mail", "main", "major", "make", "mammal", "man", "manage", "mandate", "mango", "mansion", "manual", "maple", "marble", "march", "margin", "marine", "market", "marriage", "mask", "mass", "master", "match", "material", "math", "matrix", "matter", "maximum", "maze", "meadow", "mean", "measure", "meat", "mechanic", "medal", "media", "melody", "melt", "member", "memory", "mention", "menu", "mercy", "merge", "merit", "merry", "mesh", "message", "metal", "method", "middle", "midnight", "milk", "million", "mimic", "mind", "minimum", "minor", "minute", "miracle", "mirror", "misery", "miss", "mistake", "mix", "mixed", "mixture", "mobile", "model", "modify", "mom", "moment", "monitor", "monkey", "monster", "month", "moon", "moral", "more", "morning", "mosquito", "mother", "motion", "motor", "mountain", "mouse", "move", "movie", "much", "muffin", "mule", "multiply", "muscle", "museum", "mushroom", "music", "must", "mutual", "myself", "mystery", "myth", "naive", "name", "napkin", "narrow", "nasty", "nation", "nature", "near", "neck", "need", "negative", "neglect", "neither", "nephew", "nerve", "nest", "net", "network", "neutral", "never", "news", "next", "nice", "night", "noble", "noise", "nominee", "noodle", "normal", "north", "nose", "notable", "note", "nothing", "notice", "novel", "now", "nuclear", "number", "nurse", "nut", "oak", "obey", "object", "oblige", "obscure", "observe", "obtain", "obvious", "occur", "ocean", "october", "odor", "off", "offer", "office", "often", "oil", "okay", "old", "olive", "olympic", "omit", "once", "one", "onion", "online", "only", "open", "opera", "opinion", "oppose", "option", "orange", "orbit", "orchard", "order", "ordinary", "organ", "orient", "original", "orphan", "ostrich", "other", "outdoor", "outer", "output", "outside", "oval", "oven", "over", "own", "owner", "oxygen", "oyster", "ozone", "pact", "paddle", "page", "pair", "palace", "palm", "panda", "panel", "panic", "panther", "paper", "parade", "parent", "park", "parrot", "party", "pass", "patch", "path", "patient", "patrol", "pattern", "pause", "pave", "payment", "peace", "peanut", "pear", "peasant", "pelican", "pen", "penalty", "pencil", "people", "pepper", "perfect", "permit", "person", "pet", "phone", "photo", "phrase", "physical", "piano", "picnic", "picture", "piece", "pig", "pigeon", "pill", "pilot", "pink", "pioneer", "pipe", "pistol", "pitch", "pizza", "place", "planet", "plastic", "plate", "play", "please", "pledge", "pluck", "plug", "plunge", "poem", "poet", "point", "polar", "pole", "police", "pond", "pony", "pool", "popular", "portion", "position", "possible", "post", "potato", "pottery", "poverty", "powder", "power", "practice", "praise", "predict", "prefer", "prepare", "present", "pretty", "prevent", "price", "pride", "primary", "print", "priority", "prison", "private", "prize", "problem", "process", "produce", "profit", "program", "project", "promote", "proof", "property", "prosper", "protect", "proud", "provide", "public", "pudding", "pull", "pulp", "pulse", "pumpkin", "punch", "pupil", "puppy", "purchase", "purity", "purpose", "purse", "push", "put", "puzzle", "pyramid", "quality", "quantum", "quarter", "question", "quick", "quit", "quiz", "quote", "rabbit", "raccoon", "race", "rack", "radar", "radio", "rail", "rain", "raise", "rally", "ramp", "ranch", "random", "range", "rapid", "rare", "rate", "rather", "raven", "raw", "razor", "ready", "real", "reason", "rebel", "rebuild", "recall", "receive", "recipe", "record", "recycle", "reduce", "reflect", "reform", "refuse", "region", "regret", "regular", "reject", "relax", "release", "relief", "rely", "remain", "remember", "remind", "remove", "render", "renew", "rent", "reopen", "repair", "repeat", "replace", "report", "require", "rescue", "resemble", "resist", "resource", "response", "result", "retire", "retreat", "return", "reunion", "reveal", "review", "reward", "rhythm", "rib", "ribbon", "rice", "rich", "ride", "ridge", "rifle", "right", "rigid", "ring", "riot", "ripple", "risk", "ritual", "rival", "river", "road", "roast", "robot", "robust", "rocket", "romance", "roof", "rookie", "room", "rose", "rotate", "rough", "round", "route", "royal", "rubber", "rude", "rug", "rule", "run", "runway", "rural", "sad", "saddle", "sadness", "safe", "sail", "salad", "salmon", "salon", "salt", "salute", "same", "sample", "sand", "satisfy", "satoshi", "sauce", "sausage", "save", "say", "scale", "scan", "scare", "scatter", "scene", "scheme", "school", "science", "scissors", "scorpion", "scout", "scrap", "screen", "script", "scrub", "sea", "search", "season", "seat", "second", "secret", "section", "security", "seed", "seek", "segment", "select", "sell", "seminar", "senior", "sense", "sentence", "series", "service", "session", "settle", "setup", "seven", "shadow", "shaft", "shallow", "share", "shed", "shell", "sheriff", "shield", "shift", "shine", "ship", "shiver", "shock", "shoe", "shoot", "shop", "short", "shoulder", "shove", "shrimp", "shrug", "shuffle", "shy", "sibling", "sick", "side", "siege", "sight", "sign", "silent", "silk", "silly", "silver", "similar", "simple", "since", "sing", "siren", "sister", "situate", "six", "size", "skate", "sketch", "ski", "skill", "skin", "skirt", "skull", "slab", "slam", "sleep", "slender", "slice", "slide", "slight", "slim", "slogan", "slot", "slow", "slush", "small", "smart", "smile", "smoke", "smooth", "snack", "snake", "snap", "sniff", "snow", "soap", "soccer", "social", "sock", "soda", "soft", "solar", "soldier", "solid", "solution", "solve", "someone", "song", "soon", "sorry", "sort", "soul", "sound", "soup", "source", "south", "space", "spare", "spatial", "spawn", "speak", "special", "speed", "spell", "spend", "sphere", "spice", "spider", "spike", "spin", "spirit", "split", "spoil", "sponsor", "spoon", "sport", "spot", "spray", "spread", "spring", "spy", "square", "squeeze", "squirrel", "stable", "stadium", "staff", "stage", "stairs", "stamp", "stand", "start", "state", "stay", "steak", "steel", "stem", "step", "stereo", "stick", "still", "sting", "stock", "stomach", "stone", "stool", "story", "stove", "strategy", "street", "strike", "strong", "struggle", "student", "stuff", "stumble", "style", "subject", "submit", "subway", "success", "such", "sudden", "suffer", "sugar", "suggest", "suit", "summer", "sun", "sunny", "sunset", "super", "supply", "supreme", "sure", "surface", "surge", "surprise", "surround", "survey", "suspect", "sustain", "swallow", "swamp", "swap", "swarm", "swear", "sweet", "swift", "swim", "swing", "switch", "sword", "symbol", "symptom", "syrup", "system", "table", "tackle", "tag", "tail", "talent", "talk", "tank", "tape", "target", "task", "taste", "tattoo", "taxi", "teach", "team", "tell", "ten", "tenant", "tennis", "tent", "term", "test", "text", "thank", "that", "theme", "then", "theory", "there", "they", "thing", "this", "thought", "three", "thrive", "throw", "thumb", "thunder", "ticket", "tide", "tiger", "tilt", "timber", "time", "tiny", "tip", "tired", "tissue", "title", "toast", "tobacco", "today", "toddler", "toe", "together", "toilet", "token", "tomato", "tomorrow", "tone", "tongue", "tonight", "tool", "tooth", "top", "topic", "topple", "torch", "tornado", "tortoise", "toss", "total", "tourist", "toward", "tower", "town", "toy", "track", "trade", "traffic", "tragic", "train", "transfer", "trap", "trash", "travel", "tray", "treat", "tree", "trend", "trial", "tribe", "trick", "trigger", "trim", "trip", "trophy", "trouble", "truck", "true", "truly", "trumpet", "trust", "truth", "try", "tube", "tuition", "tumble", "tuna", "tunnel", "turkey", "turn", "turtle", "twelve", "twenty", "twice", "twin", "twist", "two", "type", "typical", "ugly", "umbrella", "unable", "unaware", "uncle", "uncover", "under", "undo", "unfair", "unfold", "unhappy", "uniform", "unique", "unit", "universe", "unknown", "unlock", "until", "unusual", "unveil", "update", "upgrade", "uphold", "upon", "upper", "upset", "urban", "urge", "usage", "use", "used", "useful", "useless", "usual", "utility", "vacant", "vacuum", "vague", "valid", "valley", "valve", "van", "vanish", "vapor", "various", "vast", "vault", "vehicle", "velvet", "vendor", "venture", "venue", "verb", "verify", "version", "very", "vessel", "veteran", "viable", "vibrant", "vicious", "victory", "video", "view", "village", "vintage", "violin", "virtual", "virus", "visa", "visit", "visual", "vital", "vivid", "vocal", "voice", "void", "volcano", "volume", "vote", "voyage", "wage", "wagon", "wait", "walk", "wall", "walnut", "want", "warfare", "warm", "warrior", "wash", "wasp", "waste", "water", "wave", "way", "wealth", "weapon", "wear", "weasel", "weather", "web", "wedding", "weekend", "weird", "welcome", "west", "wet", "whale", "what", "wheat", "wheel", "when", "where", "whip", "whisper", "wide", "width", "wife", "wild", "will", "win", "window", "wine", "wing", "wink", "winner", "winter", "wire", "wisdom", "wise", "wish", "witness", "wolf", "woman", "wonder", "wood", "wool", "word", "work", "world", "worry", "worth", "wrap", "wreck", "wrestle", "wrist", "write", "wrong", "yard", "year", "yellow", "you", "young", "youth", "zebra", "zero", "zone", "zoo"]
      },
      4599: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTickTock = e.loadTickTock = void 0, e.loadTickTock = function(t) {
          return {
            tick: t.loadBit(),
            tock: t.loadBit()
          }
        }, e.storeTickTock = function(t) {
          return e => {
            e.storeBit(t.tick), e.storeBit(t.tock)
          }
        }
      },
      4641: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.toCaipChainId = e.parseCaipAccountId = e.parseCaipChainId = e.isCaipAssetId = e.isCaipAssetType = e.isCaipAccountAddress = e.isCaipAccountId = e.isCaipReference = e.isCaipNamespace = e.isCaipChainId = e.KnownCaipNamespace = e.CaipAssetIdStruct = e.CaipAssetTypeStruct = e.CaipAccountAddressStruct = e.CaipAccountIdStruct = e.CaipReferenceStruct = e.CaipNamespaceStruct = e.CaipChainIdStruct = e.CAIP_ASSET_ID_REGEX = e.CAIP_ASSET_TYPE_REGEX = e.CAIP_ACCOUNT_ADDRESS_REGEX = e.CAIP_ACCOUNT_ID_REGEX = e.CAIP_REFERENCE_REGEX = e.CAIP_NAMESPACE_REGEX = e.CAIP_CHAIN_ID_REGEX = void 0;
        const n = r(35620);
        var i;

        function o(t) {
          return (0, n.is)(t, e.CaipNamespaceStruct)
        }

        function s(t) {
          return (0, n.is)(t, e.CaipReferenceStruct)
        }
        e.CAIP_CHAIN_ID_REGEX = /^(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})$/u, e.CAIP_NAMESPACE_REGEX = /^[-a-z0-9]{3,8}$/u, e.CAIP_REFERENCE_REGEX = /^[-_a-zA-Z0-9]{1,32}$/u, e.CAIP_ACCOUNT_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32})):(?<accountAddress>[-.%a-zA-Z0-9]{1,128})$/u, e.CAIP_ACCOUNT_ADDRESS_REGEX = /^[-.%a-zA-Z0-9]{1,128}$/u, e.CAIP_ASSET_TYPE_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})$/u, e.CAIP_ASSET_ID_REGEX = /^(?<chainId>(?<namespace>[-a-z0-9]{3,8}):(?<reference>[-_a-zA-Z0-9]{1,32}))\/(?<assetNamespace>[-a-z0-9]{3,8}):(?<assetReference>[-.%a-zA-Z0-9]{1,128})\/(?<tokenId>[-.%a-zA-Z0-9]{1,78})$/u, e.CaipChainIdStruct = (0, n.pattern)((0, n.string)(), e.CAIP_CHAIN_ID_REGEX), e.CaipNamespaceStruct = (0, n.pattern)((0, n.string)(), e.CAIP_NAMESPACE_REGEX), e.CaipReferenceStruct = (0, n.pattern)((0, n.string)(), e.CAIP_REFERENCE_REGEX), e.CaipAccountIdStruct = (0, n.pattern)((0, n.string)(), e.CAIP_ACCOUNT_ID_REGEX), e.CaipAccountAddressStruct = (0, n.pattern)((0, n.string)(), e.CAIP_ACCOUNT_ADDRESS_REGEX), e.CaipAssetTypeStruct = (0, n.pattern)((0, n.string)(), e.CAIP_ASSET_TYPE_REGEX), e.CaipAssetIdStruct = (0, n.pattern)((0, n.string)(), e.CAIP_ASSET_ID_REGEX), (i = e.KnownCaipNamespace || (e.KnownCaipNamespace = {})).Bip122 = "bip122", i.Eip155 = "eip155", i.Wallet = "wallet", e.isCaipChainId = function(t) {
          return (0, n.is)(t, e.CaipChainIdStruct)
        }, e.isCaipNamespace = o, e.isCaipReference = s, e.isCaipAccountId = function(t) {
          return (0, n.is)(t, e.CaipAccountIdStruct)
        }, e.isCaipAccountAddress = function(t) {
          return (0, n.is)(t, e.CaipAccountAddressStruct)
        }, e.isCaipAssetType = function(t) {
          return (0, n.is)(t, e.CaipAssetTypeStruct)
        }, e.isCaipAssetId = function(t) {
          return (0, n.is)(t, e.CaipAssetIdStruct)
        }, e.parseCaipChainId = function(t) {
          const r = e.CAIP_CHAIN_ID_REGEX.exec(t);
          if (!r?.groups) throw Error("Invalid CAIP chain ID.");
          return {
            namespace: r.groups.namespace,
            reference: r.groups.reference
          }
        }, e.parseCaipAccountId = function(t) {
          const r = e.CAIP_ACCOUNT_ID_REGEX.exec(t);
          if (!r?.groups) throw Error("Invalid CAIP account ID.");
          return {
            address: r.groups.accountAddress,
            chainId: r.groups.chainId,
            chain: {
              namespace: r.groups.namespace,
              reference: r.groups.reference
            }
          }
        }, e.toCaipChainId = function(t, r) {
          if (!o(t)) throw Error('Invalid "namespace", must match: ' + e.CAIP_NAMESPACE_REGEX.toString());
          if (!s(r)) throw Error('Invalid "reference", must match: ' + e.CAIP_REFERENCE_REGEX.toString());
          return `${t}:${r}`
        }
      },
      4870: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.hmac_sha512 = e.hmac_sha512_fallback = void 0;
        const o = i(r(68343)),
          s = r(32370);
        e.hmac_sha512_fallback = async function(t, e) {
          let r = "string" == typeof t ? n.from(t, "utf-8") : t,
            i = "string" == typeof e ? n.from(e, "utf-8") : e;
          const s = new o.default("SHA-512", "HEX", {
            hmacKey: {
              value: r.toString("hex"),
              format: "HEX"
            }
          });
          s.update(i.toString("hex"));
          const a = s.getHash("HEX");
          return n.from(a, "hex")
        }, e.hmac_sha512 = function(t, e) {
          return (0, s.hmac_sha512)(t, e)
        }
      },
      5342: (t, e, r) => {
        const n = r(97075);
        t.exports = (t, e, r) => n(t, e, "<", r)
      },
      5830: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, n.default)(t), e = (0, i.default)(e, f), !t.includes(",")) return !1;
          var r = t.split(",");
          return !(r[0].startsWith("(") && !r[1].endsWith(")") || r[1].endsWith(")") && !r[0].startsWith("(")) && (e.checkDMS ? u.test(r[0]) && c.test(r[1]) : s.test(r[0]) && a.test(r[1]))
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = /^\(?[+-]?(90(\.0+)?|[1-8]?\d(\.\d+)?)$/,
          a = /^\s?[+-]?(180(\.0+)?|1[0-7]\d(\.\d+)?|\d{1,2}(\.\d+)?)\)?$/,
          u = /^(([1-8]?\d)\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|90\D+0\D+0)\D+[NSns]?$/i,
          c = /^\s*([1-7]?\d{1,2}\D+([1-5]?\d|60)\D+([1-5]?\d|60)(\.\d+)?|180\D+0\D+0)\D+[EWew]?$/i,
          f = {
            checkDMS: !1
          };
        t.exports = e.default, t.exports.default = e.default
      },
      5974: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer,
          i = r(65606),
          o = r(94148),
          s = r(44442),
          a = r(58411),
          u = r(71447),
          c = r(19681);
        for (var f in c) e[f] = c[f];

        function l(t) {
          if ("number" != typeof t || t < e.DEFLATE || t > e.UNZIP) throw new TypeError("Bad argument");
          this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = t, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0
        }
        e.NONE = 0, e.DEFLATE = 1, e.INFLATE = 2, e.GZIP = 3, e.GUNZIP = 4, e.DEFLATERAW = 5, e.INFLATERAW = 6, e.UNZIP = 7, l.prototype.close = function() {
          this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, o(this.init_done, "close before init"), o(this.mode <= e.UNZIP), this.mode === e.DEFLATE || this.mode === e.GZIP || this.mode === e.DEFLATERAW ? a.deflateEnd(this.strm) : (this.mode === e.INFLATE || this.mode === e.GUNZIP || this.mode === e.INFLATERAW || this.mode === e.UNZIP) && u.inflateEnd(this.strm), this.mode = e.NONE, this.dictionary = null)
        }, l.prototype.write = function(t, e, r, n, i, o, s) {
          return this.it(!0, t, e, r, n, i, o, s)
        }, l.prototype.writeSync = function(t, e, r, n, i, o, s) {
          return this.it(!1, t, e, r, n, i, o, s)
        }, l.prototype.it = function(t, r, s, a, u, c, f, l) {
          if (o.equal(arguments.length, 8), o(this.init_done, "write before init"), o(this.mode !== e.NONE, "already finalized"), o.equal(!1, this.write_in_progress, "write already in progress"), o.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, o.equal(!1, void 0 === r, "must provide flush value"), this.write_in_progress = !0, r !== e.Z_NO_FLUSH && r !== e.Z_PARTIAL_FLUSH && r !== e.Z_SYNC_FLUSH && r !== e.Z_FULL_FLUSH && r !== e.Z_FINISH && r !== e.Z_BLOCK) throw Error("Invalid flush value");
          if (null == s && (s = n.alloc(0), u = 0, a = 0), this.strm.avail_in = u, this.strm.input = s, this.strm.next_in = a, this.strm.avail_out = l, this.strm.output = c, this.strm.next_out = f, this.flush = r, !t) return this.ot(), this.st() ? this.ut() : void 0;
          var h = this;
          return i.nextTick(function() {
            h.ot(), h.ct()
          }), this
        }, l.prototype.ut = function() {
          var t = this.strm.avail_out,
            e = this.strm.avail_in;
          return this.write_in_progress = !1, [e, t]
        }, l.prototype.ot = function() {
          var t = null;
          switch (this.mode) {
            case e.DEFLATE:
            case e.GZIP:
            case e.DEFLATERAW:
              this.err = a.deflate(this.strm, this.flush);
              break;
            case e.UNZIP:
              switch (this.strm.avail_in > 0 && (t = this.strm.next_in), this.gzip_id_bytes_read) {
                case 0:
                  if (null === t) break;
                  if (31 !== this.strm.input[t]) {
                    this.mode = e.INFLATE;
                    break
                  }
                  if (this.gzip_id_bytes_read = 1, t++, 1 === this.strm.avail_in) break;
                case 1:
                  if (null === t) break;
                  139 === this.strm.input[t] ? (this.gzip_id_bytes_read = 2, this.mode = e.GUNZIP) : this.mode = e.INFLATE;
                  break;
                default:
                  throw Error("invalid number of gzip magic number bytes read")
              }
            case e.INFLATE:
            case e.GUNZIP:
            case e.INFLATERAW:
              for (this.err = u.inflate(this.strm, this.flush), this.err === e.Z_NEED_DICT && this.dictionary && (this.err = u.inflateSetDictionary(this.strm, this.dictionary), this.err === e.Z_OK ? this.err = u.inflate(this.strm, this.flush) : this.err === e.Z_DATA_ERROR && (this.err = e.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === e.GUNZIP && this.err === e.Z_STREAM_END && 0 !== this.strm.next_in[0];) this.reset(), this.err = u.inflate(this.strm, this.flush);
              break;
            default:
              throw Error("Unknown mode " + this.mode)
          }
        }, l.prototype.st = function() {
          switch (this.err) {
            case e.Z_OK:
            case e.Z_BUF_ERROR:
              if (0 !== this.strm.avail_out && this.flush === e.Z_FINISH) return this.ft("unexpected end of file"), !1;
              break;
            case e.Z_STREAM_END:
              break;
            case e.Z_NEED_DICT:
              return null == this.dictionary ? this.ft("Missing dictionary") : this.ft("Bad dictionary"), !1;
            default:
              return this.ft("Zlib error"), !1
          }
          return !0
        }, l.prototype.ct = function() {
          if (this.st()) {
            var t = this.strm.avail_out,
              e = this.strm.avail_in;
            this.write_in_progress = !1, this.callback(e, t), this.pending_close && this.close()
          }
        }, l.prototype.ft = function(t) {
          this.strm.msg && (t = this.strm.msg), this.onerror(t, this.err), this.write_in_progress = !1, this.pending_close && this.close()
        }, l.prototype.init = function(t, r, n, i, s) {
          o(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), o(t >= 8 && 15 >= t, "invalid windowBits"), o(r >= -1 && 9 >= r, "invalid compression level"), o(n >= 1 && 9 >= n, "invalid memlevel"), o(i === e.Z_FILTERED || i === e.Z_HUFFMAN_ONLY || i === e.Z_RLE || i === e.Z_FIXED || i === e.Z_DEFAULT_STRATEGY, "invalid strategy"), this.ht(r, t, n, i, s), this.dt()
        }, l.prototype.params = function() {
          throw Error("deflateParams Not supported")
        }, l.prototype.reset = function() {
          this.bt(), this.dt()
        }, l.prototype.ht = function(t, r, n, i, o) {
          switch (this.level = t, this.windowBits = r, this.memLevel = n, this.strategy = i, this.flush = e.Z_NO_FLUSH, this.err = e.Z_OK, (this.mode === e.GZIP || this.mode === e.GUNZIP) && (this.windowBits += 16), this.mode === e.UNZIP && (this.windowBits += 32), (this.mode === e.DEFLATERAW || this.mode === e.INFLATERAW) && (this.windowBits = -1 * this.windowBits), this.strm = new s, this.mode) {
            case e.DEFLATE:
            case e.GZIP:
            case e.DEFLATERAW:
              this.err = a.deflateInit2(this.strm, this.level, e.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
              break;
            case e.INFLATE:
            case e.GUNZIP:
            case e.INFLATERAW:
            case e.UNZIP:
              this.err = u.inflateInit2(this.strm, this.windowBits);
              break;
            default:
              throw Error("Unknown mode " + this.mode)
          }
          this.err !== e.Z_OK && this.ft("Init error"), this.dictionary = o, this.write_in_progress = !1, this.init_done = !0
        }, l.prototype.dt = function() {
          if (null != this.dictionary) {
            switch (this.err = e.Z_OK, this.mode) {
              case e.DEFLATE:
              case e.DEFLATERAW:
                this.err = a.deflateSetDictionary(this.strm, this.dictionary)
            }
            this.err !== e.Z_OK && this.ft("Failed to set dictionary")
          }
        }, l.prototype.bt = function() {
          switch (this.err = e.Z_OK, this.mode) {
            case e.DEFLATE:
            case e.DEFLATERAW:
            case e.GZIP:
              this.err = a.deflateReset(this.strm);
              break;
            case e.INFLATE:
            case e.INFLATERAW:
            case e.GUNZIP:
              this.err = u.inflateReset(this.strm)
          }
          this.err !== e.Z_OK && this.ft("Failed to reset stream")
        }, e.Zlib = l
      },
      6188: t => {
        "use strict";
        t.exports = Math.max
      },
      6215: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer,
          i = r(65606);
        Object.defineProperty(e, "_", {
          value: !0
        }), e.InvalidStatusCodeError = e.InvalidCertError = void 0;
        const o = Object.freeze({
          redirect: !0,
          expectStatusCode: 200,
          headers: {},
          full: !1,
          keepAlive: !0,
          cors: !1,
          referrer: !1,
          sslAllowSelfSigned: !1,
          yt: 0
        });
        class s extends Error {
          constructor(t, e) {
            super(t), this.fingerprint256 = e
          }
        }
        e.InvalidCertError = s;
        class a extends Error {
          constructor(t) {
            super("Request Failed. Status Code: " + t), this.statusCode = t
          }
        }

        function u(t, e) {
          if (!e || "text" === e || "json" === e) try {
            let r = new TextDecoder("utf8", {
              fatal: !0
            }).decode(t);
            if ("text" === e) return r;
            try {
              return JSON.parse(r)
            } catch (t) {
              if ("json" === e) throw t;
              return r
            }
          } catch (t) {
            if ("text" === e || "json" === e) throw t
          }
          return t
        }
        e.InvalidStatusCodeError = a;
        let c = {};

        function f(t, e) {
          let i = {
            ...o,
            ...e
          };
          const l = r(11568),
            h = r(11083),
            d = r(78559),
            {
              promisify: p
            } = r(40537),
            {
              resolve: b
            } = r(88835),
            m = !!/^https/.test(t);
          let y = {
            method: i.method || "GET",
            headers: {
              "Accept-Encoding": "gzip, deflate, br"
            }
          };
          const g = t => t.replace(/:| /g, "").toLowerCase();
          if (i.keepAlive) {
            const t = {
                keepAlive: !0,
                keepAliveMsecs: 3e4,
                maxFreeSockets: 1024,
                maxCachedSessions: 1024
              },
              e = [m, m && i.sslPinnedCertificates?.map(t => g(t)).sort()].join();
            y.agent = c[e] || (c[e] = new(m ? h : l).Agent(t))
          }
          return "json" === i.type && (y.headers["Content-Type"] = "application/json"), i.data && (i.method || (y.method = "POST"), y.body = "json" === i.type ? JSON.stringify(i.data) : i.data), y.headers = {
            ...y.headers,
            ...i.headers
          }, i.sslAllowSelfSigned && (y.rejectUnauthorized = !1), new Promise((e, r) => {
            const o = async e => {
              if (e && "DEPTH_ZERO_SELF_SIGNED_CERT" === e.code) try {
                await f(t, {
                  ...i,
                  sslAllowSelfSigned: !0,
                  sslPinnedCertificates: []
                })
              } catch (t) {
                t && t.fingerprint256 && (e = new s("Self-signed SSL certificate: " + t.fingerprint256, t.fingerprint256))
              }
              r(e)
            }, c = (m ? h : l).request(t, y, s => {
              s.on("error", o), (async () => {
                try {
                  e(await (async e => {
                    const r = e.statusCode;
                    if (i.redirect && r >= 300 && 400 > r && e.headers.location) {
                      if (10 == i.yt) throw Error("Request failed. Too much redirects.");
                      return i.yt += 1, await f(b(t, e.headers.location), i)
                    }
                    if (i.expectStatusCode && r !== i.expectStatusCode) throw e.resume(), new a(r);
                    let o = [];
                    for await (const t of e) o.push(t);
                    let s = n.concat(o);
                    const c = e.headers["content-encoding"];
                    "br" === c && (s = await p(d.brotliDecompress)(s)), ("gzip" === c || "deflate" === c) && (s = await p(d.unzip)(s));
                    const l = u(s, i.type);
                    return i.full ? {
                      headers: e.headers,
                      status: r,
                      body: l
                    } : l
                  })(s))
                } catch (t) {
                  r(t)
                }
              })()
            });
            c.on("error", o);
            const v = i.sslPinnedCertificates?.map(t => g(t)),
              w = t => {
                const e = g(t.getPeerCertificate()?.fingerprint256 || "");
                if ((e || !t.isSessionReused()) && !v.includes(e)) return c.emit("error", new s(`Invalid SSL certificate: ${e} Expected: ${v}`, e)), c.abort()
              };
            i.sslPinnedCertificates && c.on("socket", t => {
              t.listeners("secureConnect").map(t => (t.name || "").replace("bound ", "")).includes("mfetchSecureConnect") || t.on("secureConnect", w.bind(null, t))
            }), i.keepAlive && c.setNoDelay(!0), y.body && c.write(y.body), c.end()
          })
        }
        const l = new Set(["Accept", "Accept-Language", "Content-Language", "Content-Type"].map(t => t.toLowerCase())),
          h = new Set(["Accept-Charset", "Accept-Encoding", "Access-Control-Request-Headers", "Access-Control-Request-Method", "Connection", "Content-Length", "Cookie", "Cookie2", "Date", "DNT", "Expect", "Host", "Keep-Alive", "Origin", "Referer", "TE", "Trailer", "Transfer-Encoding", "Upgrade", "Via"].map(t => t.toLowerCase()));
        async function d(t, e) {
          let r = {
            ...o,
            ...e
          };
          const n = new Headers;
          "json" === r.type && n.set("Content-Type", "application/json");
          let i = new URL(t);
          if (i.username) {
            const t = btoa(`${i.username}:${i.password}`);
            n.set("Authorization", "Basic " + t), i.username = "", i.password = ""
          }
          t = "" + i;
          for (let t in r.headers) {
            const e = t.toLowerCase();
            (l.has(e) || r.cors && !h.has(e)) && n.set(t, r.headers[t])
          }
          let s = {
            headers: n,
            redirect: r.redirect ? "follow" : "manual"
          };
          r.referrer || (s.referrerPolicy = "no-referrer"), r.cors && (s.mode = "cors"), r.data && (r.method || (s.method = "POST"), s.body = "json" === r.type ? JSON.stringify(r.data) : r.data);
          const c = await fetch(t, s);
          if (r.expectStatusCode && c.status !== r.expectStatusCode) throw new a(c.status);
          const f = u(new Uint8Array(await c.arrayBuffer()), r.type);
          return r.full ? {
            headers: Object.fromEntries(c.headers.entries()),
            status: c.status,
            body: f
          } : f
        }
        const p = !!("object" == typeof i && i.versions && i.versions.node && i.versions.v8);
        e.default = function(t, e) {
          return (p ? f : d)(t, e)
        }
      },
      6549: t => {
        "use strict";
        t.exports = Object.getOwnPropertyDescriptor
      },
      6579: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.array = e.getTupleType = e.getArrayType = e.isArrayType = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(34175),
          s = r(76291),
          a = r(64122),
          u = r(72516),
          c = /^(?<type>.*)\[(?<length>\d*?)\]$/u;
        e.isArrayType = t => c.test(t), e.getArrayType = t => {
          const e = t.match(c);
          return (0, n.assert)(e?.groups?.type, new i.ParserError(`Invalid array type. Expected an array type, but received "${t}".`)), [e.groups.type, e.groups.length ? parseInt(e.groups.length, 10) : void 0]
        }, e.getTupleType = (t, e) => `(${Array(e).fill(t).join(",")})`, e.array = {
          isDynamic(t) {
            const [r, n] = (0, e.getArrayType)(t);
            return void 0 === n || (0, o.isDynamicParser)((0, o.getParser)(r), r)
          },
          isType: t => (0, e.isArrayType)(t),
          getByteLength(t) {
            (0, n.assert)((0, e.isArrayType)(t), new i.ParserError(`Expected an array type, but received "${t}".`));
            const [r, s] = (0, e.getArrayType)(t);
            return (0, o.isDynamicParser)(this, t) || void 0 === s ? 32 : u.tuple.getByteLength((0, e.getTupleType)(r, s))
          },
          encode({
            type: t,
            buffer: r,
            value: c,
            packed: f,
            tight: l
          }) {
            const [h, d] = (0, e.getArrayType)(t);
            if ((0, n.assert)(!f || !(0, e.isArrayType)(h), new i.ParserError("Cannot pack nested arrays.")), f && (0, o.isDynamicParser)((0, o.getParser)(h), h)) return (0, o.pack)({
              types: Array(c.length).fill(h),
              values: c,
              byteArray: r,
              packed: f,
              arrayPacked: !0,
              tight: l
            });
            if (d) return (0, n.assert)(d === c.length, new i.ParserError(`Array length does not match type length. Expected a length of ${d}, but received ${c.length}.`)), u.tuple.encode({
              type: (0, e.getTupleType)(h, d),
              buffer: r,
              value: c,
              packed: a.fixedBytes.isType(h) && l,
              tight: l
            });
            if (f) return (0, o.pack)({
              types: Array(c.length).fill(h),
              values: c,
              byteArray: r,
              packed: a.fixedBytes.isType(h) && l,
              arrayPacked: !0,
              tight: l
            });
            const p = (0, s.padStart)((0, n.numberToBytes)(c.length));
            return (0, o.pack)({
              types: Array(c.length).fill(h),
              values: c,
              byteArray: (0, n.concatBytes)([r, p]),
              packed: f,
              tight: l
            })
          },
          decode({
            type: t,
            value: r,
            ...s
          }) {
            const [a, c] = (0, e.getArrayType)(t);
            if (c) {
              const t = u.tuple.decode({
                type: (0, e.getTupleType)(a, c),
                value: r,
                ...s
              });
              return (0, n.assert)(t.length === c, new i.ParserError(`Array length does not match type length. Expected a length of ${c}, but received ${t.length}.`)), t
            }
            const f = (0, n.bytesToNumber)(r.subarray(0, 32));
            return (0, o.unpack)(Array(f).fill(a), r.subarray(32))
          }
        }
      },
      6585: t => {
        var e = 1e3,
          r = 60 * e,
          n = 60 * r,
          i = 24 * n,
          o = 7 * i;

        function s(t, e, r, n) {
          var i = e >= 1.5 * r;
          return Math.round(t / r) + " " + n + (i ? "s" : "")
        }
        t.exports = function(t, a) {
          a = a || {};
          var u = typeof t;
          if ("string" === u && t.length > 0) return function(t) {
            if (100 >= (t += "").length) {
              var s = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);
              if (s) {
                var a = parseFloat(s[1]);
                switch ((s[2] || "ms").toLowerCase()) {
                  case "years":
                  case "year":
                  case "yrs":
                  case "yr":
                  case "y":
                    return 315576e5 * a;
                  case "weeks":
                  case "week":
                  case "w":
                    return a * o;
                  case "days":
                  case "day":
                  case "d":
                    return a * i;
                  case "hours":
                  case "hour":
                  case "hrs":
                  case "hr":
                  case "h":
                    return a * n;
                  case "minutes":
                  case "minute":
                  case "mins":
                  case "min":
                  case "m":
                    return a * r;
                  case "seconds":
                  case "second":
                  case "secs":
                  case "sec":
                  case "s":
                    return a * e;
                  case "milliseconds":
                  case "millisecond":
                  case "msecs":
                  case "msec":
                  case "ms":
                    return a;
                  default:
                    return
                }
              }
            }
          }(t);
          if ("number" === u && isFinite(t)) return a.long ? function(t) {
            var o = Math.abs(t);
            return i > o ? n > o ? r > o ? e > o ? t + " ms" : s(t, o, e, "second") : s(t, o, r, "minute") : s(t, o, n, "hour") : s(t, o, i, "day")
          }(t) : function(t) {
            var o = Math.abs(t);
            return i > o ? n > o ? r > o ? e > o ? t + "ms" : Math.round(t / e) + "s" : Math.round(t / r) + "m" : Math.round(t / n) + "h" : Math.round(t / i) + "d"
          }(t);
          throw Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(t))
        }
      },
      6688: (t, e, r) => {
        var n;

        function i() {
          if (void 0 !== n) return n;
          if (r.g.XMLHttpRequest) {
            n = new r.g.XMLHttpRequest;
            try {
              n.open("GET", r.g.XDomainRequest ? "/" : "https://example.com")
            } catch {
              n = null
            }
          } else n = null;
          return n
        }

        function o(t) {
          var e = i();
          if (!e) return !1;
          try {
            return e.responseType = t, e.responseType === t
          } catch {}
          return !1
        }

        function s(t) {
          return "function" == typeof t
        }
        e.fetch = s(r.g.fetch) && s(r.g.ReadableStream), e.writableStream = s(r.g.WritableStream), e.abortController = s(r.g.AbortController), e.arraybuffer = e.fetch || o("arraybuffer"), e.msstream = !e.fetch && o("ms-stream"), e.mozchunkedarraybuffer = !e.fetch && o("moz-chunked-arraybuffer"), e.overrideMimeType = e.fetch || !!i() && s(i().overrideMimeType), n = null
      },
      6782: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t),
            function(t) {
              var e = "\\d{".concat(t.digits_after_decimal[0], "}");
              t.digits_after_decimal.forEach(function(t, r) {
                0 !== r && (e = "".concat(e, "|\\d{").concat(t, "}"))
              });
              var r = "(".concat(t.symbol.replace(/\W/, function(t) {
                  return "\\".concat(t)
                }), ")").concat(t.require_symbol ? "" : "?"),
                n = "-?",
                i = "[1-9]\\d{0,2}(\\".concat(t.thousands_separator, "\\d{3})*"),
                o = "(".concat(["0|[1-9]\\d*", i].join("|"), ")?"),
                s = "(\\".concat(t.decimal_separator, "(").concat(e, "))").concat(t.require_decimal ? "" : "?"),
                a = o + (t.allow_decimal || t.require_decimal ? s : "");
              return t.allow_negatives && !t.parens_for_negatives && (t.negative_sign_after_digits ? a += n : t.negative_sign_before_digits && (a = n + a)), t.allow_negative_sign_placeholder ? a = "( (?!\\-))?".concat(a) : t.allow_space_after_symbol ? a = " ?".concat(a) : t.allow_space_after_digits && (a += "( (?!$))?"), t.symbol_after_digits ? a += r : a = r + a, t.allow_negatives && (t.parens_for_negatives ? a = "(\\(".concat(a, "\\)|").concat(a, ")") : t.negative_sign_before_digits || t.negative_sign_after_digits || (a = n + a)), RegExp("^(?!-? )(?=.*\\d)".concat(a, "$"))
            }(e = (0, n.default)(e, s)).test(t)
        };
        var n = o(r(71229)),
          i = o(r(83399));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = {
          symbol: "$",
          require_symbol: !1,
          allow_space_after_symbol: !1,
          symbol_after_digits: !1,
          allow_negatives: !0,
          parens_for_negatives: !1,
          negative_sign_before_digits: !1,
          negative_sign_after_digits: !1,
          allow_negative_sign_placeholder: !1,
          thousands_separator: ",",
          decimal_separator: ".",
          allow_decimal: !0,
          require_decimal: !1,
          digits_after_decimal: [2],
          allow_space_after_digits: !1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      6917: (t, e, r) => {
        var n = r(65606),
          i = r(48287).Buffer,
          o = r(6688),
          s = r(56698),
          a = r(28399),
          u = e.readyStates = {
            UNSENT: 0,
            OPENED: 1,
            HEADERS_RECEIVED: 2,
            LOADING: 3,
            DONE: 4
          },
          c = e.IncomingMessage = function(t, e, r, s) {
            var u = this;
            if (a.Readable.call(u), u.vt = r, u.headers = {}, u.rawHeaders = [], u.trailers = {}, u.rawTrailers = [], u.on("end", function() {
                n.nextTick(function() {
                  u.emit("close")
                })
              }), "fetch" === r) {
              let t = function() {
                f.read().then(function(e) {
                  if (!u.wt) {
                    if (s(e.done), e.done) return void u.push(null);
                    u.push(i.from(e.value)), t()
                  }
                }).catch(function(t) {
                  s(!0), u.wt || u.emit("error", t)
                })
              };
              if (u.At = e, u.url = e.url, u.statusCode = e.status, u.statusMessage = e.statusText, e.headers.forEach(function(t, e) {
                  u.headers[e.toLowerCase()] = t, u.rawHeaders.push(e, t)
                }), o.writableStream) {
                var c = new WritableStream({
                  write: function(t) {
                    return s(!1), new Promise(function(e, r) {
                      u.wt ? r() : u.push(i.from(t)) ? e() : u.Tt = e
                    })
                  },
                  close: function() {
                    s(!0), u.wt || u.push(null)
                  },
                  abort: function(t) {
                    s(!0), u.wt || u.emit("error", t)
                  }
                });
                try {
                  return void e.body.pipeTo(c).catch(function(t) {
                    s(!0), u.wt || u.emit("error", t)
                  })
                } catch {}
              }
              var f = e.body.getReader();
              t()
            } else if (u.Et = t, u.Pt = 0, u.url = t.responseURL, u.statusCode = t.status, u.statusMessage = t.statusText, t.getAllResponseHeaders().split(/\r?\n/).forEach(function(t) {
                var e = t.match(/^([^:]+):\s*(.*)/);
                if (e) {
                  var r = e[1].toLowerCase();
                  "set-cookie" === r ? (void 0 === u.headers[r] && (u.headers[r] = []), u.headers[r].push(e[2])) : void 0 !== u.headers[r] ? u.headers[r] += ", " + e[2] : u.headers[r] = e[2], u.rawHeaders.push(e[1], e[2])
                }
              }), u.kt = "x-user-defined", !o.overrideMimeType) {
              var l = u.rawHeaders["mime-type"];
              if (l) {
                var h = l.match(/;\s*charset=([^;])(;|$)/);
                h && (u.kt = h[1].toLowerCase())
              }
              u.kt || (u.kt = "utf-8")
            }
          };
        s(c, a.Readable), c.prototype.xt = function() {
          var t = this.Tt;
          t && (this.Tt = null, t())
        }, c.prototype.It = function(t) {
          var e = this,
            n = e.Et,
            o = null;
          switch (e.vt) {
            case "text":
              if ((o = n.responseText).length > e.Pt) {
                var s = o.substr(e.Pt);
                if ("x-user-defined" === e.kt) {
                  for (var a = i.alloc(s.length), c = 0; c < s.length; c++) a[c] = 255 & s.charCodeAt(c);
                  e.push(a)
                } else e.push(s, e.kt);
                e.Pt = o.length
              }
              break;
            case "arraybuffer":
              if (n.readyState !== u.DONE || !n.response) break;
              o = n.response, e.push(i.from(new Uint8Array(o)));
              break;
            case "moz-chunked-arraybuffer":
              if (o = n.response, n.readyState !== u.LOADING || !o) break;
              e.push(i.from(new Uint8Array(o)));
              break;
            case "ms-stream":
              if (o = n.response, n.readyState !== u.LOADING) break;
              var f = new r.g.MSStreamReader;
              f.onprogress = function() {
                f.result.byteLength > e.Pt && (e.push(i.from(new Uint8Array(f.result.slice(e.Pt)))), e.Pt = f.result.byteLength)
              }, f.onload = function() {
                t(!0), e.push(null)
              }, f.readAsArrayBuffer(o)
          }
          e.Et.readyState === u.DONE && "ms-stream" !== e.vt && (t(!0), e.push(null))
        }
      },
      7059: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => 0 > n(t, e, r)
      },
      7071: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), a.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = "(-|_)",
          s = "".concat("(([a-zA-Z]{2,3}(-([A-Za-z]{3}(-[A-Za-z]{3}){0,2}))?)|([a-zA-Z]{5,8}))", "(").concat(o).concat("([A-Za-z]{4})", ")?(").concat(o).concat("([A-Za-z]{2}|\\d{3})", ")?(").concat(o).concat("([A-Za-z0-9]{5,8}|(\\d[A-Z-a-z0-9]{3}))", ")*(").concat(o).concat("((\\d|[A-W]|[Y-Z]|[a-w]|[y-z])(-[A-Za-z0-9]{2,8})+)", ")*(").concat(o).concat("(x(-[A-Za-z0-9]{1,8})+)", ")?"),
          a = RegExp("(^(x(-[A-Za-z0-9]{1,8})+)$)|(^(((en-GB-oed)|(i-ami)|(i-bnn)|(i-default)|(i-enochian)|(i-hak)|(i-klingon)|(i-lux)|(i-mingo)|(i-navajo)|(i-pwn)|(i-tao)|(i-tay)|(i-tsu)|(sgn-BE-FR)|(sgn-BE-NL)|(sgn-CH-DE))|((art-lojban)|(cel-gaulish)|(no-bok)|(no-nyn)|(zh-guoyu)|(zh-hakka)|(zh-min)|(zh-min-nan)|(zh-xiang)))$)|(^".concat(s, "$)"));
        t.exports = e.default, t.exports.default = e.default
      },
      7176: (t, e, r) => {
        "use strict";
        var n, i = r(73126),
          o = r(75795);
        try {
          n = [].__proto__ === Array.prototype
        } catch (t) {
          if (!t || "object" != typeof t || !("code" in t) || "ERR_PROTO_ACCESS" !== t.code) throw t
        }
        var s = !!n && o && o(Object.prototype, "__proto__"),
          a = Object,
          u = a.getPrototypeOf;
        t.exports = s && "function" == typeof s.get ? i([s.get]) : "function" == typeof u && function(t) {
          return u(null == t ? t : a(t))
        }
      },
      7325: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.string = void 0;
        const n = r(65534),
          i = r(8653);
        e.string = {
          isDynamic: !0,
          isType: t => "string" === t,
          getByteLength: () => 32,
          encode: ({
            buffer: t,
            value: e,
            packed: r,
            tight: o
          }) => i.bytes.encode({
            type: "bytes",
            buffer: t,
            value: (0, n.stringToBytes)(e),
            packed: r,
            tight: o
          }),
          decode: t => (0, n.bytesToString)(i.bytes.decode(t))
        }
      },
      7552: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.St || (Object.create ? function(t, e) {
            Object.defineProperty(t, "default", {
              enumerable: !0,
              value: e
            })
          } : function(t, e) {
            t.default = e
          }),
          o = this && this.Ot || function(t) {
            if (t && t._) return t;
            var e = {};
            if (null != t)
              for (var r in t) "default" !== r && {}.hasOwnProperty.call(t, r) && n(e, t, r);
            return i(e, t), e
          },
          s = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.z = void 0;
        const a = o(r(79325));
        e.z = a, s(r(79325), e), e.default = a
      },
      7673: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, n.default)(t), (e = (0, i.default)(e, u)).crockford ? a.test(t) : !(t.length % 8 != 0 || !s.test(t))
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = /^[A-Z2-7]+=*$/,
          a = /^[A-HJKMNP-TV-Z0-9]+$/,
          u = {
            crockford: !1
          };
        t.exports = e.default, t.exports.default = e.default
      },
      7941: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV4 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey, t.walletId)
          }
          constructor(t, e, r) {
            this.workchain = t, this.publicKey = e, this.walletId = null != r ? r : 698983191 + t;
            let o = i.Cell.fromBoc(n.from("te6ccgECFAEAAtQAART/APSkE/S88sgLAQIBIAIDAgFIBAUE+PKDCNcYINMf0x/THwL4I7vyZO1E0NMf0x/T//QE0VFDuvKhUVG68qIF+QFUEGT5EPKj+AAkpMjLH1JAyx9SMMv/UhD0AMntVPgPAdMHIcAAn2xRkyDXSpbTB9QC+wDoMOAhwAHjACHAAuMAAcADkTDjDQOkyMsfEssfy/8QERITAubQAdDTAyFxsJJfBOAi10nBIJJfBOAC0x8hghBwbHVnvSKCEGRzdHK9sJJfBeAD+kAwIPpEAcjKB8v/ydDtRNCBAUDXIfQEMFyBAQj0Cm+hMbOSXwfgBdM/yCWCEHBsdWe6kjgw4w0DghBkc3RyupJfBuMNBgcCASAICQB4AfoA9AQw+CdvIjBQCqEhvvLgUIIQcGx1Z4MesXCAGFAEywUmzxZY+gIZ9ADLaRfLH1Jgyz8gyYBA+wAGAIpQBIEBCPRZMO1E0IEBQNcgyAHPFvQAye1UAXKwjiOCEGRzdHKDHrFwgBhQBcsFUAPPFiP6AhPLassfyz/JgED7AJJfA+ICASAKCwBZvSQrb2omhAgKBrkPoCGEcNQICEekk30pkQzmkD6f+YN4EoAbeBAUiYcVnzGEAgFYDA0AEbjJftRNDXCx+AA9sp37UTQgQFA1yH0BDACyMoHy//J0AGBAQj0Cm+hMYAIBIA4PABmtznaiaEAga5Drhf/AABmvHfaiaEAQa5DrhY/AAG7SB/oA1NQi+QAFyMoHFcv/ydB3dIAYyMsFywIizxZQBfoCFMtrEszMyXP7AMhAFIEBCPRR8qcCAHCBAQjXGPoA0z/IVCBHgQEI9FHyp4IQbm90ZXB0gBjIywXLAlAGzxZQBPoCFMtqEssfyz/Jc/sAAgBsgQEI1xj6ANM/MFIkgQEI9Fnyp4IQZHN0cnB0gBjIywXLAlAFzxZQA/oCE8tqyx8Syz/Jc/sAAAr0AMntVA==", "base64"))[0],
              s = (0, i.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(this.publicKey).storeBit(0).endCell();
            this.init = {
              code: o,
              data: s
            }, this.address = (0, i.contractAddress)(t, {
              code: o,
              data: s
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            return (0, o.createWalletTransferV4)({
              ...t,
              sendMode: t.sendMode ?? i.SendMode.PAY_GAS_SEPARATELY,
              walletId: this.walletId
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV4 = s
      },
      8117: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.deriveSymmetricPath = e.deriveSymmetricHardenedKey = e.getSymmetricMasterKeyFromSeed = void 0;
        const i = r(4870);
        async function o(t) {
          const e = await (0, i.hmac_sha512)("Symmetric key seed", t);
          return {
            key: e.slice(32),
            chainCode: e.slice(0, 32)
          }
        }
        async function s(t, e) {
          const r = n.concat([n.alloc(1, 0), n.from(e)]),
            o = await (0, i.hmac_sha512)(t.chainCode, r);
          return {
            key: o.slice(32),
            chainCode: o.slice(0, 32)
          }
        }
        e.getSymmetricMasterKeyFromSeed = o, e.deriveSymmetricHardenedKey = s, e.deriveSymmetricPath = async function(t, e) {
          let r = await o(t),
            n = [...e];
          for (; n.length > 0;) {
            let t = n[0];
            n = n.slice(1), r = await s(r, t)
          }
          return r.key
        }
      },
      8387: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(14112), e), i(r(80331), e), i(r(27322), e)
      },
      8461: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = o;
          if ((e = e || {}).allow_hyphens && (r = s), !r.test(t)) return !1;
          t = t.replace(/-/g, "");
          for (var n = 0, a = 2, u = 0; 14 > u; u++) {
            var c = t.substring(14 - u - 1, 14 - u),
              f = parseInt(c, 10) * a;
            n += 10 > f ? f : f % 10 + 1, 1 === a ? a += 1 : a -= 1
          }
          return (10 - n % 10) % 10 === parseInt(t.substring(14, 15), 10)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[0-9]{15}$/,
          s = /^\d{2}-\d{6}-\d{6}-\d{1}$/;
        t.exports = e.default, t.exports.default = e.default
      },
      8653: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bytes = void 0;
        const n = r(65534),
          i = r(76291);
        e.bytes = {
          isDynamic: !0,
          isType: t => "bytes" === t,
          getByteLength: () => 32,
          encode({
            buffer: t,
            value: e,
            packed: r
          }) {
            const o = (0, n.createBytes)(e);
            if (r) return (0, n.concatBytes)([t, o]);
            const s = 32 * Math.ceil(o.byteLength / 32);
            return (0, n.concatBytes)([t, (0, i.padStart)((0, n.numberToBytes)(o.byteLength)), (0, i.padEnd)(o, s)])
          },
          decode({
            value: t
          }) {
            const e = t.subarray(0, 32),
              r = (0, n.bytesToNumber)(e);
            return t.slice(32, 32 + r)
          }
        }
      },
      9394: (t, e, r) => {
        "use strict";
        var n = r(89211);
        t.exports = function() {
          return "function" == typeof Object.is ? Object.is : n
        }
      },
      9447: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.comment = e.external = e.internal = void 0;
        const n = r(3512),
          i = r(66902),
          o = r(65871),
          s = r(97070),
          a = r(71784);
        e.internal = function(t) {
          let e, r, u, c = !0;
          if (null !== t.bounce && void 0 !== t.bounce && (c = t.bounce), "string" == typeof t.to) e = n.Address.parse(t.to);
          else {
            if (!n.Address.isAddress(t.to)) throw Error("Invalid address " + t.to);
            e = t.to
          }
          r = "string" == typeof t.value ? (0, s.toNano)(t.value) : t.value, t.extracurrency && (u = (0, a.packExtraCurrencyDict)(t.extracurrency));
          let f = i.Cell.EMPTY;
          return "string" == typeof t.body ? f = (0, o.beginCell)().storeUint(0, 32).storeStringTail(t.body).endCell() : t.body && (f = t.body), {
            info: {
              type: "internal",
              dest: e,
              value: {
                coins: r,
                other: u
              },
              bounce: c,
              ihrDisabled: !0,
              bounced: !1,
              ihrFee: 0n,
              forwardFee: 0n,
              createdAt: 0,
              createdLt: 0n
            },
            init: t.init ?? void 0,
            body: f
          }
        }, e.external = function(t) {
          let e;
          if ("string" == typeof t.to) e = n.Address.parse(t.to);
          else {
            if (!n.Address.isAddress(t.to)) throw Error("Invalid address " + t.to);
            e = t.to
          }
          return {
            info: {
              type: "external-in",
              dest: e,
              importFee: 0n
            },
            init: t.init ?? void 0,
            body: t.body || i.Cell.EMPTY
          }
        }, e.comment = function(t) {
          return (0, o.beginCell)().storeUint(0, 32).storeStringTail(t).endCell()
        }
      },
      9805: (t, e) => {
        "use strict";
        var r = "u" > typeof Uint8Array && "u" > typeof Uint16Array && "u" > typeof Int32Array;

        function n(t, e) {
          return {}.hasOwnProperty.call(t, e)
        }
        e.assign = function(t) {
          for (var e = [].slice.call(arguments, 1); e.length;) {
            var r = e.shift();
            if (r) {
              if ("object" != typeof r) throw new TypeError(r + "must be non-object");
              for (var i in r) n(r, i) && (t[i] = r[i])
            }
          }
          return t
        }, e.shrinkBuf = function(t, e) {
          return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t)
        };
        var i = {
            arraySet: function(t, e, r, n, i) {
              if (e.subarray && t.subarray) t.set(e.subarray(r, r + n), i);
              else
                for (var o = 0; n > o; o++) t[i + o] = e[r + o]
            },
            flattenChunks: function(t) {
              var e, r, n, i, o, s;
              for (n = 0, e = 0, r = t.length; r > e; e++) n += t[e].length;
              for (s = new Uint8Array(n), i = 0, e = 0, r = t.length; r > e; e++) o = t[e], s.set(o, i), i += o.length;
              return s
            }
          },
          o = {
            arraySet: function(t, e, r, n, i) {
              for (var o = 0; n > o; o++) t[i + o] = e[r + o]
            },
            flattenChunks: function(t) {
              return [].concat.apply([], t)
            }
          };
        e.setTyped = function(t) {
          t ? (e.Buf8 = Uint8Array, e.Buf16 = Uint16Array, e.Buf32 = Int32Array, e.assign(e, i)) : (e.Buf8 = Array, e.Buf16 = Array, e.Buf32 = Array, e.assign(e, o))
        }, e.setTyped(r)
      },
      9896: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getRepr = e.getBitsDescriptor = e.getRefsDescriptor = void 0;
        const i = r(34654),
          o = r(34382);

        function s(t, e, r) {
          return t.length + 8 * (r !== i.CellType.Ordinary ? 1 : 0) + 32 * e
        }

        function a(t) {
          let e = t.length;
          return Math.ceil(e / 8) + Math.floor(e / 8)
        }
        e.getRefsDescriptor = s, e.getBitsDescriptor = a, e.getRepr = function(t, e, r, u, c, f) {
          const l = Math.ceil(e.length / 8),
            h = n.alloc(2 + l + 34 * r.length);
          let d = 0;
          h[d++] = s(r, c, f), h[d++] = a(t), (0, o.bitsToPaddedBuffer)(e).copy(h, d), d += l;
          for (const t of r) {
            let e;
            e = f == i.CellType.MerkleProof || f == i.CellType.MerkleUpdate ? t.depth(u + 1) : t.depth(u), h[d++] = Math.floor(e / 256), h[d++] = e % 256
          }
          for (const t of r) {
            let e;
            e = f == i.CellType.MerkleProof || f == i.CellType.MerkleUpdate ? t.hash(u + 1) : t.hash(u), e.copy(h, d), d += 32
          }
          return h
        }
      },
      9957: (t, e, r) => {
        "use strict";
        var n = function() {}.call,
          i = {}.hasOwnProperty,
          o = r(66743);
        t.exports = o.call(n, i)
      },
      9970: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => n(e, t, r)
      },
      10076: t => {
        "use strict";
        t.exports = function() {}.call
      },
      10132: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.mnemonicFromRandomSeed = e.mnemonicIndexesToBytes = e.bytesToMnemonics = e.bytesToMnemonicIndexes = e.mnemonicNew = e.mnemonicValidate = e.mnemonicToHDSeed = e.mnemonicToWalletKey = e.mnemonicToPrivateKey = e.mnemonicToSeed = e.mnemonicToEntropy = void 0;
        const o = i(r(88947)),
          s = r(51682),
          a = r(4870),
          u = r(59256),
          c = r(12202),
          f = r(4436);
        async function l(t) {
          const e = await p(t);
          return await async function(t) {
            return 1 == (await (0, u.pbkdf2_sha512)(t, "TON fast seed version", 1, 64))[0]
          }(e) && !await d(e)
        }

        function h(t) {
          return t.map(t => t.toLowerCase().trim())
        }
        async function d(t) {
          return 0 == (await (0, u.pbkdf2_sha512)(t, "TON seed version", 390, 64))[0]
        }
        async function p(t, e) {
          return await (0, a.hmac_sha512)(t.join(" "), e && e.length > 0 ? e : "")
        }
        async function b(t, e, r) {
          const n = await p(t, r);
          return await (0, u.pbkdf2_sha512)(n, e, 1e5, 64)
        }
        async function m(t, e) {
          t = h(t);
          const r = await b(t, "TON default seed", e);
          let i = o.default.sign.keyPair.fromSeed(r.slice(0, 32));
          return {
            publicKey: n.from(i.publicKey),
            secretKey: n.from(i.secretKey)
          }
        }
        async function y(t, e) {
          t = h(t);
          for (let e of t)
            if (0 > f.wordlist.indexOf(e)) return !1;
          return !(e && e.length > 0 && !await l(t)) && await d(await p(t, e))
        }

        function g(t, e) {
          let r = (0, c.bytesToBits)(t),
            n = [];
          for (let t = 0; e > t; t++) {
            let e = r.slice(11 * t, 11 * t + 11);
            n.push(parseInt(e, 2))
          }
          return n
        }

        function v(t, e) {
          let r = g(t, e),
            n = [];
          for (let t of r) n.push(f.wordlist[t]);
          return n
        }
        e.mnemonicToEntropy = p, e.mnemonicToSeed = b, e.mnemonicToPrivateKey = m, e.mnemonicToWalletKey = async function(t, e) {
          let r = (await m(t, e)).secretKey.slice(0, 32);
          const i = o.default.sign.keyPair.fromSeed(r);
          return {
            publicKey: n.from(i.publicKey),
            secretKey: n.from(i.secretKey)
          }
        }, e.mnemonicToHDSeed = async function(t, e) {
          return t = h(t), await b(t, "TON HD Keys seed", e)
        }, e.mnemonicValidate = y, e.mnemonicNew = async function(t = 24, e) {
          let r = [];
          for (;;) {
            r = [];
            for (let e = 0; t > e; e++) {
              let t = await (0, s.getSecureRandomNumber)(0, f.wordlist.length);
              r.push(f.wordlist[t])
            }
            if ((!e || 0 >= e.length || await l(r)) && await d(await p(r, e))) break
          }
          return r
        }, e.bytesToMnemonicIndexes = g, e.bytesToMnemonics = v, e.mnemonicIndexesToBytes = function(t) {
          let e = "";
          for (let r of t) {
            if (!Number.isSafeInteger(r) || 0 > r || r >= 2028) throw Error("Invalid input");
            e += (0, c.lpad)(r.toString(2), "0", 11)
          }
          for (; e.length % 8 != 0;) e += "0";
          return (0, c.bitsToBytes)(e)
        }, e.mnemonicFromRandomSeed = async function(t, e = 24, r) {
          const n = Math.ceil(11 * e / 8);
          let i = t;
          for (;;) {
            let t = await (0, u.pbkdf2_sha512)(i, "TON mnemonic seed", 390, n),
              o = v(t, e);
            if (await y(o, r)) return o;
            i = t
          }
        }
      },
      10487: (t, e, r) => {
        "use strict";
        var n = r(96897),
          i = r(30655),
          o = r(73126),
          s = r(12205);
        t.exports = function(t) {
          var e = o(arguments),
            r = t.length - (arguments.length - 1);
          return n(e, 1 + (r > 0 ? r : 0), !0)
        }, i ? i(t.exports, "apply", {
          value: s
        }) : t.exports.apply = s
      },
      10574: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeCurrencyCollection = e.loadCurrencyCollection = void 0;
        const n = r(97590);
        e.loadCurrencyCollection = function(t) {
          const e = t.loadCoins(),
            r = t.loadDict(n.Dictionary.Keys.Uint(32), n.Dictionary.Values.BigVarUint(5));
          return 0 === r.size ? {
            coins: e
          } : {
            other: r,
            coins: e
          }
        }, e.storeCurrencyCollection = function(t) {
          return e => {
            e.storeCoins(t.coins), t.other ? e.storeDict(t.other) : e.storeBit(0)
          }
        }
      },
      10676: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, i.default)(t), e in o) return o[e](t);
          if ("any" === e) {
            for (var r in o)
              if ((0, o[r])(t)) return !0;
            return !1
          }
          throw Error("Invalid locale '".concat(e, "'"))
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            "cs-CZ": function(t) {
              return /^(([ABCDEFHIJKLMNPRSTUVXYZ]|[0-9])-?){5,8}$/.test(t)
            },
            "de-DE": function(t) {
              return /^((A|AA|AB|AC|AE|AH|AK|AM|AN|A|AP|AS|AT|AU|AW|AZ|B|BA|BB|BC|BE|BF|BH|BI|BK|BL|BM|BN|BO|B|BS|BT|BZ|C|CA|CB|CE|CO|CR|CW|D|DA|DD|DE|DH|DI|DL|DM|DN|DO|DU|DW|DZ|E|EA|EB|ED|EE|EF|EG|EH|EI|EL|EM|EN|ER|ES|EU|EW|F|FB|FD|FF|FG|FI|FL|FN|FO|FR|FS|FT|F|FW|FZ|G|GA|GC|GD|GE|GF|GG|GI|GK|GL|GM|GN|G|GP|GR|GS|GT|G|GV|GW|GZ|H|HA|HB|HC|HD|HE|HF|HG|HH|HI|HK|HL|HM|HN|HO|HP|HR|HS|HU|HV|HX|HY|HZ|IK|IL|IN|IZ|J|JE|JL|K|KA|KB|KC|KE|KF|KG|KH|KI|KK|KL|KM|KN|KO|KR|KS|KT|KU|KW|KY|L|LA|LB|LC|LD|LF|LG|LH|LI|LL|LM|LN|L|LP|LR|LU|M|MA|MB|MC|MD|ME|MG|MH|MI|MK|ML|MM|MN|MO|MQ|MR|MS|M|MW|MY|MZ|N|NB|ND|NE|NF|NH|NI|NK|NM|N|NP|NR|NT|NU|NW|NY|NZ|OA|OB|OC|OD|OE|OF|OG|OH|OK|OL|OP|OS|OZ|P|PA|PB|PE|PF|PI|PL|PM|PN|PR|PS|PW|PZ|R|RA|RC|RD|RE|RG|RH|RI|RL|RM|RN|RO|RP|RS|RT|RU|RV|RW|RZ|S|SB|SC|SE|SG|SI|SK|SL|SM|SN|SO|SP|SR|ST|SU|SW|SY|SZ|TE|TF|TG|TO|TP|TR|TS|TT|T|B|UE|UH|UL|UM|UN|V|VB|VG|VK|VR|VS|W|WA|WB|WE|WF|WI|WK|WL|WM|WN|WO|WR|WS|WT|W|WW|WZ|Z|ZE|ZI|ZP|ZR|ZW|ZZ)[- ]?[A-Z]{1,2}[- ]?\d{1,4}|(ABG|ABI|AIB|AIC|ALF|ALZ|ANA|ANG|ANK|APD|ARN|ART|ASL|ASZ|AUR|AZE|BAD|BAR|BBG|BCH|BED|BER|BGD|BGL|BID|BIN|BIR|BIT|BIW|BKS|BLB|BLK|BNA|BOG|BOH|BOR|BOT|BRA|BRB|BRG|BRK|BRL|BRV|BSB|BSK|BTF|BD|BUL|BR|BS|BZ|CAS|CHA|CLP|CLZ|COC|COE|CUX|DAH|DAN|DAU|DBR|DEG|DEL|DGF|DIL|DIN|DIZ|DKB|DLG|DON|DUD|DW|EBE|EBN|EBS|ECK|EIC|EIL|EIN|EIS|EMD|EMS|ERB|ERH|ERK|ERZ|ESB|ESW|FDB|FDS|FEU|FFB|FKB|FL|FOR|FRG|FRI|FRW|FTL|FS|GAN|GAP|GDB|GEL|GEO|GER|GHA|GHC|GLA|GMN|GNT|GOA|GOH|GRA|GRH|GRI|GRM|GRZ|GTH|GUB|GUN|GVM|HAB|HAL|HAM|HAS|HBN|HBS|HCH|HDH|HDL|HEB|HEF|HEI|HER|HET|HGN|HGW|HHM|HIG|HIP|HM|HOG|HOH|HOL|HOM|HOR|HS|HOT|HRO|HSK|HST|HVL|HWI|IGB|ILL|JL|KEH|KEL|KEM|KIB|KLE|KLZ|KN|KT|KZ|KRU|KN|KUS|KYF|LAN|LAU|LBS|LBZ|LDK|LDS|LEO|LER|LEV|LIB|LIF|LIP|LB|LOS|LRO|LSZ|LN|LUP|LWL|MAB|MAI|MAK|MAL|MED|MEG|MEI|MEK|MEL|MER|MET|MGH|MGN|MHL|MIL|MKK|MOD|MOL|MON|MOS|MSE|MSH|MSP|MST|MTK|MTL|MB|MR|MYK|MZG|NAB|NAI|NAU|NDH|NEA|NEB|NEC|NEN|NES|NEW|NMB|NMS|NOH|NOL|NOM|NOR|NVP|NWM|OAL|OBB|OBG|OCH|OHA|HR|OHV|OHZ|OPR|OSL|OVI|OVL|OVP|PAF|PAN|PAR|PCH|PEG|PIR|PL|PR|QFT|QLB|RDG|REG|REH|REI|RID|RIE|ROD|ROF|ROK|ROL|ROS|ROT|ROW|RSL|RD|RG|SAB|SAD|SAN|SAW|SBG|SBK|SCZ|SDH|SDL|SDT|SEB|SEE|SEF|SEL|SFB|SFT|SGH|SHA|SHG|SHK|SHL|SIG|SIM|SLE|SLF|SLK|SLN|SLS|SL|SLZ|SM|SOB|SOG|SOK|SM|SON|SPB|SPN|SRB|SRO|STA|STB|STD|STE|STL|SUL|SW|SWA|SZB|TBB|TDO|TET|TIR|TL|TUT|UEM|UER|UFF|USI|VAI|VEC|VER|VIB|VIE|VIT|VOH|WAF|WAK|WAN|WAR|WAT|WBS|WDA|WEL|WEN|WER|WES|WHV|WIL|WIS|WIT|WIZ|WLG|WMS|WND|WOB|WOH|WOL|WOR|WOS|WRN|WSF|WST|WSW|WTL|WTM|WUG|WM|WUN|WUR|WZL|ZEL|ZIG)[- ]?(([A-Z][- ]?\d{1,4})|([A-Z]{2}[- ]?\d{1,3})))[- ]?(E|H)?$/.test(t)
            },
            "de-LI": function(t) {
              return /^FL[- ]?\d{1,5}[UZ]?$/.test(t)
            },
            "en-IN": function(t) {
              return /^[A-Z]{2}[ -]?[0-9]{1,2}(?:[ -]?[A-Z])(?:[ -]?[A-Z]*)?[ -]?[0-9]{4}$/.test(t)
            },
            "es-AR": function(t) {
              return /^(([A-Z]{2} ?[0-9]{3} ?[A-Z]{2})|([A-Z]{3} ?[0-9]{3}))$/.test(t)
            },
            "fi-FI": function(t) {
              return /^(?=.{4,7})(([A-Z]{1,3}|[0-9]{1,3})[\s-]?([A-Z]{1,3}|[0-9]{1,5}))$/.test(t)
            },
            "hu-HU": function(t) {
              return /^((((?!AAA)(([A-NPRSTVZWXY]{1})([A-PR-Z]{1})([A-HJ-NPR-Z]))|(A[ABC]I)|A[ABC]O|A[A-W]Q|BPI|BPO|UCO|UDO|XAO)-(?!000)\d{3})|(M\d{6})|((CK|DT|CD|HC|H[ABEFIKLMNPRSTVX]|MA|OT|R[A-Z]) \d{2}-\d{2})|(CD \d{3}-\d{3})|(C-(C|X) \d{4})|(X-(A|B|C) \d{4})|(([EPVZ]-\d{5}))|(S A[A-Z]{2} \d{2})|(SP \d{2}-\d{2}))$/.test(t)
            },
            "pt-BR": function(t) {
              return /^[A-Z]{3}[ -]?[0-9][A-Z][0-9]{2}|[A-Z]{3}[ -]?[0-9]{4}$/.test(t)
            },
            "pt-PT": function(t) {
              return /^([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})[ -]?([A-Z]{2}|[0-9]{2})$/.test(t)
            },
            "sq-AL": function(t) {
              return /^[A-Z]{2}[- ]?((\d{3}[- ]?(([A-Z]{2})|T))|(R[- ]?\d{3}))$/.test(t)
            },
            "sv-SE": function(t) {
              return /^[A-HJ-PR-UW-Z]{3} ?[\d]{2}[A-HJ-PR-UW-Z1-9]$|(^[A-Z ]{2,7}$)/.test(t.trim())
            }
          };
        t.exports = e.default, t.exports.default = e.default
      },
      11002: t => {
        "use strict";
        t.exports = function() {}.apply
      },
      11065: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionCreditPhase = e.loadTransactionCreditPhase = void 0;
        const n = r(10574);
        e.loadTransactionCreditPhase = function(t) {
          return {
            dueFeesColelcted: t.loadBit() ? t.loadCoins() : void 0,
            credit: (0, n.loadCurrencyCollection)(t)
          }
        }, e.storeTransactionCreditPhase = function(t) {
          return e => {
            null === t.dueFeesColelcted || void 0 === t.dueFeesColelcted ? e.storeBit(!1) : (e.storeBit(!0), e.storeCoins(t.dueFeesColelcted)), e.store((0, n.storeCurrencyCollection)(t.credit))
          }
        }
      },
      11083: (t, e, r) => {
        var n = r(11568),
          i = r(88835),
          o = t.exports;
        for (var s in n) n.hasOwnProperty(s) && (o[s] = n[s]);

        function a(t) {
          if ("string" == typeof t && (t = i.parse(t)), t.protocol || (t.protocol = "https:"), "https:" !== t.protocol) throw Error('Protocol "' + t.protocol + '" not supported. Expected "https:"');
          return t
        }
        o.request = function(t, e) {
          return t = a(t), n.request.call(this, t, e)
        }, o.get = function(t, e) {
          return t = a(t), n.get.call(this, t, e)
        }
      },
      11514: (t, e, r) => {
        "use strict";
        var n = r(38403);
        t.exports = function() {
          return !Object.assign || function() {
            if (!Object.assign) return !1;
            for (var t = "abcdefghijklmnopqrst", e = t.split(""), r = {}, n = 0; n < e.length; ++n) r[e[n]] = e[n];
            var i = Object.assign({}, r),
              o = "";
            for (var s in i) o += s;
            return t !== o
          }() || function() {
            if (!Object.assign || !Object.preventExtensions) return !1;
            var t = Object.preventExtensions({
              1: 2
            });
            try {
              Object.assign(t, "xy")
            } catch {
              return "y" === t[1]
            }
            return !1
          }() ? n : Object.assign
        }
      },
      11568: (t, e, r) => {
        var n = r(55537),
          i = r(6917),
          o = r(57510),
          s = r(86866),
          a = r(88835),
          u = e;
        u.request = function(t, e) {
          t = "string" == typeof t ? a.parse(t) : o(t);
          var i = -1 === r.g.location.protocol.search(/^https?:$/) ? "http:" : "",
            s = t.protocol || i,
            u = t.hostname || t.host,
            c = t.port,
            f = t.path || "/";
          u && -1 !== u.indexOf(":") && (u = "[" + u + "]"), t.url = (u ? s + "//" + u : "") + (c ? ":" + c : "") + f, t.method = (t.method || "GET").toUpperCase(), t.headers = t.headers || {};
          var l = new n(t);
          return e && l.on("response", e), l
        }, u.get = function(t, e) {
          var r = u.request(t, e);
          return r.end(), r
        }, u.ClientRequest = n, u.IncomingMessage = i.IncomingMessage, u.Agent = function() {}, u.Agent.defaultMaxSockets = 4, u.globalAgent = new u.Agent, u.STATUS_CODES = s, u.METHODS = ["CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE"]
      },
      11763: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e) => n(t, e, !0)
      },
      12202: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;

        function i(t, e, r) {
          for (; t.length < r;) t = e + t;
          return t
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bitsToBytes = e.bytesToBits = e.lpad = void 0, e.lpad = i, e.bytesToBits = function(t) {
          let e = "";
          for (let r = 0; r < t.length; r++) e += i(t.at(r).toString(2), "0", 8);
          return e
        }, e.bitsToBytes = function(t) {
          if (t.length % 8 != 0) throw Error("Uneven bits");
          let e = [];
          for (; t.length > 0;) e.push(parseInt(t.slice(0, 8), 2)), t = t.slice(8);
          return n.from(e)
        }
      },
      12205: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(11002),
          o = r(13144);
        t.exports = function() {
          return o(n, i, arguments)
        }
      },
      12458: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.recoverTypedSignature = e.signTypedData = e.typedSignatureHash = e.TypedDataUtils = e.TYPED_MESSAGE_SCHEMA = e.SignTypedDataVersion = void 0;
        const n = r(68683),
          i = r(33537),
          o = r(78366),
          s = r(76291),
          a = r(65534),
          u = r(32019),
          c = r(43007);
        var f, l;

        function h(t, e) {
          if (!Object.keys(f).includes(t)) throw Error(`Invalid version: '${t}'`);
          if (e && !e.includes(t)) throw Error(`SignTypedDataVersion not allowed: '${t}'. Allowed versions are: ${e.join(", ")}`)
        }

        function d(t, e) {
          (0, a.assert)(null !== e, `Unable to encode value: Invalid number. Expected a valid number value, but received "${e}".`);
          const r = BigInt(e),
            n = (0, o.getLength)(t),
            i = BigInt(2) ** BigInt(n) - BigInt(1);
          return (0, a.assert)(r >= -i && i >= r, `Unable to encode value: Number "${e}" is out of range for type "${t}".`), r
        }

        function p(t) {
          let e = BigInt(0);
          for (let r = 0; r < t.length; r++) {
            const n = BigInt(t.charCodeAt(r) - 48);
            e *= BigInt(10), e += 49 > n ? 17 > n ? n : n - BigInt(17) + BigInt(10) : n - BigInt(49) + BigInt(10)
          }
          return (0, s.padStart)((0, a.bigIntToBytes)(e), 20)
        }

        function b(t, e, r, o, c) {
          if (h(c, [f.V3, f.V4]), void 0 !== t[r]) return ["bytes32", c === f.V4 && null == o ? "0x0000000000000000000000000000000000000000000000000000000000000000" : (0, n.arrToBufArr)((0, u.keccak256)(m(r, o, t, c)))];
          if ("function" === r) throw Error('Unsupported or invalid type: "function"');
          if (void 0 === o) throw Error(`missing value for field ${e} of type ${r}`);
          if ("address" === r) {
            if ("number" == typeof o) return ["address", (0, s.padStart)((0, a.numberToBytes)(o), 20)];
            if ((0, a.isStrictHexString)(o)) return ["address", (0, a.add0x)(o)];
            if ("string" == typeof o) return ["address", p(o).subarray(0, 20)]
          }
          if ("bool" === r) return ["bool", !!o];
          if ("bytes" === r) return "number" == typeof o ? o = (0, a.numberToBytes)(o) : (0, a.isStrictHexString)(o) || "0x" === o ? o = (0, a.hexToBytes)(o) : "string" == typeof o && (o = (0, a.stringToBytes)(o)), ["bytes32", (0, n.arrToBufArr)((0, u.keccak256)(o))];
          if (r.startsWith("bytes") && "bytes" !== r && !r.includes("[")) return "number" == typeof o ? 0 > o ? ["bytes32", new Uint8Array(32)] : ["bytes32", (0, a.bigIntToBytes)(BigInt(o))] : (0, a.isStrictHexString)(o) ? ["bytes32", (0, a.hexToBytes)(o)] : ["bytes32", o];
          if (r.startsWith("int") && !r.includes("[")) {
            const t = d(r, o);
            return t < BigInt(0) ? ["int256", t] : ["uint256", t]
          }
          if ("string" === r) return o = "number" == typeof o ? (0, a.numberToBytes)(o) : (0, a.stringToBytes)(o ?? ""), ["bytes32", (0, n.arrToBufArr)((0, u.keccak256)(o))];
          if (r.endsWith("]")) {
            if (c === f.V3) throw Error("Arrays are unimplemented in encodeData; use V4 extension");
            const s = r.slice(0, r.lastIndexOf("[")),
              a = o.map(r => b(t, e, s, r, c));
            return ["bytes32", (0, n.arrToBufArr)((0, u.keccak256)((0, i.encode)(a.map(([t]) => t), a.map(([, t]) => t))))]
          }
          return [r, o]
        }

        function m(t, e, r, o) {
          h(o, [f.V3, f.V4]);
          const s = ["bytes32"],
            a = [w(t, r)];
          for (const n of r[t]) {
            if (o === f.V3 && void 0 === e[n.name]) continue;
            const [t, i] = b(r, n.name, n.type, e[n.name], o);
            s.push(t), a.push(i)
          }
          return (0, n.arrToBufArr)((0, i.encode)(s, a))
        }

        function y(t, e) {
          let r = "";
          const n = g(t, e);
          n.delete(t);
          const i = [t, ...Array.from(n).sort()];
          for (const t of i) {
            if (!e[t]) throw Error("No type definition specified: " + t);
            r += `${t}(${e[t].map(({name:t,type:e})=>"\n            $ {\n              ie\n            }\n            $ {\n              H\n            }\n            ").join(",")})`
          }
          return r
        }

        function g(t, e, r = new Set) {
          if ("string" != typeof t) throw Error("Invalid findTypeDependencies input " + JSON.stringify(t));
          if ([t] = t.match(/^\w*/u), r.has(t) || void 0 === e[t]) return r;
          r.add(t);
          for (const n of e[t]) g(n.type, e, r);
          return r
        }

        function v(t, e, r, i) {
          h(i, [f.V3, f.V4]);
          const o = m(t, e, r, i),
            s = (0, u.keccak256)(o);
          return (0, n.arrToBufArr)(s)
        }

        function w(t, e) {
          const r = (0, a.stringToBytes)(y(t, e));
          return (0, n.arrToBufArr)((0, u.keccak256)(r))
        }

        function A(t) {
          const r = {};
          for (const n in e.TYPED_MESSAGE_SCHEMA.properties) t[n] && (r[n] = t[n]);
          return "types" in r && (r.types = Object.assign({
            EIP712Domain: []
          }, r.types)), r
        }

        function T(t, e) {
          h(e, [f.V3, f.V4]);
          const r = A(t),
            {
              domain: n
            } = r;
          return v("EIP712Domain", n, {
            EIP712Domain: r.types.EIP712Domain
          }, e)
        }

        function E(t, e) {
          if ((0, o.isArrayType)(t) && Array.isArray(e)) {
            const [r] = (0, o.getArrayType)(t);
            return e.map(t => E(r, t))
          }
          if ("address" === t) {
            if ("number" == typeof e) return (0, s.padStart)((0, a.numberToBytes)(e), 20);
            if ((0, a.isStrictHexString)(e)) return (0, s.padStart)((0, a.hexToBytes)(e).subarray(0, 20), 20);
            if (e instanceof Uint8Array) return (0, s.padStart)(e.subarray(0, 20), 20)
          }
          if ("bool" === t) return !!e;
          if (t.startsWith("bytes") && "bytes" !== t) {
            const r = (0, o.getByteLength)(t);
            if ("number" == typeof e) return 0 > e ? new Uint8Array : (0, a.numberToBytes)(e).subarray(0, r);
            if ((0, a.isStrictHexString)(e)) return (0, a.hexToBytes)(e).subarray(0, r);
            if (e instanceof Uint8Array) return e.subarray(0, r)
          }
          if (t.startsWith("uint") && "number" == typeof e) return Math.abs(e);
          if (t.startsWith("int") && "number" == typeof e) {
            const r = (0, o.getLength)(t);
            return BigInt.asIntN(r, BigInt(e))
          }
          return e
        }

        function P(t) {
          return t.map(t => "number" == typeof t ? (0, s.padStart)((0, a.numberToBytes)(t), 32) : (0, a.isStrictHexString)(t) ? (0, s.padStart)((0, a.hexToBytes)(t).subarray(0, 32), 32) : t instanceof Uint8Array ? (0, s.padStart)(t.subarray(0, 32), 32) : t)
        }

        function k(t, e) {
          return e.map(e => {
            if ("string" == typeof e || "number" == typeof e || "bigint" == typeof e) {
              const r = d(t, e);
              if (r >= BigInt(0)) return (0, s.padStart)((0, a.bigIntToBytes)(r), 32);
              const n = (0, o.getLength)(t),
                i = BigInt.asIntN(n, r);
              return (0, a.signedBigIntToBytes)(i, 32)
            }
            return e
          })
        }

        function x(t) {
          const e = Error("Expect argument to be non-empty array");
          if ("object" != typeof t || !("length" in t) || !t.length) throw e;
          const r = t.map(({
              name: t,
              type: e,
              value: r
            }) => {
              if ("address[]" === e) return {
                name: t,
                type: "bytes32[]",
                value: P(r)
              };
              if (e.startsWith("int") && (0, o.isArrayType)(e)) {
                const [n, i] = (0, o.getArrayType)(e);
                return {
                  name: t,
                  type: `bytes32[${i??""}]`,
                  value: k(n, r)
                }
              }
              return {
                name: t,
                type: e,
                value: E(e, r)
              }
            }),
            s = r.map(t => "bytes" !== t.type ? t.value : (0, c.legacyToBuffer)(t.value)),
            a = r.map(t => {
              if ("function" === t.type) throw Error('Unsupported or invalid type: "function"');
              return t.type
            }),
            f = t.map(t => {
              if (!t.name) throw e;
              return `${t.type} ${t.name}`
            });
          return (0, n.arrToBufArr)((0, u.keccak256)((0, i.encodePacked)(["bytes32", "bytes32"], [(0, u.keccak256)((0, i.encodePacked)(["string[]"], [f], !0)), (0, u.keccak256)((0, i.encodePacked)(a, s, !0))])))
        }(l = f = e.SignTypedDataVersion || (e.SignTypedDataVersion = {})).V1 = "V1", l.V3 = "V3", l.V4 = "V4", e.TYPED_MESSAGE_SCHEMA = {
          type: "object",
          properties: {
            types: {
              type: "object",
              additionalProperties: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    name: {
                      type: "string"
                    },
                    type: {
                      type: "string"
                    }
                  },
                  required: ["name", "type"]
                }
              }
            },
            primaryType: {
              type: "string"
            },
            domain: {
              type: "object"
            },
            message: {
              type: "object"
            }
          },
          required: ["types", "primaryType", "domain", "message"]
        }, e.TypedDataUtils = {
          encodeData: m,
          encodeType: y,
          findTypeDependencies: g,
          hashStruct: v,
          hashType: w,
          sanitizeData: A,
          eip712Hash: function(t, e) {
            h(e, [f.V3, f.V4]);
            const r = A(t),
              i = [(0, a.hexToBytes)("1901")];
            return i.push(T(t, e)), "EIP712Domain" !== r.primaryType && i.push(v(r.primaryType, r.message, r.types, e)), (0, n.arrToBufArr)((0, u.keccak256)((0, a.concatBytes)(i)))
          },
          eip712DomainHash: T
        }, e.typedSignatureHash = function(t) {
          const e = x(t);
          return (0, a.bytesToHex)(e)
        }, e.signTypedData = function({
          privateKey: t,
          data: r,
          version: i
        }) {
          if (h(i), (0, c.isNullish)(r)) throw Error("Missing data parameter");
          if ((0, c.isNullish)(t)) throw Error("Missing private key parameter");
          const o = i === f.V1 ? x(r) : e.TypedDataUtils.eip712Hash(r, i),
            s = (0, n.ecsign)(o, t);
          return (0, c.concatSig)((0, n.arrToBufArr)((0, a.bigIntToBytes)(s.v)), s.r, s.s)
        }, e.recoverTypedSignature = function({
          data: t,
          signature: r,
          version: i
        }) {
          if (h(i), (0, c.isNullish)(t)) throw Error("Missing data parameter");
          if ((0, c.isNullish)(r)) throw Error("Missing signature parameter");
          const o = i === f.V1 ? x(t) : e.TypedDataUtils.eip712Hash(t, i),
            s = (0, c.recoverPublicKey)(o, r),
            u = (0, n.publicToAddress)(s);
          return (0, a.bytesToHex)(u)
        }
      },
      12483: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, i.default)(t), e) {
            var r = RegExp("[".concat(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+$"), "g");
            return t.replace(r, "")
          }
          for (var n = t.length - 1;
            /\s/.test(t.charAt(n));) n -= 1;
          return t.slice(0, n + 1)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      13003: t => {
        "use strict";
        t.exports = function(t) {
          return t != t
        }
      },
      13144: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(11002),
          o = r(10076),
          s = r(47119);
        t.exports = s || n.call(o, i)
      },
      13237: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.commaDecimal = e.dotDecimal = e.bengaliLocales = e.farsiLocales = e.arabicLocales = e.englishLocales = e.decimal = e.alphanumeric = e.alpha = void 0;
        var r = {
          "en-US": /^[A-Z]+$/i,
          "az-AZ": /^[A-VXYZ]+$/i,
          "bg-BG": /^[-]+$/i,
          "cs-CZ": /^[A-Z]+$/i,
          "da-DK": /^[A-Z]+$/i,
          "de-DE": /^[A-Z]+$/i,
          "el-GR": /^[-]+$/i,
          "es-ES": /^[A-Z]+$/i,
          "fa-IR": /^[]+$/i,
          "fi-FI": /^[A-Z]+$/i,
          "fr-FR": /^[A-Z]+$/i,
          "it-IT": /^[A-Z]+$/i,
          "ja-JP": /^[----]+$/i,
          "nb-NO": /^[A-Z]+$/i,
          "nl-NL": /^[A-Z]+$/i,
          "nn-NO": /^[A-Z]+$/i,
          "hu-HU": /^[A-Z]+$/i,
          "pl-PL": /^[A-Z]+$/i,
          "pt-PT": /^[A-Z]+$/i,
          "ru-RU": /^[-]+$/i,
          "kk-KZ": /^[-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
          "sl-SI": /^[A-Z]+$/i,
          "sk-SK": /^[A-Z]+$/i,
          "sr-RS@latin": /^[A-Z]+$/i,
          "sr-RS": /^[-]+$/i,
          "sv-SE": /^[A-Z]+$/i,
          "th-TH": /^[-\s]+$/i,
          "tr-TR": /^[A-Z]+$/i,
          "uk-UA": /^[-I]+$/i,
          "vi-VN": /^[A-Z]+$/i,
          "ko-KR": /^[---]*$/,
          "ku-IQ": /^[]+$/i,
          ar: /^[]+$/,
          he: /^[-]+$/,
          fa: /^['']+$/i,
          bn: /^['']+$/,
          "hi-IN": /^[\u0900-\u0961]+[\u0972-\u097F]*$/i,
          "si-LK": /^[\u0D80-\u0DFF]+$/
        };
        e.alpha = r;
        var n = {
          "en-US": /^[0-9A-Z]+$/i,
          "az-AZ": /^[0-9A-VXYZ]+$/i,
          "bg-BG": /^[0-9-]+$/i,
          "cs-CZ": /^[0-9A-Z]+$/i,
          "da-DK": /^[0-9A-Z]+$/i,
          "de-DE": /^[0-9A-Z]+$/i,
          "el-GR": /^[0-9-]+$/i,
          "es-ES": /^[0-9A-Z]+$/i,
          "fi-FI": /^[0-9A-Z]+$/i,
          "fr-FR": /^[0-9A-Z]+$/i,
          "it-IT": /^[0-9A-Z]+$/i,
          "ja-JP": /^[0-9-----]+$/i,
          "hu-HU": /^[0-9A-Z]+$/i,
          "nb-NO": /^[0-9A-Z]+$/i,
          "nl-NL": /^[0-9A-Z]+$/i,
          "nn-NO": /^[0-9A-Z]+$/i,
          "pl-PL": /^[0-9A-Z]+$/i,
          "pt-PT": /^[0-9A-Z]+$/i,
          "ru-RU": /^[0-9-]+$/i,
          "kk-KZ": /^[0-9-\u04D8\u04B0\u0406\u04A2\u0492\u04AE\u049A\u04E8\u04BA]+$/i,
          "sl-SI": /^[0-9A-Z]+$/i,
          "sk-SK": /^[0-9A-Z]+$/i,
          "sr-RS@latin": /^[0-9A-Z]+$/i,
          "sr-RS": /^[0-9-]+$/i,
          "sv-SE": /^[0-9A-Z]+$/i,
          "th-TH": /^[-\s]+$/i,
          "tr-TR": /^[0-9A-Z]+$/i,
          "uk-UA": /^[0-9-I]+$/i,
          "ko-KR": /^[0-9---]*$/,
          "ku-IQ": /^[0-9]+$/i,
          "vi-VN": /^[0-9A-Z]+$/i,
          ar: /^[0-9]+$/,
          he: /^[0-9-]+$/,
          fa: /^['0-9']+$/i,
          bn: /^['']+$/,
          "hi-IN": /^[\u0900-\u0963]+[\u0966-\u097F]*$/i,
          "si-LK": /^[0-9\u0D80-\u0DFF]+$/
        };
        e.alphanumeric = n;
        var i = {
          "en-US": ".",
          ar: ""
        };
        e.decimal = i;
        var o = ["AU", "GB", "HK", "IN", "NZ", "ZA", "ZM"];
        e.englishLocales = o;
        for (var s, a = 0; o.length > a; a++) r[s = "en-".concat(o[a])] = r["en-US"], n[s] = n["en-US"], i[s] = i["en-US"];
        var u = ["AE", "BH", "DZ", "EG", "IQ", "JO", "KW", "LB", "LY", "MA", "QM", "QA", "SA", "SD", "SY", "TN", "YE"];
        e.arabicLocales = u;
        for (var c, f = 0; u.length > f; f++) r[c = "ar-".concat(u[f])] = r.ar, n[c] = n.ar, i[c] = i.ar;
        var l = ["IR", "AF"];
        e.farsiLocales = l;
        for (var h, d = 0; l.length > d; d++) n[h = "fa-".concat(l[d])] = n.fa, i[h] = i.ar;
        var p = ["BD", "IN"];
        e.bengaliLocales = p;
        for (var b, m = 0; p.length > m; m++) r[b = "bn-".concat(p[m])] = r.bn, n[b] = n.bn, i[b] = i["en-US"];
        var y = ["ar-EG", "ar-LB", "ar-LY"];
        e.dotDecimal = y;
        var g = ["bg-BG", "cs-CZ", "da-DK", "de-DE", "el-GR", "en-ZM", "es-ES", "fr-CA", "fr-FR", "id-ID", "it-IT", "ku-IQ", "hi-IN", "hu-HU", "nb-NO", "nn-NO", "nl-NL", "pl-PL", "pt-PT", "ru-RU", "kk-KZ", "si-LK", "sl-SI", "sr-RS@latin", "sr-RS", "sv-SE", "tr-TR", "uk-UA", "vi-VN"];
        e.commaDecimal = g;
        for (var v = 0; y.length > v; v++) i[y[v]] = i["en-US"];
        for (var w = 0; g.length > w; w++) i[g[w]] = ",";
        r["fr-CA"] = r["fr-FR"], n["fr-CA"] = n["fr-FR"], r["pt-BR"] = r["pt-PT"], n["pt-BR"] = n["pt-PT"], i["pt-BR"] = i["pt-PT"], r["pl-Pl"] = r["pl-PL"], n["pl-Pl"] = n["pl-PL"], i["pl-Pl"] = i["pl-PL"], r["fa-AF"] = r.fa
      },
      13543: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionDescription = e.loadTransactionDescription = void 0;
        const n = r(65871),
          i = r(49589),
          o = r(96305),
          s = r(464),
          a = r(35726),
          u = r(53857),
          c = r(11065),
          f = r(58353);
        e.loadTransactionDescription = function(t) {
          let e = t.loadUint(4);
          if (0 === e) {
            const e = t.loadBit();
            let r, n;
            t.loadBit() && (r = (0, f.loadTransactionStoragePhase)(t)), t.loadBit() && (n = (0, c.loadTransactionCreditPhase)(t));
            let i, o = (0, u.loadTransactionComputePhase)(t);
            t.loadBit() && (i = (0, s.loadTransactionActionPhase)(t.loadRef().beginParse()));
            let l, h = t.loadBit();
            return t.loadBit() && (l = (0, a.loadTransactionBouncePhase)(t)), {
              type: "generic",
              creditFirst: e,
              storagePhase: r,
              creditPhase: n,
              computePhase: o,
              actionPhase: i,
              bouncePhase: l,
              aborted: h,
              destroyed: t.loadBit()
            }
          }
          if (1 === e) return {
            type: "storage",
            storagePhase: (0, f.loadTransactionStoragePhase)(t)
          };
          if (2 === e || 3 === e) {
            const r = 3 === e;
            let n, i = (0, f.loadTransactionStoragePhase)(t),
              o = (0, u.loadTransactionComputePhase)(t);
            return t.loadBit() && (n = (0, s.loadTransactionActionPhase)(t.loadRef().beginParse())), {
              type: "tick-tock",
              isTock: r,
              storagePhase: i,
              computePhase: o,
              actionPhase: n,
              aborted: t.loadBit(),
              destroyed: t.loadBit()
            }
          }
          if (4 === e) {
            let e, r = (0, i.loadSplitMergeInfo)(t);
            t.loadBit() && (e = (0, f.loadTransactionStoragePhase)(t));
            let n, o = (0, u.loadTransactionComputePhase)(t);
            return t.loadBit() && (n = (0, s.loadTransactionActionPhase)(t.loadRef().beginParse())), {
              type: "split-prepare",
              splitInfo: r,
              storagePhase: e,
              computePhase: o,
              actionPhase: n,
              aborted: t.loadBit(),
              destroyed: t.loadBit()
            }
          }
          if (5 === e) return {
            type: "split-install",
            splitInfo: (0, i.loadSplitMergeInfo)(t),
            prepareTransaction: (0, o.loadTransaction)(t.loadRef().beginParse()),
            installed: t.loadBit()
          };
          throw Error("Unsupported transaction description type " + e)
        }, e.storeTransactionDescription = function(t) {
          return e => {
            if ("generic" === t.type) e.storeUint(0, 4), e.storeBit(t.creditFirst), t.storagePhase ? (e.storeBit(!0), e.store((0, f.storeTransactionsStoragePhase)(t.storagePhase))) : e.storeBit(!1), t.creditPhase ? (e.storeBit(!0), e.store((0, c.storeTransactionCreditPhase)(t.creditPhase))) : e.storeBit(!1), e.store((0, u.storeTransactionComputePhase)(t.computePhase)), t.actionPhase ? (e.storeBit(!0), e.storeRef((0, n.beginCell)().store((0, s.storeTransactionActionPhase)(t.actionPhase)))) : e.storeBit(!1), e.storeBit(t.aborted), t.bouncePhase ? (e.storeBit(!0), e.store((0, a.storeTransactionBouncePhase)(t.bouncePhase))) : e.storeBit(!1), e.storeBit(t.destroyed);
            else if ("storage" === t.type) e.storeUint(1, 4), e.store((0, f.storeTransactionsStoragePhase)(t.storagePhase));
            else if ("tick-tock" === t.type) e.storeUint(t.isTock ? 3 : 2, 4), e.store((0, f.storeTransactionsStoragePhase)(t.storagePhase)), e.store((0, u.storeTransactionComputePhase)(t.computePhase)), t.actionPhase ? (e.storeBit(!0), e.storeRef((0, n.beginCell)().store((0, s.storeTransactionActionPhase)(t.actionPhase)))) : e.storeBit(!1), e.storeBit(t.aborted), e.storeBit(t.destroyed);
            else if ("split-prepare" === t.type) e.storeUint(4, 4), e.store((0, i.storeSplitMergeInfo)(t.splitInfo)), t.storagePhase ? (e.storeBit(!0), e.store((0, f.storeTransactionsStoragePhase)(t.storagePhase))) : e.storeBit(!1), e.store((0, u.storeTransactionComputePhase)(t.computePhase)), t.actionPhase ? (e.storeBit(!0), e.store((0, s.storeTransactionActionPhase)(t.actionPhase))) : e.storeBit(!1), e.storeBit(t.aborted), e.storeBit(t.destroyed);
            else {
              if ("split-install" !== t.type) throw Error("Unsupported transaction description type " + t.type);
              e.storeUint(5, 4), e.store((0, i.storeSplitMergeInfo)(t.splitInfo)), e.storeRef((0, n.beginCell)().store((0, o.storeTransaction)(t.prepareTransaction))), e.storeBit(t.installed)
            }
          }
        }
      },
      13735: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, n.default)(t), (0, i.default)(t) % parseInt(e, 10) === 0
        };
        var n = o(r(83399)),
          i = o(r(33752));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      13752: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), t = Date.parse(t), isNaN(t) ? null : new Date(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      13874: (t, e, r) => {
        const n = r(78311);
        t.exports = (t, e) => {
          try {
            return new n(t, e).range || "*"
          } catch {
            return null
          }
        }
      },
      13999: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => 0 !== n(t, e, r)
      },
      14035: (t, e, r) => {
        "use strict";
        var n, i = r(36556),
          o = r(49092)(),
          s = r(9957),
          a = r(75795);
        if (o) {
          var u = i("RegExp.prototype.exec"),
            c = {},
            f = function() {
              throw c
            },
            l = {
              toString: f,
              valueOf: f
            };
          "symbol" == typeof Symbol.toPrimitive && (l[Symbol.toPrimitive] = f), n = function(t) {
            if (!t || "object" != typeof t) return !1;
            var e = a(t, "lastIndex");
            if (!e || !s(e, "value")) return !1;
            try {
              u(t, l)
            } catch (t) {
              return t === c
            }
          }
        } else {
          var h = i("Object.prototype.toString");
          n = function(t) {
            return !(!t || "object" != typeof t && "function" != typeof t) && "[object RegExp]" === h(t)
          }
        }
        t.exports = n
      },
      14112: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV5R1 = void 0;
        const i = r(1307),
          o = r(20574),
          s = r(27322);
        class a {
          static create(t) {
            let e = 0;
            return "workchain" in t && null != t.workchain && (e = t.workchain), t.walletId?.context && (0, s.isWalletIdV5R1ClientContext)(t.walletId.context) && null != t.walletId.context.workchain && (e = t.walletId.context.workchain), new a(e, t.publicKey, {
              networkGlobalId: t.walletId?.networkGlobalId ?? -239,
              context: t.walletId?.context ?? {
                workchain: 0,
                walletVersion: "v5r1",
                subwalletNumber: 0
              }
            })
          }
          constructor(t, e, r) {
            this.publicKey = e, this.walletId = r, this.walletId = r;
            let o = i.Cell.fromBoc(n.from("b5ee9c7241021401000281000114ff00f4a413f4bcf2c80b01020120020d020148030402dcd020d749c120915b8f6320d70b1f2082106578746ebd21821073696e74bdb0925f03e082106578746eba8eb48020d72101d074d721fa4030fa44f828fa443058bd915be0ed44d0810141d721f4058307f40e6fa1319130e18040d721707fdb3ce03120d749810280b99130e070e2100f020120050c020120060902016e07080019adce76a2684020eb90eb85ffc00019af1df6a2684010eb90eb858fc00201480a0b0017b325fb51341c75c875c2c7e00011b262fb513435c280200019be5f0f6a2684080a0eb90fa02c0102f20e011e20d70b1f82107369676ebaf2e08a7f0f01e68ef0eda2edfb218308d722028308d723208020d721d31fd31fd31fed44d0d200d31f20d31fd3ffd70a000af90140ccf9109a28945f0adb31e1f2c087df02b35007b0f2d0845125baf2e0855036baf2e086f823bbf2d0882292f800de01a47fc8ca00cb1f01cf16c9ed542092f80fde70db3cd81003f6eda2edfb02f404216e926c218e4c0221d73930709421c700b38e2d01d72820761e436c20d749c008f2e09320d74ac002f2e09320d71d06c712c2005230b0f2d089d74cd7393001a4e86c128407bbf2e093d74ac000f2e093ed55e2d20001c000915be0ebd72c08142091709601d72c081c12e25210b1e30f20d74a111213009601fa4001fa44f828fa443058baf2e091ed44d0810141d718f405049d7fc8ca0040048307f453f2e08b8e14038307f45bf2e08c22d70a00216e01b3b0f2d090e2c85003cf1612f400c9ed54007230d72c08248e2d21f2e092d200ed44d0d2005113baf2d08f54503091319c01810140d721d70a00f2e08ee2c8ca0058cf16c9ed5493f2c08de20010935bdb31e1d74cd0b4d6c35e", "hex"))[0],
              a = (0, i.beginCell)().storeUint(1, 1).storeUint(0, 32).store((0, s.storeWalletIdV5R1)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
            this.init = {
              code: o,
              data: a
            }, this.address = (0, i.contractAddress)(t, {
              code: o,
              data: a
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async getExtensions(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("get_extensions", [])).stack.readCellOpt() : null
          }
          async getExtensionsArray(t) {
            const e = await this.getExtensions(t);
            return e ? i.Dictionary.loadDirect(i.Dictionary.Keys.BigUint(256), i.Dictionary.Values.BigInt(1), e).keys().map(t => {
              const e = this.address.workChain;
              return i.Address.parseRaw(`${e}:${t.toString(16).padStart(64,"0")}`)
            }) : []
          }
          async getIsSecretKeyAuthEnabled(t) {
            return (await t.get("is_signature_allowed", [])).stack.readBoolean()
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            const r = await this.createTransfer(e);
            await this.send(t, r)
          }
          async sendAddExtension(t, e) {
            const r = await this.createAddExtension(e);
            await this.send(t, r)
          }
          async sendRemoveExtension(t, e) {
            const r = await this.createRemoveExtension(e);
            await this.send(t, r)
          }
          createActions(t) {
            return t.messages.map(e => ({
              type: "sendMsg",
              mode: t.sendMode,
              outMsg: e
            }))
          }
          createTransfer(t) {
            return this.createRequest({
              actions: this.createActions({
                messages: t.messages,
                sendMode: t.sendMode
              }),
              ...t
            })
          }
          createAddExtension(t) {
            return this.createRequest({
              actions: [{
                type: "addExtension",
                address: t.extensionAddress
              }],
              ...t
            })
          }
          createRemoveExtension(t) {
            return this.createRequest({
              actions: [{
                type: "removeExtension",
                address: t.extensionAddress
              }],
              ...t
            })
          }
          createRequest(t) {
            return "extension" === t.authType ? (0, o.createWalletTransferV5R1)(t) : (0, o.createWalletTransferV5R1)({
              ...t,
              walletId: (0, s.storeWalletIdV5R1)(this.walletId)
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode ?? i.SendMode.PAY_GAS_SEPARATELY + i.SendMode.IGNORE_ERRORS,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV5R1 = a, a.OpCodes = {
          auth_extension: 1702392942,
          auth_signed_external: 1936287598,
          auth_signed_internal: 1936289396
        }
      },
      14545: (t, e) => {
        e.isatty = function() {
          return !1
        }, e.ReadStream = function() {
          throw Error("tty.ReadStream is not implemented")
        }, e.WriteStream = function() {
          throw Error("tty.WriteStream is not implemented")
        }
      },
      14568: (t, e) => {
        "use strict";
        var r, n;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.SendMode = void 0, (n = r || (e.SendMode = r = {}))[n.CARRY_ALL_REMAINING_BALANCE = 128] = "CARRY_ALL_REMAINING_BALANCE", n[n.CARRY_ALL_REMAINING_INCOMING_VALUE = 64] = "CARRY_ALL_REMAINING_INCOMING_VALUE", n[n.DESTROY_ACCOUNT_IF_ZERO = 32] = "DESTROY_ACCOUNT_IF_ZERO", n[n.PAY_GAS_SEPARATELY = 1] = "PAY_GAS_SEPARATELY", n[n.IGNORE_ERRORS = 2] = "IGNORE_ERRORS", n[n.NONE = 0] = "NONE"
      },
      14660: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeHashUpdate = e.loadHashUpdate = void 0, e.loadHashUpdate = function(t) {
          if (114 !== t.loadUint(8)) throw Error("Invalid data");
          return {
            oldHash: t.loadBuffer(32),
            newHash: t.loadBuffer(32)
          }
        }, e.storeHashUpdate = function(t) {
          return e => {
            e.storeUint(114, 8), e.storeBuffer(t.oldHash), e.storeBuffer(t.newHash)
          }
        }
      },
      14803: (t, e, r) => {
        "use strict";
        var n = r(58859),
          i = r(69675),
          o = function(t, e, r) {
            for (var n, i = t; null != (n = i.next); i = n)
              if (n.key === e) return i.next = n.next, r || (n.next = t.next, t.next = n), n
          };
        t.exports = function() {
          var t, e = {
            assert: function(t) {
              if (!e.has(t)) throw new i("Side channel does not contain " + n(t))
            },
            delete: function(e) {
              var r = t && t.next,
                n = function(t, e) {
                  if (t) return o(t, e, !0)
                }(t, e);
              return n && r && r === n && (t = void 0), !!n
            },
            get: function(e) {
              return function(t, e) {
                if (t) {
                  var r = o(t, e);
                  return r && r.value
                }
              }(t, e)
            },
            has: function(e) {
              return function(t, e) {
                return !!t && !!o(t, e)
              }(t, e)
            },
            set: function(e, r) {
              t || (t = {
                  next: void 0
                }),
                function(t, e, r) {
                  var n = o(t, e);
                  n ? n.value = r : t.next = {
                    key: e,
                    next: t.next,
                    value: r
                  }
                }(t, e, r)
            }
          };
          return e
        }
      },
      14823: t => {
        "use strict";
        var e = function() {
          for (var t, e = [], r = 0; 256 > r; r++) {
            t = r;
            for (var n = 0; 8 > n; n++) t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
            e[r] = t
          }
          return e
        }();
        t.exports = function(t, r, n, i) {
          var o = e,
            s = i + n;
          t ^= -1;
          for (var a = i; s > a; a++) t = t >>> 8 ^ o[255 & (t ^ r[a])];
          return -1 ^ t
        }
      },
      15340: () => {},
      15354: (t, e) => {
        "use strict";
        var r;

        function n(t) {
          return 127 >= t.charCodeAt(0)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.calculateNumberSize = e.calculateStringSize = e.isASCII = e.isPlainObject = e.ESCAPE_CHARACTERS_REGEXP = e.JsonSize = e.getKnownPropertyNames = e.hasProperty = e.isObject = e.isNullOrUndefined = e.isNonEmptyArray = void 0, e.isNonEmptyArray = function(t) {
          return Array.isArray(t) && t.length > 0
        }, e.isNullOrUndefined = function(t) {
          return null == t
        }, e.isObject = function(t) {
          return !!t && "object" == typeof t && !Array.isArray(t)
        }, e.hasProperty = (t, e) => Object.hasOwnProperty.call(t, e), e.getKnownPropertyNames = function(t) {
          return Object.getOwnPropertyNames(t)
        }, (r = e.JsonSize || (e.JsonSize = {}))[r.Null = 4] = "Null", r[r.Comma = 1] = "Comma", r[r.Wrapper = 1] = "Wrapper", r[r.True = 4] = "True", r[r.False = 5] = "False", r[r.Quote = 1] = "Quote", r[r.Colon = 1] = "Colon", r[r.Date = 24] = "Date", e.ESCAPE_CHARACTERS_REGEXP = /"|\\|\n|\r|\t/gu, e.isPlainObject = function(t) {
          if ("object" != typeof t || null === t) return !1;
          try {
            let e = t;
            for (; null !== Object.getPrototypeOf(e);) e = Object.getPrototypeOf(e);
            return Object.getPrototypeOf(t) === e
          } catch {
            return !1
          }
        }, e.isASCII = n, e.calculateStringSize = function(t) {
          return t.split("").reduce((t, e) => n(e) ? t + 1 : t + 2, 0) + (t.match(e.ESCAPE_CHARACTERS_REGEXP) ?? []).length
        }, e.calculateNumberSize = function(t) {
          return t.toString().length
        }
      },
      16284: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.accountBodyToRLP = e.accountBodyToSlim = e.accountBodyFromSlim = e.isZeroAddress = e.zeroAddress = e.importPublic = e.privateToAddress = e.privateToPublic = e.publicToAddress = e.pubToAddress = e.isValidPublic = e.isValidPrivate = e.generateAddress2 = e.generateAddress = e.isValidChecksumAddress = e.toChecksumAddress = e.isValidAddress = e.Account = void 0;
        const i = r(66289),
          o = r(32019),
          s = r(26513),
          a = r(82672),
          u = r(77312),
          c = r(89838),
          f = r(35546),
          l = r(59498),
          h = BigInt(0);
        class d {
          constructor(t = h, e = h, r = c.KECCAK256_RLP, n = c.KECCAK256_NULL) {
            this.nonce = t, this.balance = e, this.storageRoot = r, this.codeHash = n, this.Bt()
          }
          static fromAccountData(t) {
            const {
              nonce: e,
              balance: r,
              storageRoot: n,
              codeHash: i
            } = t;
            return new d(void 0 !== e ? (0, u.bufferToBigInt)((0, u.toBuffer)(e)) : void 0, void 0 !== r ? (0, u.bufferToBigInt)((0, u.toBuffer)(r)) : void 0, void 0 !== n ? (0, u.toBuffer)(n) : void 0, void 0 !== i ? (0, u.toBuffer)(i) : void 0)
          }
          static fromRlpSerializedAccount(t) {
            const e = (0, u.arrToBufArr)(i.RLP.decode(Uint8Array.from(t)));
            if (!Array.isArray(e)) throw Error("Invalid serialized account input. Must be array");
            return this.fromValuesArray(e)
          }
          static fromValuesArray(t) {
            const [e, r, n, i] = t;
            return new d((0, u.bufferToBigInt)(e), (0, u.bufferToBigInt)(r), n, i)
          }
          Bt() {
            if (this.nonce < h) throw Error("nonce must be greater than zero");
            if (this.balance < h) throw Error("balance must be greater than zero");
            if (32 !== this.storageRoot.length) throw Error("storageRoot must have a length of 32");
            if (32 !== this.codeHash.length) throw Error("codeHash must have a length of 32")
          }
          raw() {
            return [(0, u.bigIntToUnpaddedBuffer)(this.nonce), (0, u.bigIntToUnpaddedBuffer)(this.balance), this.storageRoot, this.codeHash]
          }
          serialize() {
            return n.from(i.RLP.encode((0, u.bufArrToArr)(this.raw())))
          }
          isContract() {
            return !this.codeHash.equals(c.KECCAK256_NULL)
          }
          isEmpty() {
            return this.balance === h && this.nonce === h && this.codeHash.equals(c.KECCAK256_NULL)
          }
        }

        function p(t) {
          const [e, r, n, i] = t;
          return [e, r, 0 === (0, u.arrToBufArr)(n).length ? c.KECCAK256_RLP : n, 0 === (0, u.arrToBufArr)(i).length ? c.KECCAK256_NULL : i]
        }
        e.Account = d, e.isValidAddress = function(t) {
          try {
            (0, f.assertIsString)(t)
          } catch {
            return !1
          }
          return /^0x[0-9a-fA-F]{40}$/.test(t)
        }, e.toChecksumAddress = function(t, e) {
          (0, f.assertIsHexString)(t);
          const r = (0, l.stripHexPrefix)(t).toLowerCase();
          let i = "";
          void 0 !== e && (i = (0, u.bufferToBigInt)((0, u.toBuffer)(e)).toString() + "0x");
          const s = n.from(i + r, "utf8"),
            c = (0, a.bytesToHex)((0, o.keccak256)(s));
          let h = "0x";
          for (let t = 0; t < r.length; t++) 8 > parseInt(c[t], 16) ? h += r[t] : h += r[t].toUpperCase();
          return h
        }, e.isValidChecksumAddress = function(t, r) {
          return (0, e.isValidAddress)(t) && (0, e.toChecksumAddress)(t, r) === t
        }, e.generateAddress = function(t, e) {
          return (0, f.assertIsBuffer)(t), (0, f.assertIsBuffer)(e), (0, u.bufferToBigInt)(e) === BigInt(0) ? n.from((0, o.keccak256)(i.RLP.encode((0, u.bufArrToArr)([t, null])))).slice(-20) : n.from((0, o.keccak256)(i.RLP.encode((0, u.bufArrToArr)([t, e])))).slice(-20)
        }, e.generateAddress2 = function(t, e, r) {
          if ((0, f.assertIsBuffer)(t), (0, f.assertIsBuffer)(e), (0, f.assertIsBuffer)(r), 20 !== t.length) throw Error("Expected from to be of length 20");
          if (32 !== e.length) throw Error("Expected salt to be of length 32");
          const i = (0, o.keccak256)(n.concat([n.from("ff", "hex"), t, e, (0, o.keccak256)(r)]));
          return (0, u.toBuffer)(i).slice(-20)
        }, e.isValidPrivate = function(t) {
          return s.secp256k1.utils.isValidPrivateKey(t)
        }, e.isValidPublic = function(t, e = !1) {
          if ((0, f.assertIsBuffer)(t), 64 === t.length) try {
            return s.secp256k1.ProjectivePoint.fromHex(n.concat([n.from([4]), t])), !0
          } catch {
            return !1
          }
          if (!e) return !1;
          try {
            return s.secp256k1.ProjectivePoint.fromHex(t), !0
          } catch {
            return !1
          }
        }, e.pubToAddress = function(t, e = !1) {
          if ((0, f.assertIsBuffer)(t), e && 64 !== t.length && (t = n.from(s.secp256k1.ProjectivePoint.fromHex(t).toRawBytes(!1).slice(1))), 64 !== t.length) throw Error("Expected pubKey to be of length 64");
          return n.from((0, o.keccak256)(t)).slice(-20)
        }, e.publicToAddress = e.pubToAddress, e.privateToPublic = function(t) {
          return (0, f.assertIsBuffer)(t), n.from(s.secp256k1.ProjectivePoint.fromPrivateKey(t).toRawBytes(!1).slice(1))
        }, e.privateToAddress = function(t) {
          return (0, e.publicToAddress)((0, e.privateToPublic)(t))
        }, e.importPublic = function(t) {
          return (0, f.assertIsBuffer)(t), 64 !== t.length && (t = n.from(s.secp256k1.ProjectivePoint.fromHex(t).toRawBytes(!1).slice(1))), t
        }, e.zeroAddress = function() {
          const t = (0, u.zeros)(20);
          return (0, u.bufferToHex)(t)
        }, e.isZeroAddress = function(t) {
          try {
            (0, f.assertIsString)(t)
          } catch {
            return !1
          }
          return (0, e.zeroAddress)() === t
        }, e.accountBodyFromSlim = p;
        const b = new Uint8Array(0);
        e.accountBodyToSlim = function(t) {
          const [e, r, n, i] = t;
          return [e, r, (0, u.arrToBufArr)(n).equals(c.KECCAK256_RLP) ? b : n, (0, u.arrToBufArr)(i).equals(c.KECCAK256_NULL) ? b : i]
        }, e.accountBodyToRLP = function(t, e = !0) {
          const r = e ? p(t) : t;
          return (0, u.arrToBufArr)(i.RLP.encode(r))
        }
      },
      16340: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(53318), e), i(r(77670), e), i(r(66408), e)
      },
      16708: (t, e, r) => {
        "use strict";
        var n, i = r(65606);

        function o(t) {
          var e = this;
          this.next = null, this.entry = null, this.finish = function() {
            ! function(t, e) {
              var r = t.entry;
              for (t.entry = null; r;) {
                var n = r.callback;
                e.pendingcb--, n(void 0), r = r.next
              }
              e.corkedRequestsFree.next = t
            }(e, t)
          }
        }
        t.exports = k, k.WritableState = P;
        var s, a = {
            deprecate: r(94643)
          },
          u = r(40345),
          c = r(48287).Buffer,
          f = ("u" > typeof r.g ? r.g : "u" > typeof window ? window : "u" > typeof self ? self : {}).Uint8Array || function() {},
          l = r(75896),
          h = r(65291).getHighWaterMark,
          d = r(86048).F,
          p = d.ERR_INVALID_ARG_TYPE,
          b = d.ERR_METHOD_NOT_IMPLEMENTED,
          m = d.ERR_MULTIPLE_CALLBACK,
          y = d.ERR_STREAM_CANNOT_PIPE,
          g = d.ERR_STREAM_DESTROYED,
          v = d.ERR_STREAM_NULL_VALUES,
          w = d.ERR_STREAM_WRITE_AFTER_END,
          A = d.ERR_UNKNOWN_ENCODING,
          T = l.errorOrDestroy;

        function E() {}

        function P(t, e, s) {
          n = n || r(25382), t = t || {}, "boolean" != typeof s && (s = e instanceof n), this.objectMode = !!t.objectMode, s && (this.objectMode = this.objectMode || !!t.writableObjectMode), this.highWaterMark = h(this, t, "writableHighWaterMark", s), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
          var a = !1 === t.decodeStrings;
          this.decodeStrings = !a, this.defaultEncoding = t.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(t) {
            ! function(t, e) {
              var r = t.Wt,
                n = r.sync,
                o = r.writecb;
              if ("function" != typeof o) throw new m;
              if (function(t) {
                  t.writing = !1, t.writecb = null, t.length -= t.writelen, t.writelen = 0
                }(r), e) ! function(t, e, r, n, o) {
                --e.pendingcb, r ? (i.nextTick(o, n), i.nextTick(W, t, e), t.Wt.errorEmitted = !0, T(t, n)) : (o(n), t.Wt.errorEmitted = !0, T(t, n), W(t, e))
              }(t, r, n, e, o);
              else {
                var s = O(r) || t.destroyed;
                !s && !r.corked && !r.bufferProcessing && r.bufferedRequest && S(t, r), n ? i.nextTick(I, t, r, s, o) : I(t, r, s, o)
              }
            }(e, t)
          }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new o(this)
        }

        function k(t) {
          var e = this instanceof(n = n || r(25382));
          if (!e && !s.call(k, this)) return new k(t);
          this.Wt = new P(t, this, e), this.writable = !0, t && ("function" == typeof t.write && (this.it = t.write), "function" == typeof t.writev && (this.Mt = t.writev), "function" == typeof t.destroy && (this.Ct = t.destroy), "function" == typeof t.final && (this.Rt = t.final)), u.call(this)
        }

        function x(t, e, r, n, i, o, s) {
          e.writelen = n, e.writecb = s, e.writing = !0, e.sync = !0, e.destroyed ? e.onwrite(new g("write")) : r ? t.Mt(i, e.onwrite) : t.it(i, o, e.onwrite), e.sync = !1
        }

        function I(t, e, r, n) {
          r || function(t, e) {
            0 === e.length && e.needDrain && (e.needDrain = !1, t.emit("drain"))
          }(t, e), e.pendingcb--, n(), W(t, e)
        }

        function S(t, e) {
          e.bufferProcessing = !0;
          var r = e.bufferedRequest;
          if (t.Mt && r && r.next) {
            var n = e.bufferedRequestCount,
              i = Array(n),
              s = e.corkedRequestsFree;
            s.entry = r;
            for (var a = 0, u = !0; r;) i[a] = r, r.isBuf || (u = !1), r = r.next, a += 1;
            i.allBuffers = u, x(t, e, !0, e.length, i, "", s.finish), e.pendingcb++, e.lastBufferedRequest = null, s.next ? (e.corkedRequestsFree = s.next, s.next = null) : e.corkedRequestsFree = new o(e), e.bufferedRequestCount = 0
          } else {
            for (; r;) {
              var c = r.chunk,
                f = r.encoding,
                l = r.callback;
              if (x(t, e, !1, e.objectMode ? 1 : c.length, c, f, l), r = r.next, e.bufferedRequestCount--, e.writing) break
            }
            null === r && (e.lastBufferedRequest = null)
          }
          e.bufferedRequest = r, e.bufferProcessing = !1
        }

        function O(t) {
          return t.ending && 0 === t.length && null === t.bufferedRequest && !t.finished && !t.writing
        }

        function B(t, e) {
          t.Rt(function(r) {
            e.pendingcb--, r && T(t, r), e.prefinished = !0, t.emit("prefinish"), W(t, e)
          })
        }

        function W(t, e) {
          var r = O(e);
          if (r && (function(t, e) {
              !e.prefinished && !e.finalCalled && ("function" != typeof t.Rt || e.destroyed ? (e.prefinished = !0, t.emit("prefinish")) : (e.pendingcb++, e.finalCalled = !0, i.nextTick(B, t, e)))
            }(t, e), 0 === e.pendingcb && (e.finished = !0, t.emit("finish"), e.autoDestroy))) {
            var n = t.rt;
            (!n || n.autoDestroy && n.endEmitted) && t.destroy()
          }
          return r
        }
        r(56698)(k, u), P.prototype.getBuffer = function() {
            for (var t = this.bufferedRequest, e = []; t;) e.push(t), t = t.next;
            return e
          },
          function() {
            try {
              Object.defineProperty(P.prototype, "buffer", {
                get: a.deprecate(function() {
                  return this.getBuffer()
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
              })
            } catch {}
          }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (s = Function.prototype[Symbol.hasInstance], Object.defineProperty(k, Symbol.hasInstance, {
            value: function(t) {
              return !!s.call(this, t) || this === k && t && t.Wt instanceof P
            }
          })) : s = function(t) {
            return t instanceof this
          }, k.prototype.pipe = function() {
            T(this, new y)
          }, k.prototype.write = function(t, e, r) {
            var n = this.Wt,
              o = !1,
              s = !n.objectMode && function(t) {
                return c.isBuffer(t) || t instanceof f
              }(t);
            return s && !c.isBuffer(t) && (t = function(t) {
              return c.from(t)
            }(t)), "function" == typeof e && (r = e, e = null), s ? e = "buffer" : e || (e = n.defaultEncoding), "function" != typeof r && (r = E), n.ending ? function(t, e) {
              var r = new w;
              T(t, r), i.nextTick(e, r)
            }(this, r) : (s || function(t, e, r, n) {
              var o;
              return null === r ? o = new v : "string" != typeof r && !e.objectMode && (o = new p("chunk", ["string", "Buffer"], r)), !o || (T(t, o), i.nextTick(n, o), !1)
            }(this, n, t, r)) && (n.pendingcb++, o = function(t, e, r, n, i, o) {
              if (!r) {
                var s = function(t, e, r) {
                  return !t.objectMode && !1 !== t.decodeStrings && "string" == typeof e && (e = c.from(e, r)), e
                }(e, n, i);
                n !== s && (r = !0, i = "buffer", n = s)
              }
              var a = e.objectMode ? 1 : n.length;
              e.length += a;
              var u = e.length < e.highWaterMark;
              if (u || (e.needDrain = !0), e.writing || e.corked) {
                var f = e.lastBufferedRequest;
                e.lastBufferedRequest = {
                  chunk: n,
                  encoding: i,
                  isBuf: r,
                  callback: o,
                  next: null
                }, f ? f.next = e.lastBufferedRequest : e.bufferedRequest = e.lastBufferedRequest, e.bufferedRequestCount += 1
              } else x(t, e, !1, a, n, i, o);
              return u
            }(this, n, s, t, e, r)), o
          }, k.prototype.cork = function() {
            this.Wt.corked++
          }, k.prototype.uncork = function() {
            var t = this.Wt;
            t.corked && (t.corked--, !t.writing && !t.corked && !t.bufferProcessing && t.bufferedRequest && S(this, t))
          }, k.prototype.setDefaultEncoding = function(t) {
            if ("string" == typeof t && (t = t.toLowerCase()), -1 >= ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((t + "").toLowerCase())) throw new A(t);
            return this.Wt.defaultEncoding = t, this
          }, Object.defineProperty(k.prototype, "writableBuffer", {
            enumerable: !1,
            get: function() {
              return this.Wt && this.Wt.getBuffer()
            }
          }), Object.defineProperty(k.prototype, "writableHighWaterMark", {
            enumerable: !1,
            get: function() {
              return this.Wt.highWaterMark
            }
          }), k.prototype.it = function(t, e, r) {
            r(new b("_write()"))
          }, k.prototype.Mt = null, k.prototype.end = function(t, e, r) {
            var n = this.Wt;
            return "function" == typeof t ? (r = t, t = null, e = null) : "function" == typeof e && (r = e, e = null), null != t && this.write(t, e), n.corked && (n.corked = 1, this.uncork()), n.ending || function(t, e, r) {
              e.ending = !0, W(t, e), r && (e.finished ? i.nextTick(r) : t.once("finish", r)), e.ended = !0, t.writable = !1
            }(this, n, r), this
          }, Object.defineProperty(k.prototype, "writableLength", {
            enumerable: !1,
            get: function() {
              return this.Wt.length
            }
          }), Object.defineProperty(k.prototype, "destroyed", {
            enumerable: !1,
            get: function() {
              return void 0 !== this.Wt && this.Wt.destroyed
            },
            set: function(t) {
              this.Wt && (this.Wt.destroyed = t)
            }
          }), k.prototype.destroy = l.destroy, k.prototype.Nt = l.undestroy, k.prototype.Ct = function(t, e) {
            e(t)
          }
      },
      16763: (t, e, r) => {
        var n = r(95364);
        t.exports = n("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")
      },
      16767: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bitsForNumber = void 0, e.bitsForNumber = function(t, e) {
          let r = BigInt(t);
          if ("int" === e) return 0n === r || -1n === r ? 1 : (r > 0 ? r : -r).toString(2).length + 1;
          if ("uint" === e) {
            if (0 > r) throw Error("value is negative. Got " + t);
            return r.toString(2).length
          }
          throw Error("invalid mode. Got " + e)
        }
      },
      16874: t => {
        const e = Number.MAX_SAFE_INTEGER || 9007199254740991;
        t.exports = {
          MAX_LENGTH: 256,
          MAX_SAFE_COMPONENT_LENGTH: 16,
          MAX_SAFE_BUILD_LENGTH: 250,
          MAX_SAFE_INTEGER: e,
          RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"],
          SEMVER_SPEC_VERSION: "2.0.0",
          FLAG_INCLUDE_PRERELEASE: 1,
          FLAG_LOOSE: 2
        }
      },
      17115: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          (0, n.default)(t);
          var r = t.split("/");
          if (2 !== r.length || !s.test(r[1]) || r[1].length > 1 && r[1].startsWith("0")) return !1;
          if (!(0, i.default)(r[0], e)) return !1;
          var o = null;
          switch (e + "") {
            case "4":
              o = a;
              break;
            case "6":
              o = u;
              break;
            default:
              o = (0, i.default)(r[0], "6") ? u : a
          }
          return r[1] <= o && r[1] >= 0
        };
        var n = o(r(83399)),
          i = o(r(35372));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = /^\d{1,3}$/,
          a = 32,
          u = 128;
        t.exports = e.default, t.exports.default = e.default
      },
      17179: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
          (0, i.default)(t);
          var r = function(t) {
            var e = function(t) {
                var e = {};
                return Array.from(t).forEach(function(t) {
                  e[t] ? e[t] += 1 : e[t] = 1
                }), e
              }(t),
              r = {
                length: t.length,
                uniqueChars: Object.keys(e).length,
                uppercaseCount: 0,
                lowercaseCount: 0,
                numberCount: 0,
                symbolCount: 0
              };
            return Object.keys(e).forEach(function(t) {
              s.test(t) ? r.uppercaseCount += e[t] : a.test(t) ? r.lowercaseCount += e[t] : u.test(t) ? r.numberCount += e[t] : c.test(t) && (r.symbolCount += e[t])
            }), r
          }(t);
          return (e = (0, n.default)(e || {}, f)).returnScore ? function(t, e) {
            var r = 0;
            return r += t.uniqueChars * e.pointsPerUnique, r += (t.length - t.uniqueChars) * e.pointsPerRepeat, t.lowercaseCount > 0 && (r += e.pointsForContainingLower), t.uppercaseCount > 0 && (r += e.pointsForContainingUpper), t.numberCount > 0 && (r += e.pointsForContainingNumber), t.symbolCount > 0 && (r += e.pointsForContainingSymbol), r
          }(r, e) : !(r.length < e.minLength || r.lowercaseCount < e.minLowercase || r.uppercaseCount < e.minUppercase || r.numberCount < e.minNumbers || r.symbolCount < e.minSymbols)
        };
        var n = o(r(71229)),
          i = o(r(83399));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = /^[A-Z]$/,
          a = /^[a-z]$/,
          u = /^[0-9]$/,
          c = /^[-#!$@%^&*()_+|~=`{}\[\]:";'<>?,.\/ ]$/,
          f = {
            minLength: 8,
            minLowercase: 1,
            minUppercase: 1,
            minNumbers: 1,
            minSymbols: 1,
            returnScore: !1,
            pointsPerUnique: 1,
            pointsPerRepeat: .5,
            pointsForContainingLower: 10,
            pointsForContainingUpper: 10,
            pointsForContainingNumber: 10,
            pointsForContainingSymbol: 10
          };
        t.exports = e.default, t.exports.default = e.default
      },
      17233: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      17412: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.randomBytes = e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.checkOpts = e.Hash = e.concatBytes = e.toBytes = e.utf8ToBytes = e.asyncLoop = e.nextTick = e.hexToBytes = e.bytesToHex = e.byteSwap32 = e.byteSwapIfBE = e.byteSwap = e.isLE = e.rotl = e.rotr = e.createView = e.u32 = e.u8 = e.isBytes = void 0;
        const n = r(457),
          i = r(28021);
        e.isBytes = function(t) {
          return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
        }, e.u8 = t => new Uint8Array(t.buffer, t.byteOffset, t.byteLength), e.u32 = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)), e.createView = t => new DataView(t.buffer, t.byteOffset, t.byteLength), e.rotr = (t, e) => t << 32 - e | t >>> e, e.rotl = (t, e) => t << e | t >>> 32 - e >>> 0, e.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], e.byteSwap = t => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255, e.byteSwapIfBE = e.isLE ? t => t : t => (0, e.byteSwap)(t), e.byteSwap32 = function(t) {
          for (let r = 0; r < t.length; r++) t[r] = (0, e.byteSwap)(t[r])
        };
        const o = Array.from({
          length: 256
        }, (t, e) => e.toString(16).padStart(2, "0"));

        function s(t) {
          return 48 > t || t > 57 ? 65 > t || t > 70 ? 97 > t || t > 102 ? void 0 : t - 87 : t - 55 : t - 48
        }

        function a(t) {
          if ("string" != typeof t) throw Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array((new TextEncoder).encode(t))
        }

        function u(t) {
          return "string" == typeof t && (t = a(t)), (0, i.bytes)(t), t
        }
        e.bytesToHex = function(t) {
          (0, i.bytes)(t);
          let e = "";
          for (let r = 0; r < t.length; r++) e += o[t[r]];
          return e
        }, e.hexToBytes = function(t) {
          if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
          const e = t.length,
            r = e / 2;
          if (e % 2) throw Error("padded hex string expected, got unpadded hex of length " + e);
          const n = new Uint8Array(r);
          for (let e = 0, i = 0; r > e; e++, i += 2) {
            const r = s(t.charCodeAt(i)),
              o = s(t.charCodeAt(i + 1));
            if (void 0 === r || void 0 === o) {
              const e = t[i] + t[i + 1];
              throw Error('hex string expected, got non-hex character "' + e + '" at index ' + i)
            }
            n[e] = 16 * r + o
          }
          return n
        }, e.nextTick = async () => {}, e.asyncLoop = async function(t, r, n) {
          let i = Date.now();
          for (let o = 0; t > o; o++) {
            n(o);
            const t = Date.now() - i;
            t >= 0 && r > t || (await (0, e.nextTick)(), i += t)
          }
        }, e.utf8ToBytes = a, e.toBytes = u, e.concatBytes = function(...t) {
          let e = 0;
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            (0, i.bytes)(n), e += n.length
          }
          const r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), n += i.length
          }
          return r
        }, e.Hash = class {
          clone() {
            return this.jt()
          }
        };
        const c = {}.toString;
        e.checkOpts = function(t, e) {
          if (void 0 !== e && "[object Object]" !== c.call(e)) throw Error("Options should be object or undefined");
          return Object.assign(t, e)
        }, e.wrapConstructor = function(t) {
          const e = e => t().update(u(e)).digest(),
            r = t();
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
        }, e.wrapConstructorWithOpts = function(t) {
          const e = (e, r) => t(r).update(u(e)).digest(),
            r = t({});
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = e => t(e), e
        }, e.wrapXOFConstructorWithOpts = function(t) {
          const e = (e, r) => t(r).update(u(e)).digest(),
            r = t({});
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = e => t(e), e
        }, e.randomBytes = function(t = 32) {
          if (n.crypto && "function" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(t));
          throw Error("crypto.getRandomValues must be defined")
        }
      },
      17773: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.remove0x = e.add0x = e.isValidChecksumAddress = e.getChecksumAddress = e.isValidHexAddress = e.assertIsStrictHexString = e.assertIsHexString = e.isStrictHexString = e.isHexString = e.HexChecksumAddressStruct = e.HexAddressStruct = e.StrictHexStruct = e.HexStruct = void 0;
        const n = r(35620),
          i = r(32955),
          o = r(74772),
          s = r(67295);

        function a(t) {
          return (0, n.is)(t, e.HexStruct)
        }

        function u(t) {
          return (0, n.is)(t, e.StrictHexStruct)
        }

        function c(t) {
          (0, o.assert)((0, n.is)(t, e.HexChecksumAddressStruct), "Invalid hex address.");
          const r = l(t.toLowerCase()),
            a = l((0, s.bytesToHex)((0, i.keccak_256)(r)));
          return "0x" + r.split("").map((t, e) => {
            const r = a[e];
            return (0, o.assert)((0, n.is)(r, (0, n.string)()), "Hash shorter than address."), parseInt(r, 16) > 7 ? t.toUpperCase() : t
          }).join("")
        }

        function f(t) {
          return !!(0, n.is)(t, e.HexChecksumAddressStruct) && c(t) === t
        }

        function l(t) {
          return t.startsWith("0x") || t.startsWith("0X") ? t.substring(2) : t
        }
        e.HexStruct = (0, n.pattern)((0, n.string)(), /^(?:0x)?[0-9a-f]+$/iu), e.StrictHexStruct = (0, n.pattern)((0, n.string)(), /^0x[0-9a-f]+$/iu), e.HexAddressStruct = (0, n.pattern)((0, n.string)(), /^0x[0-9a-f]{40}$/u), e.HexChecksumAddressStruct = (0, n.pattern)((0, n.string)(), /^0x[0-9a-fA-F]{40}$/u), e.isHexString = a, e.isStrictHexString = u, e.assertIsHexString = function(t) {
          (0, o.assert)(a(t), "Value must be a hexadecimal string.")
        }, e.assertIsStrictHexString = function(t) {
          (0, o.assert)(u(t), 'Value must be a hexadecimal string, starting with "0x".')
        }, e.isValidHexAddress = function(t) {
          return (0, n.is)(t, e.HexAddressStruct) || f(t)
        }, e.getChecksumAddress = c, e.isValidChecksumAddress = f, e.add0x = function(t) {
          return t.startsWith("0x") ? t : t.startsWith("0X") ? "0x" + t.substring(2) : "0x" + t
        }, e.remove0x = l
      },
      17833: (t, e, r) => {
        var n = r(65606);
        e.formatArgs = function(e) {
          if (e[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e[0] + (this.useColors ? "%c " : " ") + "+" + t.exports.humanize(this.diff), !this.useColors) return;
          const r = "color: " + this.color;
          e.splice(1, 0, r, "color: inherit");
          let n = 0,
            i = 0;
          e[0].replace(/%[a-zA-Z%]/g, t => {
            "%%" !== t && (n++, "%c" === t && (i = n))
          }), e.splice(i, 0, r)
        }, e.save = function(t) {
          try {
            t ? e.storage.setItem("debug", t) : e.storage.removeItem("debug")
          } catch {}
        }, e.load = function() {
          let t;
          try {
            t = e.storage.getItem("debug") || e.storage.getItem("DEBUG")
          } catch {}
          return !t && "u" > typeof n && "env" in n && (t = "MISSING_ENV_VAR".DEBUG), t
        }, e.useColors = function() {
          if ("u" > typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) return !0;
          if ("u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return !1;
          let t;
          return "u" > typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "u" > typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "u" > typeof navigator && navigator.userAgent && (t = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(t[1], 10) >= 31 || "u" > typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)
        }, e.storage = function() {
          try {
            return localStorage
          } catch {}
        }(), e.destroy = (() => {
          let t = !1;
          return () => {
            t || (t = !0, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))
          }
        })(), e.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], e.log = console.debug || console.log || (() => {}), t.exports = r(40736)(e);
        const {
          formatters: i
        } = t.exports;
        i.j = function(t) {
          try {
            return JSON.stringify(t)
          } catch (t) {
            return "[UnexpectedJSONParseError]: " + t.message
          }
        }
      },
      18335: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      18941: (t, e) => {
        "use strict";
        var r;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.timeSince = e.inMilliseconds = e.Duration = void 0, (r = e.Duration || (e.Duration = {}))[r.Millisecond = 1] = "Millisecond", r[r.Second = 1e3] = "Second", r[r.Minute = 6e4] = "Minute", r[r.Hour = 36e5] = "Hour", r[r.Day = 864e5] = "Day", r[r.Week = 6048e5] = "Week", r[r.Year = 31536e6] = "Year";
        const n = (t, e) => {
          if (!(t => Number.isInteger(t) && t >= 0)(t)) throw Error(`"${e}" must be a non-negative integer. Received: "${t}".`)
        };
        e.inMilliseconds = function(t, e) {
          return n(t, "count"), t * e
        }, e.timeSince = function(t) {
          return n(t, "timestamp"), Date.now() - t
        }
      },
      19266: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          var r;
          if ((0, n.default)(t), "[object Array]" === {}.toString.call(e)) {
            var o = [];
            for (r in e)({}).hasOwnProperty.call(e, r) && (o[r] = (0, i.default)(e[r]));
            return o.indexOf(t) >= 0
          }
          return "object" === s(e) ? e.hasOwnProperty(t) : !(!e || "function" != typeof e.indexOf || 0 > e.indexOf(t))
        };
        var n = o(r(83399)),
          i = o(r(45772));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }

        function s(t) {
          return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        t.exports = e.default, t.exports.default = e.default
      },
      19372: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bitMask = void 0, e.isBytes = o, e.abytes = s, e.bytesToHex = u, e.numberToHexUnpadded = c, e.hexToNumber = f, e.hexToBytes = d, e.bytesToNumberBE = function(t) {
          return f(u(t))
        }, e.bytesToNumberLE = function(t) {
          return s(t), f(u(Uint8Array.from(t).reverse()))
        }, e.numberToBytesBE = p, e.numberToBytesLE = function(t, e) {
          return p(t, e).reverse()
        }, e.numberToVarBytesBE = function(t) {
          return d(c(t))
        }, e.ensureBytes = function(t, e, r) {
          let n;
          if ("string" == typeof e) try {
            n = d(e)
          } catch (r) {
            throw Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)
          } else {
            if (!o(e)) throw Error(t + " must be hex string or Uint8Array");
            n = Uint8Array.from(e)
          }
          const i = n.length;
          if ("number" == typeof r && i !== r) throw Error(`${t} expected ${r} bytes, got ${i}`);
          return n
        }, e.concatBytes = b, e.equalBytes = function(t, e) {
          if (t.length !== e.length) return !1;
          let r = 0;
          for (let n = 0; n < t.length; n++) r |= t[n] ^ e[n];
          return 0 === r
        }, e.utf8ToBytes = function(t) {
          if ("string" != typeof t) throw Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array((new TextEncoder).encode(t))
        }, e.bitLen = function(t) {
          let e;
          for (e = 0; t > r; t >>= n, e += 1);
          return e
        }, e.bitGet = function(t, e) {
          return t >> BigInt(e) & n
        }, e.bitSet = function(t, e, i) {
          return t | (i ? n : r) << BigInt(e)
        }, e.createHmacDrbg = function(t, e, r) {
          if ("number" != typeof t || 2 > t) throw Error("hashLen must be a number");
          if ("number" != typeof e || 2 > e) throw Error("qByteLen must be a number");
          if ("function" != typeof r) throw Error("hmacFn must be a function");
          let n = m(t),
            i = m(t),
            o = 0;
          const s = () => {
              n.fill(1), i.fill(0), o = 0
            },
            a = (...t) => r(i, n, ...t),
            u = (t = m()) => {
              i = a(y([0]), t), n = a(), 0 !== t.length && (i = a(y([1]), t), n = a())
            },
            c = () => {
              if (o++ >= 1e3) throw Error("drbg: tried 1000 values");
              let t = 0;
              const r = [];
              for (; e > t;) {
                n = a();
                const e = n.slice();
                r.push(e), t += n.length
              }
              return b(...r)
            };
          return (t, e) => {
            let r;
            for (s(), u(t); !(r = e(c()));) u();
            return s(), r
          }
        }, e.validateObject = function(t, e, r = {}) {
          const n = (e, r, n) => {
            const i = g[r];
            if ("function" != typeof i) throw Error(`Invalid validator "${r}", expected function`);
            const o = t[e];
            if (!(n && void 0 === o || i(o, t))) throw Error(`Invalid param ${e+""}=${o} (${typeof o}), expected ${r}`)
          };
          for (const [t, r] of Object.entries(e)) n(t, r, !1);
          for (const [t, e] of Object.entries(r)) n(t, e, !0);
          return t
        };
        const r = BigInt(0),
          n = BigInt(1),
          i = BigInt(2);

        function o(t) {
          return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
        }

        function s(t) {
          if (!o(t)) throw Error("Uint8Array expected")
        }
        const a = Array.from({
          length: 256
        }, (t, e) => e.toString(16).padStart(2, "0"));

        function u(t) {
          s(t);
          let e = "";
          for (let r = 0; r < t.length; r++) e += a[t[r]];
          return e
        }

        function c(t) {
          const e = t.toString(16);
          return 1 & e.length ? "0" + e : e
        }

        function f(t) {
          if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
          return BigInt("" === t ? "0" : "0x" + t)
        }
        const l = {
          _t: 48,
          Dt: 57,
          Ut: 65,
          Lt: 70,
          Ft: 97,
          $t: 102
        };

        function h(t) {
          return t < l._t || t > l.Dt ? t < l.Ut || t > l.Lt ? t < l.Ft || t > l.$t ? void 0 : t - (l.Ft - 10) : t - (l.Ut - 10) : t - l._t
        }

        function d(t) {
          if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
          const e = t.length,
            r = e / 2;
          if (e % 2) throw Error("padded hex string expected, got unpadded hex of length " + e);
          const n = new Uint8Array(r);
          for (let e = 0, i = 0; r > e; e++, i += 2) {
            const r = h(t.charCodeAt(i)),
              o = h(t.charCodeAt(i + 1));
            if (void 0 === r || void 0 === o) {
              const e = t[i] + t[i + 1];
              throw Error('hex string expected, got non-hex character "' + e + '" at index ' + i)
            }
            n[e] = 16 * r + o
          }
          return n
        }

        function p(t, e) {
          return d(t.toString(16).padStart(2 * e, "0"))
        }

        function b(...t) {
          let e = 0;
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            s(n), e += n.length
          }
          const r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), n += i.length
          }
          return r
        }
        e.bitMask = t => (i << BigInt(t - 1)) - n;
        const m = t => new Uint8Array(t),
          y = t => Uint8Array.from(t),
          g = {
            bigint: t => "bigint" == typeof t,
            function: t => "function" == typeof t,
            boolean: t => "boolean" == typeof t,
            string: t => "string" == typeof t,
            stringOrUint8Array: t => "string" == typeof t || o(t),
            isSafeInteger: t => Number.isSafeInteger(t),
            array: t => Array.isArray(t),
            field: (t, e) => e.Fp.isValid(t),
            hash: t => "function" == typeof t && Number.isSafeInteger(t.outputLen)
          }
      },
      19628: (t, e, r) => {
        const n = r(53908),
          i = r(78311);
        t.exports = (t, e, r) => {
          let o = null,
            s = null,
            a = null;
          try {
            a = new i(e, r)
          } catch {
            return null
          }
          return t.forEach(t => {
            a.test(t) && (!o || -1 === s.compare(t)) && (o = t, s = new n(o, r))
          }), o
        }
      },
      19681: t => {
        "use strict";
        t.exports = {
          Z_NO_FLUSH: 0,
          Z_PARTIAL_FLUSH: 1,
          Z_SYNC_FLUSH: 2,
          Z_FULL_FLUSH: 3,
          Z_FINISH: 4,
          Z_BLOCK: 5,
          Z_TREES: 6,
          Z_OK: 0,
          Z_STREAM_END: 1,
          Z_NEED_DICT: 2,
          Z_ERRNO: -1,
          Z_STREAM_ERROR: -2,
          Z_DATA_ERROR: -3,
          Z_BUF_ERROR: -5,
          Z_NO_COMPRESSION: 0,
          Z_BEST_SPEED: 1,
          Z_BEST_COMPRESSION: 9,
          Z_DEFAULT_COMPRESSION: -1,
          Z_FILTERED: 1,
          Z_HUFFMAN_ONLY: 2,
          Z_RLE: 3,
          Z_FIXED: 4,
          Z_DEFAULT_STRATEGY: 0,
          Z_BINARY: 0,
          Z_TEXT: 1,
          Z_UNKNOWN: 2,
          Z_DEFLATED: 8
        }
      },
      20489: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.DER = void 0, e.weierstrassPoints = p, e.weierstrass = function(t) {
          const r = function(t) {
              const e = (0, n.validateBasic)(t);
              return o.validateObject(e, {
                hash: "hash",
                hmac: "function",
                randomBytes: "function"
              }, {
                bits2int: "function",
                bits2int_modN: "function",
                lowS: "boolean"
              }), Object.freeze({
                lowS: !0,
                ...e
              })
            }(t),
            {
              Fp: a,
              n: u
            } = r,
            l = a.BYTES + 1,
            h = 2 * a.BYTES + 1;

          function d(t) {
            return i.mod(t, u)
          }

          function b(t) {
            return i.invert(t, u)
          }
          const {
            ProjectivePoint: m,
            normPrivateKeyToScalar: y,
            weierstrassEquation: g,
            isWithinCurveOrder: v
          } = p({
            ...r,
            toBytes(t, e, r) {
              const n = e.toAffine(),
                i = a.toBytes(n.x),
                s = o.concatBytes;
              return r ? s(Uint8Array.from([e.hasEvenY() ? 2 : 3]), i) : s(Uint8Array.from([4]), i, a.toBytes(n.y))
            },
            fromBytes(t) {
              const e = t.length,
                r = t[0],
                n = t.subarray(1);
              if (e !== l || 2 !== r && 3 !== r) {
                if (e === h && 4 === r) return {
                  x: a.fromBytes(n.subarray(0, a.BYTES)),
                  y: a.fromBytes(n.subarray(a.BYTES, 2 * a.BYTES))
                };
                throw Error(`Point of length ${e} was invalid. Expected ${l} compressed bytes or ${h} uncompressed bytes`)
              } {
                const t = o.bytesToNumberBE(n);
                if (! function(t) {
                    return t > c && t < a.ORDER
                  }(t)) throw Error("Point is not on curve");
                const e = g(t);
                let i;
                try {
                  i = a.sqrt(e)
                } catch (t) {
                  const e = t instanceof Error ? ": " + t.message : "";
                  throw Error("Point is not on curve" + e)
                }
                return !(1 & ~r) != ((i & f) === f) && (i = a.neg(i)), {
                  x: t,
                  y: i
                }
              }
            }
          }), w = t => o.bytesToHex(o.numberToBytesBE(t, r.nByteLength));

          function A(t) {
            return t > u >> f
          }
          const T = (t, e, r) => o.bytesToNumberBE(t.slice(e, r));
          class E {
            constructor(t, e, r) {
              this.r = t, this.s = e, this.recovery = r, this.assertValidity()
            }
            static fromCompact(t) {
              const e = r.nByteLength;
              return t = (0, s.ensureBytes)("compactSignature", t, 2 * e), new E(T(t, 0, e), T(t, e, 2 * e))
            }
            static fromDER(t) {
              const {
                r: r,
                s: n
              } = e.DER.toSig((0, s.ensureBytes)("DER", t));
              return new E(r, n)
            }
            assertValidity() {
              if (!v(this.r)) throw Error("r must be 0 < r < CURVE.n");
              if (!v(this.s)) throw Error("s must be 0 < s < CURVE.n")
            }
            addRecoveryBit(t) {
              return new E(this.r, this.s, t)
            }
            recoverPublicKey(t) {
              const {
                r: e,
                s: n,
                recovery: i
              } = this, o = I((0, s.ensureBytes)("msgHash", t));
              if (null == i || ![0, 1, 2, 3].includes(i)) throw Error("recovery id invalid");
              const u = 2 === i || 3 === i ? e + r.n : e;
              if (u >= a.ORDER) throw Error("recovery id 2 or 3 invalid");
              const c = 1 & i ? "03" : "02",
                f = m.fromHex(c + w(u)),
                l = b(u),
                h = d(-o * l),
                p = d(n * l),
                y = m.BASE.multiplyAndAddUnsafe(f, h, p);
              if (!y) throw Error("point at infinify");
              return y.assertValidity(), y
            }
            hasHighS() {
              return A(this.s)
            }
            normalizeS() {
              return this.hasHighS() ? new E(this.r, d(-this.s), this.recovery) : this
            }
            toDERRawBytes() {
              return o.hexToBytes(this.toDERHex())
            }
            toDERHex() {
              return e.DER.hexFromSig({
                r: this.r,
                s: this.s
              })
            }
            toCompactRawBytes() {
              return o.hexToBytes(this.toCompactHex())
            }
            toCompactHex() {
              return w(this.r) + w(this.s)
            }
          }
          const P = {
            isValidPrivateKey(t) {
              try {
                return y(t), !0
              } catch {
                return !1
              }
            },
            normPrivateKeyToScalar: y,
            randomPrivateKey: () => {
              const t = i.getMinHashLength(r.n);
              return i.mapHashToField(r.randomBytes(t), r.n)
            },
            precompute: (t = 8, e = m.BASE) => (e.zt(t), e.multiply(BigInt(3)), e)
          };

          function k(t) {
            const e = o.isBytes(t),
              r = "string" == typeof t,
              n = (e || r) && t.length;
            return e ? n === l || n === h : r ? n === 2 * l || n === 2 * h : t instanceof m
          }
          const x = r.bits2int || function(t) {
              const e = o.bytesToNumberBE(t),
                n = 8 * t.length - r.nBitLength;
              return n > 0 ? e >> BigInt(n) : e
            },
            I = r.bits2int_modN || function(t) {
              return d(x(t))
            },
            S = o.bitMask(r.nBitLength);

          function O(t) {
            if ("bigint" != typeof t) throw Error("bigint expected");
            if (c > t || t >= S) throw Error("bigint expected < 2^" + r.nBitLength);
            return o.numberToBytesBE(t, r.nByteLength)
          }
          const B = {
              lowS: r.lowS,
              prehash: !1
            },
            W = {
              lowS: r.lowS,
              prehash: !1
            };
          return m.BASE.zt(8), {
            CURVE: r,
            getPublicKey: function(t, e = !0) {
              return m.fromPrivateKey(t).toRawBytes(e)
            },
            getSharedSecret: function(t, e, r = !0) {
              if (k(t)) throw Error("first arg must be private key");
              if (!k(e)) throw Error("second arg must be public key");
              return m.fromHex(e).multiply(y(t)).toRawBytes(r)
            },
            sign: function(t, e, n = B) {
              const {
                seed: i,
                k2sig: u
              } = function(t, e, n = B) {
                if (["recovered", "canonical"].some(t => t in n)) throw Error("sign() legacy options not supported");
                const {
                  hash: i,
                  randomBytes: u
                } = r;
                let {
                  lowS: l,
                  prehash: h,
                  extraEntropy: p
                } = n;
                null == l && (l = !0), t = (0, s.ensureBytes)("msgHash", t), h && (t = (0, s.ensureBytes)("prehashed msgHash", i(t)));
                const g = I(t),
                  w = y(e),
                  T = [O(w), O(g)];
                if (null != p && !1 !== p) {
                  const t = !0 === p ? u(a.BYTES) : p;
                  T.push((0, s.ensureBytes)("extraEntropy", t))
                }
                const P = o.concatBytes(...T),
                  k = g;
                return {
                  seed: P,
                  k2sig: function(t) {
                    const e = x(t);
                    if (!v(e)) return;
                    const r = b(e),
                      n = m.BASE.multiply(e).toAffine(),
                      i = d(n.x);
                    if (i === c) return;
                    const o = d(r * d(k + i * w));
                    if (o === c) return;
                    let s = (n.x === i ? 0 : 2) | +(n.y & f),
                      a = o;
                    return l && A(o) && (a = function(t) {
                      return A(t) ? d(-t) : t
                    }(o), s ^= 1), new E(i, a, s)
                  }
                }
              }(t, e, n), l = r;
              return o.createHmacDrbg(l.hash.outputLen, l.nByteLength, l.hmac)(i, u)
            },
            verify: function(t, n, i, a = W) {
              const u = t;
              if (n = (0, s.ensureBytes)("msgHash", n), i = (0, s.ensureBytes)("publicKey", i), "strict" in a) throw Error("options.strict was renamed to lowS");
              const {
                lowS: c,
                prehash: f
              } = a;
              let l, h;
              try {
                if ("string" == typeof u || o.isBytes(u)) try {
                  l = E.fromDER(u)
                } catch (t) {
                  if (!(t instanceof e.DER.Err)) throw t;
                  l = E.fromCompact(u)
                } else {
                  if ("object" != typeof u || "bigint" != typeof u.r || "bigint" != typeof u.s) throw Error("PARSE");
                  {
                    const {
                      r: t,
                      s: e
                    } = u;
                    l = new E(t, e)
                  }
                }
                h = m.fromHex(i)
              } catch (t) {
                if ("PARSE" === t.message) throw Error("signature must be Signature instance, Uint8Array or hex string");
                return !1
              }
              if (c && l.hasHighS()) return !1;
              f && (n = r.hash(n));
              const {
                r: p,
                s: y
              } = l, g = I(n), v = b(y), w = d(g * v), A = d(p * v), T = m.BASE.multiplyAndAddUnsafe(h, w, A)?.toAffine();
              return !!T && d(T.x) === p
            },
            ProjectivePoint: m,
            Signature: E,
            utils: P
          }
        }, e.SWUFpSqrtRatio = b, e.mapToCurveSimpleSWU = function(t, e) {
          if (i.validateField(t), !t.isValid(e.A) || !t.isValid(e.B) || !t.isValid(e.Z)) throw Error("mapToCurveSimpleSWU: invalid opts");
          const r = b(t, e.Z);
          if (!t.isOdd) throw Error("Fp.isOdd is not implemented!");
          return n => {
            let i, o, s, a, u, c, f, l;
            i = t.sqr(n), i = t.mul(i, e.Z), o = t.sqr(i), o = t.add(o, i), s = t.add(o, t.ONE), s = t.mul(s, e.B), a = t.cmov(e.Z, t.neg(o), !t.eql(o, t.ZERO)), a = t.mul(a, e.A), o = t.sqr(s), c = t.sqr(a), u = t.mul(c, e.A), o = t.add(o, u), o = t.mul(o, s), c = t.mul(c, a), u = t.mul(c, e.B), o = t.add(o, u), f = t.mul(i, s);
            const {
              isValid: h,
              value: d
            } = r(o, c);
            l = t.mul(i, n), l = t.mul(l, d), f = t.cmov(f, s, h), l = t.cmov(l, d, h);
            const p = t.isOdd(n) === t.isOdd(l);
            return l = t.cmov(t.neg(l), l, p), f = t.div(f, a), {
              x: f,
              y: l
            }
          }
        };
        const n = r(59206),
          i = r(89015),
          o = r(19372),
          s = r(19372),
          {
            bytesToNumberBE: a,
            hexToBytes: u
          } = o;
        e.DER = {
          Err: class extends Error {
            constructor(t = "") {
              super(t)
            }
          },
          Ht(t) {
            const {
              Err: r
            } = e.DER;
            if (2 > t.length || 2 !== t[0]) throw new r("Invalid signature integer tag");
            const n = t[1],
              i = t.subarray(2, n + 2);
            if (!n || i.length !== n) throw new r("Invalid signature integer: wrong length");
            if (128 & i[0]) throw new r("Invalid signature integer: negative");
            if (0 === i[0] && !(128 & i[1])) throw new r("Invalid signature integer: unnecessary leading zero");
            return {
              d: a(i),
              l: t.subarray(n + 2)
            }
          },
          toSig(t) {
            const {
              Err: r
            } = e.DER, n = "string" == typeof t ? u(t) : t;
            o.abytes(n);
            let i = n.length;
            if (2 > i || 48 != n[0]) throw new r("Invalid signature tag");
            if (n[1] !== i - 2) throw new r("Invalid signature: incorrect length");
            const {
              d: s,
              l: a
            } = e.DER.Ht(n.subarray(2)), {
              d: c,
              l: f
            } = e.DER.Ht(a);
            if (f.length) throw new r("Invalid signature: left bytes after parsing");
            return {
              r: s,
              s: c
            }
          },
          hexFromSig(t) {
            const e = t => 8 & Number.parseInt(t[0], 16) ? "00" + t : t,
              r = t => {
                const e = t.toString(16);
                return 1 & e.length ? "0" + e : e
              },
              n = e(r(t.s)),
              i = e(r(t.r)),
              o = n.length / 2,
              s = i.length / 2,
              a = r(o),
              u = r(s);
            return `30${r(s+o+4)}02${u}${i}02${a}${n}`
          }
        };
        const c = BigInt(0),
          f = BigInt(1),
          l = BigInt(2),
          h = BigInt(3),
          d = BigInt(4);

        function p(t) {
          const e = function(t) {
              const e = (0, n.validateBasic)(t);
              o.validateObject(e, {
                a: "field",
                b: "field"
              }, {
                allowedPrivateKeyLengths: "array",
                wrapPrivateKey: "boolean",
                isTorsionFree: "function",
                clearCofactor: "function",
                allowInfinityPoint: "boolean",
                fromBytes: "function",
                toBytes: "function"
              });
              const {
                endo: r,
                Fp: i,
                a: s
              } = e;
              if (r) {
                if (!i.eql(s, i.ZERO)) throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                if ("object" != typeof r || "bigint" != typeof r.beta || "function" != typeof r.splitScalar) throw Error("Expected endomorphism with beta: bigint and splitScalar: function")
              }
              return Object.freeze({
                ...e
              })
            }(t),
            {
              Fp: r
            } = e,
            a = e.toBytes || ((t, e, n) => {
              const i = e.toAffine();
              return o.concatBytes(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y))
            }),
            u = e.fromBytes || (t => {
              const e = t.subarray(1);
              return {
                x: r.fromBytes(e.subarray(0, r.BYTES)),
                y: r.fromBytes(e.subarray(r.BYTES, 2 * r.BYTES))
              }
            });

          function l(t) {
            const {
              a: n,
              b: i
            } = e, o = r.sqr(t), s = r.mul(o, t);
            return r.add(r.add(s, r.mul(t, n)), i)
          }
          if (!r.eql(r.sqr(e.Gy), l(e.Gx))) throw Error("bad generator point: equation left != right");

          function d(t) {
            return "bigint" == typeof t && t > c && t < e.n
          }

          function p(t) {
            if (!d(t)) throw Error("Expected valid bigint: 0 < bigint < curve.n")
          }

          function b(t) {
            const {
              allowedPrivateKeyLengths: r,
              nByteLength: n,
              wrapPrivateKey: a,
              n: u
            } = e;
            if (r && "bigint" != typeof t) {
              if (o.isBytes(t) && (t = o.bytesToHex(t)), "string" != typeof t || !r.includes(t.length)) throw Error("Invalid key");
              t = t.padStart(2 * n, "0")
            }
            let c;
            try {
              c = "bigint" == typeof t ? t : o.bytesToNumberBE((0, s.ensureBytes)("private key", t, n))
            } catch {
              throw Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)
            }
            return a && (c = i.mod(c, u)), p(c), c
          }
          const m = new Map;

          function y(t) {
            if (!(t instanceof g)) throw Error("ProjectivePoint expected")
          }
          class g {
            constructor(t, e, n) {
              if (this.px = t, this.py = e, this.pz = n, null == t || !r.isValid(t)) throw Error("x required");
              if (null == e || !r.isValid(e)) throw Error("y required");
              if (null == n || !r.isValid(n)) throw Error("z required")
            }
            static fromAffine(t) {
              const {
                x: e,
                y: n
              } = t || {};
              if (!t || !r.isValid(e) || !r.isValid(n)) throw Error("invalid affine point");
              if (t instanceof g) throw Error("projective point not allowed");
              const i = t => r.eql(t, r.ZERO);
              return i(e) && i(n) ? g.ZERO : new g(e, n, r.ONE)
            }
            get x() {
              return this.toAffine().x
            }
            get y() {
              return this.toAffine().y
            }
            static normalizeZ(t) {
              const e = r.invertBatch(t.map(t => t.pz));
              return t.map((t, r) => t.toAffine(e[r])).map(g.fromAffine)
            }
            static fromHex(t) {
              const e = g.fromAffine(u((0, s.ensureBytes)("pointHex", t)));
              return e.assertValidity(), e
            }
            static fromPrivateKey(t) {
              return g.BASE.multiply(b(t))
            }
            zt(t) {
              this.Gt = t, m.delete(this)
            }
            assertValidity() {
              if (this.is0()) {
                if (e.allowInfinityPoint && !r.is0(this.py)) return;
                throw Error("bad point: ZERO")
              }
              const {
                x: t,
                y: n
              } = this.toAffine();
              if (!r.isValid(t) || !r.isValid(n)) throw Error("bad point: x or y not FE");
              const i = r.sqr(n),
                o = l(t);
              if (!r.eql(i, o)) throw Error("bad point: equation left != right");
              if (!this.isTorsionFree()) throw Error("bad point: not in prime-order subgroup")
            }
            hasEvenY() {
              const {
                y: t
              } = this.toAffine();
              if (r.isOdd) return !r.isOdd(t);
              throw Error("Field doesn't support isOdd")
            }
            equals(t) {
              y(t);
              const {
                px: e,
                py: n,
                pz: i
              } = this, {
                px: o,
                py: s,
                pz: a
              } = t, u = r.eql(r.mul(e, a), r.mul(o, i)), c = r.eql(r.mul(n, a), r.mul(s, i));
              return u && c
            }
            negate() {
              return new g(this.px, r.neg(this.py), this.pz)
            }
            double() {
              const {
                a: t,
                b: n
              } = e, i = r.mul(n, h), {
                px: o,
                py: s,
                pz: a
              } = this;
              let u = r.ZERO,
                c = r.ZERO,
                f = r.ZERO,
                l = r.mul(o, o),
                d = r.mul(s, s),
                p = r.mul(a, a),
                b = r.mul(o, s);
              return b = r.add(b, b), f = r.mul(o, a), f = r.add(f, f), u = r.mul(t, f), c = r.mul(i, p), c = r.add(u, c), u = r.sub(d, c), c = r.add(d, c), c = r.mul(u, c), u = r.mul(b, u), f = r.mul(i, f), p = r.mul(t, p), b = r.sub(l, p), b = r.mul(t, b), b = r.add(b, f), f = r.add(l, l), l = r.add(f, l), l = r.add(l, p), l = r.mul(l, b), c = r.add(c, l), p = r.mul(s, a), p = r.add(p, p), l = r.mul(p, b), u = r.sub(u, l), f = r.mul(p, d), f = r.add(f, f), f = r.add(f, f), new g(u, c, f)
            }
            add(t) {
              y(t);
              const {
                px: n,
                py: i,
                pz: o
              } = this, {
                px: s,
                py: a,
                pz: u
              } = t;
              let c = r.ZERO,
                f = r.ZERO,
                l = r.ZERO;
              const d = e.a,
                p = r.mul(e.b, h);
              let b = r.mul(n, s),
                m = r.mul(i, a),
                v = r.mul(o, u),
                w = r.add(n, i),
                A = r.add(s, a);
              w = r.mul(w, A), A = r.add(b, m), w = r.sub(w, A), A = r.add(n, o);
              let T = r.add(s, u);
              return A = r.mul(A, T), T = r.add(b, v), A = r.sub(A, T), T = r.add(i, o), c = r.add(a, u), T = r.mul(T, c), c = r.add(m, v), T = r.sub(T, c), l = r.mul(d, A), c = r.mul(p, v), l = r.add(c, l), c = r.sub(m, l), l = r.add(m, l), f = r.mul(c, l), m = r.add(b, b), m = r.add(m, b), v = r.mul(d, v), A = r.mul(p, A), m = r.add(m, v), v = r.sub(b, v), v = r.mul(d, v), A = r.add(A, v), b = r.mul(m, A), f = r.add(f, b), b = r.mul(T, A), c = r.mul(w, c), c = r.sub(c, b), b = r.mul(w, m), l = r.mul(T, l), l = r.add(l, b), new g(c, f, l)
            }
            subtract(t) {
              return this.add(t.negate())
            }
            is0() {
              return this.equals(g.ZERO)
            }
            wNAF(t) {
              return w.wNAFCached(this, m, t, t => {
                const e = r.invertBatch(t.map(t => t.pz));
                return t.map((t, r) => t.toAffine(e[r])).map(g.fromAffine)
              })
            }
            multiplyUnsafe(t) {
              const n = g.ZERO;
              if (t === c) return n;
              if (p(t), t === f) return this;
              const {
                endo: i
              } = e;
              if (!i) return w.unsafeLadder(this, t);
              let {
                k1neg: o,
                k1: s,
                k2neg: a,
                k2: u
              } = i.splitScalar(t), l = n, h = n, d = this;
              for (; s > c || u > c;) s & f && (l = l.add(d)), u & f && (h = h.add(d)), d = d.double(), s >>= f, u >>= f;
              return o && (l = l.negate()), a && (h = h.negate()), h = new g(r.mul(h.px, i.beta), h.py, h.pz), l.add(h)
            }
            multiply(t) {
              p(t);
              let n, i, o = t;
              const {
                endo: s
              } = e;
              if (s) {
                const {
                  k1neg: t,
                  k1: e,
                  k2neg: a,
                  k2: u
                } = s.splitScalar(o);
                let {
                  p: c,
                  f: f
                } = this.wNAF(e), {
                  p: l,
                  f: h
                } = this.wNAF(u);
                c = w.constTimeNegate(t, c), l = w.constTimeNegate(a, l), l = new g(r.mul(l.px, s.beta), l.py, l.pz), n = c.add(l), i = f.add(h)
              } else {
                const {
                  p: t,
                  f: e
                } = this.wNAF(o);
                n = t, i = e
              }
              return g.normalizeZ([n, i])[0]
            }
            multiplyAndAddUnsafe(t, e, r) {
              const n = g.BASE,
                i = (t, e) => e !== c && e !== f && t.equals(n) ? t.multiply(e) : t.multiplyUnsafe(e),
                o = i(this, e).add(i(t, r));
              return o.is0() ? void 0 : o
            }
            toAffine(t) {
              const {
                px: e,
                py: n,
                pz: i
              } = this, o = this.is0();
              null == t && (t = o ? r.ONE : r.inv(i));
              const s = r.mul(e, t),
                a = r.mul(n, t),
                u = r.mul(i, t);
              if (o) return {
                x: r.ZERO,
                y: r.ZERO
              };
              if (!r.eql(u, r.ONE)) throw Error("invZ was invalid");
              return {
                x: s,
                y: a
              }
            }
            isTorsionFree() {
              const {
                h: t,
                isTorsionFree: r
              } = e;
              if (t === f) return !0;
              if (r) return r(g, this);
              throw Error("isTorsionFree() has not been declared for the elliptic curve")
            }
            clearCofactor() {
              const {
                h: t,
                clearCofactor: r
              } = e;
              return t === f ? this : r ? r(g, this) : this.multiplyUnsafe(e.h)
            }
            toRawBytes(t = !0) {
              return this.assertValidity(), a(g, this, t)
            }
            toHex(t = !0) {
              return o.bytesToHex(this.toRawBytes(t))
            }
          }
          g.BASE = new g(e.Gx, e.Gy, r.ONE), g.ZERO = new g(r.ZERO, r.ONE, r.ZERO);
          const v = e.nBitLength,
            w = (0, n.wNAF)(g, e.endo ? Math.ceil(v / 2) : v);
          return {
            CURVE: e,
            ProjectivePoint: g,
            normPrivateKeyToScalar: b,
            weierstrassEquation: l,
            isWithinCurveOrder: d
          }
        }

        function b(t, e) {
          const r = t.ORDER;
          let n = c;
          for (let t = r - f; t % l === c; t /= l) n += f;
          const i = n,
            o = l << i - f - f,
            s = o * l,
            a = (r - f) / s,
            u = (a - f) / l,
            p = s - f,
            b = o,
            m = t.pow(e, a),
            y = t.pow(e, (a + f) / l);
          let g = (e, r) => {
            let n = m,
              o = t.pow(r, p),
              s = t.sqr(o);
            s = t.mul(s, r);
            let a = t.mul(e, s);
            a = t.pow(a, u), a = t.mul(a, o), o = t.mul(a, r), s = t.mul(a, e);
            let c = t.mul(s, o);
            a = t.pow(c, b);
            let h = t.eql(a, t.ONE);
            o = t.mul(s, y), a = t.mul(c, n), s = t.cmov(o, s, h), c = t.cmov(a, c, h);
            for (let e = i; e > f; e--) {
              let r = e - l;
              r = l << r - f;
              let i = t.pow(c, r);
              const a = t.eql(i, t.ONE);
              o = t.mul(s, n), n = t.mul(n, n), i = t.mul(c, n), s = t.cmov(o, s, a), c = t.cmov(i, c, a)
            }
            return {
              isValid: h,
              value: s
            }
          };
          if (t.ORDER % d === h) {
            const r = (t.ORDER - h) / d,
              n = t.sqrt(t.neg(e));
            g = (e, i) => {
              let o = t.sqr(i);
              const s = t.mul(e, i);
              o = t.mul(o, s);
              let a = t.pow(o, r);
              a = t.mul(a, s);
              const u = t.mul(a, n),
                c = t.mul(t.sqr(a), i),
                f = t.eql(c, e);
              return {
                isValid: f,
                value: t.cmov(u, a, f)
              }
            }
          }
          return g
        }
      },
      20555: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.LevelMask = void 0;
        class r {
          constructor(t = 0) {
            var e;
            this.Kt = 0, this.Kt = t, this.Vt = (e = this.Kt, 16843009 * ((e = (858993459 & (e -= e >> 1 & 1431655765)) + (e >> 2 & 858993459)) + (e >> 4) & 252645135) >> 24), this.Zt = this.Vt + 1
          }
          get value() {
            return this.Kt
          }
          get level() {
            return 32 - Math.clz32(this.Kt)
          }
          get hashIndex() {
            return this.Vt
          }
          get hashCount() {
            return this.Zt
          }
          apply(t) {
            return new r(this.Kt & (1 << t) - 1)
          }
          isSignificant(t) {
            return 0 === t || (this.Kt >> t - 1) % 2 != 0
          }
        }
        e.LevelMask = r
      },
      20574: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.createWalletTransferV1 = function(t) {
          let e = (0, n.beginCell)().storeUint(t.seqno, 32);
          t.message && (e.storeUint(t.sendMode, 8), e.storeRef((0, n.beginCell)().store((0, n.storeMessageRelaxed)(t.message))));
          let r = (0, i.sign)(e.endCell().hash(), t.secretKey);
          return (0, n.beginCell)().storeBuffer(r).storeBuilder(e).endCell()
        }, e.createWalletTransferV2 = function(t) {
          if (t.messages.length > 4) throw Error("Maximum number of messages in a single transfer is 4");
          let e = (0, n.beginCell)().storeUint(t.seqno, 32);
          if (0 === t.seqno)
            for (let t = 0; 32 > t; t++) e.storeBit(1);
          else e.storeUint(t.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
          for (let r of t.messages) e.storeUint(t.sendMode, 8), e.storeRef((0, n.beginCell)().store((0, n.storeMessageRelaxed)(r)));
          let r = (0, i.sign)(e.endCell().hash(), t.secretKey);
          return (0, n.beginCell)().storeBuffer(r).storeBuilder(e).endCell()
        }, e.createWalletTransferV3 = function(t) {
          if (t.messages.length > 4) throw Error("Maximum number of messages in a single transfer is 4");
          let e = (0, n.beginCell)().storeUint(t.walletId, 32);
          if (0 === t.seqno)
            for (let t = 0; 32 > t; t++) e.storeBit(1);
          else e.storeUint(t.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
          e.storeUint(t.seqno, 32);
          for (let r of t.messages) e.storeUint(t.sendMode, 8), e.storeRef((0, n.beginCell)().store((0, n.storeMessageRelaxed)(r)));
          return (0, a.signPayload)(t, e, f)
        }, e.createWalletTransferV4 = function(t) {
          if (t.messages.length > 4) throw Error("Maximum number of messages in a single transfer is 4");
          let e = (0, n.beginCell)().storeUint(t.walletId, 32);
          if (0 === t.seqno)
            for (let t = 0; 32 > t; t++) e.storeBit(1);
          else e.storeUint(t.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
          e.storeUint(t.seqno, 32), e.storeUint(0, 8);
          for (let r of t.messages) e.storeUint(t.sendMode, 8), e.storeRef((0, n.beginCell)().store((0, n.storeMessageRelaxed)(r)));
          return (0, a.signPayload)(t, e, f)
        }, e.createWalletTransferV5Beta = function(t) {
          if (t.actions.length > 255) throw Error("Maximum number of OutActions in a single request is 255");
          if ("extension" === t.authType) return (0, n.beginCell)().storeUint(o.WalletContractV5Beta.OpCodes.auth_extension, 32).store((0, s.storeOutListExtendedV5Beta)(t.actions)).endCell();
          const e = (0, n.beginCell)().storeUint("internal" === t.authType ? o.WalletContractV5Beta.OpCodes.auth_signed_internal : o.WalletContractV5Beta.OpCodes.auth_signed_external, 32).store(t.walletId);
          if (0 === t.seqno)
            for (let t = 0; 32 > t; t++) e.storeBit(1);
          else e.storeUint(t.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
          return e.storeUint(t.seqno, 32).store((0, s.storeOutListExtendedV5Beta)(t.actions)), (0, a.signPayload)(t, e, l)
        }, e.createWalletTransferV5R1 = function(t) {
          if (t.actions.length > 255) throw Error("Maximum number of OutActions in a single request is 255");
          if ("extension" === (t = {
              ...t
            }).authType) return (0, n.beginCell)().storeUint(u.WalletContractV5R1.OpCodes.auth_extension, 32).storeUint(t.queryId ?? 0, 64).store((0, c.storeOutListExtendedV5R1)(t.actions)).endCell();
          t.actions = (0, c.patchV5R1ActionsSendMode)(t.actions, t.authType);
          const e = (0, n.beginCell)().storeUint("internal" === t.authType ? u.WalletContractV5R1.OpCodes.auth_signed_internal : u.WalletContractV5R1.OpCodes.auth_signed_external, 32).store(t.walletId);
          if (0 === t.seqno)
            for (let t = 0; 32 > t; t++) e.storeBit(1);
          else e.storeUint(t.timeout || Math.floor(Date.now() / 1e3) + 60, 32);
          return e.storeUint(t.seqno, 32).store((0, c.storeOutListExtendedV5R1)(t.actions)), (0, a.signPayload)(t, e, l)
        };
        const n = r(1307),
          i = r(75269),
          o = r(53318),
          s = r(77670),
          a = r(32644),
          u = r(14112),
          c = r(80331);

        function f(t, e) {
          return (0, n.beginCell)().storeBuffer(t).storeBuilder(e).endCell()
        }

        function l(t, e) {
          return (0, n.beginCell)().storeBuilder(e).storeBuffer(t).endCell()
        }
      },
      20706: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wordlist = void 0, e.wordlist = ["abacus", "abdomen", "abdominal", "abide", "abiding", "ability", "ablaze", "able", "abnormal", "abrasion", "abrasive", "abreast", "abridge", "abroad", "abruptly", "absence", "absentee", "absently", "absinthe", "absolute", "absolve", "abstain", "abstract", "absurd", "accent", "acclaim", "acclimate", "accompany", "account", "accuracy", "accurate", "accustom", "acetone", "achiness", "aching", "acid", "acorn", "acquaint", "acquire", "acre", "acrobat", "acronym", "acting", "action", "activate", "activator", "active", "activism", "activist", "activity", "actress", "acts", "acutely", "acuteness", "aeration", "aerobics", "aerosol", "aerospace", "afar", "affair", "affected", "affecting", "affection", "affidavit", "affiliate", "affirm", "affix", "afflicted", "affluent", "afford", "affront", "aflame", "afloat", "aflutter", "afoot", "afraid", "afterglow", "afterlife", "aftermath", "aftermost", "afternoon", "aged", "ageless", "agency", "agenda", "agent", "aggregate", "aghast", "agile", "agility", "aging", "agnostic", "agonize", "agonizing", "agony", "agreeable", "agreeably", "agreed", "agreeing", "agreement", "aground", "ahead", "ahoy", "aide", "aids", "aim", "ajar", "alabaster", "alarm", "albatross", "album", "alfalfa", "algebra", "algorithm", "alias", "alibi", "alienable", "alienate", "aliens", "alike", "alive", "alkaline", "alkalize", "almanac", "almighty", "almost", "aloe", "aloft", "aloha", "alone", "alongside", "aloof", "alphabet", "alright", "although", "altitude", "alto", "aluminum", "alumni", "always", "amaretto", "amaze", "amazingly", "amber", "ambiance", "ambiguity", "ambiguous", "ambition", "ambitious", "ambulance", "ambush", "amendable", "amendment", "amends", "amenity", "amiable", "amicably", "amid", "amigo", "amino", "amiss", "ammonia", "ammonium", "amnesty", "amniotic", "among", "amount", "amperage", "ample", "amplifier", "amplify", "amply", "amuck", "amulet", "amusable", "amused", "amusement", "amuser", "amusing", "anaconda", "anaerobic", "anagram", "anatomist", "anatomy", "anchor", "anchovy", "ancient", "android", "anemia", "anemic", "aneurism", "anew", "angelfish", "angelic", "anger", "angled", "angler", "angles", "angling", "angrily", "angriness", "anguished", "angular", "animal", "animate", "animating", "animation", "animator", "anime", "animosity", "ankle", "annex", "annotate", "announcer", "annoying", "annually", "annuity", "anointer", "another", "answering", "antacid", "antarctic", "anteater", "antelope", "antennae", "anthem", "anthill", "anthology", "antibody", "antics", "antidote", "antihero", "antiquely", "antiques", "antiquity", "antirust", "antitoxic", "antitrust", "antiviral", "antivirus", "antler", "antonym", "antsy", "anvil", "anybody", "anyhow", "anymore", "anyone", "anyplace", "anything", "anytime", "anyway", "anywhere", "aorta", "apache", "apostle", "appealing", "appear", "appease", "appeasing", "appendage", "appendix", "appetite", "appetizer", "applaud", "applause", "apple", "appliance", "applicant", "applied", "apply", "appointee", "appraisal", "appraiser", "apprehend", "approach", "approval", "approve", "apricot", "april", "apron", "aptitude", "aptly", "aqua", "aqueduct", "arbitrary", "arbitrate", "ardently", "area", "arena", "arguable", "arguably", "argue", "arise", "armadillo", "armband", "armchair", "armed", "armful", "armhole", "arming", "armless", "armoire", "armored", "armory", "armrest", "army", "aroma", "arose", "around", "arousal", "arrange", "array", "arrest", "arrival", "arrive", "arrogance", "arrogant", "arson", "art", "ascend", "ascension", "ascent", "ascertain", "ashamed", "ashen", "ashes", "ashy", "aside", "askew", "asleep", "asparagus", "aspect", "aspirate", "aspire", "aspirin", "astonish", "astound", "astride", "astrology", "astronaut", "astronomy", "astute", "atlantic", "atlas", "atom", "atonable", "atop", "atrium", "atrocious", "atrophy", "attach", "attain", "attempt", "attendant", "attendee", "attention", "attentive", "attest", "attic", "attire", "attitude", "attractor", "attribute", "atypical", "auction", "audacious", "audacity", "audible", "audibly", "audience", "audio", "audition", "augmented", "august", "authentic", "author", "autism", "autistic", "autograph", "automaker", "automated", "automatic", "autopilot", "available", "avalanche", "avatar", "avenge", "avenging", "avenue", "average", "aversion", "avert", "aviation", "aviator", "avid", "avoid", "await", "awaken", "award", "aware", "awhile", "awkward", "awning", "awoke", "awry", "axis", "babble", "babbling", "babied", "baboon", "backache", "backboard", "backboned", "backdrop", "backed", "backer", "backfield", "backfire", "backhand", "backing", "backlands", "backlash", "backless", "backlight", "backlit", "backlog", "backpack", "backpedal", "backrest", "backroom", "backshift", "backside", "backslid", "backspace", "backspin", "backstab", "backstage", "backtalk", "backtrack", "backup", "backward", "backwash", "backwater", "backyard", "bacon", "bacteria", "bacterium", "badass", "badge", "badland", "badly", "badness", "baffle", "baffling", "bagel", "bagful", "baggage", "bagged", "baggie", "bagginess", "bagging", "baggy", "bagpipe", "baguette", "baked", "bakery", "bakeshop", "baking", "balance", "balancing", "balcony", "balmy", "balsamic", "bamboo", "banana", "banish", "banister", "banjo", "bankable", "bankbook", "banked", "banker", "banking", "banknote", "bankroll", "banner", "bannister", "banshee", "banter", "barbecue", "barbed", "barbell", "barber", "barcode", "barge", "bargraph", "barista", "baritone", "barley", "barmaid", "barman", "barn", "barometer", "barrack", "barracuda", "barrel", "barrette", "barricade", "barrier", "barstool", "bartender", "barterer", "bash", "basically", "basics", "basil", "basin", "basis", "basket", "batboy", "batch", "bath", "baton", "bats", "battalion", "battered", "battering", "battery", "batting", "battle", "bauble", "bazooka", "blabber", "bladder", "blade", "blah", "blame", "blaming", "blanching", "blandness", "blank", "blaspheme", "blasphemy", "blast", "blatancy", "blatantly", "blazer", "blazing", "bleach", "bleak", "bleep", "blemish", "blend", "bless", "blighted", "blimp", "bling", "blinked", "blinker", "blinking", "blinks", "blip", "blissful", "blitz", "blizzard", "bloated", "bloating", "blob", "blog", "bloomers", "blooming", "blooper", "blot", "blouse", "blubber", "bluff", "bluish", "blunderer", "blunt", "blurb", "blurred", "blurry", "blurt", "blush", "blustery", "boaster", "boastful", "boasting", "boat", "bobbed", "bobbing", "bobble", "bobcat", "bobsled", "bobtail", "bodacious", "body", "bogged", "boggle", "bogus", "boil", "bok", "bolster", "bolt", "bonanza", "bonded", "bonding", "bondless", "boned", "bonehead", "boneless", "bonelike", "boney", "bonfire", "bonnet", "bonsai", "bonus", "bony", "boogeyman", "boogieman", "book", "boondocks", "booted", "booth", "bootie", "booting", "bootlace", "bootleg", "boots", "boozy", "borax", "boring", "borough", "borrower", "borrowing", "boss", "botanical", "botanist", "botany", "botch", "both", "bottle", "bottling", "bottom", "bounce", "bouncing", "bouncy", "bounding", "boundless", "bountiful", "bovine", "boxcar", "boxer", "boxing", "boxlike", "boxy", "breach", "breath", "breeches", "breeching", "breeder", "breeding", "breeze", "breezy", "brethren", "brewery", "brewing", "briar", "bribe", "brick", "bride", "bridged", "brigade", "bright", "brilliant", "brim", "bring", "brink", "brisket", "briskly", "briskness", "bristle", "brittle", "broadband", "broadcast", "broaden", "broadly", "broadness", "broadside", "broadways", "broiler", "broiling", "broken", "broker", "bronchial", "bronco", "bronze", "bronzing", "brook", "broom", "brought", "browbeat", "brownnose", "browse", "browsing", "bruising", "brunch", "brunette", "brunt", "brush", "brussels", "brute", "brutishly", "bubble", "bubbling", "bubbly", "buccaneer", "bucked", "bucket", "buckle", "buckshot", "buckskin", "bucktooth", "buckwheat", "buddhism", "buddhist", "budding", "buddy", "budget", "buffalo", "buffed", "buffer", "buffing", "buffoon", "buggy", "bulb", "bulge", "bulginess", "bulgur", "bulk", "bulldog", "bulldozer", "bullfight", "bullfrog", "bullhorn", "bullion", "bullish", "bullpen", "bullring", "bullseye", "bullwhip", "bully", "bunch", "bundle", "bungee", "bunion", "bunkbed", "bunkhouse", "bunkmate", "bunny", "bunt", "busboy", "bush", "busily", "busload", "bust", "busybody", "buzz", "cabana", "cabbage", "cabbie", "cabdriver", "cable", "caboose", "cache", "cackle", "cacti", "cactus", "caddie", "caddy", "cadet", "cadillac", "cadmium", "cage", "cahoots", "cake", "calamari", "calamity", "calcium", "calculate", "calculus", "caliber", "calibrate", "calm", "caloric", "calorie", "calzone", "camcorder", "cameo", "camera", "camisole", "camper", "campfire", "camping", "campsite", "campus", "canal", "canary", "cancel", "candied", "candle", "candy", "cane", "canine", "canister", "cannabis", "canned", "canning", "cannon", "cannot", "canola", "canon", "canopener", "canopy", "canteen", "canyon", "capable", "capably", "capacity", "cape", "capillary", "capital", "capitol", "capped", "capricorn", "capsize", "capsule", "caption", "captivate", "captive", "captivity", "capture", "caramel", "carat", "caravan", "carbon", "cardboard", "carded", "cardiac", "cardigan", "cardinal", "cardstock", "carefully", "caregiver", "careless", "caress", "caretaker", "cargo", "caring", "carless", "carload", "carmaker", "carnage", "carnation", "carnival", "carnivore", "carol", "carpenter", "carpentry", "carpool", "carport", "carried", "carrot", "carrousel", "carry", "cartel", "cartload", "carton", "cartoon", "cartridge", "cartwheel", "carve", "carving", "carwash", "cascade", "case", "cash", "casing", "casino", "casket", "cassette", "casually", "casualty", "catacomb", "catalog", "catalyst", "catalyze", "catapult", "cataract", "catatonic", "catcall", "catchable", "catcher", "catching", "catchy", "caterer", "catering", "catfight", "catfish", "cathedral", "cathouse", "catlike", "catnap", "catnip", "catsup", "cattail", "cattishly", "cattle", "catty", "catwalk", "caucasian", "caucus", "causal", "causation", "cause", "causing", "cauterize", "caution", "cautious", "cavalier", "cavalry", "caviar", "cavity", "cedar", "celery", "celestial", "celibacy", "celibate", "celtic", "cement", "census", "ceramics", "ceremony", "certainly", "certainty", "certified", "certify", "cesarean", "cesspool", "chafe", "chaffing", "chain", "chair", "chalice", "challenge", "chamber", "chamomile", "champion", "chance", "change", "channel", "chant", "chaos", "chaperone", "chaplain", "chapped", "chaps", "chapter", "character", "charbroil", "charcoal", "charger", "charging", "chariot", "charity", "charm", "charred", "charter", "charting", "chase", "chasing", "chaste", "chastise", "chastity", "chatroom", "chatter", "chatting", "chatty", "cheating", "cheddar", "cheek", "cheer", "cheese", "cheesy", "chef", "chemicals", "chemist", "chemo", "cherisher", "cherub", "chess", "chest", "chevron", "chevy", "chewable", "chewer", "chewing", "chewy", "chief", "chihuahua", "childcare", "childhood", "childish", "childless", "childlike", "chili", "chill", "chimp", "chip", "chirping", "chirpy", "chitchat", "chivalry", "chive", "chloride", "chlorine", "choice", "chokehold", "choking", "chomp", "chooser", "choosing", "choosy", "chop", "chosen", "chowder", "chowtime", "chrome", "chubby", "chuck", "chug", "chummy", "chump", "chunk", "churn", "chute", "cider", "cilantro", "cinch", "cinema", "cinnamon", "circle", "circling", "circular", "circulate", "circus", "citable", "citadel", "citation", "citizen", "citric", "citrus", "city", "civic", "civil", "clad", "claim", "clambake", "clammy", "clamor", "clamp", "clamshell", "clang", "clanking", "clapped", "clapper", "clapping", "clarify", "clarinet", "clarity", "clash", "clasp", "class", "clatter", "clause", "clavicle", "claw", "clay", "clean", "clear", "cleat", "cleaver", "cleft", "clench", "clergyman", "clerical", "clerk", "clever", "clicker", "client", "climate", "climatic", "cling", "clinic", "clinking", "clip", "clique", "cloak", "clobber", "clock", "clone", "cloning", "closable", "closure", "clothes", "clothing", "cloud", "clover", "clubbed", "clubbing", "clubhouse", "clump", "clumsily", "clumsy", "clunky", "clustered", "clutch", "clutter", "coach", "coagulant", "coastal", "coaster", "coasting", "coastland", "coastline", "coat", "coauthor", "cobalt", "cobbler", "cobweb", "cocoa", "coconut", "cod", "coeditor", "coerce", "coexist", "coffee", "cofounder", "cognition", "cognitive", "cogwheel", "coherence", "coherent", "cohesive", "coil", "coke", "cola", "cold", "coleslaw", "coliseum", "collage", "collapse", "collar", "collected", "collector", "collide", "collie", "collision", "colonial", "colonist", "colonize", "colony", "colossal", "colt", "coma", "come", "comfort", "comfy", "comic", "coming", "comma", "commence", "commend", "comment", "commerce", "commode", "commodity", "commodore", "common", "commotion", "commute", "commuting", "compacted", "compacter", "compactly", "compactor", "companion", "company", "compare", "compel", "compile", "comply", "component", "composed", "composer", "composite", "compost", "composure", "compound", "compress", "comprised", "computer", "computing", "comrade", "concave", "conceal", "conceded", "concept", "concerned", "concert", "conch", "concierge", "concise", "conclude", "concrete", "concur", "condense", "condiment", "condition", "condone", "conducive", "conductor", "conduit", "cone", "confess", "confetti", "confidant", "confident", "confider", "confiding", "configure", "confined", "confining", "confirm", "conflict", "conform", "confound", "confront", "confused", "confusing", "confusion", "congenial", "congested", "congrats", "congress", "conical", "conjoined", "conjure", "conjuror", "connected", "connector", "consensus", "consent", "console", "consoling", "consonant", "constable", "constant", "constrain", "constrict", "construct", "consult", "consumer", "consuming", "contact", "container", "contempt", "contend", "contented", "contently", "contents", "contest", "context", "contort", "contour", "contrite", "control", "contusion", "convene", "convent", "copartner", "cope", "copied", "copier", "copilot", "coping", "copious", "copper", "copy", "coral", "cork", "cornball", "cornbread", "corncob", "cornea", "corned", "corner", "cornfield", "cornflake", "cornhusk", "cornmeal", "cornstalk", "corny", "coronary", "coroner", "corporal", "corporate", "corral", "correct", "corridor", "corrode", "corroding", "corrosive", "corsage", "corset", "cortex", "cosigner", "cosmetics", "cosmic", "cosmos", "cosponsor", "cost", "cottage", "cotton", "couch", "cough", "could", "countable", "countdown", "counting", "countless", "country", "county", "courier", "covenant", "cover", "coveted", "coveting", "coyness", "cozily", "coziness", "cozy", "crabbing", "crabgrass", "crablike", "crabmeat", "cradle", "cradling", "crafter", "craftily", "craftsman", "craftwork", "crafty", "cramp", "cranberry", "crane", "cranial", "cranium", "crank", "crate", "crave", "craving", "crawfish", "crawlers", "crawling", "crayfish", "crayon", "crazed", "crazily", "craziness", "crazy", "creamed", "creamer", "creamlike", "crease", "creasing", "creatable", "create", "creation", "creative", "creature", "credible", "credibly", "credit", "creed", "creme", "creole", "crepe", "crept", "crescent", "crested", "cresting", "crestless", "crevice", "crewless", "crewman", "crewmate", "crib", "cricket", "cried", "crier", "crimp", "crimson", "cringe", "cringing", "crinkle", "crinkly", "crisped", "crisping", "crisply", "crispness", "crispy", "criteria", "critter", "croak", "crock", "crook", "croon", "crop", "cross", "crouch", "crouton", "crowbar", "crowd", "crown", "crucial", "crudely", "crudeness", "cruelly", "cruelness", "cruelty", "crumb", "crummiest", "crummy", "crumpet", "crumpled", "cruncher", "crunching", "crunchy", "crusader", "crushable", "crushed", "crusher", "crushing", "crust", "crux", "crying", "cryptic", "crystal", "cubbyhole", "cube", "cubical", "cubicle", "cucumber", "cuddle", "cuddly", "cufflink", "culinary", "culminate", "culpable", "culprit", "cultivate", "cultural", "culture", "cupbearer", "cupcake", "cupid", "cupped", "cupping", "curable", "curator", "curdle", "cure", "curfew", "curing", "curled", "curler", "curliness", "curling", "curly", "curry", "curse", "cursive", "cursor", "curtain", "curtly", "curtsy", "curvature", "curve", "curvy", "cushy", "cusp", "cussed", "custard", "custodian", "custody", "customary", "customer", "customize", "customs", "cut", "cycle", "cyclic", "cycling", "cyclist", "cylinder", "cymbal", "cytoplasm", "cytoplast", "dab", "dad", "daffodil", "dagger", "daily", "daintily", "dainty", "dairy", "daisy", "dallying", "dance", "dancing", "dandelion", "dander", "dandruff", "dandy", "danger", "dangle", "dangling", "daredevil", "dares", "daringly", "darkened", "darkening", "darkish", "darkness", "darkroom", "darling", "darn", "dart", "darwinism", "dash", "dastardly", "data", "datebook", "dating", "daughter", "daunting", "dawdler", "dawn", "daybed", "daybreak", "daycare", "daydream", "daylight", "daylong", "dayroom", "daytime", "dazzler", "dazzling", "deacon", "deafening", "deafness", "dealer", "dealing", "dealmaker", "dealt", "dean", "debatable", "debate", "debating", "debit", "debrief", "debtless", "debtor", "debug", "debunk", "decade", "decaf", "decal", "decathlon", "decay", "deceased", "deceit", "deceiver", "deceiving", "december", "decency", "decent", "deception", "deceptive", "decibel", "decidable", "decimal", "decimeter", "decipher", "deck", "declared", "decline", "decode", "decompose", "decorated", "decorator", "decoy", "decrease", "decree", "dedicate", "dedicator", "deduce", "deduct", "deed", "deem", "deepen", "deeply", "deepness", "deface", "defacing", "defame", "default", "defeat", "defection", "defective", "defendant", "defender", "defense", "defensive", "deferral", "deferred", "defiance", "defiant", "defile", "defiling", "define", "definite", "deflate", "deflation", "deflator", "deflected", "deflector", "defog", "deforest", "defraud", "defrost", "deftly", "defuse", "defy", "degraded", "degrading", "degrease", "degree", "dehydrate", "deity", "dejected", "delay", "delegate", "delegator", "delete", "deletion", "delicacy", "delicate", "delicious", "delighted", "delirious", "delirium", "deliverer", "delivery", "delouse", "delta", "deluge", "delusion", "deluxe", "demanding", "demeaning", "demeanor", "demise", "democracy", "democrat", "demote", "demotion", "demystify", "denatured", "deniable", "denial", "denim", "denote", "dense", "density", "dental", "dentist", "denture", "deny", "deodorant", "deodorize", "departed", "departure", "depict", "deplete", "depletion", "deplored", "deploy", "deport", "depose", "depraved", "depravity", "deprecate", "depress", "deprive", "depth", "deputize", "deputy", "derail", "deranged", "derby", "derived", "desecrate", "deserve", "deserving", "designate", "designed", "designer", "designing", "deskbound", "desktop", "deskwork", "desolate", "despair", "despise", "despite", "destiny", "destitute", "destruct", "detached", "detail", "detection", "detective", "detector", "detention", "detergent", "detest", "detonate", "detonator", "detoxify", "detract", "deuce", "devalue", "deviancy", "deviant", "deviate", "deviation", "deviator", "device", "devious", "devotedly", "devotee", "devotion", "devourer", "devouring", "devoutly", "dexterity", "dexterous", "diabetes", "diabetic", "diabolic", "diagnoses", "diagnosis", "diagram", "dial", "diameter", "diaper", "diaphragm", "diary", "dice", "dicing", "dictate", "dictation", "dictator", "difficult", "diffused", "diffuser", "diffusion", "diffusive", "dig", "dilation", "diligence", "diligent", "dill", "dilute", "dime", "diminish", "dimly", "dimmed", "dimmer", "dimness", "dimple", "diner", "dingbat", "dinghy", "dinginess", "dingo", "dingy", "dining", "dinner", "diocese", "dioxide", "diploma", "dipped", "dipper", "dipping", "directed", "direction", "directive", "directly", "directory", "direness", "dirtiness", "disabled", "disagree", "disallow", "disarm", "disarray", "disaster", "disband", "disbelief", "disburse", "discard", "discern", "discharge", "disclose", "discolor", "discount", "discourse", "discover", "discuss", "disdain", "disengage", "disfigure", "disgrace", "dish", "disinfect", "disjoin", "disk", "dislike", "disliking", "dislocate", "dislodge", "disloyal", "dismantle", "dismay", "dismiss", "dismount", "disobey", "disorder", "disown", "disparate", "disparity", "dispatch", "dispense", "dispersal", "dispersed", "disperser", "displace", "display", "displease", "disposal", "dispose", "disprove", "dispute", "disregard", "disrupt", "dissuade", "distance", "distant", "distaste", "distill", "distinct", "distort", "distract", "distress", "district", "distrust", "ditch", "ditto", "ditzy", "dividable", "divided", "dividend", "dividers", "dividing", "divinely", "diving", "divinity", "divisible", "divisibly", "division", "divisive", "divorcee", "dizziness", "dizzy", "doable", "docile", "dock", "doctrine", "document", "dodge", "dodgy", "doily", "doing", "dole", "dollar", "dollhouse", "dollop", "dolly", "dolphin", "domain", "domelike", "domestic", "dominion", "dominoes", "donated", "donation", "donator", "donor", "donut", "doodle", "doorbell", "doorframe", "doorknob", "doorman", "doormat", "doornail", "doorpost", "doorstep", "doorstop", "doorway", "doozy", "dork", "dormitory", "dorsal", "dosage", "dose", "dotted", "doubling", "douche", "dove", "down", "dowry", "doze", "drab", "dragging", "dragonfly", "dragonish", "dragster", "drainable", "drainage", "drained", "drainer", "drainpipe", "dramatic", "dramatize", "drank", "drapery", "drastic", "draw", "dreaded", "dreadful", "dreadlock", "dreamboat", "dreamily", "dreamland", "dreamless", "dreamlike", "dreamt", "dreamy", "drearily", "dreary", "drench", "dress", "drew", "dribble", "dried", "drier", "drift", "driller", "drilling", "drinkable", "drinking", "dripping", "drippy", "drivable", "driven", "driver", "driveway", "driving", "drizzle", "drizzly", "drone", "drool", "droop", "drop-down", "dropbox", "dropkick", "droplet", "dropout", "dropper", "drove", "drown", "drowsily", "drudge", "drum", "dry", "dubbed", "dubiously", "duchess", "duckbill", "ducking", "duckling", "ducktail", "ducky", "duct", "dude", "duffel", "dugout", "duh", "duke", "duller", "dullness", "duly", "dumping", "dumpling", "dumpster", "duo", "dupe", "duplex", "duplicate", "duplicity", "durable", "durably", "duration", "duress", "during", "dusk", "dust", "dutiful", "duty", "duvet", "dwarf", "dweeb", "dwelled", "dweller", "dwelling", "dwindle", "dwindling", "dynamic", "dynamite", "dynasty", "dyslexia", "dyslexic", "each", "eagle", "earache", "eardrum", "earflap", "earful", "earlobe", "early", "earmark", "earmuff", "earphone", "earpiece", "earplugs", "earring", "earshot", "earthen", "earthlike", "earthling", "earthly", "earthworm", "earthy", "earwig", "easeful", "easel", "easiest", "easily", "easiness", "easing", "eastbound", "eastcoast", "easter", "eastward", "eatable", "eaten", "eatery", "eating", "eats", "ebay", "ebony", "ebook", "ecard", "eccentric", "echo", "eclair", "eclipse", "ecologist", "ecology", "economic", "economist", "economy", "ecosphere", "ecosystem", "edge", "edginess", "edging", "edgy", "edition", "editor", "educated", "education", "educator", "eel", "effective", "effects", "efficient", "effort", "eggbeater", "egging", "eggnog", "eggplant", "eggshell", "egomaniac", "egotism", "egotistic", "either", "eject", "elaborate", "elastic", "elated", "elbow", "eldercare", "elderly", "eldest", "electable", "election", "elective", "elephant", "elevate", "elevating", "elevation", "elevator", "eleven", "elf", "eligible", "eligibly", "eliminate", "elite", "elitism", "elixir", "elk", "ellipse", "elliptic", "elm", "elongated", "elope", "eloquence", "eloquent", "elsewhere", "elude", "elusive", "elves", "email", "embargo", "embark", "embassy", "embattled", "embellish", "ember", "embezzle", "emblaze", "emblem", "embody", "embolism", "emboss", "embroider", "emcee", "emerald", "emergency", "emission", "emit", "emote", "emoticon", "emotion", "empathic", "empathy", "emperor", "emphases", "emphasis", "emphasize", "emphatic", "empirical", "employed", "employee", "employer", "emporium", "empower", "emptier", "emptiness", "empty", "emu", "enable", "enactment", "enamel", "enchanted", "enchilada", "encircle", "enclose", "enclosure", "encode", "encore", "encounter", "encourage", "encroach", "encrust", "encrypt", "endanger", "endeared", "endearing", "ended", "ending", "endless", "endnote", "endocrine", "endorphin", "endorse", "endowment", "endpoint", "endurable", "endurance", "enduring", "energetic", "energize", "energy", "enforced", "enforcer", "engaged", "engaging", "engine", "engorge", "engraved", "engraver", "engraving", "engross", "engulf", "enhance", "enigmatic", "enjoyable", "enjoyably", "enjoyer", "enjoying", "enjoyment", "enlarged", "enlarging", "enlighten", "enlisted", "enquirer", "enrage", "enrich", "enroll", "enslave", "ensnare", "ensure", "entail", "entangled", "entering", "entertain", "enticing", "entire", "entitle", "entity", "entomb", "entourage", "entrap", "entree", "entrench", "entrust", "entryway", "entwine", "enunciate", "envelope", "enviable", "enviably", "envious", "envision", "envoy", "envy", "enzyme", "epic", "epidemic", "epidermal", "epidermis", "epidural", "epilepsy", "epileptic", "epilogue", "epiphany", "episode", "equal", "equate", "equation", "equator", "equinox", "equipment", "equity", "equivocal", "eradicate", "erasable", "erased", "eraser", "erasure", "ergonomic", "errand", "errant", "erratic", "error", "erupt", "escalate", "escalator", "escapable", "escapade", "escapist", "escargot", "eskimo", "esophagus", "espionage", "espresso", "esquire", "essay", "essence", "essential", "establish", "estate", "esteemed", "estimate", "estimator", "estranged", "estrogen", "etching", "eternal", "eternity", "ethanol", "ether", "ethically", "ethics", "euphemism", "evacuate", "evacuee", "evade", "evaluate", "evaluator", "evaporate", "evasion", "evasive", "even", "everglade", "evergreen", "everybody", "everyday", "everyone", "evict", "evidence", "evident", "evil", "evoke", "evolution", "evolve", "exact", "exalted", "example", "excavate", "excavator", "exceeding", "exception", "excess", "exchange", "excitable", "exciting", "exclaim", "exclude", "excluding", "exclusion", "exclusive", "excretion", "excretory", "excursion", "excusable", "excusably", "excuse", "exemplary", "exemplify", "exemption", "exerciser", "exert", "exes", "exfoliate", "exhale", "exhaust", "exhume", "exile", "existing", "exit", "exodus", "exonerate", "exorcism", "exorcist", "expand", "expanse", "expansion", "expansive", "expectant", "expedited", "expediter", "expel", "expend", "expenses", "expensive", "expert", "expire", "expiring", "explain", "expletive", "explicit", "explode", "exploit", "explore", "exploring", "exponent", "exporter", "exposable", "expose", "exposure", "express", "expulsion", "exquisite", "extended", "extending", "extent", "extenuate", "exterior", "external", "extinct", "extortion", "extradite", "extras", "extrovert", "extrude", "extruding", "exuberant", "fable", "fabric", "fabulous", "facebook", "facecloth", "facedown", "faceless", "facelift", "faceplate", "faceted", "facial", "facility", "facing", "facsimile", "faction", "factoid", "factor", "factsheet", "factual", "faculty", "fade", "fading", "failing", "falcon", "fall", "false", "falsify", "fame", "familiar", "family", "famine", "famished", "fanatic", "fancied", "fanciness", "fancy", "fanfare", "fang", "fanning", "fantasize", "fantastic", "fantasy", "fascism", "fastball", "faster", "fasting", "fastness", "faucet", "favorable", "favorably", "favored", "favoring", "favorite", "fax", "feast", "federal", "fedora", "feeble", "feed", "feel", "feisty", "feline", "felt-tip", "feminine", "feminism", "feminist", "feminize", "femur", "fence", "fencing", "fender", "ferment", "fernlike", "ferocious", "ferocity", "ferret", "ferris", "ferry", "fervor", "fester", "festival", "festive", "festivity", "fetal", "fetch", "fever", "fiber", "fiction", "fiddle", "fiddling", "fidelity", "fidgeting", "fidgety", "fifteen", "fifth", "fiftieth", "fifty", "figment", "figure", "figurine", "filing", "filled", "filler", "filling", "film", "filter", "filth", "filtrate", "finale", "finalist", "finalize", "finally", "finance", "financial", "finch", "fineness", "finer", "finicky", "finished", "finisher", "finishing", "finite", "finless", "finlike", "fiscally", "fit", "five", "flaccid", "flagman", "flagpole", "flagship", "flagstick", "flagstone", "flail", "flakily", "flaky", "flame", "flammable", "flanked", "flanking", "flannels", "flap", "flaring", "flashback", "flashbulb", "flashcard", "flashily", "flashing", "flashy", "flask", "flatbed", "flatfoot", "flatly", "flatness", "flatten", "flattered", "flatterer", "flattery", "flattop", "flatware", "flatworm", "flavored", "flavorful", "flavoring", "flaxseed", "fled", "fleshed", "fleshy", "flick", "flier", "flight", "flinch", "fling", "flint", "flip", "flirt", "float", "flock", "flogging", "flop", "floral", "florist", "floss", "flounder", "flyable", "flyaway", "flyer", "flying", "flyover", "flypaper", "foam", "foe", "fog", "foil", "folic", "folk", "follicle", "follow", "fondling", "fondly", "fondness", "fondue", "font", "food", "fool", "footage", "football", "footbath", "footboard", "footer", "footgear", "foothill", "foothold", "footing", "footless", "footman", "footnote", "footpad", "footpath", "footprint", "footrest", "footsie", "footsore", "footwear", "footwork", "fossil", "foster", "founder", "founding", "fountain", "fox", "foyer", "fraction", "fracture", "fragile", "fragility", "fragment", "fragrance", "fragrant", "frail", "frame", "framing", "frantic", "fraternal", "frayed", "fraying", "frays", "freckled", "freckles", "freebase", "freebee", "freebie", "freedom", "freefall", "freehand", "freeing", "freeload", "freely", "freemason", "freeness", "freestyle", "freeware", "freeway", "freewill", "freezable", "freezing", "freight", "french", "frenzied", "frenzy", "frequency", "frequent", "fresh", "fretful", "fretted", "friction", "friday", "fridge", "fried", "friend", "frighten", "frightful", "frigidity", "frigidly", "frill", "fringe", "frisbee", "frisk", "fritter", "frivolous", "frolic", "from", "front", "frostbite", "frosted", "frostily", "frosting", "frostlike", "frosty", "froth", "frown", "frozen", "fructose", "frugality", "frugally", "fruit", "frustrate", "frying", "gab", "gaffe", "gag", "gainfully", "gaining", "gains", "gala", "gallantly", "galleria", "gallery", "galley", "gallon", "gallows", "gallstone", "galore", "galvanize", "gambling", "game", "gaming", "gamma", "gander", "gangly", "gangrene", "gangway", "gap", "garage", "garbage", "garden", "gargle", "garland", "garlic", "garment", "garnet", "garnish", "garter", "gas", "gatherer", "gathering", "gating", "gauging", "gauntlet", "gauze", "gave", "gawk", "gazing", "gear", "gecko", "geek", "geiger", "gem", "gender", "generic", "generous", "genetics", "genre", "gentile", "gentleman", "gently", "gents", "geography", "geologic", "geologist", "geology", "geometric", "geometry", "geranium", "gerbil", "geriatric", "germicide", "germinate", "germless", "germproof", "gestate", "gestation", "gesture", "getaway", "getting", "getup", "giant", "gibberish", "giblet", "giddily", "giddiness", "giddy", "gift", "gigabyte", "gigahertz", "gigantic", "giggle", "giggling", "giggly", "gigolo", "gilled", "gills", "gimmick", "girdle", "giveaway", "given", "giver", "giving", "gizmo", "gizzard", "glacial", "glacier", "glade", "gladiator", "gladly", "glamorous", "glamour", "glance", "glancing", "glandular", "glare", "glaring", "glass", "glaucoma", "glazing", "gleaming", "gleeful", "glider", "gliding", "glimmer", "glimpse", "glisten", "glitch", "glitter", "glitzy", "gloater", "gloating", "gloomily", "gloomy", "glorified", "glorifier", "glorify", "glorious", "glory", "gloss", "glove", "glowing", "glowworm", "glucose", "glue", "gluten", "glutinous", "glutton", "gnarly", "gnat", "goal", "goatskin", "goes", "goggles", "going", "goldfish", "goldmine", "goldsmith", "golf", "goliath", "gonad", "gondola", "gone", "gong", "good", "gooey", "goofball", "goofiness", "goofy", "google", "goon", "gopher", "gore", "gorged", "gorgeous", "gory", "gosling", "gossip", "gothic", "gotten", "gout", "gown", "grab", "graceful", "graceless", "gracious", "gradation", "graded", "grader", "gradient", "grading", "gradually", "graduate", "graffiti", "grafted", "grafting", "grain", "granddad", "grandkid", "grandly", "grandma", "grandpa", "grandson", "granite", "granny", "granola", "grant", "granular", "grape", "graph", "grapple", "grappling", "grasp", "grass", "gratified", "gratify", "grating", "gratitude", "gratuity", "gravel", "graveness", "graves", "graveyard", "gravitate", "gravity", "gravy", "gray", "grazing", "greasily", "greedily", "greedless", "greedy", "green", "greeter", "greeting", "grew", "greyhound", "grid", "grief", "grievance", "grieving", "grievous", "grill", "grimace", "grimacing", "grime", "griminess", "grimy", "grinch", "grinning", "grip", "gristle", "grit", "groggily", "groggy", "groin", "groom", "groove", "grooving", "groovy", "grope", "ground", "grouped", "grout", "grove", "grower", "growing", "growl", "grub", "grudge", "grudging", "grueling", "gruffly", "grumble", "grumbling", "grumbly", "grumpily", "grunge", "grunt", "guacamole", "guidable", "guidance", "guide", "guiding", "guileless", "guise", "gulf", "gullible", "gully", "gulp", "gumball", "gumdrop", "gumminess", "gumming", "gummy", "gurgle", "gurgling", "guru", "gush", "gusto", "gusty", "gutless", "guts", "gutter", "guy", "guzzler", "gyration", "habitable", "habitant", "habitat", "habitual", "hacked", "hacker", "hacking", "hacksaw", "had", "haggler", "haiku", "half", "halogen", "halt", "halved", "halves", "hamburger", "hamlet", "hammock", "hamper", "hamster", "hamstring", "handbag", "handball", "handbook", "handbrake", "handcart", "handclap", "handclasp", "handcraft", "handcuff", "handed", "handful", "handgrip", "handgun", "handheld", "handiness", "handiwork", "handlebar", "handled", "handler", "handling", "handmade", "handoff", "handpick", "handprint", "handrail", "handsaw", "handset", "handsfree", "handshake", "handstand", "handwash", "handwork", "handwoven", "handwrite", "handyman", "hangnail", "hangout", "hangover", "hangup", "hankering", "hankie", "hanky", "haphazard", "happening", "happier", "happiest", "happily", "happiness", "happy", "harbor", "hardcopy", "hardcore", "hardcover", "harddisk", "hardened", "hardener", "hardening", "hardhat", "hardhead", "hardiness", "hardly", "hardness", "hardship", "hardware", "hardwired", "hardwood", "hardy", "harmful", "harmless", "harmonica", "harmonics", "harmonize", "harmony", "harness", "harpist", "harsh", "harvest", "hash", "hassle", "haste", "hastily", "hastiness", "hasty", "hatbox", "hatchback", "hatchery", "hatchet", "hatching", "hatchling", "hate", "hatless", "hatred", "haunt", "haven", "hazard", "hazelnut", "hazily", "haziness", "hazing", "hazy", "headache", "headband", "headboard", "headcount", "headdress", "headed", "header", "headfirst", "headgear", "heading", "headlamp", "headless", "headlock", "headphone", "headpiece", "headrest", "headroom", "headscarf", "headset", "headsman", "headstand", "headstone", "headway", "headwear", "heap", "heat", "heave", "heavily", "heaviness", "heaving", "hedge", "hedging", "heftiness", "hefty", "helium", "helmet", "helper", "helpful", "helping", "helpless", "helpline", "hemlock", "hemstitch", "hence", "henchman", "henna", "herald", "herbal", "herbicide", "herbs", "heritage", "hermit", "heroics", "heroism", "herring", "herself", "hertz", "hesitancy", "hesitant", "hesitate", "hexagon", "hexagram", "hubcap", "huddle", "huddling", "huff", "hug", "hula", "hulk", "hull", "human", "humble", "humbling", "humbly", "humid", "humiliate", "humility", "humming", "hummus", "humongous", "humorist", "humorless", "humorous", "humpback", "humped", "humvee", "hunchback", "hundredth", "hunger", "hungrily", "hungry", "hunk", "hunter", "hunting", "huntress", "huntsman", "hurdle", "hurled", "hurler", "hurling", "hurray", "hurricane", "hurried", "hurry", "hurt", "husband", "hush", "husked", "huskiness", "hut", "hybrid", "hydrant", "hydrated", "hydration", "hydrogen", "hydroxide", "hyperlink", "hypertext", "hyphen", "hypnoses", "hypnosis", "hypnotic", "hypnotism", "hypnotist", "hypnotize", "hypocrisy", "hypocrite", "ibuprofen", "ice", "iciness", "icing", "icky", "icon", "icy", "idealism", "idealist", "idealize", "ideally", "idealness", "identical", "identify", "identity", "ideology", "idiocy", "idiom", "idly", "igloo", "ignition", "ignore", "iguana", "illicitly", "illusion", "illusive", "image", "imaginary", "imagines", "imaging", "imbecile", "imitate", "imitation", "immature", "immerse", "immersion", "imminent", "immobile", "immodest", "immorally", "immortal", "immovable", "immovably", "immunity", "immunize", "impaired", "impale", "impart", "impatient", "impeach", "impeding", "impending", "imperfect", "imperial", "impish", "implant", "implement", "implicate", "implicit", "implode", "implosion", "implosive", "imply", "impolite", "important", "importer", "impose", "imposing", "impotence", "impotency", "impotent", "impound", "imprecise", "imprint", "imprison", "impromptu", "improper", "improve", "improving", "improvise", "imprudent", "impulse", "impulsive", "impure", "impurity", "iodine", "iodize", "ion", "ipad", "iphone", "ipod", "irate", "irk", "iron", "irregular", "irrigate", "irritable", "irritably", "irritant", "irritate", "islamic", "islamist", "isolated", "isolating", "isolation", "isotope", "issue", "issuing", "italicize", "italics", "item", "itinerary", "itunes", "ivory", "ivy", "jab", "jackal", "jacket", "jackknife", "jackpot", "jailbird", "jailbreak", "jailer", "jailhouse", "jalapeno", "jam", "janitor", "january", "jargon", "jarring", "jasmine", "jaundice", "jaunt", "java", "jawed", "jawless", "jawline", "jaws", "jaybird", "jaywalker", "jazz", "jeep", "jeeringly", "jellied", "jelly", "jersey", "jester", "jet", "jiffy", "jigsaw", "jimmy", "jingle", "jingling", "jinx", "jitters", "jittery", "job", "jockey", "jockstrap", "jogger", "jogging", "john", "joining", "jokester", "jokingly", "jolliness", "jolly", "jolt", "jot", "jovial", "joyfully", "joylessly", "joyous", "joyride", "joystick", "jubilance", "jubilant", "judge", "judgingly", "judicial", "judiciary", "judo", "juggle", "juggling", "jugular", "juice", "juiciness", "juicy", "jujitsu", "jukebox", "july", "jumble", "jumbo", "jump", "junction", "juncture", "june", "junior", "juniper", "junkie", "junkman", "junkyard", "jurist", "juror", "jury", "justice", "justifier", "justify", "justly", "justness", "juvenile", "kabob", "kangaroo", "karaoke", "karate", "karma", "kebab", "keenly", "keenness", "keep", "keg", "kelp", "kennel", "kept", "kerchief", "kerosene", "kettle", "kick", "kiln", "kilobyte", "kilogram", "kilometer", "kilowatt", "kilt", "kimono", "kindle", "kindling", "kindly", "kindness", "kindred", "kinetic", "kinfolk", "king", "kinship", "kinsman", "kinswoman", "kissable", "kisser", "kissing", "kitchen", "kite", "kitten", "kitty", "kiwi", "kleenex", "knapsack", "knee", "knelt", "knickers", "knoll", "koala", "kooky", "kosher", "krypton", "kudos", "kung", "labored", "laborer", "laboring", "laborious", "labrador", "ladder", "ladies", "ladle", "ladybug", "ladylike", "lagged", "lagging", "lagoon", "lair", "lake", "lance", "landed", "landfall", "landfill", "landing", "landlady", "landless", "landline", "landlord", "landmark", "landmass", "landmine", "landowner", "landscape", "landside", "landslide", "language", "lankiness", "lanky", "lantern", "lapdog", "lapel", "lapped", "lapping", "laptop", "lard", "large", "lark", "lash", "lasso", "last", "latch", "late", "lather", "latitude", "latrine", "latter", "latticed", "launch", "launder", "laundry", "laurel", "lavender", "lavish", "laxative", "lazily", "laziness", "lazy", "lecturer", "left", "legacy", "legal", "legend", "legged", "leggings", "legible", "legibly", "legislate", "lego", "legroom", "legume", "legwarmer", "legwork", "lemon", "lend", "length", "lens", "lent", "leotard", "lesser", "letdown", "lethargic", "lethargy", "letter", "lettuce", "level", "leverage", "levers", "levitate", "levitator", "liability", "liable", "liberty", "librarian", "library", "licking", "licorice", "lid", "life", "lifter", "lifting", "liftoff", "ligament", "likely", "likeness", "likewise", "liking", "lilac", "lilly", "lily", "limb", "limeade", "limelight", "limes", "limit", "limping", "limpness", "line", "lingo", "linguini", "linguist", "lining", "linked", "linoleum", "linseed", "lint", "lion", "lip", "liquefy", "liqueur", "liquid", "lisp", "list", "litigate", "litigator", "litmus", "litter", "little", "livable", "lived", "lively", "liver", "livestock", "lividly", "living", "lizard", "lubricant", "lubricate", "lucid", "luckily", "luckiness", "luckless", "lucrative", "ludicrous", "lugged", "lukewarm", "lullaby", "lumber", "luminance", "luminous", "lumpiness", "lumping", "lumpish", "lunacy", "lunar", "lunchbox", "luncheon", "lunchroom", "lunchtime", "lung", "lurch", "lure", "luridness", "lurk", "lushly", "lushness", "luster", "lustfully", "lustily", "lustiness", "lustrous", "lusty", "luxurious", "luxury", "lying", "lyrically", "lyricism", "lyricist", "lyrics", "macarena", "macaroni", "macaw", "mace", "machine", "machinist", "magazine", "magenta", "maggot", "magical", "magician", "magma", "magnesium", "magnetic", "magnetism", "magnetize", "magnifier", "magnify", "magnitude", "magnolia", "mahogany", "maimed", "majestic", "majesty", "majorette", "majority", "makeover", "maker", "makeshift", "making", "malformed", "malt", "mama", "mammal", "mammary", "mammogram", "manager", "managing", "manatee", "mandarin", "mandate", "mandatory", "mandolin", "manger", "mangle", "mango", "mangy", "manhandle", "manhole", "manhood", "manhunt", "manicotti", "manicure", "manifesto", "manila", "mankind", "manlike", "manliness", "manly", "manmade", "manned", "mannish", "manor", "manpower", "mantis", "mantra", "manual", "many", "map", "marathon", "marauding", "marbled", "marbles", "marbling", "march", "mardi", "margarine", "margarita", "margin", "marigold", "marina", "marine", "marital", "maritime", "marlin", "marmalade", "maroon", "married", "marrow", "marry", "marshland", "marshy", "marsupial", "marvelous", "marxism", "mascot", "masculine", "mashed", "mashing", "massager", "masses", "massive", "mastiff", "matador", "matchbook", "matchbox", "matcher", "matching", "matchless", "material", "maternal", "maternity", "math", "mating", "matriarch", "matrimony", "matrix", "matron", "matted", "matter", "maturely", "maturing", "maturity", "mauve", "maverick", "maximize", "maximum", "maybe", "mayday", "mayflower", "moaner", "moaning", "mobile", "mobility", "mobilize", "mobster", "mocha", "mocker", "mockup", "modified", "modify", "modular", "modulator", "module", "moisten", "moistness", "moisture", "molar", "molasses", "mold", "molecular", "molecule", "molehill", "mollusk", "mom", "monastery", "monday", "monetary", "monetize", "moneybags", "moneyless", "moneywise", "mongoose", "mongrel", "monitor", "monkhood", "monogamy", "monogram", "monologue", "monopoly", "monorail", "monotone", "monotype", "monoxide", "monsieur", "monsoon", "monstrous", "monthly", "monument", "moocher", "moodiness", "moody", "mooing", "moonbeam", "mooned", "moonlight", "moonlike", "moonlit", "moonrise", "moonscape", "moonshine", "moonstone", "moonwalk", "mop", "morale", "morality", "morally", "morbidity", "morbidly", "morphine", "morphing", "morse", "mortality", "mortally", "mortician", "mortified", "mortify", "mortuary", "mosaic", "mossy", "most", "mothball", "mothproof", "motion", "motivate", "motivator", "motive", "motocross", "motor", "motto", "mountable", "mountain", "mounted", "mounting", "mourner", "mournful", "mouse", "mousiness", "moustache", "mousy", "mouth", "movable", "move", "movie", "moving", "mower", "mowing", "much", "muck", "mud", "mug", "mulberry", "mulch", "mule", "mulled", "mullets", "multiple", "multiply", "multitask", "multitude", "mumble", "mumbling", "mumbo", "mummified", "mummify", "mummy", "mumps", "munchkin", "mundane", "municipal", "muppet", "mural", "murkiness", "murky", "murmuring", "muscular", "museum", "mushily", "mushiness", "mushroom", "mushy", "music", "musket", "muskiness", "musky", "mustang", "mustard", "muster", "mustiness", "musty", "mutable", "mutate", "mutation", "mute", "mutilated", "mutilator", "mutiny", "mutt", "mutual", "muzzle", "myself", "myspace", "mystified", "mystify", "myth", "nacho", "nag", "nail", "name", "naming", "nanny", "nanometer", "nape", "napkin", "napped", "napping", "nappy", "narrow", "nastily", "nastiness", "national", "native", "nativity", "natural", "nature", "naturist", "nautical", "navigate", "navigator", "navy", "nearby", "nearest", "nearly", "nearness", "neatly", "neatness", "nebula", "nebulizer", "nectar", "negate", "negation", "negative", "neglector", "negligee", "negligent", "negotiate", "nemeses", "nemesis", "neon", "nephew", "nerd", "nervous", "nervy", "nest", "net", "neurology", "neuron", "neurosis", "neurotic", "neuter", "neutron", "never", "next", "nibble", "nickname", "nicotine", "niece", "nifty", "nimble", "nimbly", "nineteen", "ninetieth", "ninja", "nintendo", "ninth", "nuclear", "nuclei", "nucleus", "nugget", "nullify", "number", "numbing", "numbly", "numbness", "numeral", "numerate", "numerator", "numeric", "numerous", "nuptials", "nursery", "nursing", "nurture", "nutcase", "nutlike", "nutmeg", "nutrient", "nutshell", "nuttiness", "nutty", "nuzzle", "nylon", "oaf", "oak", "oasis", "oat", "obedience", "obedient", "obituary", "object", "obligate", "obliged", "oblivion", "oblivious", "oblong", "obnoxious", "oboe", "obscure", "obscurity", "observant", "observer", "observing", "obsessed", "obsession", "obsessive", "obsolete", "obstacle", "obstinate", "obstruct", "obtain", "obtrusive", "obtuse", "obvious", "occultist", "occupancy", "occupant", "occupier", "occupy", "ocean", "ocelot", "octagon", "octane", "october", "octopus", "ogle", "oil", "oink", "ointment", "okay", "old", "olive", "olympics", "omega", "omen", "ominous", "omission", "omit", "omnivore", "onboard", "oncoming", "ongoing", "onion", "online", "onlooker", "only", "onscreen", "onset", "onshore", "onslaught", "onstage", "onto", "onward", "onyx", "oops", "ooze", "oozy", "opacity", "opal", "open", "operable", "operate", "operating", "operation", "operative", "operator", "opium", "opossum", "opponent", "oppose", "opposing", "opposite", "oppressed", "oppressor", "opt", "opulently", "osmosis", "other", "otter", "ouch", "ought", "ounce", "outage", "outback", "outbid", "outboard", "outbound", "outbreak", "outburst", "outcast", "outclass", "outcome", "outdated", "outdoors", "outer", "outfield", "outfit", "outflank", "outgoing", "outgrow", "outhouse", "outing", "outlast", "outlet", "outline", "outlook", "outlying", "outmatch", "outmost", "outnumber", "outplayed", "outpost", "outpour", "output", "outrage", "outrank", "outreach", "outright", "outscore", "outsell", "outshine", "outshoot", "outsider", "outskirts", "outsmart", "outsource", "outspoken", "outtakes", "outthink", "outward", "outweigh", "outwit", "oval", "ovary", "oven", "overact", "overall", "overarch", "overbid", "overbill", "overbite", "overblown", "overboard", "overbook", "overbuilt", "overcast", "overcoat", "overcome", "overcook", "overcrowd", "overdraft", "overdrawn", "overdress", "overdrive", "overdue", "overeager", "overeater", "overexert", "overfed", "overfeed", "overfill", "overflow", "overfull", "overgrown", "overhand", "overhang", "overhaul", "overhead", "overhear", "overheat", "overhung", "overjoyed", "overkill", "overlabor", "overlaid", "overlap", "overlay", "overload", "overlook", "overlord", "overlying", "overnight", "overpass", "overpay", "overplant", "overplay", "overpower", "overprice", "overrate", "overreach", "overreact", "override", "overripe", "overrule", "overrun", "overshoot", "overshot", "oversight", "oversized", "oversleep", "oversold", "overspend", "overstate", "overstay", "overstep", "overstock", "overstuff", "oversweet", "overtake", "overthrow", "overtime", "overtly", "overtone", "overture", "overturn", "overuse", "overvalue", "overview", "overwrite", "owl", "oxford", "oxidant", "oxidation", "oxidize", "oxidizing", "oxygen", "oxymoron", "oyster", "ozone", "paced", "pacemaker", "pacific", "pacifier", "pacifism", "pacifist", "pacify", "padded", "padding", "paddle", "paddling", "padlock", "pagan", "pager", "paging", "pajamas", "palace", "palatable", "palm", "palpable", "palpitate", "paltry", "pampered", "pamperer", "pampers", "pamphlet", "panama", "pancake", "pancreas", "panda", "pandemic", "pang", "panhandle", "panic", "panning", "panorama", "panoramic", "panther", "pantomime", "pantry", "pants", "pantyhose", "paparazzi", "papaya", "paper", "paprika", "papyrus", "parabola", "parachute", "parade", "paradox", "paragraph", "parakeet", "paralegal", "paralyses", "paralysis", "paralyze", "paramedic", "parameter", "paramount", "parasail", "parasite", "parasitic", "parcel", "parched", "parchment", "pardon", "parish", "parka", "parking", "parkway", "parlor", "parmesan", "parole", "parrot", "parsley", "parsnip", "partake", "parted", "parting", "partition", "partly", "partner", "partridge", "party", "passable", "passably", "passage", "passcode", "passenger", "passerby", "passing", "passion", "passive", "passivism", "passover", "passport", "password", "pasta", "pasted", "pastel", "pastime", "pastor", "pastrami", "pasture", "pasty", "patchwork", "patchy", "paternal", "paternity", "path", "patience", "patient", "patio", "patriarch", "patriot", "patrol", "patronage", "patronize", "pauper", "pavement", "paver", "pavestone", "pavilion", "paving", "pawing", "payable", "payback", "paycheck", "payday", "payee", "payer", "paying", "payment", "payphone", "payroll", "pebble", "pebbly", "pecan", "pectin", "peculiar", "peddling", "pediatric", "pedicure", "pedigree", "pedometer", "pegboard", "pelican", "pellet", "pelt", "pelvis", "penalize", "penalty", "pencil", "pendant", "pending", "penholder", "penknife", "pennant", "penniless", "penny", "penpal", "pension", "pentagon", "pentagram", "pep", "perceive", "percent", "perch", "percolate", "perennial", "perfected", "perfectly", "perfume", "periscope", "perish", "perjurer", "perjury", "perkiness", "perky", "perm", "peroxide", "perpetual", "perplexed", "persecute", "persevere", "persuaded", "persuader", "pesky", "peso", "pessimism", "pessimist", "pester", "pesticide", "petal", "petite", "petition", "petri", "petroleum", "petted", "petticoat", "pettiness", "petty", "petunia", "phantom", "phobia", "phoenix", "phonebook", "phoney", "phonics", "phoniness", "phony", "phosphate", "photo", "phrase", "phrasing", "placard", "placate", "placidly", "plank", "planner", "plant", "plasma", "plaster", "plastic", "plated", "platform", "plating", "platinum", "platonic", "platter", "platypus", "plausible", "plausibly", "playable", "playback", "player", "playful", "playgroup", "playhouse", "playing", "playlist", "playmaker", "playmate", "playoff", "playpen", "playroom", "playset", "plaything", "playtime", "plaza", "pleading", "pleat", "pledge", "plentiful", "plenty", "plethora", "plexiglas", "pliable", "plod", "plop", "plot", "plow", "ploy", "pluck", "plug", "plunder", "plunging", "plural", "plus", "plutonium", "plywood", "poach", "pod", "poem", "poet", "pogo", "pointed", "pointer", "pointing", "pointless", "pointy", "poise", "poison", "poker", "poking", "polar", "police", "policy", "polio", "polish", "politely", "polka", "polo", "polyester", "polygon", "polygraph", "polymer", "poncho", "pond", "pony", "popcorn", "pope", "poplar", "popper", "poppy", "popsicle", "populace", "popular", "populate", "porcupine", "pork", "porous", "porridge", "portable", "portal", "portfolio", "porthole", "portion", "portly", "portside", "poser", "posh", "posing", "possible", "possibly", "possum", "postage", "postal", "postbox", "postcard", "posted", "poster", "posting", "postnasal", "posture", "postwar", "pouch", "pounce", "pouncing", "pound", "pouring", "pout", "powdered", "powdering", "powdery", "power", "powwow", "pox", "praising", "prance", "prancing", "pranker", "prankish", "prankster", "prayer", "praying", "preacher", "preaching", "preachy", "preamble", "precinct", "precise", "precision", "precook", "precut", "predator", "predefine", "predict", "preface", "prefix", "preflight", "preformed", "pregame", "pregnancy", "pregnant", "preheated", "prelaunch", "prelaw", "prelude", "premiere", "premises", "premium", "prenatal", "preoccupy", "preorder", "prepaid", "prepay", "preplan", "preppy", "preschool", "prescribe", "preseason", "preset", "preshow", "president", "presoak", "press", "presume", "presuming", "preteen", "pretended", "pretender", "pretense", "pretext", "pretty", "pretzel", "prevail", "prevalent", "prevent", "preview", "previous", "prewar", "prewashed", "prideful", "pried", "primal", "primarily", "primary", "primate", "primer", "primp", "princess", "print", "prior", "prism", "prison", "prissy", "pristine", "privacy", "private", "privatize", "prize", "proactive", "probable", "probably", "probation", "probe", "probing", "probiotic", "problem", "procedure", "process", "proclaim", "procreate", "procurer", "prodigal", "prodigy", "produce", "product", "profane", "profanity", "professed", "professor", "profile", "profound", "profusely", "progeny", "prognosis", "program", "progress", "projector", "prologue", "prolonged", "promenade", "prominent", "promoter", "promotion", "prompter", "promptly", "prone", "prong", "pronounce", "pronto", "proofing", "proofread", "proofs", "propeller", "properly", "property", "proponent", "proposal", "propose", "props", "prorate", "protector", "protegee", "proton", "prototype", "protozoan", "protract", "protrude", "proud", "provable", "proved", "proven", "provided", "provider", "providing", "province", "proving", "provoke", "provoking", "provolone", "prowess", "prowler", "prowling", "proximity", "proxy", "prozac", "prude", "prudishly", "prune", "pruning", "pry", "psychic", "public", "publisher", "pucker", "pueblo", "pug", "pull", "pulmonary", "pulp", "pulsate", "pulse", "pulverize", "puma", "pumice", "pummel", "punch", "punctual", "punctuate", "punctured", "pungent", "punisher", "punk", "pupil", "puppet", "puppy", "purchase", "pureblood", "purebred", "purely", "pureness", "purgatory", "purge", "purging", "purifier", "purify", "purist", "puritan", "purity", "purple", "purplish", "purposely", "purr", "purse", "pursuable", "pursuant", "pursuit", "purveyor", "pushcart", "pushchair", "pusher", "pushiness", "pushing", "pushover", "pushpin", "pushup", "pushy", "putdown", "putt", "puzzle", "puzzling", "pyramid", "pyromania", "python", "quack", "quadrant", "quail", "quaintly", "quake", "quaking", "qualified", "qualifier", "qualify", "quality", "qualm", "quantum", "quarrel", "quarry", "quartered", "quarterly", "quarters", "quartet", "quench", "query", "quicken", "quickly", "quickness", "quicksand", "quickstep", "quiet", "quill", "quilt", "quintet", "quintuple", "quirk", "quit", "quiver", "quizzical", "quotable", "quotation", "quote", "rabid", "race", "racing", "racism", "rack", "racoon", "radar", "radial", "radiance", "radiantly", "radiated", "radiation", "radiator", "radio", "radish", "raffle", "raft", "rage", "ragged", "raging", "ragweed", "raider", "railcar", "railing", "railroad", "railway", "raisin", "rake", "raking", "rally", "ramble", "rambling", "ramp", "ramrod", "ranch", "rancidity", "random", "ranged", "ranger", "ranging", "ranked", "ranking", "ransack", "ranting", "rants", "rare", "rarity", "rascal", "rash", "rasping", "ravage", "raven", "ravine", "raving", "ravioli", "ravishing", "reabsorb", "reach", "reacquire", "reaction", "reactive", "reactor", "reaffirm", "ream", "reanalyze", "reappear", "reapply", "reappoint", "reapprove", "rearrange", "rearview", "reason", "reassign", "reassure", "reattach", "reawake", "rebalance", "rebate", "rebel", "rebirth", "reboot", "reborn", "rebound", "rebuff", "rebuild", "rebuilt", "reburial", "rebuttal", "recall", "recant", "recapture", "recast", "recede", "recent", "recess", "recharger", "recipient", "recital", "recite", "reckless", "reclaim", "recliner", "reclining", "recluse", "reclusive", "recognize", "recoil", "recollect", "recolor", "reconcile", "reconfirm", "reconvene", "recopy", "record", "recount", "recoup", "recovery", "recreate", "rectal", "rectangle", "rectified", "rectify", "recycled", "recycler", "recycling", "reemerge", "reenact", "reenter", "reentry", "reexamine", "referable", "referee", "reference", "refill", "refinance", "refined", "refinery", "refining", "refinish", "reflected", "reflector", "reflex", "reflux", "refocus", "refold", "reforest", "reformat", "reformed", "reformer", "reformist", "refract", "refrain", "refreeze", "refresh", "refried", "refueling", "refund", "refurbish", "refurnish", "refusal", "refuse", "refusing", "refutable", "refute", "regain", "regalia", "regally", "reggae", "regime", "region", "register", "registrar", "registry", "regress", "regretful", "regroup", "regular", "regulate", "regulator", "rehab", "reheat", "rehire", "rehydrate", "reimburse", "reissue", "reiterate", "rejoice", "rejoicing", "rejoin", "rekindle", "relapse", "relapsing", "relatable", "related", "relation", "relative", "relax", "relay", "relearn", "release", "relenting", "reliable", "reliably", "reliance", "reliant", "relic", "relieve", "relieving", "relight", "relish", "relive", "reload", "relocate", "relock", "reluctant", "rely", "remake", "remark", "remarry", "rematch", "remedial", "remedy", "remember", "reminder", "remindful", "remission", "remix", "remnant", "remodeler", "remold", "remorse", "remote", "removable", "removal", "removed", "remover", "removing", "rename", "renderer", "rendering", "rendition", "renegade", "renewable", "renewably", "renewal", "renewed", "renounce", "renovate", "renovator", "rentable", "rental", "rented", "renter", "reoccupy", "reoccur", "reopen", "reorder", "repackage", "repacking", "repaint", "repair", "repave", "repaying", "repayment", "repeal", "repeated", "repeater", "repent", "rephrase", "replace", "replay", "replica", "reply", "reporter", "repose", "repossess", "repost", "repressed", "reprimand", "reprint", "reprise", "reproach", "reprocess", "reproduce", "reprogram", "reps", "reptile", "reptilian", "repugnant", "repulsion", "repulsive", "repurpose", "reputable", "reputably", "request", "require", "requisite", "reroute", "rerun", "resale", "resample", "rescuer", "reseal", "research", "reselect", "reseller", "resemble", "resend", "resent", "reset", "reshape", "reshoot", "reshuffle", "residence", "residency", "resident", "residual", "residue", "resigned", "resilient", "resistant", "resisting", "resize", "resolute", "resolved", "resonant", "resonate", "resort", "resource", "respect", "resubmit", "result", "resume", "resupply", "resurface", "resurrect", "retail", "retainer", "retaining", "retake", "retaliate", "retention", "rethink", "retinal", "retired", "retiree", "retiring", "retold", "retool", "retorted", "retouch", "retrace", "retract", "retrain", "retread", "retreat", "retrial", "retrieval", "retriever", "retry", "return", "retying", "retype", "reunion", "reunite", "reusable", "reuse", "reveal", "reveler", "revenge", "revenue", "reverb", "revered", "reverence", "reverend", "reversal", "reverse", "reversing", "reversion", "revert", "revisable", "revise", "revision", "revisit", "revivable", "revival", "reviver", "reviving", "revocable", "revoke", "revolt", "revolver", "revolving", "reward", "rewash", "rewind", "rewire", "reword", "rework", "rewrap", "rewrite", "rhyme", "ribbon", "ribcage", "rice", "riches", "richly", "richness", "rickety", "ricotta", "riddance", "ridden", "ride", "riding", "rifling", "rift", "rigging", "rigid", "rigor", "rimless", "rimmed", "rind", "rink", "rinse", "rinsing", "riot", "ripcord", "ripeness", "ripening", "ripping", "ripple", "rippling", "riptide", "rise", "rising", "risk", "risotto", "ritalin", "ritzy", "rival", "riverbank", "riverbed", "riverboat", "riverside", "riveter", "riveting", "roamer", "roaming", "roast", "robbing", "robe", "robin", "robotics", "robust", "rockband", "rocker", "rocket", "rockfish", "rockiness", "rocking", "rocklike", "rockslide", "rockstar", "rocky", "rogue", "roman", "romp", "rope", "roping", "roster", "rosy", "rotten", "rotting", "rotunda", "roulette", "rounding", "roundish", "roundness", "roundup", "roundworm", "routine", "routing", "rover", "roving", "royal", "rubbed", "rubber", "rubbing", "rubble", "rubdown", "ruby", "ruckus", "rudder", "rug", "ruined", "rule", "rumble", "rumbling", "rummage", "rumor", "runaround", "rundown", "runner", "running", "runny", "runt", "runway", "rupture", "rural", "ruse", "rush", "rust", "rut", "sabbath", "sabotage", "sacrament", "sacred", "sacrifice", "sadden", "saddlebag", "saddled", "saddling", "sadly", "sadness", "safari", "safeguard", "safehouse", "safely", "safeness", "saffron", "saga", "sage", "sagging", "saggy", "said", "saint", "sake", "salad", "salami", "salaried", "salary", "saline", "salon", "saloon", "salsa", "salt", "salutary", "salute", "salvage", "salvaging", "salvation", "same", "sample", "sampling", "sanction", "sanctity", "sanctuary", "sandal", "sandbag", "sandbank", "sandbar", "sandblast", "sandbox", "sanded", "sandfish", "sanding", "sandlot", "sandpaper", "sandpit", "sandstone", "sandstorm", "sandworm", "sandy", "sanitary", "sanitizer", "sank", "santa", "sapling", "sappiness", "sappy", "sarcasm", "sarcastic", "sardine", "sash", "sasquatch", "sassy", "satchel", "satiable", "satin", "satirical", "satisfied", "satisfy", "saturate", "saturday", "sauciness", "saucy", "sauna", "savage", "savanna", "saved", "savings", "savior", "savor", "saxophone", "say", "scabbed", "scabby", "scalded", "scalding", "scale", "scaling", "scallion", "scallop", "scalping", "scam", "scandal", "scanner", "scanning", "scant", "scapegoat", "scarce", "scarcity", "scarecrow", "scared", "scarf", "scarily", "scariness", "scarring", "scary", "scavenger", "scenic", "schedule", "schematic", "scheme", "scheming", "schilling", "schnapps", "scholar", "science", "scientist", "scion", "scoff", "scolding", "scone", "scoop", "scooter", "scope", "scorch", "scorebook", "scorecard", "scored", "scoreless", "scorer", "scoring", "scorn", "scorpion", "scotch", "scoundrel", "scoured", "scouring", "scouting", "scouts", "scowling", "scrabble", "scraggly", "scrambled", "scrambler", "scrap", "scratch", "scrawny", "screen", "scribble", "scribe", "scribing", "scrimmage", "script", "scroll", "scrooge", "scrounger", "scrubbed", "scrubber", "scruffy", "scrunch", "scrutiny", "scuba", "scuff", "sculptor", "sculpture", "scurvy", "scuttle", "secluded", "secluding", "seclusion", "second", "secrecy", "secret", "sectional", "sector", "secular", "securely", "security", "sedan", "sedate", "sedation", "sedative", "sediment", "seduce", "seducing", "segment", "seismic", "seizing", "seldom", "selected", "selection", "selective", "selector", "self", "seltzer", "semantic", "semester", "semicolon", "semifinal", "seminar", "semisoft", "semisweet", "senate", "senator", "send", "senior", "senorita", "sensation", "sensitive", "sensitize", "sensually", "sensuous", "sepia", "september", "septic", "septum", "sequel", "sequence", "sequester", "series", "sermon", "serotonin", "serpent", "serrated", "serve", "service", "serving", "sesame", "sessions", "setback", "setting", "settle", "settling", "setup", "sevenfold", "seventeen", "seventh", "seventy", "severity", "shabby", "shack", "shaded", "shadily", "shadiness", "shading", "shadow", "shady", "shaft", "shakable", "shakily", "shakiness", "shaking", "shaky", "shale", "shallot", "shallow", "shame", "shampoo", "shamrock", "shank", "shanty", "shape", "shaping", "share", "sharpener", "sharper", "sharpie", "sharply", "sharpness", "shawl", "sheath", "shed", "sheep", "sheet", "shelf", "shell", "shelter", "shelve", "shelving", "sherry", "shield", "shifter", "shifting", "shiftless", "shifty", "shimmer", "shimmy", "shindig", "shine", "shingle", "shininess", "shining", "shiny", "ship", "shirt", "shivering", "shock", "shone", "shoplift", "shopper", "shopping", "shoptalk", "shore", "shortage", "shortcake", "shortcut", "shorten", "shorter", "shorthand", "shortlist", "shortly", "shortness", "shorts", "shortwave", "shorty", "shout", "shove", "showbiz", "showcase", "showdown", "shower", "showgirl", "showing", "showman", "shown", "showoff", "showpiece", "showplace", "showroom", "showy", "shrank", "shrapnel", "shredder", "shredding", "shrewdly", "shriek", "shrill", "shrimp", "shrine", "shrink", "shrivel", "shrouded", "shrubbery", "shrubs", "shrug", "shrunk", "shucking", "shudder", "shuffle", "shuffling", "shun", "shush", "shut", "shy", "siamese", "siberian", "sibling", "siding", "sierra", "siesta", "sift", "sighing", "silenced", "silencer", "silent", "silica", "silicon", "silk", "silliness", "silly", "silo", "silt", "silver", "similarly", "simile", "simmering", "simple", "simplify", "simply", "sincere", "sincerity", "singer", "singing", "single", "singular", "sinister", "sinless", "sinner", "sinuous", "sip", "siren", "sister", "sitcom", "sitter", "sitting", "situated", "situation", "sixfold", "sixteen", "sixth", "sixties", "sixtieth", "sixtyfold", "sizable", "sizably", "size", "sizing", "sizzle", "sizzling", "skater", "skating", "skedaddle", "skeletal", "skeleton", "skeptic", "sketch", "skewed", "skewer", "skid", "skied", "skier", "skies", "skiing", "skilled", "skillet", "skillful", "skimmed", "skimmer", "skimming", "skimpily", "skincare", "skinhead", "skinless", "skinning", "skinny", "skintight", "skipper", "skipping", "skirmish", "skirt", "skittle", "skydiver", "skylight", "skyline", "skype", "skyrocket", "skyward", "slab", "slacked", "slacker", "slacking", "slackness", "slacks", "slain", "slam", "slander", "slang", "slapping", "slapstick", "slashed", "slashing", "slate", "slather", "slaw", "sled", "sleek", "sleep", "sleet", "sleeve", "slept", "sliceable", "sliced", "slicer", "slicing", "slick", "slider", "slideshow", "sliding", "slighted", "slighting", "slightly", "slimness", "slimy", "slinging", "slingshot", "slinky", "slip", "slit", "sliver", "slobbery", "slogan", "sloped", "sloping", "sloppily", "sloppy", "slot", "slouching", "slouchy", "sludge", "slug", "slum", "slurp", "slush", "sly", "small", "smartly", "smartness", "smasher", "smashing", "smashup", "smell", "smelting", "smile", "smilingly", "smirk", "smite", "smith", "smitten", "smock", "smog", "smoked", "smokeless", "smokiness", "smoking", "smoky", "smolder", "smooth", "smother", "smudge", "smudgy", "smuggler", "smuggling", "smugly", "smugness", "snack", "snagged", "snaking", "snap", "snare", "snarl", "snazzy", "sneak", "sneer", "sneeze", "sneezing", "snide", "sniff", "snippet", "snipping", "snitch", "snooper", "snooze", "snore", "snoring", "snorkel", "snort", "snout", "snowbird", "snowboard", "snowbound", "snowcap", "snowdrift", "snowdrop", "snowfall", "snowfield", "snowflake", "snowiness", "snowless", "snowman", "snowplow", "snowshoe", "snowstorm", "snowsuit", "snowy", "snub", "snuff", "snuggle", "snugly", "snugness", "speak", "spearfish", "spearhead", "spearman", "spearmint", "species", "specimen", "specked", "speckled", "specks", "spectacle", "spectator", "spectrum", "speculate", "speech", "speed", "spellbind", "speller", "spelling", "spendable", "spender", "spending", "spent", "spew", "sphere", "spherical", "sphinx", "spider", "spied", "spiffy", "spill", "spilt", "spinach", "spinal", "spindle", "spinner", "spinning", "spinout", "spinster", "spiny", "spiral", "spirited", "spiritism", "spirits", "spiritual", "splashed", "splashing", "splashy", "splatter", "spleen", "splendid", "splendor", "splice", "splicing", "splinter", "splotchy", "splurge", "spoilage", "spoiled", "spoiler", "spoiling", "spoils", "spoken", "spokesman", "sponge", "spongy", "sponsor", "spoof", "spookily", "spooky", "spool", "spoon", "spore", "sporting", "sports", "sporty", "spotless", "spotlight", "spotted", "spotter", "spotting", "spotty", "spousal", "spouse", "spout", "sprain", "sprang", "sprawl", "spray", "spree", "sprig", "spring", "sprinkled", "sprinkler", "sprint", "sprite", "sprout", "spruce", "sprung", "spry", "spud", "spur", "sputter", "spyglass", "squabble", "squad", "squall", "squander", "squash", "squatted", "squatter", "squatting", "squeak", "squealer", "squealing", "squeamish", "squeegee", "squeeze", "squeezing", "squid", "squiggle", "squiggly", "squint", "squire", "squirt", "squishier", "squishy", "stability", "stabilize", "stable", "stack", "stadium", "staff", "stage", "staging", "stagnant", "stagnate", "stainable", "stained", "staining", "stainless", "stalemate", "staleness", "stalling", "stallion", "stamina", "stammer", "stamp", "stand", "stank", "staple", "stapling", "starboard", "starch", "stardom", "stardust", "starfish", "stargazer", "staring", "stark", "starless", "starlet", "starlight", "starlit", "starring", "starry", "starship", "starter", "starting", "startle", "startling", "startup", "starved", "starving", "stash", "state", "static", "statistic", "statue", "stature", "status", "statute", "statutory", "staunch", "stays", "steadfast", "steadier", "steadily", "steadying", "steam", "steed", "steep", "steerable", "steering", "steersman", "stegosaur", "stellar", "stem", "stench", "stencil", "step", "stereo", "sterile", "sterility", "sterilize", "sterling", "sternness", "sternum", "stew", "stick", "stiffen", "stiffly", "stiffness", "stifle", "stifling", "stillness", "stilt", "stimulant", "stimulate", "stimuli", "stimulus", "stinger", "stingily", "stinging", "stingray", "stingy", "stinking", "stinky", "stipend", "stipulate", "stir", "stitch", "stock", "stoic", "stoke", "stole", "stomp", "stonewall", "stoneware", "stonework", "stoning", "stony", "stood", "stooge", "stool", "stoop", "stoplight", "stoppable", "stoppage", "stopped", "stopper", "stopping", "stopwatch", "storable", "storage", "storeroom", "storewide", "storm", "stout", "stove", "stowaway", "stowing", "straddle", "straggler", "strained", "strainer", "straining", "strangely", "stranger", "strangle", "strategic", "strategy", "stratus", "straw", "stray", "streak", "stream", "street", "strength", "strenuous", "strep", "stress", "stretch", "strewn", "stricken", "strict", "stride", "strife", "strike", "striking", "strive", "striving", "strobe", "strode", "stroller", "strongbox", "strongly", "strongman", "struck", "structure", "strudel", "struggle", "strum", "strung", "strut", "stubbed", "stubble", "stubbly", "stubborn", "stucco", "stuck", "student", "studied", "studio", "study", "stuffed", "stuffing", "stuffy", "stumble", "stumbling", "stump", "stung", "stunned", "stunner", "stunning", "stunt", "stupor", "sturdily", "sturdy", "styling", "stylishly", "stylist", "stylized", "stylus", "suave", "subarctic", "subatomic", "subdivide", "subdued", "subduing", "subfloor", "subgroup", "subheader", "subject", "sublease", "sublet", "sublevel", "sublime", "submarine", "submerge", "submersed", "submitter", "subpanel", "subpar", "subplot", "subprime", "subscribe", "subscript", "subsector", "subside", "subsiding", "subsidize", "subsidy", "subsoil", "subsonic", "substance", "subsystem", "subtext", "subtitle", "subtly", "subtotal", "subtract", "subtype", "suburb", "subway", "subwoofer", "subzero", "succulent", "such", "suction", "sudden", "sudoku", "suds", "sufferer", "suffering", "suffice", "suffix", "suffocate", "suffrage", "sugar", "suggest", "suing", "suitable", "suitably", "suitcase", "suitor", "sulfate", "sulfide", "sulfite", "sulfur", "sulk", "sullen", "sulphate", "sulphuric", "sultry", "superbowl", "superglue", "superhero", "superior", "superjet", "superman", "supermom", "supernova", "supervise", "supper", "supplier", "supply", "support", "supremacy", "supreme", "surcharge", "surely", "sureness", "surface", "surfacing", "surfboard", "surfer", "surgery", "surgical", "surging", "surname", "surpass", "surplus", "surprise", "surreal", "surrender", "surrogate", "surround", "survey", "survival", "survive", "surviving", "survivor", "sushi", "suspect", "suspend", "suspense", "sustained", "sustainer", "swab", "swaddling", "swagger", "swampland", "swan", "swapping", "swarm", "sway", "swear", "sweat", "sweep", "swell", "swept", "swerve", "swifter", "swiftly", "swiftness", "swimmable", "swimmer", "swimming", "swimsuit", "swimwear", "swinger", "swinging", "swipe", "swirl", "switch", "swivel", "swizzle", "swooned", "swoop", "swoosh", "swore", "sworn", "swung", "sycamore", "sympathy", "symphonic", "symphony", "symptom", "synapse", "syndrome", "synergy", "synopses", "synopsis", "synthesis", "synthetic", "syrup", "system", "t-shirt", "tabasco", "tabby", "tableful", "tables", "tablet", "tableware", "tabloid", "tackiness", "tacking", "tackle", "tackling", "tacky", "taco", "tactful", "tactical", "tactics", "tactile", "tactless", "tadpole", "taekwondo", "tag", "tainted", "take", "taking", "talcum", "talisman", "tall", "talon", "tamale", "tameness", "tamer", "tamper", "tank", "tanned", "tannery", "tanning", "tantrum", "tapeless", "tapered", "tapering", "tapestry", "tapioca", "tapping", "taps", "tarantula", "target", "tarmac", "tarnish", "tarot", "tartar", "tartly", "tartness", "task", "tassel", "taste", "tastiness", "tasting", "tasty", "tattered", "tattle", "tattling", "tattoo", "taunt", "tavern", "thank", "that", "thaw", "theater", "theatrics", "thee", "theft", "theme", "theology", "theorize", "thermal", "thermos", "thesaurus", "these", "thesis", "thespian", "thicken", "thicket", "thickness", "thieving", "thievish", "thigh", "thimble", "thing", "think", "thinly", "thinner", "thinness", "thinning", "thirstily", "thirsting", "thirsty", "thirteen", "thirty", "thong", "thorn", "those", "thousand", "thrash", "thread", "threaten", "threefold", "thrift", "thrill", "thrive", "thriving", "throat", "throbbing", "throng", "throttle", "throwaway", "throwback", "thrower", "throwing", "thud", "thumb", "thumping", "thursday", "thus", "thwarting", "thyself", "tiara", "tibia", "tidal", "tidbit", "tidiness", "tidings", "tidy", "tiger", "tighten", "tightly", "tightness", "tightrope", "tightwad", "tigress", "tile", "tiling", "till", "tilt", "timid", "timing", "timothy", "tinderbox", "tinfoil", "tingle", "tingling", "tingly", "tinker", "tinkling", "tinsel", "tinsmith", "tint", "tinwork", "tiny", "tipoff", "tipped", "tipper", "tipping", "tiptoeing", "tiptop", "tiring", "tissue", "trace", "tracing", "track", "traction", "tractor", "trade", "trading", "tradition", "traffic", "tragedy", "trailing", "trailside", "train", "traitor", "trance", "tranquil", "transfer", "transform", "translate", "transpire", "transport", "transpose", "trapdoor", "trapeze", "trapezoid", "trapped", "trapper", "trapping", "traps", "trash", "travel", "traverse", "travesty", "tray", "treachery", "treading", "treadmill", "treason", "treat", "treble", "tree", "trekker", "tremble", "trembling", "tremor", "trench", "trend", "trespass", "triage", "trial", "triangle", "tribesman", "tribunal", "tribune", "tributary", "tribute", "triceps", "trickery", "trickily", "tricking", "trickle", "trickster", "tricky", "tricolor", "tricycle", "trident", "tried", "trifle", "trifocals", "trillion", "trilogy", "trimester", "trimmer", "trimming", "trimness", "trinity", "trio", "tripod", "tripping", "triumph", "trivial", "trodden", "trolling", "trombone", "trophy", "tropical", "tropics", "trouble", "troubling", "trough", "trousers", "trout", "trowel", "truce", "truck", "truffle", "trump", "trunks", "trustable", "trustee", "trustful", "trusting", "trustless", "truth", "try", "tubby", "tubeless", "tubular", "tucking", "tuesday", "tug", "tuition", "tulip", "tumble", "tumbling", "tummy", "turban", "turbine", "turbofan", "turbojet", "turbulent", "turf", "turkey", "turmoil", "turret", "turtle", "tusk", "tutor", "tutu", "tux", "tweak", "tweed", "tweet", "tweezers", "twelve", "twentieth", "twenty", "twerp", "twice", "twiddle", "twiddling", "twig", "twilight", "twine", "twins", "twirl", "twistable", "twisted", "twister", "twisting", "twisty", "twitch", "twitter", "tycoon", "tying", "tyke", "udder", "ultimate", "ultimatum", "ultra", "umbilical", "umbrella", "umpire", "unabashed", "unable", "unadorned", "unadvised", "unafraid", "unaired", "unaligned", "unaltered", "unarmored", "unashamed", "unaudited", "unawake", "unaware", "unbaked", "unbalance", "unbeaten", "unbend", "unbent", "unbiased", "unbitten", "unblended", "unblessed", "unblock", "unbolted", "unbounded", "unboxed", "unbraided", "unbridle", "unbroken", "unbuckled", "unbundle", "unburned", "unbutton", "uncanny", "uncapped", "uncaring", "uncertain", "unchain", "unchanged", "uncharted", "uncheck", "uncivil", "unclad", "unclaimed", "unclamped", "unclasp", "uncle", "unclip", "uncloak", "unclog", "unclothed", "uncoated", "uncoiled", "uncolored", "uncombed", "uncommon", "uncooked", "uncork", "uncorrupt", "uncounted", "uncouple", "uncouth", "uncover", "uncross", "uncrown", "uncrushed", "uncured", "uncurious", "uncurled", "uncut", "undamaged", "undated", "undaunted", "undead", "undecided", "undefined", "underage", "underarm", "undercoat", "undercook", "undercut", "underdog", "underdone", "underfed", "underfeed", "underfoot", "undergo", "undergrad", "underhand", "underline", "underling", "undermine", "undermost", "underpaid", "underpass", "underpay", "underrate", "undertake", "undertone", "undertook", "undertow", "underuse", "underwear", "underwent", "underwire", "undesired", "undiluted", "undivided", "undocked", "undoing", "undone", "undrafted", "undress", "undrilled", "undusted", "undying", "unearned", "unearth", "unease", "uneasily", "uneasy", "uneatable", "uneaten", "unedited", "unelected", "unending", "unengaged", "unenvied", "unequal", "unethical", "uneven", "unexpired", "unexposed", "unfailing", "unfair", "unfasten", "unfazed", "unfeeling", "unfiled", "unfilled", "unfitted", "unfitting", "unfixable", "unfixed", "unflawed", "unfocused", "unfold", "unfounded", "unframed", "unfreeze", "unfrosted", "unfrozen", "unfunded", "unglazed", "ungloved", "unglue", "ungodly", "ungraded", "ungreased", "unguarded", "unguided", "unhappily", "unhappy", "unharmed", "unhealthy", "unheard", "unhearing", "unheated", "unhelpful", "unhidden", "unhinge", "unhitched", "unholy", "unhook", "unicorn", "unicycle", "unified", "unifier", "uniformed", "uniformly", "unify", "unimpeded", "uninjured", "uninstall", "uninsured", "uninvited", "union", "uniquely", "unisexual", "unison", "unissued", "unit", "universal", "universe", "unjustly", "unkempt", "unkind", "unknotted", "unknowing", "unknown", "unlaced", "unlatch", "unlawful", "unleaded", "unlearned", "unleash", "unless", "unleveled", "unlighted", "unlikable", "unlimited", "unlined", "unlinked", "unlisted", "unlit", "unlivable", "unloaded", "unloader", "unlocked", "unlocking", "unlovable", "unloved", "unlovely", "unloving", "unluckily", "unlucky", "unmade", "unmanaged", "unmanned", "unmapped", "unmarked", "unmasked", "unmasking", "unmatched", "unmindful", "unmixable", "unmixed", "unmolded", "unmoral", "unmovable", "unmoved", "unmoving", "unnamable", "unnamed", "unnatural", "unneeded", "unnerve", "unnerving", "unnoticed", "unopened", "unopposed", "unpack", "unpadded", "unpaid", "unpainted", "unpaired", "unpaved", "unpeeled", "unpicked", "unpiloted", "unpinned", "unplanned", "unplanted", "unpleased", "unpledged", "unplowed", "unplug", "unpopular", "unproven", "unquote", "unranked", "unrated", "unraveled", "unreached", "unread", "unreal", "unreeling", "unrefined", "unrelated", "unrented", "unrest", "unretired", "unrevised", "unrigged", "unripe", "unrivaled", "unroasted", "unrobed", "unroll", "unruffled", "unruly", "unrushed", "unsaddle", "unsafe", "unsaid", "unsalted", "unsaved", "unsavory", "unscathed", "unscented", "unscrew", "unsealed", "unseated", "unsecured", "unseeing", "unseemly", "unseen", "unselect", "unselfish", "unsent", "unsettled", "unshackle", "unshaken", "unshaved", "unshaven", "unsheathe", "unshipped", "unsightly", "unsigned", "unskilled", "unsliced", "unsmooth", "unsnap", "unsocial", "unsoiled", "unsold", "unsolved", "unsorted", "unspoiled", "unspoken", "unstable", "unstaffed", "unstamped", "unsteady", "unsterile", "unstirred", "unstitch", "unstopped", "unstuck", "unstuffed", "unstylish", "unsubtle", "unsubtly", "unsuited", "unsure", "unsworn", "untagged", "untainted", "untaken", "untamed", "untangled", "untapped", "untaxed", "unthawed", "unthread", "untidy", "untie", "until", "untimed", "untimely", "untitled", "untoasted", "untold", "untouched", "untracked", "untrained", "untreated", "untried", "untrimmed", "untrue", "untruth", "unturned", "untwist", "untying", "unusable", "unused", "unusual", "unvalued", "unvaried", "unvarying", "unveiled", "unveiling", "unvented", "unviable", "unvisited", "unvocal", "unwanted", "unwarlike", "unwary", "unwashed", "unwatched", "unweave", "unwed", "unwelcome", "unwell", "unwieldy", "unwilling", "unwind", "unwired", "unwitting", "unwomanly", "unworldly", "unworn", "unworried", "unworthy", "unwound", "unwoven", "unwrapped", "unwritten", "unzip", "upbeat", "upchuck", "upcoming", "upcountry", "update", "upfront", "upgrade", "upheaval", "upheld", "uphill", "uphold", "uplifted", "uplifting", "upload", "upon", "upper", "upright", "uprising", "upriver", "uproar", "uproot", "upscale", "upside", "upstage", "upstairs", "upstart", "upstate", "upstream", "upstroke", "upswing", "uptake", "uptight", "uptown", "upturned", "upward", "upwind", "uranium", "urban", "urchin", "urethane", "urgency", "urgent", "urging", "urologist", "urology", "usable", "usage", "useable", "used", "uselessly", "user", "usher", "usual", "utensil", "utility", "utilize", "utmost", "utopia", "utter", "vacancy", "vacant", "vacate", "vacation", "vagabond", "vagrancy", "vagrantly", "vaguely", "vagueness", "valiant", "valid", "valium", "valley", "valuables", "value", "vanilla", "vanish", "vanity", "vanquish", "vantage", "vaporizer", "variable", "variably", "varied", "variety", "various", "varmint", "varnish", "varsity", "varying", "vascular", "vaseline", "vastly", "vastness", "veal", "vegan", "veggie", "vehicular", "velcro", "velocity", "velvet", "vendetta", "vending", "vendor", "veneering", "vengeful", "venomous", "ventricle", "venture", "venue", "venus", "verbalize", "verbally", "verbose", "verdict", "verify", "verse", "version", "versus", "vertebrae", "vertical", "vertigo", "very", "vessel", "vest", "veteran", "veto", "vexingly", "viability", "viable", "vibes", "vice", "vicinity", "victory", "video", "viewable", "viewer", "viewing", "viewless", "viewpoint", "vigorous", "village", "villain", "vindicate", "vineyard", "vintage", "violate", "violation", "violator", "violet", "violin", "viper", "viral", "virtual", "virtuous", "virus", "visa", "viscosity", "viscous", "viselike", "visible", "visibly", "vision", "visiting", "visitor", "visor", "vista", "vitality", "vitalize", "vitally", "vitamins", "vivacious", "vividly", "vividness", "vixen", "vocalist", "vocalize", "vocally", "vocation", "voice", "voicing", "void", "volatile", "volley", "voltage", "volumes", "voter", "voting", "voucher", "vowed", "vowel", "voyage", "wackiness", "wad", "wafer", "waffle", "waged", "wager", "wages", "waggle", "wagon", "wake", "waking", "walk", "walmart", "walnut", "walrus", "waltz", "wand", "wannabe", "wanted", "wanting", "wasabi", "washable", "washbasin", "washboard", "washbowl", "washcloth", "washday", "washed", "washer", "washhouse", "washing", "washout", "washroom", "washstand", "washtub", "wasp", "wasting", "watch", "water", "waviness", "waving", "wavy", "whacking", "whacky", "wham", "wharf", "wheat", "whenever", "whiff", "whimsical", "whinny", "whiny", "whisking", "whoever", "whole", "whomever", "whoopee", "whooping", "whoops", "why", "wick", "widely", "widen", "widget", "widow", "width", "wieldable", "wielder", "wife", "wifi", "wikipedia", "wildcard", "wildcat", "wilder", "wildfire", "wildfowl", "wildland", "wildlife", "wildly", "wildness", "willed", "willfully", "willing", "willow", "willpower", "wilt", "wimp", "wince", "wincing", "wind", "wing", "winking", "winner", "winnings", "winter", "wipe", "wired", "wireless", "wiring", "wiry", "wisdom", "wise", "wish", "wisplike", "wispy", "wistful", "wizard", "wobble", "wobbling", "wobbly", "wok", "wolf", "wolverine", "womanhood", "womankind", "womanless", "womanlike", "womanly", "womb", "woof", "wooing", "wool", "woozy", "word", "work", "worried", "worrier", "worrisome", "worry", "worsening", "worshiper", "worst", "wound", "woven", "wow", "wrangle", "wrath", "wreath", "wreckage", "wrecker", "wrecking", "wrench", "wriggle", "wriggly", "wrinkle", "wrinkly", "wrist", "writing", "written", "wrongdoer", "wronged", "wrongful", "wrongly", "wrongness", "wrought", "xbox", "xerox", "yahoo", "yam", "yanking", "yapping", "yard", "yarn", "yeah", "yearbook", "yearling", "yearly", "yearning", "yeast", "yelling", "yelp", "yen", "yesterday", "yiddish", "yield", "yin", "yippee", "yo-yo", "yodel", "yoga", "yogurt", "yonder", "yoyo", "yummy", "zap", "zealous", "zebra", "zen", "zeppelin", "zero", "zestfully", "zesty", "zigzagged", "zipfile", "zipping", "zippy", "zips", "zit", "zodiac", "zombie", "zone", "zoning", "zookeeper", "zoologist", "zoology", "zoom"]
      },
      21155: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.TupleReader = void 0;
        class r {
          constructor(t) {
            this.items = [...t]
          }
          get remaining() {
            return this.items.length
          }
          peek() {
            if (0 === this.items.length) throw Error("EOF");
            return this.items[0]
          }
          pop() {
            if (0 === this.items.length) throw Error("EOF");
            let t = this.items[0];
            return this.items.splice(0, 1), t
          }
          skip(t = 1) {
            for (let e = 0; t > e; e++) this.pop();
            return this
          }
          readBigNumber() {
            let t = this.pop();
            if ("int" !== t.type) throw Error("Not a number");
            return t.value
          }
          readBigNumberOpt() {
            let t = this.pop();
            if ("null" === t.type) return null;
            if ("int" !== t.type) throw Error("Not a number");
            return t.value
          }
          readNumber() {
            return +this.readBigNumber()
          }
          readNumberOpt() {
            let t = this.readBigNumberOpt();
            return null !== t ? +t : null
          }
          readBoolean() {
            return 0 !== this.readNumber()
          }
          readBooleanOpt() {
            let t = this.readNumberOpt();
            return null !== t ? 0 !== t : null
          }
          readAddress() {
            let t = this.readCell().beginParse().loadAddress();
            if (null !== t) return t;
            throw Error("Not an address")
          }
          readAddressOpt() {
            let t = this.readCellOpt();
            return null !== t ? t.beginParse().loadMaybeAddress() : null
          }
          readCell() {
            let t = this.pop();
            if ("cell" !== t.type && "slice" !== t.type && "builder" !== t.type) throw Error("Not a cell: " + t.type);
            return t.cell
          }
          readCellOpt() {
            let t = this.pop();
            if ("null" === t.type) return null;
            if ("cell" !== t.type && "slice" !== t.type && "builder" !== t.type) throw Error("Not a cell");
            return t.cell
          }
          readTuple() {
            let t = this.pop();
            if ("tuple" !== t.type) throw Error("Not a tuple");
            return new r(t.items)
          }
          readTupleOpt() {
            let t = this.pop();
            if ("null" === t.type) return null;
            if ("tuple" !== t.type) throw Error("Not a tuple");
            return new r(t.items)
          }
          static readLispList(t) {
            const e = [];
            let r = t;
            for (; null !== r;) {
              var n = r.pop();
              if (0 === r.items.length || "tuple" !== r.items[0].type && "null" !== r.items[0].type) throw Error("Lisp list consists only from (any, tuple) elements and ends with null");
              r = r.readTupleOpt(), e.push(n)
            }
            return e
          }
          readLispListDirect() {
            return 1 === this.items.length && "null" === this.items[0].type ? [] : r.readLispList(this)
          }
          readLispList() {
            return r.readLispList(this.readTupleOpt())
          }
          readBuffer() {
            let t = this.readCell().beginParse();
            if (0 !== t.remainingRefs || t.remainingBits % 8 != 0) throw Error("Not a buffer");
            return t.loadBuffer(t.remainingBits / 8)
          }
          readBufferOpt() {
            let t = this.readCellOpt();
            if (null !== t) {
              let e = t.beginParse();
              if (0 !== e.remainingRefs || e.remainingBits % 8 != 0) throw Error("Not a buffer");
              return e.loadBuffer(e.remainingBits / 8)
            }
            return null
          }
          readString() {
            return this.readCell().beginParse().loadStringTail()
          }
          readStringOpt() {
            let t = this.readCellOpt();
            return null !== t ? t.beginParse().loadStringTail() : null
          }
        }
        e.TupleReader = r
      },
      21640: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.parseTuple = e.serializeTuple = void 0;
        const n = r(65871),
          i = BigInt("-9223372036854775808"),
          o = BigInt("9223372036854775807");

        function s(t, e) {
          if ("null" === t.type) e.storeUint(0, 8);
          else if ("int" === t.type) t.value > o || t.value < i ? (e.storeUint(256, 15), e.storeInt(t.value, 257)) : (e.storeUint(1, 8), e.storeInt(t.value, 64));
          else if ("nan" === t.type) e.storeInt(767, 16);
          else if ("cell" === t.type) e.storeUint(3, 8), e.storeRef(t.cell);
          else if ("slice" === t.type) e.storeUint(4, 8), e.storeUint(0, 10), e.storeUint(t.cell.bits.length, 10), e.storeUint(0, 3), e.storeUint(t.cell.refs.length, 3), e.storeRef(t.cell);
          else if ("builder" === t.type) e.storeUint(5, 8), e.storeRef(t.cell);
          else {
            if ("tuple" !== t.type) throw Error("Invalid value");
            {
              let r = null,
                i = null;
              for (let e = 0; e < t.items.length; e++) {
                let o = r;
                r = i, i = o, e > 1 && (r = (0, n.beginCell)().storeRef(i).storeRef(r).endCell());
                let a = (0, n.beginCell)();
                s(t.items[e], a), i = a.endCell()
              }
              e.storeUint(7, 8), e.storeUint(t.items.length, 16), r && e.storeRef(r), i && e.storeRef(i)
            }
          }
        }

        function a(t) {
          let e = t.loadUint(8);
          if (0 === e) return {
            type: "null"
          };
          if (1 === e) return {
            type: "int",
            value: t.loadIntBig(64)
          };
          if (2 === e) return 0 === t.loadUint(7) ? {
            type: "int",
            value: t.loadIntBig(257)
          } : (t.loadBit(), {
            type: "nan"
          });
          if (3 === e) return {
            type: "cell",
            cell: t.loadRef()
          };
          if (4 === e) {
            let e = t.loadUint(10),
              r = t.loadUint(10),
              i = t.loadUint(3),
              o = t.loadUint(3),
              s = t.loadRef().beginParse();
            s.skip(e);
            let a = s.loadBits(r - e),
              u = (0, n.beginCell)().storeBits(a);
            if (o > i) {
              for (let t = 0; i > t; t++) s.loadRef();
              for (let t = 0; o - i > t; t++) u.storeRef(s.loadRef())
            }
            return {
              type: "slice",
              cell: u.endCell()
            }
          }
          if (5 === e) return {
            type: "builder",
            cell: t.loadRef()
          };
          if (7 === e) {
            let e = t.loadUint(16),
              r = [];
            if (e > 1) {
              let n = t.loadRef().beginParse(),
                i = t.loadRef().beginParse();
              r.unshift(a(i));
              for (let t = 0; e - 2 > t; t++) {
                let t = n;
                n = t.loadRef().beginParse(), i = t.loadRef().beginParse(), r.unshift(a(i))
              }
              r.unshift(a(n))
            } else 1 === e && r.push(a(t.loadRef().beginParse()));
            return {
              type: "tuple",
              items: r
            }
          }
          throw Error("Unsupported stack item")
        }

        function u(t, e) {
          if (t.length > 0) {
            let r = (0, n.beginCell)();
            u(t.slice(0, t.length - 1), r), e.storeRef(r.endCell()), s(t[t.length - 1], e)
          }
        }
        e.serializeTuple = function(t) {
          let e = (0, n.beginCell)();
          return e.storeUint(t.length, 24), u([...t], e), e.endCell()
        }, e.parseTuple = function(t) {
          let e = [],
            r = t.beginParse(),
            n = r.loadUint(24);
          for (let t = 0; n > t; t++) {
            let t = r.loadRef();
            e.unshift(a(r)), r = t.beginParse()
          }
          return e
        }
      },
      21666: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), e && e.no_symbols ? s.test(t) : RegExp("^[+-]?([0-9]*[".concat((e || {}).locale ? o.decimal[e.locale] : ".", "])?[0-9]+$")).test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(13237),
          s = /^[0-9]+$/;
        t.exports = e.default, t.exports.default = e.default
      },
      21998: (t, e, r) => {
        "use strict";
        var n = r(9805),
          i = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
          o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
          s = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
          a = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
        t.exports = function(t, e, r, u, c, f, l, h) {
          var d, p, b, m, y, g, v, w, A, T = h.bits,
            E = 0,
            P = 0,
            k = 0,
            x = 0,
            I = 0,
            S = 0,
            O = 0,
            B = 0,
            W = 0,
            M = 0,
            C = null,
            R = 0,
            N = new n.Buf16(16),
            j = new n.Buf16(16),
            _ = null,
            D = 0;
          for (E = 0; 15 >= E; E++) N[E] = 0;
          for (P = 0; u > P; P++) N[e[r + P]]++;
          for (I = T, x = 15; x >= 1 && 0 === N[x]; x--);
          if (I > x && (I = x), 0 === x) return c[f++] = 20971520, c[f++] = 20971520, h.bits = 1, 0;
          for (k = 1; x > k && 0 === N[k]; k++);
          for (k > I && (I = k), B = 1, E = 1; 15 >= E; E++)
            if (B <<= 1, 0 > (B -= N[E])) return -1;
          if (B > 0 && (0 === t || 1 !== x)) return -1;
          for (j[1] = 0, E = 1; 15 > E; E++) j[E + 1] = j[E] + N[E];
          for (P = 0; u > P; P++) 0 !== e[r + P] && (l[j[e[r + P]]++] = P);
          if (0 === t ? (C = _ = l, g = 19) : 1 === t ? (C = i, R -= 257, _ = o, D -= 257, g = 256) : (C = s, _ = a, g = -1), M = 0, P = 0, E = k, y = f, S = I, O = 0, b = -1, m = (W = 1 << I) - 1, 1 === t && W > 852 || 2 === t && W > 592) return 1;
          for (;;) {
            v = E - O, l[P] < g ? (w = 0, A = l[P]) : l[P] > g ? (w = _[D + l[P]], A = C[R + l[P]]) : (w = 96, A = 0), d = 1 << E - O, k = p = 1 << S;
            do {
              c[y + (M >> O) + (p -= d)] = v << 24 | w << 16 | A
            } while (0 !== p);
            for (d = 1 << E - 1; M & d;) d >>= 1;
            if (0 !== d ? (M &= d - 1, M += d) : M = 0, P++, 0 === --N[E]) {
              if (E === x) break;
              E = e[r + l[P]]
            }
            if (E > I && (M & m) !== b) {
              for (0 === O && (O = I), y += k, B = 1 << (S = E - O); x > S + O && (B -= N[S + O]) > 0;) S++, B <<= 1;
              if (W += 1 << S, 1 === t && W > 852 || 2 === t && W > 592) return 1;
              c[b = M & m] = I << 24 | S << 16 | y - f
            }
          }
          return 0 !== M && (c[y + M] = 4194304 | E - O << 24), h.bits = I, 0
        }
      },
      22318: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.toBig = e.shrSL = e.shrSH = e.rotrSL = e.rotrSH = e.rotrBL = e.rotrBH = e.rotr32L = e.rotr32H = e.rotlSL = e.rotlSH = e.rotlBL = e.rotlBH = e.add5L = e.add5H = e.add4L = e.add4H = e.add3L = e.add3H = void 0, e.add = v, e.fromBig = i, e.split = o;
        const r = BigInt(2 ** 32 - 1),
          n = BigInt(32);

        function i(t, e = !1) {
          return e ? {
            h: +(t & r),
            l: +(t >> n & r)
          } : {
            h: 0 | +(t >> n & r),
            l: 0 | +(t & r)
          }
        }

        function o(t, e = !1) {
          const r = t.length;
          let n = new Uint32Array(r),
            o = new Uint32Array(r);
          for (let s = 0; r > s; s++) {
            const {
              h: r,
              l: a
            } = i(t[s], e);
            [n[s], o[s]] = [r, a]
          }
          return [n, o]
        }
        const s = (t, e) => BigInt(t >>> 0) << n | BigInt(e >>> 0);
        e.toBig = s;
        const a = (t, e, r) => t >>> r;
        e.shrSH = a;
        const u = (t, e, r) => t << 32 - r | e >>> r;
        e.shrSL = u;
        const c = (t, e, r) => t >>> r | e << 32 - r;
        e.rotrSH = c;
        const f = (t, e, r) => t << 32 - r | e >>> r;
        e.rotrSL = f;
        const l = (t, e, r) => t << 64 - r | e >>> r - 32;
        e.rotrBH = l;
        const h = (t, e, r) => t >>> r - 32 | e << 64 - r;
        e.rotrBL = h;
        const d = (t, e) => e;
        e.rotr32H = d;
        const p = (t, e) => t;
        e.rotr32L = p;
        const b = (t, e, r) => t << r | e >>> 32 - r;
        e.rotlSH = b;
        const m = (t, e, r) => e << r | t >>> 32 - r;
        e.rotlSL = m;
        const y = (t, e, r) => e << r - 32 | t >>> 64 - r;
        e.rotlBH = y;
        const g = (t, e, r) => t << r - 32 | e >>> 64 - r;

        function v(t, e, r, n) {
          const i = (e >>> 0) + (n >>> 0);
          return {
            h: t + r + (i / 4294967296 | 0) | 0,
            l: 0 | i
          }
        }
        e.rotlBL = g;
        const w = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0);
        e.add3L = w;
        const A = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0;
        e.add3H = A;
        const T = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0);
        e.add4L = T;
        const E = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0;
        e.add4H = E;
        const P = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
        e.add5L = P;
        const k = (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0;
        e.add5H = k;
        const x = {
          fromBig: i,
          split: o,
          toBig: s,
          shrSH: a,
          shrSL: u,
          rotrSH: c,
          rotrSL: f,
          rotrBH: l,
          rotrBL: h,
          rotr32H: d,
          rotr32L: p,
          rotlSH: b,
          rotlSL: m,
          rotlBH: y,
          rotlBL: g,
          add: v,
          add3L: w,
          add3H: A,
          add4L: T,
          add4H: E,
          add5H: k,
          add5L: P
        };
        e.default = x
      },
      22391: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.iterate = void 0;
        const n = r(65534);
        e.iterate = function*(t, e = 32) {
          for (let r = 0; r < t.length; r += e) {
            const i = t => {
                (0, n.assert)(t >= 0, "Cannot skip a negative number of bytes."), (0, n.assert)(t % e === 0, "Length must be a multiple of the size."), r += t
              },
              o = t.subarray(r);
            yield {
              skip: i,
              value: o
            }
          }
          return {
            skip: () => {},
            value: new Uint8Array
          }
        }
      },
      22738: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeStateInit = e.loadStateInit = void 0;
        const n = r(97590),
          i = r(62672),
          o = r(4599);
        e.loadStateInit = function(t) {
          let e, r;
          t.loadBit() && (e = t.loadUint(5)), t.loadBit() && (r = (0, o.loadTickTock)(t));
          let s = t.loadMaybeRef(),
            a = t.loadMaybeRef(),
            u = t.loadDict(n.Dictionary.Keys.BigUint(256), i.SimpleLibraryValue);
          return 0 === u.size && (u = void 0), {
            splitDepth: e,
            special: r,
            code: s,
            data: a,
            libraries: u
          }
        }, e.storeStateInit = function(t) {
          return e => {
            null !== t.splitDepth && void 0 !== t.splitDepth ? (e.storeBit(!0), e.storeUint(t.splitDepth, 5)) : e.storeBit(!1), null !== t.special && void 0 !== t.special ? (e.storeBit(!0), e.store((0, o.storeTickTock)(t.special))) : e.storeBit(!1), e.storeMaybeRef(t.code), e.storeMaybeRef(t.data), e.storeDict(t.libraries)
          }
        }
      },
      22979: (t, e) => {
        "use strict";

        function r(t, e, n, i, o) {
          let s = 0,
            a = t;
          if (0 == (e.loadBit() ? 1 : 0)) {
            s = function(t) {
              let e = 0;
              for (; t.loadBit();) e++;
              return e
            }(e);
            for (let t = 0; s > t; t++) a += e.loadBit() ? "1" : "0"
          } else if (0 == (e.loadBit() ? 1 : 0)) {
            s = e.loadUint(Math.ceil(Math.log2(n + 1)));
            for (let t = 0; s > t; t++) a += e.loadBit() ? "1" : "0"
          } else {
            let t = e.loadBit() ? "1" : "0";
            s = e.loadUint(Math.ceil(Math.log2(n + 1)));
            for (let e = 0; s > e; e++) a += t
          }
          if (n - s === 0) i.set(BigInt("0b" + a), o(e));
          else {
            let t = e.loadRef(),
              u = e.loadRef();
            t.isExotic || r(a + "0", t.beginParse(), n - s - 1, i, o), u.isExotic || r(a + "1", u.beginParse(), n - s - 1, i, o)
          }
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.parseDict = void 0, e.parseDict = function(t, e, n) {
          let i = new Map;
          return t && r("", t, e, i, n), i
        }
      },
      23515: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.computeStorageFees = e.computeMessageForwardFees = e.computeGasPrices = e.computeFwdFees = e.computeExternalMessageFees = e.loadConfigParamsAsSlice = e.loadConfigParamById = e.parseFullConfig = e.parseVotingSetup = e.parseValidatorSet = e.parseProposalSetup = e.parseBridge = e.configParseWorkchainDescriptor = e.configParseValidatorSet = e.configParseMsgPrices = e.configParseMasterAddressRequired = e.configParseMasterAddress = e.configParseGasLimitsPrices = e.configParseBridge = e.configParse40 = e.configParse29 = e.configParse28 = e.configParse18 = e.configParse17 = e.configParse16 = e.configParse15 = e.configParse13 = e.configParse12 = e.configParse8 = e.configParse5 = e.ElectorContract = e.MultisigWallet = e.MultisigOrderBuilder = e.MultisigOrder = e.JettonWallet = e.JettonMaster = e.WalletContractV5R1 = e.WalletContractV5Beta = e.WalletContractV4 = e.WalletContractV3R2 = e.WalletContractV3R1 = e.WalletContractV2R2 = e.WalletContractV2R1 = e.WalletContractV1R3 = e.WalletContractV1R2 = e.WalletContractV1R1 = e.TonClient4 = e.TonClient = e.HttpApi = void 0, i(r(1307), e);
        var o = r(41972);
        Object.defineProperty(e, "HttpApi", {
          enumerable: !0,
          get: function() {
            return o.HttpApi
          }
        });
        var s = r(98737);
        Object.defineProperty(e, "TonClient", {
          enumerable: !0,
          get: function() {
            return s.TonClient
          }
        });
        var a = r(50993);
        Object.defineProperty(e, "TonClient4", {
          enumerable: !0,
          get: function() {
            return a.TonClient4
          }
        });
        var u = r(94471);
        Object.defineProperty(e, "WalletContractV1R1", {
          enumerable: !0,
          get: function() {
            return u.WalletContractV1R1
          }
        });
        var c = r(90746);
        Object.defineProperty(e, "WalletContractV1R2", {
          enumerable: !0,
          get: function() {
            return c.WalletContractV1R2
          }
        });
        var f = r(3273);
        Object.defineProperty(e, "WalletContractV1R3", {
          enumerable: !0,
          get: function() {
            return f.WalletContractV1R3
          }
        });
        var l = r(71902);
        Object.defineProperty(e, "WalletContractV2R1", {
          enumerable: !0,
          get: function() {
            return l.WalletContractV2R1
          }
        });
        var h = r(99579);
        Object.defineProperty(e, "WalletContractV2R2", {
          enumerable: !0,
          get: function() {
            return h.WalletContractV2R2
          }
        });
        var d = r(79145);
        Object.defineProperty(e, "WalletContractV3R1", {
          enumerable: !0,
          get: function() {
            return d.WalletContractV3R1
          }
        });
        var p = r(28784);
        Object.defineProperty(e, "WalletContractV3R2", {
          enumerable: !0,
          get: function() {
            return p.WalletContractV3R2
          }
        });
        var b = r(7941);
        Object.defineProperty(e, "WalletContractV4", {
          enumerable: !0,
          get: function() {
            return b.WalletContractV4
          }
        });
        var m = r(16340);
        Object.defineProperty(e, "WalletContractV5Beta", {
          enumerable: !0,
          get: function() {
            return m.WalletContractV5Beta
          }
        });
        var y = r(8387);
        Object.defineProperty(e, "WalletContractV5R1", {
          enumerable: !0,
          get: function() {
            return y.WalletContractV5R1
          }
        });
        var g = r(24440);
        Object.defineProperty(e, "JettonMaster", {
          enumerable: !0,
          get: function() {
            return g.JettonMaster
          }
        });
        var v = r(55411);
        Object.defineProperty(e, "JettonWallet", {
          enumerable: !0,
          get: function() {
            return v.JettonWallet
          }
        });
        var w = r(64204);
        Object.defineProperty(e, "MultisigOrder", {
          enumerable: !0,
          get: function() {
            return w.MultisigOrder
          }
        });
        var A = r(69673);
        Object.defineProperty(e, "MultisigOrderBuilder", {
          enumerable: !0,
          get: function() {
            return A.MultisigOrderBuilder
          }
        });
        var T = r(42227);
        Object.defineProperty(e, "MultisigWallet", {
          enumerable: !0,
          get: function() {
            return T.MultisigWallet
          }
        });
        var E = r(28078);
        Object.defineProperty(e, "ElectorContract", {
          enumerable: !0,
          get: function() {
            return E.ElectorContract
          }
        });
        var P = r(57017);
        Object.defineProperty(e, "configParse5", {
          enumerable: !0,
          get: function() {
            return P.configParse5
          }
        }), Object.defineProperty(e, "configParse8", {
          enumerable: !0,
          get: function() {
            return P.configParse8
          }
        }), Object.defineProperty(e, "configParse12", {
          enumerable: !0,
          get: function() {
            return P.configParse12
          }
        }), Object.defineProperty(e, "configParse13", {
          enumerable: !0,
          get: function() {
            return P.configParse13
          }
        }), Object.defineProperty(e, "configParse15", {
          enumerable: !0,
          get: function() {
            return P.configParse15
          }
        }), Object.defineProperty(e, "configParse16", {
          enumerable: !0,
          get: function() {
            return P.configParse16
          }
        }), Object.defineProperty(e, "configParse17", {
          enumerable: !0,
          get: function() {
            return P.configParse17
          }
        }), Object.defineProperty(e, "configParse18", {
          enumerable: !0,
          get: function() {
            return P.configParse18
          }
        }), Object.defineProperty(e, "configParse28", {
          enumerable: !0,
          get: function() {
            return P.configParse28
          }
        }), Object.defineProperty(e, "configParse29", {
          enumerable: !0,
          get: function() {
            return P.configParse29
          }
        }), Object.defineProperty(e, "configParse40", {
          enumerable: !0,
          get: function() {
            return P.configParse40
          }
        }), Object.defineProperty(e, "configParseBridge", {
          enumerable: !0,
          get: function() {
            return P.configParseBridge
          }
        }), Object.defineProperty(e, "configParseGasLimitsPrices", {
          enumerable: !0,
          get: function() {
            return P.configParseGasLimitsPrices
          }
        }), Object.defineProperty(e, "configParseMasterAddress", {
          enumerable: !0,
          get: function() {
            return P.configParseMasterAddress
          }
        }), Object.defineProperty(e, "configParseMasterAddressRequired", {
          enumerable: !0,
          get: function() {
            return P.configParseMasterAddressRequired
          }
        }), Object.defineProperty(e, "configParseMsgPrices", {
          enumerable: !0,
          get: function() {
            return P.configParseMsgPrices
          }
        }), Object.defineProperty(e, "configParseValidatorSet", {
          enumerable: !0,
          get: function() {
            return P.configParseValidatorSet
          }
        }), Object.defineProperty(e, "configParseWorkchainDescriptor", {
          enumerable: !0,
          get: function() {
            return P.configParseWorkchainDescriptor
          }
        }), Object.defineProperty(e, "parseBridge", {
          enumerable: !0,
          get: function() {
            return P.parseBridge
          }
        }), Object.defineProperty(e, "parseProposalSetup", {
          enumerable: !0,
          get: function() {
            return P.parseProposalSetup
          }
        }), Object.defineProperty(e, "parseValidatorSet", {
          enumerable: !0,
          get: function() {
            return P.parseValidatorSet
          }
        }), Object.defineProperty(e, "parseVotingSetup", {
          enumerable: !0,
          get: function() {
            return P.parseVotingSetup
          }
        }), Object.defineProperty(e, "parseFullConfig", {
          enumerable: !0,
          get: function() {
            return P.parseFullConfig
          }
        }), Object.defineProperty(e, "loadConfigParamById", {
          enumerable: !0,
          get: function() {
            return P.loadConfigParamById
          }
        }), Object.defineProperty(e, "loadConfigParamsAsSlice", {
          enumerable: !0,
          get: function() {
            return P.loadConfigParamsAsSlice
          }
        });
        var k = r(80868);
        Object.defineProperty(e, "computeExternalMessageFees", {
          enumerable: !0,
          get: function() {
            return k.computeExternalMessageFees
          }
        }), Object.defineProperty(e, "computeFwdFees", {
          enumerable: !0,
          get: function() {
            return k.computeFwdFees
          }
        }), Object.defineProperty(e, "computeGasPrices", {
          enumerable: !0,
          get: function() {
            return k.computeGasPrices
          }
        }), Object.defineProperty(e, "computeMessageForwardFees", {
          enumerable: !0,
          get: function() {
            return k.computeMessageForwardFees
          }
        }), Object.defineProperty(e, "computeStorageFees", {
          enumerable: !0,
          get: function() {
            return k.computeStorageFees
          }
        })
      },
      23641: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          return (0, i.default)(t),
            function(t, e) {
              var r = t.replace(/[\s\-]+/gi, "").toUpperCase(),
                n = r.slice(0, 2).toUpperCase(),
                i = n in o;
              if (e.whitelist) {
                if (! function(t) {
                    var e = t.filter(function(t) {
                      return !(t in o)
                    });
                    return !(e.length > 0)
                  }(e.whitelist)) return !1;
                if (!e.whitelist.includes(n)) return !1
              }
              return (!e.blacklist || !e.blacklist.includes(n)) && i && o[n].test(r)
            }(t, e) && function(t) {
              var e = t.replace(/[^A-Z0-9]+/gi, "").toUpperCase();
              return 1 === (e.slice(4) + e.slice(0, 4)).replace(/[A-Z]/g, function(t) {
                return t.charCodeAt(0) - 55
              }).match(/\d{1,7}/g).reduce(function(t, e) {
                return +(t + e) % 97
              }, "")
            }(t)
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            AD: /^(AD[0-9]{2})\d{8}[A-Z0-9]{12}$/,
            AE: /^(AE[0-9]{2})\d{3}\d{16}$/,
            AL: /^(AL[0-9]{2})\d{8}[A-Z0-9]{16}$/,
            AT: /^(AT[0-9]{2})\d{16}$/,
            AZ: /^(AZ[0-9]{2})[A-Z0-9]{4}\d{20}$/,
            BA: /^(BA[0-9]{2})\d{16}$/,
            BE: /^(BE[0-9]{2})\d{12}$/,
            BG: /^(BG[0-9]{2})[A-Z]{4}\d{6}[A-Z0-9]{8}$/,
            BH: /^(BH[0-9]{2})[A-Z]{4}[A-Z0-9]{14}$/,
            BR: /^(BR[0-9]{2})\d{23}[A-Z]{1}[A-Z0-9]{1}$/,
            BY: /^(BY[0-9]{2})[A-Z0-9]{4}\d{20}$/,
            CH: /^(CH[0-9]{2})\d{5}[A-Z0-9]{12}$/,
            CR: /^(CR[0-9]{2})\d{18}$/,
            CY: /^(CY[0-9]{2})\d{8}[A-Z0-9]{16}$/,
            CZ: /^(CZ[0-9]{2})\d{20}$/,
            DE: /^(DE[0-9]{2})\d{18}$/,
            DK: /^(DK[0-9]{2})\d{14}$/,
            DO: /^(DO[0-9]{2})[A-Z]{4}\d{20}$/,
            EE: /^(EE[0-9]{2})\d{16}$/,
            EG: /^(EG[0-9]{2})\d{25}$/,
            ES: /^(ES[0-9]{2})\d{20}$/,
            FI: /^(FI[0-9]{2})\d{14}$/,
            FO: /^(FO[0-9]{2})\d{14}$/,
            FR: /^(FR[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
            GB: /^(GB[0-9]{2})[A-Z]{4}\d{14}$/,
            GE: /^(GE[0-9]{2})[A-Z0-9]{2}\d{16}$/,
            GI: /^(GI[0-9]{2})[A-Z]{4}[A-Z0-9]{15}$/,
            GL: /^(GL[0-9]{2})\d{14}$/,
            GR: /^(GR[0-9]{2})\d{7}[A-Z0-9]{16}$/,
            GT: /^(GT[0-9]{2})[A-Z0-9]{4}[A-Z0-9]{20}$/,
            HR: /^(HR[0-9]{2})\d{17}$/,
            HU: /^(HU[0-9]{2})\d{24}$/,
            IE: /^(IE[0-9]{2})[A-Z0-9]{4}\d{14}$/,
            IL: /^(IL[0-9]{2})\d{19}$/,
            IQ: /^(IQ[0-9]{2})[A-Z]{4}\d{15}$/,
            IR: /^(IR[0-9]{2})0\d{2}0\d{18}$/,
            IS: /^(IS[0-9]{2})\d{22}$/,
            IT: /^(IT[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
            JO: /^(JO[0-9]{2})[A-Z]{4}\d{22}$/,
            KW: /^(KW[0-9]{2})[A-Z]{4}[A-Z0-9]{22}$/,
            KZ: /^(KZ[0-9]{2})\d{3}[A-Z0-9]{13}$/,
            LB: /^(LB[0-9]{2})\d{4}[A-Z0-9]{20}$/,
            LC: /^(LC[0-9]{2})[A-Z]{4}[A-Z0-9]{24}$/,
            LI: /^(LI[0-9]{2})\d{5}[A-Z0-9]{12}$/,
            LT: /^(LT[0-9]{2})\d{16}$/,
            LU: /^(LU[0-9]{2})\d{3}[A-Z0-9]{13}$/,
            LV: /^(LV[0-9]{2})[A-Z]{4}[A-Z0-9]{13}$/,
            MA: /^(MA[0-9]{26})$/,
            MC: /^(MC[0-9]{2})\d{10}[A-Z0-9]{11}\d{2}$/,
            MD: /^(MD[0-9]{2})[A-Z0-9]{20}$/,
            ME: /^(ME[0-9]{2})\d{18}$/,
            MK: /^(MK[0-9]{2})\d{3}[A-Z0-9]{10}\d{2}$/,
            MR: /^(MR[0-9]{2})\d{23}$/,
            MT: /^(MT[0-9]{2})[A-Z]{4}\d{5}[A-Z0-9]{18}$/,
            MU: /^(MU[0-9]{2})[A-Z]{4}\d{19}[A-Z]{3}$/,
            MZ: /^(MZ[0-9]{2})\d{21}$/,
            NL: /^(NL[0-9]{2})[A-Z]{4}\d{10}$/,
            NO: /^(NO[0-9]{2})\d{11}$/,
            PK: /^(PK[0-9]{2})[A-Z0-9]{4}\d{16}$/,
            PL: /^(PL[0-9]{2})\d{24}$/,
            PS: /^(PS[0-9]{2})[A-Z0-9]{4}\d{21}$/,
            PT: /^(PT[0-9]{2})\d{21}$/,
            QA: /^(QA[0-9]{2})[A-Z]{4}[A-Z0-9]{21}$/,
            RO: /^(RO[0-9]{2})[A-Z]{4}[A-Z0-9]{16}$/,
            RS: /^(RS[0-9]{2})\d{18}$/,
            SA: /^(SA[0-9]{2})\d{2}[A-Z0-9]{18}$/,
            SC: /^(SC[0-9]{2})[A-Z]{4}\d{20}[A-Z]{3}$/,
            SE: /^(SE[0-9]{2})\d{20}$/,
            SI: /^(SI[0-9]{2})\d{15}$/,
            SK: /^(SK[0-9]{2})\d{20}$/,
            SM: /^(SM[0-9]{2})[A-Z]{1}\d{10}[A-Z0-9]{12}$/,
            SV: /^(SV[0-9]{2})[A-Z0-9]{4}\d{20}$/,
            TL: /^(TL[0-9]{2})\d{19}$/,
            TN: /^(TN[0-9]{2})\d{20}$/,
            TR: /^(TR[0-9]{2})\d{5}[A-Z0-9]{17}$/,
            UA: /^(UA[0-9]{2})\d{6}[A-Z0-9]{19}$/,
            VA: /^(VA[0-9]{2})\d{18}$/,
            VG: /^(VG[0-9]{2})[A-Z0-9]{4}\d{16}$/,
            XK: /^(XK[0-9]{2})\d{16}$/
          },
          s = Object.keys(o);
        e.locales = s
      },
      23665: (t, e, r) => {
        "use strict";
        var n = r(9805);

        function i(t) {
          for (var e = t.length; --e >= 0;) t[e] = 0
        }
        var o = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
          s = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
          a = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
          u = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
          c = Array(576);
        i(c);
        var f = Array(60);
        i(f);
        var l = Array(512);
        i(l);
        var h = Array(256);
        i(h);
        var d = Array(29);
        i(d);
        var p, b, m, y = Array(30);

        function g(t, e, r, n, i) {
          this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = n, this.max_length = i, this.has_stree = t && t.length
        }

        function v(t, e) {
          this.dyn_tree = t, this.max_code = 0, this.stat_desc = e
        }

        function w(t) {
          return 256 > t ? l[t] : l[256 + (t >>> 7)]
        }

        function A(t, e) {
          t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255
        }

        function T(t, e, r) {
          t.bi_valid > 16 - r ? (t.bi_buf |= e << t.bi_valid & 65535, A(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += r - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r)
        }

        function E(t, e, r) {
          T(t, r[2 * e], r[2 * e + 1])
        }

        function P(t, e) {
          var r = 0;
          do {
            r |= 1 & t, t >>>= 1, r <<= 1
          } while (--e > 0);
          return r >>> 1
        }

        function k(t, e, r) {
          var n, i, o = Array(16),
            s = 0;
          for (n = 1; 15 >= n; n++) o[n] = s = s + r[n - 1] << 1;
          for (i = 0; e >= i; i++) {
            var a = t[2 * i + 1];
            0 !== a && (t[2 * i] = P(o[a]++, a))
          }
        }

        function x(t) {
          var e;
          for (e = 0; 286 > e; e++) t.dyn_ltree[2 * e] = 0;
          for (e = 0; 30 > e; e++) t.dyn_dtree[2 * e] = 0;
          for (e = 0; 19 > e; e++) t.bl_tree[2 * e] = 0;
          t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0
        }

        function I(t) {
          t.bi_valid > 8 ? A(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0
        }

        function S(t, e, r, n) {
          var i = 2 * e,
            o = 2 * r;
          return t[i] < t[o] || t[i] === t[o] && n[e] <= n[r]
        }

        function O(t, e, r) {
          for (var n = t.heap[r], i = r << 1; i <= t.heap_len && (i < t.heap_len && S(e, t.heap[i + 1], t.heap[i], t.depth) && i++, !S(e, n, t.heap[i], t.depth));) t.heap[r] = t.heap[i], r = i, i <<= 1;
          t.heap[r] = n
        }

        function B(t, e, r) {
          var n, i, a, u, c = 0;
          if (0 !== t.last_lit)
            do {
              n = t.pending_buf[t.d_buf + 2 * c] << 8 | t.pending_buf[t.d_buf + 2 * c + 1], i = t.pending_buf[t.l_buf + c], c++, 0 === n ? E(t, i, e) : (E(t, (a = h[i]) + 256 + 1, e), 0 !== (u = o[a]) && T(t, i -= d[a], u), E(t, a = w(--n), r), 0 !== (u = s[a]) && T(t, n -= y[a], u))
            } while (c < t.last_lit);
          E(t, 256, e)
        }

        function W(t, e) {
          var r, n, i, o = e.dyn_tree,
            s = e.stat_desc.static_tree,
            a = e.stat_desc.has_stree,
            u = e.stat_desc.elems,
            c = -1;
          for (t.heap_len = 0, t.heap_max = 573, r = 0; u > r; r++) 0 !== o[2 * r] ? (t.heap[++t.heap_len] = c = r, t.depth[r] = 0) : o[2 * r + 1] = 0;
          for (; 2 > t.heap_len;) o[2 * (i = t.heap[++t.heap_len] = 2 > c ? ++c : 0)] = 1, t.depth[i] = 0, t.opt_len--, a && (t.static_len -= s[2 * i + 1]);
          for (e.max_code = c, r = t.heap_len >> 1; r >= 1; r--) O(t, o, r);
          i = u;
          do {
            r = t.heap[1], t.heap[1] = t.heap[t.heap_len--], O(t, o, 1), n = t.heap[1], t.heap[--t.heap_max] = r, t.heap[--t.heap_max] = n, o[2 * i] = o[2 * r] + o[2 * n], t.depth[i] = (t.depth[r] < t.depth[n] ? t.depth[n] : t.depth[r]) + 1, o[2 * r + 1] = o[2 * n + 1] = i, t.heap[1] = i++, O(t, o, 1)
          } while (t.heap_len >= 2);
          t.heap[--t.heap_max] = t.heap[1],
            function(t, e) {
              var r, n, i, o, s, a, u = e.dyn_tree,
                c = e.max_code,
                f = e.stat_desc.static_tree,
                l = e.stat_desc.has_stree,
                h = e.stat_desc.extra_bits,
                d = e.stat_desc.extra_base,
                p = e.stat_desc.max_length,
                b = 0;
              for (o = 0; 15 >= o; o++) t.bl_count[o] = 0;
              for (u[2 * t.heap[t.heap_max] + 1] = 0, r = t.heap_max + 1; 573 > r; r++)(o = u[2 * u[2 * (n = t.heap[r]) + 1] + 1] + 1) > p && (o = p, b++), u[2 * n + 1] = o, c >= n && (t.bl_count[o]++, s = 0, n >= d && (s = h[n - d]), a = u[2 * n], t.opt_len += a * (o + s), l && (t.static_len += a * (f[2 * n + 1] + s)));
              if (0 !== b) {
                do {
                  for (o = p - 1; 0 === t.bl_count[o];) o--;
                  t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, b -= 2
                } while (b > 0);
                for (o = p; 0 !== o; o--)
                  for (n = t.bl_count[o]; 0 !== n;)(i = t.heap[--r]) <= c && (u[2 * i + 1] !== o && (t.opt_len += (o - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = o), n--)
              }
            }(t, e), k(o, c, t.bl_count)
        }

        function M(t, e, r) {
          var n, i, o = -1,
            s = e[1],
            a = 0,
            u = 7,
            c = 4;
          for (0 === s && (u = 138, c = 3), e[2 * (r + 1) + 1] = 65535, n = 0; r >= n; n++) i = s, s = e[2 * (n + 1) + 1], (++a >= u || i !== s) && (c > a ? t.bl_tree[2 * i] += a : 0 !== i ? (i !== o && t.bl_tree[2 * i]++, t.bl_tree[32]++) : a > 10 ? t.bl_tree[36]++ : t.bl_tree[34]++, a = 0, o = i, 0 === s ? (u = 138, c = 3) : i === s ? (u = 6, c = 3) : (u = 7, c = 4))
        }

        function C(t, e, r) {
          var n, i, o = -1,
            s = e[1],
            a = 0,
            u = 7,
            c = 4;
          for (0 === s && (u = 138, c = 3), n = 0; r >= n; n++)
            if (i = s, s = e[2 * (n + 1) + 1], ++a >= u || i !== s) {
              if (c > a)
                do {
                  E(t, i, t.bl_tree)
                } while (0 !== --a);
              else 0 !== i ? (i !== o && (E(t, i, t.bl_tree), a--), E(t, 16, t.bl_tree), T(t, a - 3, 2)) : a > 10 ? (E(t, 18, t.bl_tree), T(t, a - 11, 7)) : (E(t, 17, t.bl_tree), T(t, a - 3, 3));
              a = 0, o = i, 0 === s ? (u = 138, c = 3) : i === s ? (u = 6, c = 3) : (u = 7, c = 4)
            }
        }
        i(y);
        var R = !1;

        function N(t, e, r, i) {
          T(t, 0 + (i ? 1 : 0), 3),
            function(t, e, r) {
              I(t), A(t, r), A(t, ~r), n.arraySet(t.pending_buf, t.window, e, r, t.pending), t.pending += r
            }(t, e, r)
        }
        e.qt = function(t) {
          R || (function() {
            var t, e, r, n, i, u = Array(16);
            for (r = 0, n = 0; 28 > n; n++)
              for (d[n] = r, t = 0; 1 << o[n] > t; t++) h[r++] = n;
            for (h[r - 1] = n, i = 0, n = 0; 16 > n; n++)
              for (y[n] = i, t = 0; 1 << s[n] > t; t++) l[i++] = n;
            for (i >>= 7; 30 > n; n++)
              for (y[n] = i << 7, t = 0; 1 << s[n] - 7 > t; t++) l[256 + i++] = n;
            for (e = 0; 15 >= e; e++) u[e] = 0;
            for (t = 0; 143 >= t;) c[2 * t + 1] = 8, t++, u[8]++;
            for (; 255 >= t;) c[2 * t + 1] = 9, t++, u[9]++;
            for (; 279 >= t;) c[2 * t + 1] = 7, t++, u[7]++;
            for (; 287 >= t;) c[2 * t + 1] = 8, t++, u[8]++;
            for (k(c, 287, u), t = 0; 30 > t; t++) f[2 * t + 1] = 5, f[2 * t] = P(t, 5);
            p = new g(c, o, 257, 286, 15), b = new g(f, s, 0, 30, 15), m = new g([], a, 0, 19, 7)
          }(), R = !0), t.l_desc = new v(t.dyn_ltree, p), t.d_desc = new v(t.dyn_dtree, b), t.bl_desc = new v(t.bl_tree, m), t.bi_buf = 0, t.bi_valid = 0, x(t)
        }, e.Jt = N, e.Yt = function(t, e, r, n) {
          var i, o, s = 0;
          t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = function(t) {
            var e, r = 4093624447;
            for (e = 0; 31 >= e; e++, r >>>= 1)
              if (1 & r && 0 !== t.dyn_ltree[2 * e]) return 0;
            if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1;
            for (e = 32; 256 > e; e++)
              if (0 !== t.dyn_ltree[2 * e]) return 1;
            return 0
          }(t)), W(t, t.l_desc), W(t, t.d_desc), s = function(t) {
            var e;
            for (M(t, t.dyn_ltree, t.l_desc.max_code), M(t, t.dyn_dtree, t.d_desc.max_code), W(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * u[e] + 1]; e--);
            return t.opt_len += 14 + 3 * (e + 1), e
          }(t), (i = t.opt_len + 3 + 7 >>> 3) >= (o = t.static_len + 3 + 7 >>> 3) && (i = o)) : i = o = r + 5, r + 4 > i || -1 === e ? 4 === t.strategy || o === i ? (T(t, 2 + (n ? 1 : 0), 3), B(t, c, f)) : (T(t, 4 + (n ? 1 : 0), 3), function(t, e, r, n) {
            var i;
            for (T(t, e - 257, 5), T(t, r - 1, 5), T(t, n - 4, 4), i = 0; n > i; i++) T(t, t.bl_tree[2 * u[i] + 1], 3);
            C(t, t.dyn_ltree, e - 1), C(t, t.dyn_dtree, r - 1)
          }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), B(t, t.dyn_ltree, t.dyn_dtree)) : N(t, e, r, n), x(t), n && I(t)
        }, e.Qt = function(t, e, r) {
          return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & r, t.last_lit++, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (h[r] + 256 + 1)]++, t.dyn_dtree[2 * w(e)]++), t.last_lit === t.lit_bufsize - 1
        }, e.Xt = function(t) {
          T(t, 2, 3), E(t, 256, c),
            function(t) {
              16 === t.bi_valid ? (A(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8)
            }(t)
        }
      },
      23678: t => {
        "use strict";
        var e = {}.hasOwnProperty,
          r = "~";

        function n() {}

        function i(t, e, r) {
          this.fn = t, this.context = e, this.once = r || !1
        }

        function o(t, e, n, o, s) {
          if ("function" != typeof n) throw new TypeError("The listener must be a function");
          var a = new i(n, o || t, s),
            u = r ? r + e : e;
          return t.ye[u] ? t.ye[u].fn ? t.ye[u] = [t.ye[u], a] : t.ye[u].push(a) : (t.ye[u] = a, t.Ae++), t
        }

        function s(t, e) {
          0 === --t.Ae ? t.ye = new n : delete t.ye[e]
        }

        function a() {
          this.ye = new n, this.Ae = 0
        }
        Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (r = !1)), a.prototype.eventNames = function() {
          var t, n, i = [];
          if (0 === this.Ae) return i;
          for (n in t = this.ye) e.call(t, n) && i.push(r ? n.slice(1) : n);
          return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
        }, a.prototype.listeners = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          if (!n) return [];
          if (n.fn) return [n.fn];
          for (var i = 0, o = n.length, s = Array(o); o > i; i++) s[i] = n[i].fn;
          return s
        }, a.prototype.listenerCount = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          return n ? n.fn ? 1 : n.length : 0
        }, a.prototype.emit = function(t, e, n, i, o, s) {
          var a = r ? r + t : t;
          if (!this.ye[a]) return !1;
          var u, c, f = this.ye[a],
            l = arguments.length;
          if (f.fn) {
            switch (f.once && this.removeListener(t, f.fn, void 0, !0), l) {
              case 1:
                return f.fn.call(f.context), !0;
              case 2:
                return f.fn.call(f.context, e), !0;
              case 3:
                return f.fn.call(f.context, e, n), !0;
              case 4:
                return f.fn.call(f.context, e, n, i), !0;
              case 5:
                return f.fn.call(f.context, e, n, i, o), !0;
              case 6:
                return f.fn.call(f.context, e, n, i, o, s), !0
            }
            for (c = 1, u = Array(l - 1); l > c; c++) u[c - 1] = arguments[c];
            f.fn.apply(f.context, u)
          } else {
            var h, d = f.length;
            for (c = 0; d > c; c++) switch (f[c].once && this.removeListener(t, f[c].fn, void 0, !0), l) {
              case 1:
                f[c].fn.call(f[c].context);
                break;
              case 2:
                f[c].fn.call(f[c].context, e);
                break;
              case 3:
                f[c].fn.call(f[c].context, e, n);
                break;
              case 4:
                f[c].fn.call(f[c].context, e, n, i);
                break;
              default:
                if (!u)
                  for (h = 1, u = Array(l - 1); l > h; h++) u[h - 1] = arguments[h];
                f[c].fn.apply(f[c].context, u)
            }
          }
          return !0
        }, a.prototype.on = function(t, e, r) {
          return o(this, t, e, r, !1)
        }, a.prototype.once = function(t, e, r) {
          return o(this, t, e, r, !0)
        }, a.prototype.removeListener = function(t, e, n, i) {
          var o = r ? r + t : t;
          if (!this.ye[o]) return this;
          if (!e) return s(this, o), this;
          var a = this.ye[o];
          if (a.fn) a.fn === e && (!i || a.once) && (!n || a.context === n) && s(this, o);
          else {
            for (var u = 0, c = [], f = a.length; f > u; u++)(a[u].fn !== e || i && !a[u].once || n && a[u].context !== n) && c.push(a[u]);
            c.length ? this.ye[o] = 1 === c.length ? c[0] : c : s(this, o)
          }
          return this
        }, a.prototype.removeAllListeners = function(t) {
          var e;
          return t ? (e = r ? r + t : t, this.ye[e] && s(this, e)) : (this.ye = new n, this.Ae = 0), this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
      },
      24133: (t, e, r) => {
        "use strict";
        var n = r(10487),
          i = r(38452),
          o = r(13003),
          s = r(76642),
          a = r(92464),
          u = n(s(), Number);
        i(u, {
          getPolyfill: s,
          implementation: o,
          shim: a
        }), t.exports = u
      },
      24253: (t, e, r) => {
        "use strict";
        r.d(e, {
          v4: () => c
        });
        var n, i = new Uint8Array(16);

        function o() {
          if (!n && !(n = "u" > typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "u" > typeof msCrypto && "function" == typeof msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto))) throw Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
          return n(i)
        }
        const s = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        for (var a = [], u = 0; 256 > u; ++u) a.push((u + 256).toString(16).substr(1));
        const c = function(t, e, r) {
          var n = (t = t || {}).random || (t.rng || o)();
          if (n[6] = 15 & n[6] | 64, n[8] = 63 & n[8] | 128, e) {
            r = r || 0;
            for (var i = 0; 16 > i; ++i) e[r + i] = n[i];
            return e
          }
          return function(t) {
            var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
              r = (a[t[e + 0]] + a[t[e + 1]] + a[t[e + 2]] + a[t[e + 3]] + "-" + a[t[e + 4]] + a[t[e + 5]] + "-" + a[t[e + 6]] + a[t[e + 7]] + "-" + a[t[e + 8]] + a[t[e + 9]] + "-" + a[t[e + 10]] + a[t[e + 11]] + a[t[e + 12]] + a[t[e + 13]] + a[t[e + 14]] + a[t[e + 15]]).toLowerCase();
            if (! function(t) {
                return "string" == typeof t && s.test(t)
              }(r)) throw TypeError("Stringified UUID is invalid");
            return r
          }(n)
        }
      },
      24440: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.JettonMaster = void 0;
        const n = r(1307);
        class i {
          static create(t) {
            return new i(t)
          }
          constructor(t) {
            this.address = t
          }
          async getWalletAddress(t, e) {
            return (await t.get("get_wallet_address", [{
              type: "slice",
              cell: (0, n.beginCell)().storeAddress(e).endCell()
            }])).stack.readAddress()
          }
          async getJettonData(t) {
            let e = await t.get("get_jetton_data", []);
            return {
              totalSupply: e.stack.readBigNumber(),
              mintable: e.stack.readBoolean(),
              adminAddress: e.stack.readAddress(),
              content: e.stack.readCell(),
              walletCode: e.stack.readCell()
            }
          }
        }
        e.JettonMaster = i
      },
      24493: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e) => new n(t, e).patch
      },
      24641: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^#?([0-9A-F]{3}|[0-9A-F]{4}|[0-9A-F]{6}|[0-9A-F]{8})$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      24989: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.padEnd = e.padStart = e.set = void 0;
        const n = r(65534);
        e.set = (t, e, r) => (0, n.concatBytes)([t.subarray(0, r), e, t.subarray(r + e.length)]), e.padStart = (t, e = 32) => {
          const r = new Uint8Array(Math.max(e - t.length, 0)).fill(0);
          return (0, n.concatBytes)([r, t])
        }, e.padEnd = (t, e = 32) => {
          const r = new Uint8Array(Math.max(e - t.length, 0)).fill(0);
          return (0, n.concatBytes)([t, r])
        }
      },
      25145: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.crypto = void 0, e.crypto = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0
      },
      25200: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => 0 >= n(t, e, r)
      },
      25382: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i = Object.keys || function(t) {
            var e = [];
            for (var r in t) e.push(r);
            return e
          };
        t.exports = f;
        var o = r(45412),
          s = r(16708);
        r(56698)(f, o);
        for (var a = i(s.prototype), u = 0; u < a.length; u++) {
          var c = a[u];
          f.prototype[c] || (f.prototype[c] = s.prototype[c])
        }

        function f(t) {
          if (!(this instanceof f)) return new f(t);
          o.call(this, t), s.call(this, t), this.allowHalfOpen = !0, t && (!1 === t.readable && (this.readable = !1), !1 === t.writable && (this.writable = !1), !1 === t.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", l)))
        }

        function l() {
          this.Wt.ended || n.nextTick(h, this)
        }

        function h(t) {
          t.end()
        }
        Object.defineProperty(f.prototype, "writableHighWaterMark", {
          enumerable: !1,
          get: function() {
            return this.Wt.highWaterMark
          }
        }), Object.defineProperty(f.prototype, "writableBuffer", {
          enumerable: !1,
          get: function() {
            return this.Wt && this.Wt.getBuffer()
          }
        }), Object.defineProperty(f.prototype, "writableLength", {
          enumerable: !1,
          get: function() {
            return this.Wt.length
          }
        }), Object.defineProperty(f.prototype, "destroyed", {
          enumerable: !1,
          get: function() {
            return void 0 !== this.rt && void 0 !== this.Wt && this.rt.destroyed && this.Wt.destroyed
          },
          set: function(t) {
            void 0 === this.rt || void 0 === this.Wt || (this.rt.destroyed = t, this.Wt.destroyed = t)
          }
        })
      },
      25748: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t) || s.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(bc1)[a-z0-9]{25,39}$/,
          s = /^(1|3)[A-HJ-NP-Za-km-z1-9]{25,39}$/;
        t.exports = e.default, t.exports.default = e.default
      },
      25767: (t, e, r) => {
        "use strict";
        var n = r(82682),
          i = r(39209),
          o = r(10487),
          s = r(36556),
          a = r(75795),
          u = r(93628),
          c = s("Object.prototype.toString"),
          f = r(49092)(),
          l = typeof globalThis > "u" ? r.g : globalThis,
          h = i(),
          d = s("String.prototype.slice"),
          p = s("Array.prototype.indexOf", !0) || function(t, e) {
            for (var r = 0; r < t.length; r += 1)
              if (t[r] === e) return r;
            return -1
          },
          b = {
            __proto__: null
          };
        n(h, f && a && u ? function(t) {
          var e = new l[t];
          if (Symbol.toStringTag in e && u) {
            var r = u(e),
              n = a(r, Symbol.toStringTag);
            if (!n && r) {
              var i = u(r);
              n = a(i, Symbol.toStringTag)
            }
            b["$" + t] = o(n.get)
          }
        } : function(t) {
          var e = new l[t],
            r = e.slice || e.set;
          r && (b["$" + t] = o(r))
        }), t.exports = function(t) {
          if (!t || "object" != typeof t) return !1;
          if (!f) {
            var e = d(c(t), 8, -1);
            return p(h, e) > -1 ? e : "Object" === e && function(t) {
              var e = !1;
              return n(b, function(r, n) {
                if (!e) try {
                  r(t), e = d(n, 1)
                } catch {}
              }), e
            }(t)
          }
          return a ? function(t) {
            var e = !1;
            return n(b, function(r, n) {
              if (!e) try {
                "$" + r(t) === n && (e = d(n, 1))
              } catch {}
            }), e
          }(t) : null
        }
      },
      26278: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.deserializeInternalKey = e.serializeInternalKey = void 0;
        const i = r(3512),
          o = r(62386),
          s = r(34382);
        e.serializeInternalKey = function(t) {
          if ("number" == typeof t) {
            if (!Number.isSafeInteger(t)) throw Error("Invalid key type: not a safe integer: " + t);
            return "n:" + t.toString(10)
          }
          if ("bigint" == typeof t) return "b:" + t.toString(10);
          if (i.Address.isAddress(t)) return "a:" + t.toString();
          if (n.isBuffer(t)) return "f:" + t.toString("hex");
          if (o.BitString.isBitString(t)) return "B:" + t.toString();
          throw Error("Invalid key type")
        }, e.deserializeInternalKey = function(t) {
          let e = t.slice(0, 2),
            r = t.slice(2);
          if ("n:" === e) return parseInt(r, 10);
          if ("b:" === e) return BigInt(r);
          if ("a:" === e) return i.Address.parse(r);
          if ("f:" === e) return n.from(r, "hex");
          if ("B:" === e) {
            const t = "_" == r.slice(-1);
            if (t || r.length % 2 != 0) {
              let e = t ? r.length - 1 : r.length;
              const i = r.substr(0, e) + "0";
              return !t && 1 & e ? new o.BitString(n.from(i, "hex"), 0, e << 2) : (0, s.paddedBufferToBits)(n.from(i, "hex"))
            }
            return new o.BitString(n.from(r, "hex"), 0, r.length << 2)
          }
          throw Error("Invalid key type: " + e)
        }
      },
      26513: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.secp256k1 = void 0;
        var n = r(67694);
        Object.defineProperty(e, "secp256k1", {
          enumerable: !0,
          get: function() {
            return n.secp256k1
          }
        })
      },
      26617: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), !!o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[A-HJ-NP-Za-km-z1-9]*$/;
        t.exports = e.default, t.exports.default = e.default
      },
      27322: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isWalletIdV5R1ClientContext = o, e.loadWalletIdV5R1 = function(t, e) {
          const r = new i.BitReader(new i.BitString("bigint" == typeof t ? n.from(t.toString(16), "hex") : t instanceof i.Slice ? t.loadBuffer(4) : t, 0, 32)).loadInt(32),
            o = BigInt(r) ^ BigInt(e),
            a = (0, i.beginCell)().storeInt(o, 32).endCell().beginParse();
          if (a.loadUint(1)) {
            const t = a.loadInt(8),
              r = a.loadUint(8),
              n = a.loadUint(15),
              i = Object.entries(s).find(([t, e]) => e === r)?.[0];
            if (void 0 === i) throw Error("Can't deserialize walletId: unknown wallet version " + r);
            return {
              networkGlobalId: e,
              context: {
                walletVersion: i,
                workchain: t,
                subwalletNumber: n
              }
            }
          }
          return {
            networkGlobalId: e,
            context: a.loadUint(31)
          }
        }, e.storeWalletIdV5R1 = function(t) {
          return e => {
            let r;
            return r = o(t.context) ? (0, i.beginCell)().storeUint(1, 1).storeInt(t.context.workchain, 8).storeUint(s[t.context.walletVersion], 8).storeUint(t.context.subwalletNumber, 15).endCell().beginParse().loadInt(32) : (0, i.beginCell)().storeUint(0, 1).storeUint(t.context, 31).endCell().beginParse().loadInt(32), e.storeInt(BigInt(t.networkGlobalId) ^ BigInt(r), 32)
          }
        };
        const i = r(1307);

        function o(t) {
          return "number" != typeof t
        }
        const s = {
          v5r1: 0
        }
      },
      27349: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), 0 === t.indexOf("magnet:?") && o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /(?:^magnet:\?|[^?&]&)xt(?:\.1)?=urn:(?:(?:aich|bitprint|btih|ed2k|ed2khash|kzhash|md5|sha1|tree:tiger):[a-z0-9]{32}(?:[a-z0-9]{8})?|btmh:1220[a-z0-9]{64})(?:$|&)/i;
        t.exports = e.default, t.exports.default = e.default
      },
      27563: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.shake256 = e.shake128 = e.keccak_512 = e.keccak_384 = e.keccak_256 = e.keccak_224 = e.sha3_512 = e.sha3_384 = e.sha3_256 = e.sha3_224 = e.Keccak = e.keccakP = void 0;
        const n = r(28021),
          i = r(96286),
          o = r(17412),
          s = [],
          a = [],
          u = [],
          c = BigInt(0),
          f = BigInt(1),
          l = BigInt(2),
          h = BigInt(7),
          d = BigInt(256),
          p = BigInt(113);
        for (let t = 0, e = f, r = 1, n = 0; 24 > t; t++) {
          [r, n] = [n, (2 * r + 3 * n) % 5], s.push(2 * (5 * n + r)), a.push((t + 1) * (t + 2) / 2 % 64);
          let i = c;
          for (let t = 0; 7 > t; t++) e = (e << f ^ (e >> h) * p) % d, e & l && (i ^= f << (f << BigInt(t)) - f);
          u.push(i)
        }
        const [b, m] = (0, i.split)(u, !0), y = (t, e, r) => r > 32 ? (0, i.rotlBH)(t, e, r) : (0, i.rotlSH)(t, e, r), g = (t, e, r) => r > 32 ? (0, i.rotlBL)(t, e, r) : (0, i.rotlSL)(t, e, r);

        function v(t, e = 24) {
          const r = new Uint32Array(10);
          for (let n = 24 - e; 24 > n; n++) {
            for (let e = 0; 10 > e; e++) r[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
            for (let e = 0; 10 > e; e += 2) {
              const n = (e + 8) % 10,
                i = (e + 2) % 10,
                o = r[i],
                s = r[i + 1],
                a = y(o, s, 1) ^ r[n],
                u = g(o, s, 1) ^ r[n + 1];
              for (let r = 0; 50 > r; r += 10) t[e + r] ^= a, t[e + r + 1] ^= u
            }
            let e = t[2],
              i = t[3];
            for (let r = 0; 24 > r; r++) {
              const n = a[r],
                o = y(e, i, n),
                u = g(e, i, n),
                c = s[r];
              e = t[c], i = t[c + 1], t[c] = o, t[c + 1] = u
            }
            for (let e = 0; 50 > e; e += 10) {
              for (let n = 0; 10 > n; n++) r[n] = t[e + n];
              for (let n = 0; 10 > n; n++) t[e + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10]
            }
            t[0] ^= b[n], t[1] ^= m[n]
          }
          r.fill(0)
        }
        e.keccakP = v;
        class w extends o.Hash {
          constructor(t, e, r, i = !1, s = 24) {
            if (super(), this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, (0, n.number)(r), 0 >= this.blockLen || this.blockLen >= 200) throw Error("Sha3 supports only keccak-f1600 function");
            this.state = new Uint8Array(200), this.state32 = (0, o.u32)(this.state)
          }
          keccak() {
            o.isLE || (0, o.byteSwap32)(this.state32), v(this.state32, this.rounds), o.isLE || (0, o.byteSwap32)(this.state32), this.posOut = 0, this.pos = 0
          }
          update(t) {
            (0, n.exists)(this);
            const {
              blockLen: e,
              state: r
            } = this, i = (t = (0, o.toBytes)(t)).length;
            for (let n = 0; i > n;) {
              const o = Math.min(e - this.pos, i - n);
              for (let e = 0; o > e; e++) r[this.pos++] ^= t[n++];
              this.pos === e && this.keccak()
            }
            return this
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const {
              state: t,
              suffix: e,
              pos: r,
              blockLen: n
            } = this;
            t[r] ^= e, !!(128 & e) && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak()
          }
          writeInto(t) {
            (0, n.exists)(this, !1), (0, n.bytes)(t), this.finish();
            const e = this.state,
              {
                blockLen: r
              } = this;
            for (let n = 0, i = t.length; i > n;) {
              this.posOut >= r && this.keccak();
              const o = Math.min(r - this.posOut, i - n);
              t.set(e.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o
            }
            return t
          }
          xofInto(t) {
            if (!this.enableXOF) throw Error("XOF is not possible for this instance");
            return this.writeInto(t)
          }
          xof(t) {
            return (0, n.number)(t), this.xofInto(new Uint8Array(t))
          }
          digestInto(t) {
            if ((0, n.output)(t, this), this.finished) throw Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
          }
          destroy() {
            this.destroyed = !0, this.state.fill(0)
          }
          jt(t) {
            const {
              blockLen: e,
              suffix: r,
              outputLen: n,
              rounds: i,
              enableXOF: o
            } = this;
            return t || (t = new w(e, r, n, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = r, t.outputLen = n, t.enableXOF = o, t.destroyed = this.destroyed, t
          }
        }
        e.Keccak = w;
        const A = (t, e, r) => (0, o.wrapConstructor)(() => new w(e, t, r));
        e.sha3_224 = A(6, 144, 28), e.sha3_256 = A(6, 136, 32), e.sha3_384 = A(6, 104, 48), e.sha3_512 = A(6, 72, 64), e.keccak_224 = A(1, 144, 28), e.keccak_256 = A(1, 136, 32), e.keccak_384 = A(1, 104, 48), e.keccak_512 = A(1, 72, 64);
        const T = (t, e, r) => (0, o.wrapXOFConstructorWithOpts)((n = {}) => new w(e, t, void 0 === n.dkLen ? r : n.dkLen, !0));
        e.shake128 = T(31, 168, 16), e.shake256 = T(31, 136, 32)
      },
      27717: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, i.default)(t);
          var e = +t.slice(-1);
          return a.test(t) && e === function(t) {
            var e = 10 - t.slice(0, -1).split("").map(function(e, r) {
              return +e * function(t, e) {
                return t === o || t === s ? e % 2 == 0 ? 3 : 1 : e % 2 == 0 ? 1 : 3
              }(t.length, r)
            }).reduce(function(t, e) {
              return t + e
            }, 0) % 10;
            return 10 > e ? e : 0
          }(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = 8,
          s = 14,
          a = /^(\d{8}|\d{13}|\d{14})$/;
        t.exports = e.default, t.exports.default = e.default
      },
      27754: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.StructError = void 0, e.StructError = class extends TypeError {
          constructor(t, e) {
            let r;
            const {
              message: n,
              explanation: i,
              ...o
            } = t, {
              path: s
            } = t, a = 0 === s.length ? n : `At path: ${s.join(".")} -- ${n}`;
            super(i ?? a), null != i && (this.cause = a), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => r ?? (r = [t, ...e()])
          }
        }
      },
      28021: (t, e) => {
        "use strict";

        function r(t) {
          if (!Number.isSafeInteger(t) || 0 > t) throw Error("positive integer expected, not " + t)
        }

        function n(t) {
          if ("boolean" != typeof t) throw Error("boolean expected, not " + t)
        }

        function i(t) {
          return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
        }

        function o(t, ...e) {
          if (!i(t)) throw Error("Uint8Array expected");
          if (e.length > 0 && !e.includes(t.length)) throw Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)
        }

        function s(t) {
          if ("function" != typeof t || "function" != typeof t.create) throw Error("Hash should be wrapped by utils.wrapConstructor");
          r(t.outputLen), r(t.blockLen)
        }

        function a(t, e = !0) {
          if (t.destroyed) throw Error("Hash instance has been destroyed");
          if (e && t.finished) throw Error("Hash#digest() has already been called")
        }

        function u(t, e) {
          o(t);
          const r = e.outputLen;
          if (t.length < r) throw Error("digestInto() expects output buffer of length at least " + r)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.output = e.exists = e.hash = e.bytes = e.bool = e.number = e.isBytes = void 0, e.number = r, e.bool = n, e.isBytes = i, e.bytes = o, e.hash = s, e.exists = a, e.output = u;
        const c = {
          number: r,
          bool: n,
          bytes: o,
          hash: s,
          exists: a,
          output: u
        };
        e.default = c
      },
      28078: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ElectorContract = void 0;
        const i = r(1307),
          o = {
            serialize(t, e) {
              throw Error("not implemented")
            },
            parse: t => ({
              address: new i.Address(-1, t.loadBuffer(32)),
              weight: t.loadUintBig(64),
              stake: t.loadCoins()
            })
          },
          s = {
            serialize(t, e) {
              throw Error("not implemented")
            },
            parse(t) {
              const e = t.loadCoins();
              return t.skip(64), {
                stake: e,
                address: new i.Address(-1, t.loadBuffer(32)),
                adnl: t.loadBuffer(32)
              }
            }
          };
        class a {
          static create() {
            return new a
          }
          constructor() {
            this.address = i.Address.parseRaw("-1:3333333333333333333333333333333333333333333333333333333333333333")
          }
          async getReturnedStake(t, e) {
            if (-1 !== e.workChain) throw Error("Only masterchain addresses could have stake");
            return (await t.get("compute_returned_stake", [{
              type: "int",
              value: BigInt("0x" + e.hash.toString("hex"))
            }])).stack.readBigNumber()
          }
          async getPastElectionsList(t) {
            const e = await t.get("past_elections_list", []),
              r = new i.TupleReader(e.stack.readLispList()),
              n = [];
            for (; r.remaining > 0;) {
              const t = r.readTuple(),
                e = t.readNumber(),
                i = t.readNumber();
              t.pop();
              const o = t.readNumber();
              n.push({
                id: e,
                unfreezeAt: i,
                stakeHeld: o
              })
            }
            return n
          }
          async getPastElections(t) {
            const e = await t.get("past_elections", []),
              r = new i.TupleReader(e.stack.readLispList()),
              n = [];
            for (; r.remaining > 0;) {
              const t = r.readTuple(),
                e = t.readNumber(),
                s = t.readNumber(),
                a = t.readNumber();
              t.pop();
              const u = t.readCell(),
                c = t.readBigNumber(),
                f = t.readBigNumber();
              let l = new Map;
              const h = u.beginParse().loadDictDirect(i.Dictionary.Keys.Buffer(32), o);
              for (const [t, e] of h) l.set(BigInt("0x" + t.toString("hex")).toString(10), {
                address: e.address,
                weight: e.weight,
                stake: e.stake
              });
              n.push({
                id: e,
                unfreezeAt: s,
                stakeHeld: a,
                totalStake: c,
                bonuses: f,
                frozen: l
              })
            }
            return n
          }
          async getElectionEntities(t) {
            const e = await t.getState();
            if ("active" !== e.state.type) throw Error("Unexpected error");
            const r = i.Cell.fromBoc(e.state.data)[0].beginParse();
            if (!r.loadBit()) return null;
            const n = r.loadRef().beginParse(),
              o = n.loadUint(32),
              a = n.loadUint(32),
              u = n.loadCoins(),
              c = n.loadCoins(),
              f = n.loadDict(i.Dictionary.Keys.Buffer(32), s);
            let l = [];
            if (f)
              for (const [t, e] of f) l.push({
                pubkey: t,
                stake: e.stake,
                address: e.address,
                adnl: e.adnl
              });
            return {
              minStake: u,
              allStakes: c,
              endElectionsTime: a,
              startWorkTime: o,
              entities: l
            }
          }
          async getActiveElectionId(t) {
            const e = (await t.get("active_election_id", [])).stack.readNumber();
            return e > 0 ? e : null
          }
          async getComplaints(t, e) {
            const r = new i.TupleBuilder;
            r.writeNumber(e);
            const o = await t.get("list_complaints", r.build());
            if ("null" === o.stack.peek().type) return [];
            const s = new i.TupleReader(o.stack.readLispList()),
              a = [];
            for (; s.remaining > 0;) {
              const t = s.readTuple(),
                e = t.readBigNumber(),
                r = t.readTuple(),
                o = r.readTuple(),
                u = n.from(o.readBigNumber().toString(16), "hex"),
                c = (o.readCell(), o.readNumber()),
                f = o.readNumber(),
                l = new i.Address(-1, n.from(o.readBigNumber().toString(16), "hex")),
                h = o.readBigNumber(),
                d = o.readBigNumber(),
                p = o.readBigNumber(),
                b = [],
                m = new i.TupleReader(r.readLispList());
              for (; m.remaining > 0;) b.push(m.readNumber());
              const y = r.readBigNumber(),
                g = r.readBigNumber();
              a.push({
                id: e,
                publicKey: u,
                createdAt: c,
                severity: f,
                paid: h,
                suggestedFine: d,
                suggestedFinePart: p,
                rewardAddress: l,
                votes: b,
                remainingWeight: g,
                vsetId: y
              })
            }
            return a
          }
        }
        e.ElectorContract = a
      },
      28399: (t, e, r) => {
        (e = t.exports = r(45412)).Stream = e, e.Readable = e, e.Writable = r(16708), e.Duplex = r(25382), e.Transform = r(74610), e.PassThrough = r(63600), e.finished = r(86238), e.pipeline = r(57758)
      },
      28481: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.normalize = e.concatSig = void 0, i(r(78371), e), i(r(12458), e), i(r(73604), e);
        var o = r(43007);
        Object.defineProperty(e, "concatSig", {
          enumerable: !0,
          get: function() {
            return o.concatSig
          }
        }), Object.defineProperty(e, "normalize", {
          enumerable: !0,
          get: function() {
            return o.normalize
          }
        })
      },
      28651: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ZodError = e.quotelessJson = e.ZodIssueCode = void 0;
        const n = r(92034);
        e.ZodIssueCode = n.util.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), e.quotelessJson = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
        class i extends Error {
          get errors() {
            return this.issues
          }
          constructor(t) {
            super(), this.issues = [], this.addIssue = t => {
              this.issues = [...this.issues, t]
            }, this.addIssues = (t = []) => {
              this.issues = [...this.issues, ...t]
            };
            const e = new.target.prototype;
            Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = t
          }
          format(t) {
            const e = t || function(t) {
                return t.message
              },
              r = {
                Te: []
              },
              n = t => {
                for (const i of t.issues)
                  if ("invalid_union" === i.code) i.unionErrors.map(n);
                  else if ("invalid_return_type" === i.code) n(i.returnTypeError);
                else if ("invalid_arguments" === i.code) n(i.argumentsError);
                else if (0 === i.path.length) r.Te.push(e(i));
                else {
                  let t = r,
                    n = 0;
                  for (; n < i.path.length;) {
                    const r = i.path[n];
                    n === i.path.length - 1 ? (t[r] = t[r] || {
                      Te: []
                    }, t[r].Te.push(e(i))) : t[r] = t[r] || {
                      Te: []
                    }, t = t[r], n++
                  }
                }
              };
            return n(this), r
          }
          static assert(t) {
            if (!(t instanceof i)) throw Error("Not a ZodError: " + t)
          }
          toString() {
            return this.message
          }
          get message() {
            return JSON.stringify(this.issues, n.util.jsonStringifyReplacer, 2)
          }
          get isEmpty() {
            return 0 === this.issues.length
          }
          flatten(t = t => t.message) {
            const e = {},
              r = [];
            for (const n of this.issues)
              if (n.path.length > 0) {
                const r = n.path[0];
                e[r] = e[r] || [], e[r].push(t(n))
              } else r.push(t(n));
            return {
              formErrors: r,
              fieldErrors: e
            }
          }
          get formErrors() {
            return this.flatten()
          }
        }
        e.ZodError = i, i.create = t => new i(t)
      },
      28784: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV3R2 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey, t.walletId)
          }
          constructor(t, e, r) {
            this.workchain = t, this.publicKey = e, this.walletId = null != r ? r : 698983191 + t;
            let o = i.Cell.fromBoc(n.from("te6cckEBAQEAcQAA3v8AIN0gggFMl7ohggEznLqxn3Gw7UTQ0x/THzHXC//jBOCk8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVBC9ba0=", "base64"))[0],
              s = (0, i.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(e).endCell();
            this.init = {
              code: o,
              data: s
            }, this.address = (0, i.contractAddress)(t, {
              code: o,
              data: s
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            return (0, o.createWalletTransferV3)({
              ...t,
              sendMode: t.sendMode ?? i.SendMode.PAY_GAS_SEPARATELY,
              walletId: this.walletId
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV3R2 = s
      },
      28875: (t, e, r) => {
        "use strict";
        var n;
        if (!Object.keys) {
          var i = {}.hasOwnProperty,
            o = {}.toString,
            s = r(1093),
            a = {}.propertyIsEnumerable,
            u = !a.call({
              toString: null
            }, "toString"),
            c = a.call(function() {}, "prototype"),
            f = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"],
            l = function(t) {
              var e = t.constructor;
              return e && e.prototype === t
            },
            h = {
              $applicationCache: !0,
              $console: !0,
              $external: !0,
              $frame: !0,
              $frameElement: !0,
              $frames: !0,
              $innerHeight: !0,
              $innerWidth: !0,
              $onmozfullscreenchange: !0,
              $onmozfullscreenerror: !0,
              $outerHeight: !0,
              $outerWidth: !0,
              $pageXOffset: !0,
              $pageYOffset: !0,
              $parent: !0,
              $scrollLeft: !0,
              $scrollTop: !0,
              $scrollX: !0,
              $scrollY: !0,
              $self: !0,
              $webkitIndexedDB: !0,
              $webkitStorageInfo: !0,
              $window: !0
            },
            d = function() {
              if (typeof window > "u") return !1;
              for (var t in window) try {
                if (!h["$" + t] && i.call(window, t) && null !== window[t] && "object" == typeof window[t]) try {
                  l(window[t])
                } catch {
                  return !0
                }
              } catch {
                return !0
              }
              return !1
            }();
          n = function(t) {
            var e = null !== t && "object" == typeof t,
              r = "[object Function]" === o.call(t),
              n = s(t),
              a = e && "[object String]" === o.call(t),
              h = [];
            if (!e && !r && !n) throw new TypeError("Object.keys called on a non-object");
            var p = c && r;
            if (a && t.length > 0 && !i.call(t, 0))
              for (var b = 0; b < t.length; ++b) h.push(b + "");
            if (n && t.length > 0)
              for (var m = 0; m < t.length; ++m) h.push(m + "");
            else
              for (var y in t)(!p || "prototype" !== y) && i.call(t, y) && h.push(y + "");
            if (u)
              for (var g = function(t) {
                  if (typeof window > "u" || !d) return l(t);
                  try {
                    return l(t)
                  } catch {
                    return !1
                  }
                }(t), v = 0; f.length > v; ++v)(!g || "constructor" !== f[v]) && i.call(t, f[v]) && h.push(f[v]);
            return h
          }
        }
        t.exports = n
      },
      28993: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeShardAccounts = e.loadShardAccounts = e.ShardAccountRefValue = void 0;
        const n = r(97590),
          i = r(84458),
          o = r(30594);
        e.ShardAccountRefValue = {
          parse: t => ({
            depthBalanceInfo: (0, i.loadDepthBalanceInfo)(t),
            shardAccount: (0, o.loadShardAccount)(t)
          }),
          serialize(t, e) {
            e.store((0, i.storeDepthBalanceInfo)(t.depthBalanceInfo)), e.store((0, o.storeShardAccount)(t.shardAccount))
          }
        }, e.loadShardAccounts = function(t) {
          return n.Dictionary.load(n.Dictionary.Keys.BigUint(256), e.ShardAccountRefValue, t)
        }, e.storeShardAccounts = function(t) {
          return e => {
            e.storeDict(t)
          }
        }
      },
      29039: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.loadMasterchainStateExtra = void 0;
        const n = r(97590),
          i = r(10574);
        e.loadMasterchainStateExtra = function(t) {
          if (52262 !== t.loadUint(16)) throw Error("Invalid data");
          t.loadBit() && t.loadRef();
          let e = t.loadUintBig(256);
          return {
            config: n.Dictionary.load(n.Dictionary.Keys.Int(32), n.Dictionary.Values.Cell(), t),
            configAddress: e,
            globalBalance: (0, i.loadCurrencyCollection)(t)
          }
        }
      },
      29094: (t, e, r) => {
        var n, i = "u" > typeof globalThis && globalThis || "u" > typeof self && self || "u" > typeof r.g && r.g,
          o = function() {
            function t() {
              this.fetch = !1, this.DOMException = i.DOMException
            }
            return t.prototype = i, new t
          }();
        n = o,
          function(t) {
            var e = "u" > typeof n && n || "u" > typeof self && self || "u" > typeof r.g && r.g || {},
              i = "URLSearchParams" in e,
              o = "Symbol" in e && "iterator" in Symbol,
              s = "FileReader" in e && "Blob" in e && function() {
                try {
                  return new Blob, !0
                } catch {
                  return !1
                }
              }(),
              a = "FormData" in e,
              u = "ArrayBuffer" in e;
            if (u) var c = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"],
              f = ArrayBuffer.isView || function(t) {
                return t && c.indexOf({}.toString.call(t)) > -1
              };

            function l(t) {
              if ("string" != typeof t && (t += ""), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(t) || "" === t) throw new TypeError('Invalid character in header field name: "' + t + '"');
              return t.toLowerCase()
            }

            function h(t) {
              return "string" != typeof t && (t += ""), t
            }

            function d(t) {
              var e = {
                next: function() {
                  var e = t.shift();
                  return {
                    done: void 0 === e,
                    value: e
                  }
                }
              };
              return o && (e[Symbol.iterator] = function() {
                return e
              }), e
            }

            function p(t) {
              this.map = {}, t instanceof p ? t.forEach(function(t, e) {
                this.append(e, t)
              }, this) : Array.isArray(t) ? t.forEach(function(t) {
                if (2 != t.length) throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + t.length);
                this.append(t[0], t[1])
              }, this) : t && Object.getOwnPropertyNames(t).forEach(function(e) {
                this.append(e, t[e])
              }, this)
            }

            function b(t) {
              if (!t.Ee) {
                if (t.bodyUsed) return Promise.reject(new TypeError("Already read"));
                t.bodyUsed = !0
              }
            }

            function m(t) {
              return new Promise(function(e, r) {
                t.onload = function() {
                  e(t.result)
                }, t.onerror = function() {
                  r(t.error)
                }
              })
            }

            function y(t) {
              var e = new FileReader,
                r = m(e);
              return e.readAsArrayBuffer(t), r
            }

            function g(t) {
              if (t.slice) return t.slice(0);
              var e = new Uint8Array(t.byteLength);
              return e.set(new Uint8Array(t)), e.buffer
            }

            function v() {
              return this.bodyUsed = !1, this.Pe = function(t) {
                this.bodyUsed = this.bodyUsed, this.xe = t, t ? "string" == typeof t ? this.Ie = t : s && Blob.prototype.isPrototypeOf(t) ? this.Se = t : a && FormData.prototype.isPrototypeOf(t) ? this.Oe = t : i && URLSearchParams.prototype.isPrototypeOf(t) ? this.Ie = t.toString() : u && s && function(t) {
                  return t && DataView.prototype.isPrototypeOf(t)
                }(t) ? (this.Be = g(t.buffer), this.xe = new Blob([this.Be])) : u && (ArrayBuffer.prototype.isPrototypeOf(t) || f(t)) ? this.Be = g(t) : this.Ie = t = {}.toString.call(t) : (this.Ee = !0, this.Ie = ""), this.headers.get("content-type") || ("string" == typeof t ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this.Se && this.Se.type ? this.headers.set("content-type", this.Se.type) : i && URLSearchParams.prototype.isPrototypeOf(t) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
              }, s && (this.blob = function() {
                var t = b(this);
                if (t) return t;
                if (this.Se) return Promise.resolve(this.Se);
                if (this.Be) return Promise.resolve(new Blob([this.Be]));
                if (this.Oe) throw Error("could not read FormData body as blob");
                return Promise.resolve(new Blob([this.Ie]))
              }), this.arrayBuffer = function() {
                if (this.Be) return b(this) || (ArrayBuffer.isView(this.Be) ? Promise.resolve(this.Be.buffer.slice(this.Be.byteOffset, this.Be.byteOffset + this.Be.byteLength)) : Promise.resolve(this.Be));
                if (s) return this.blob().then(y);
                throw Error("could not read as ArrayBuffer")
              }, this.text = function() {
                var t = b(this);
                if (t) return t;
                if (this.Se) return function(t) {
                  var e = new FileReader,
                    r = m(e),
                    n = /charset=([A-Za-z0-9_-]+)/.exec(t.type),
                    i = n ? n[1] : "utf-8";
                  return e.readAsText(t, i), r
                }(this.Se);
                if (this.Be) return Promise.resolve(function(t) {
                  for (var e = new Uint8Array(t), r = Array(e.length), n = 0; n < e.length; n++) r[n] = String.fromCharCode(e[n]);
                  return r.join("")
                }(this.Be));
                if (this.Oe) throw Error("could not read FormData body as text");
                return Promise.resolve(this.Ie)
              }, a && (this.formData = function() {
                return this.text().then(T)
              }), this.json = function() {
                return this.text().then(JSON.parse)
              }, this
            }
            p.prototype.append = function(t, e) {
              t = l(t), e = h(e);
              var r = this.map[t];
              this.map[t] = r ? r + ", " + e : e
            }, p.prototype.delete = function(t) {
              delete this.map[l(t)]
            }, p.prototype.get = function(t) {
              return t = l(t), this.has(t) ? this.map[t] : null
            }, p.prototype.has = function(t) {
              return this.map.hasOwnProperty(l(t))
            }, p.prototype.set = function(t, e) {
              this.map[l(t)] = h(e)
            }, p.prototype.forEach = function(t, e) {
              for (var r in this.map) this.map.hasOwnProperty(r) && t.call(e, this.map[r], r, this)
            }, p.prototype.keys = function() {
              var t = [];
              return this.forEach(function(e, r) {
                t.push(r)
              }), d(t)
            }, p.prototype.values = function() {
              var t = [];
              return this.forEach(function(e) {
                t.push(e)
              }), d(t)
            }, p.prototype.entries = function() {
              var t = [];
              return this.forEach(function(e, r) {
                t.push([r, e])
              }), d(t)
            }, o && (p.prototype[Symbol.iterator] = p.prototype.entries);
            var w = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "PATCH", "POST", "PUT", "TRACE"];

            function A(t, r) {
              if (!(this instanceof A)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              var n = (r = r || {}).body;
              if (t instanceof A) {
                if (t.bodyUsed) throw new TypeError("Already read");
                this.url = t.url, this.credentials = t.credentials, r.headers || (this.headers = new p(t.headers)), this.method = t.method, this.mode = t.mode, this.signal = t.signal, !n && null != t.xe && (n = t.xe, t.bodyUsed = !0)
              } else this.url = t + "";
              if (this.credentials = r.credentials || this.credentials || "same-origin", (r.headers || !this.headers) && (this.headers = new p(r.headers)), this.method = function(t) {
                  var e = t.toUpperCase();
                  return w.indexOf(e) > -1 ? e : t
                }(r.method || this.method || "GET"), this.mode = r.mode || this.mode || null, this.signal = r.signal || this.signal || function() {
                  if ("AbortController" in e) return (new AbortController).signal
                }(), this.referrer = null, ("GET" === this.method || "HEAD" === this.method) && n) throw new TypeError("Body not allowed for GET or HEAD requests");
              if (this.Pe(n), !("GET" !== this.method && "HEAD" !== this.method || "no-store" !== r.cache && "no-cache" !== r.cache)) {
                var i = /([?&])_=[^&]*/;
                i.test(this.url) ? this.url = this.url.replace(i, "$1_=" + (new Date).getTime()) : this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (new Date).getTime()
              }
            }

            function T(t) {
              var e = new FormData;
              return t.trim().split("&").forEach(function(t) {
                if (t) {
                  var r = t.split("="),
                    n = r.shift().replace(/\+/g, " "),
                    i = r.join("=").replace(/\+/g, " ");
                  e.append(decodeURIComponent(n), decodeURIComponent(i))
                }
              }), e
            }

            function E(t) {
              var e = new p;
              return t.replace(/\r?\n[\t ]+/g, " ").split("\r").map(function(t) {
                return 0 === t.indexOf("\n") ? t.substr(1, t.length) : t
              }).forEach(function(t) {
                var r = t.split(":"),
                  n = r.shift().trim();
                if (n) {
                  var i = r.join(":").trim();
                  try {
                    e.append(n, i)
                  } catch (t) {
                    console.warn("Response " + t.message)
                  }
                }
              }), e
            }

            function P(t, e) {
              if (!(this instanceof P)) throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
              if (e || (e = {}), this.type = "default", this.status = void 0 === e.status ? 200 : e.status, 200 > this.status || this.status > 599) throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
              this.ok = this.status >= 200 && 300 > this.status, this.statusText = void 0 === e.statusText ? "" : "" + e.statusText, this.headers = new p(e.headers), this.url = e.url || "", this.Pe(t)
            }
            A.prototype.clone = function() {
              return new A(this, {
                body: this.xe
              })
            }, v.call(A.prototype), v.call(P.prototype), P.prototype.clone = function() {
              return new P(this.xe, {
                status: this.status,
                statusText: this.statusText,
                headers: new p(this.headers),
                url: this.url
              })
            }, P.error = function() {
              var t = new P(null, {
                status: 200,
                statusText: ""
              });
              return t.ok = !1, t.status = 0, t.type = "error", t
            };
            var k = [301, 302, 303, 307, 308];
            P.redirect = function(t, e) {
              if (-1 === k.indexOf(e)) throw new RangeError("Invalid status code");
              return new P(null, {
                status: e,
                headers: {
                  location: t
                }
              })
            }, t.DOMException = e.DOMException;
            try {
              new t.DOMException
            } catch {
              t.DOMException = function(t, e) {
                this.message = t, this.name = e;
                var r = Error(t);
                this.stack = r.stack
              }, t.DOMException.prototype = Object.create(Error.prototype), t.DOMException.prototype.constructor = t.DOMException
            }

            function x(r, n) {
              return new Promise(function(i, o) {
                var a = new A(r, n);
                if (a.signal && a.signal.aborted) return o(new t.DOMException("Aborted", "AbortError"));
                var c = new XMLHttpRequest;

                function f() {
                  c.abort()
                }
                if (c.onload = function() {
                    var t = {
                      statusText: c.statusText,
                      headers: E(c.getAllResponseHeaders() || "")
                    };
                    0 === a.url.indexOf("file://") && (200 > c.status || c.status > 599) ? t.status = 200 : t.status = c.status, t.url = "responseURL" in c ? c.responseURL : t.headers.get("X-Request-URL");
                    var e = "response" in c ? c.response : c.responseText;
                    setTimeout(function() {
                      i(new P(e, t))
                    }, 0)
                  }, c.onerror = function() {
                    setTimeout(function() {
                      o(new TypeError("Network request failed"))
                    }, 0)
                  }, c.ontimeout = function() {
                    setTimeout(function() {
                      o(new TypeError("Network request timed out"))
                    }, 0)
                  }, c.onabort = function() {
                    setTimeout(function() {
                      o(new t.DOMException("Aborted", "AbortError"))
                    }, 0)
                  }, c.open(a.method, function(t) {
                    try {
                      return "" === t && e.location.href ? e.location.href : t
                    } catch {
                      return t
                    }
                  }(a.url), !0), "include" === a.credentials ? c.withCredentials = !0 : "omit" === a.credentials && (c.withCredentials = !1), "responseType" in c && (s ? c.responseType = "blob" : u && (c.responseType = "arraybuffer")), n && "object" == typeof n.headers && !(n.headers instanceof p || e.Headers && n.headers instanceof e.Headers)) {
                  var d = [];
                  Object.getOwnPropertyNames(n.headers).forEach(function(t) {
                    d.push(l(t)), c.setRequestHeader(t, h(n.headers[t]))
                  }), a.headers.forEach(function(t, e) {
                    -1 === d.indexOf(e) && c.setRequestHeader(e, t)
                  })
                } else a.headers.forEach(function(t, e) {
                  c.setRequestHeader(e, t)
                });
                a.signal && (a.signal.addEventListener("abort", f), c.onreadystatechange = function() {
                  4 === c.readyState && a.signal.removeEventListener("abort", f)
                }), c.send(typeof a.xe > "u" ? null : a.xe)
              })
            }
            x.polyfill = !0, e.fetch || (e.fetch = x, e.Headers = p, e.Request = A, e.Response = P), t.Headers = p, t.Request = A, t.Response = P, t.fetch = x
          }({}), o.fetch.ponyfill = !0, delete o.fetch.polyfill;
        var s = i.fetch ? i : o;
        (e = s.fetch).default = s.fetch, e.fetch = s.fetch, e.Headers = s.Headers, e.Request = s.Request, e.Response = s.Response, t.exports = e
      },
      29107: t => {
        "use strict";
        const e = Symbol.for("nodejs.util.inspect.custom");
        t.exports = e
      },
      29172: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, n.default)(t);
          var e = t.split(".");
          return 3 === e.length && e.reduce(function(t, e) {
            return t && (0, i.default)(e, {
              urlSafe: !0
            })
          }, !0)
        };
        var n = o(r(83399)),
          i = o(r(98274));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      29285: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          var r, n;
          (0, i.default)(t), "object" === o(e) ? (r = e.min || 0, n = e.max) : (r = arguments[1] || 0, n = arguments[2]);
          var s = t.match(/(\uFE0F|\uFE0E)/g) || [],
            a = t.match(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g) || [],
            u = t.length - s.length - a.length;
          return u >= r && (typeof n > "u" || n >= u)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };

        function o(t) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        t.exports = e.default, t.exports.default = e.default
      },
      29368: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.exoticLibrary = void 0;
        const n = r(53528);
        e.exoticLibrary = function(t, e) {
          const r = new n.BitReader(t);
          if (264 !== t.length) throw Error(`Library cell must have exactly (8 + 256) bits, got "${t.length}"`);
          let i = r.loadUint(8);
          if (2 !== i) throw Error(`Library cell must have type 2, got "${i}"`);
          return {}
        }
      },
      29429: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.crc32c = void 0;
        const i = 2197175160;
        e.crc32c = function(t) {
          let e = -1;
          for (let r = 0; r < t.length; r++) e ^= t[r], e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1, e = 1 & e ? e >>> 1 ^ i : e >>> 1;
          e ^= 4294967295;
          let r = n.alloc(4);
          return r.writeInt32LE(e), r
        }
      },
      29666: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        }, e.fullWidth = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /[^\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        e.fullWidth = o
      },
      30041: (t, e, r) => {
        "use strict";
        var n = r(30655),
          i = r(58068),
          o = r(69675),
          s = r(75795);
        t.exports = function(t, e, r) {
          if (!t || "object" != typeof t && "function" != typeof t) throw new o("`obj` must be an object or a function`");
          if ("string" != typeof e && "symbol" != typeof e) throw new o("`property` must be a string or a symbol`");
          if (arguments.length > 3 && "boolean" != typeof arguments[3] && null !== arguments[3]) throw new o("`nonEnumerable`, if provided, must be a boolean or null");
          if (arguments.length > 4 && "boolean" != typeof arguments[4] && null !== arguments[4]) throw new o("`nonWritable`, if provided, must be a boolean or null");
          if (arguments.length > 5 && "boolean" != typeof arguments[5] && null !== arguments[5]) throw new o("`nonConfigurable`, if provided, must be a boolean or null");
          if (arguments.length > 6 && "boolean" != typeof arguments[6]) throw new o("`loose`, if provided, must be a boolean");
          var a = arguments.length > 3 ? arguments[3] : null,
            u = arguments.length > 4 ? arguments[4] : null,
            c = arguments.length > 5 ? arguments[5] : null,
            f = arguments.length > 6 && arguments[6],
            l = !!s && s(t, e);
          if (n) n(t, e, {
            configurable: null === c && l ? l.configurable : !c,
            enumerable: null === a && l ? l.enumerable : !a,
            value: r,
            writable: null === u && l ? l.writable : !u
          });
          else {
            if (!f && (a || u || c)) throw new i("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
            t[e] = r
          }
        }
      },
      30121: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("TronWebProto.ExchangeCreateContract", null, o), i.exportSymbol("TronWebProto.ExchangeInjectContract", null, o), i.exportSymbol("TronWebProto.ExchangeTransactionContract", null, o), i.exportSymbol("TronWebProto.ExchangeWithdrawContract", null, o), TronWebProto.ExchangeCreateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ExchangeCreateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ExchangeCreateContract.displayName = "TronWebProto.ExchangeCreateContract"), TronWebProto.ExchangeInjectContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ExchangeInjectContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ExchangeInjectContract.displayName = "TronWebProto.ExchangeInjectContract"), TronWebProto.ExchangeWithdrawContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ExchangeWithdrawContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ExchangeWithdrawContract.displayName = "TronWebProto.ExchangeWithdrawContract"), TronWebProto.ExchangeTransactionContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ExchangeTransactionContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ExchangeTransactionContract.displayName = "TronWebProto.ExchangeTransactionContract"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeCreateContract.prototype.toObject = function(t) {
          return TronWebProto.ExchangeCreateContract.toObject(t, this)
        }, TronWebProto.ExchangeCreateContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            firstTokenId: e.getFirstTokenId_asB64(),
            firstTokenBalance: n.Message.getFieldWithDefault(e, 3, 0),
            secondTokenId: e.getSecondTokenId_asB64(),
            secondTokenBalance: n.Message.getFieldWithDefault(e, 5, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ExchangeCreateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ExchangeCreateContract;
          return TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ExchangeCreateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setFirstTokenId(r);
              break;
            case 3:
              r = e.readInt64(), t.setFirstTokenBalance(r);
              break;
            case 4:
              r = e.readBytes(), t.setSecondTokenId(r);
              break;
            case 5:
              r = e.readInt64(), t.setSecondTokenBalance(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ExchangeCreateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ExchangeCreateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ExchangeCreateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getFirstTokenId_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getFirstTokenBalance()) && e.writeInt64(3, r), (r = t.getSecondTokenId_asU8()).length > 0 && e.writeBytes(4, r), 0 !== (r = t.getSecondTokenBalance()) && e.writeInt64(5, r)
        }, TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ExchangeCreateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ExchangeCreateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getFirstTokenId())
        }, TronWebProto.ExchangeCreateContract.prototype.getFirstTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getFirstTokenId())
        }, TronWebProto.ExchangeCreateContract.prototype.setFirstTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.ExchangeCreateContract.prototype.getFirstTokenBalance = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.ExchangeCreateContract.prototype.setFirstTokenBalance = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getSecondTokenId())
        }, TronWebProto.ExchangeCreateContract.prototype.getSecondTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getSecondTokenId())
        }, TronWebProto.ExchangeCreateContract.prototype.setSecondTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.ExchangeCreateContract.prototype.getSecondTokenBalance = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.ExchangeCreateContract.prototype.setSecondTokenBalance = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeInjectContract.prototype.toObject = function(t) {
          return TronWebProto.ExchangeInjectContract.toObject(t, this)
        }, TronWebProto.ExchangeInjectContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            exchangeId: n.Message.getFieldWithDefault(e, 2, 0),
            tokenId: e.getTokenId_asB64(),
            quant: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ExchangeInjectContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ExchangeInjectContract;
          return TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ExchangeInjectContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setExchangeId(r);
              break;
            case 3:
              r = e.readBytes(), t.setTokenId(r);
              break;
            case 4:
              r = e.readInt64(), t.setQuant(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ExchangeInjectContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ExchangeInjectContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ExchangeInjectContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getExchangeId()) && e.writeInt64(2, r), (r = t.getTokenId_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getQuant()) && e.writeInt64(4, r)
        }, TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ExchangeInjectContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ExchangeInjectContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ExchangeInjectContract.prototype.getExchangeId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ExchangeInjectContract.prototype.setExchangeId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.ExchangeInjectContract.prototype.getTokenId = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.ExchangeInjectContract.prototype.getTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getTokenId())
        }, TronWebProto.ExchangeInjectContract.prototype.getTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getTokenId())
        }, TronWebProto.ExchangeInjectContract.prototype.setTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.ExchangeInjectContract.prototype.getQuant = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.ExchangeInjectContract.prototype.setQuant = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeWithdrawContract.prototype.toObject = function(t) {
          return TronWebProto.ExchangeWithdrawContract.toObject(t, this)
        }, TronWebProto.ExchangeWithdrawContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            exchangeId: n.Message.getFieldWithDefault(e, 2, 0),
            tokenId: e.getTokenId_asB64(),
            quant: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ExchangeWithdrawContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ExchangeWithdrawContract;
          return TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ExchangeWithdrawContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setExchangeId(r);
              break;
            case 3:
              r = e.readBytes(), t.setTokenId(r);
              break;
            case 4:
              r = e.readInt64(), t.setQuant(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ExchangeWithdrawContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ExchangeWithdrawContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getExchangeId()) && e.writeInt64(2, r), (r = t.getTokenId_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getQuant()) && e.writeInt64(4, r)
        }, TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ExchangeWithdrawContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ExchangeWithdrawContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ExchangeWithdrawContract.prototype.getExchangeId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ExchangeWithdrawContract.prototype.setExchangeId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.ExchangeWithdrawContract.prototype.getTokenId = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getTokenId())
        }, TronWebProto.ExchangeWithdrawContract.prototype.getTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getTokenId())
        }, TronWebProto.ExchangeWithdrawContract.prototype.setTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.ExchangeWithdrawContract.prototype.getQuant = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.ExchangeWithdrawContract.prototype.setQuant = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ExchangeTransactionContract.prototype.toObject = function(t) {
          return TronWebProto.ExchangeTransactionContract.toObject(t, this)
        }, TronWebProto.ExchangeTransactionContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            exchangeId: n.Message.getFieldWithDefault(e, 2, 0),
            tokenId: e.getTokenId_asB64(),
            quant: n.Message.getFieldWithDefault(e, 4, 0),
            expected: n.Message.getFieldWithDefault(e, 5, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ExchangeTransactionContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ExchangeTransactionContract;
          return TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ExchangeTransactionContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setExchangeId(r);
              break;
            case 3:
              r = e.readBytes(), t.setTokenId(r);
              break;
            case 4:
              r = e.readInt64(), t.setQuant(r);
              break;
            case 5:
              r = e.readInt64(), t.setExpected(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ExchangeTransactionContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ExchangeTransactionContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getExchangeId()) && e.writeInt64(2, r), (r = t.getTokenId_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getQuant()) && e.writeInt64(4, r), 0 !== (r = t.getExpected()) && e.writeInt64(5, r)
        }, TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ExchangeTransactionContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ExchangeTransactionContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ExchangeTransactionContract.prototype.getExchangeId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ExchangeTransactionContract.prototype.setExchangeId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.ExchangeTransactionContract.prototype.getTokenId = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getTokenId())
        }, TronWebProto.ExchangeTransactionContract.prototype.getTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getTokenId())
        }, TronWebProto.ExchangeTransactionContract.prototype.setTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.ExchangeTransactionContract.prototype.getQuant = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.ExchangeTransactionContract.prototype.setQuant = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.ExchangeTransactionContract.prototype.getExpected = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.ExchangeTransactionContract.prototype.setExpected = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, i.object.extend(e, TronWebProto)
      },
      30144: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e, r = !1) => {
          if (t instanceof n) return t;
          try {
            return new n(t, e)
          } catch (t) {
            if (!r) return null;
            throw t
          }
        }
      },
      30317: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, n.default)((0, i.default)(t, e), e)
        };
        var n = o(r(12483)),
          i = o(r(62309));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      30592: (t, e, r) => {
        "use strict";
        var n = r(30655),
          i = function() {
            return !!n
          };
        i.hasArrayLengthDefineBug = function() {
          if (!n) return null;
          try {
            return 1 !== n([], "length", {
              value: 1
            }).length
          } catch {
            return !0
          }
        }, t.exports = i
      },
      30594: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeShardAccount = e.loadShardAccount = void 0;
        const n = r(65871),
          i = r(62142);
        e.loadShardAccount = function(t) {
          let e, r = t.loadRef();
          if (!r.isExotic) {
            let t = r.beginParse();
            t.loadBit() && (e = (0, i.loadAccount)(t))
          }
          return {
            account: e,
            lastTransactionHash: t.loadUintBig(256),
            lastTransactionLt: t.loadUintBig(64)
          }
        }, e.storeShardAccount = function(t) {
          return e => {
            t.account ? e.storeRef((0, n.beginCell)().storeBit(!0).store((0, i.storeAccount)(t.account))) : e.storeRef((0, n.beginCell)().storeBit(!1)), e.storeUint(t.lastTransactionHash, 256), e.storeUint(t.lastTransactionLt, 64)
          }
        }
      },
      30637: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("TronWebProto.BuyStorageBytesContract", null, o), i.exportSymbol("TronWebProto.BuyStorageContract", null, o), i.exportSymbol("TronWebProto.SellStorageContract", null, o), i.exportSymbol("TronWebProto.UpdateBrokerageContract", null, o), TronWebProto.BuyStorageBytesContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.BuyStorageBytesContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.BuyStorageBytesContract.displayName = "TronWebProto.BuyStorageBytesContract"), TronWebProto.BuyStorageContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.BuyStorageContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.BuyStorageContract.displayName = "TronWebProto.BuyStorageContract"), TronWebProto.SellStorageContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.SellStorageContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SellStorageContract.displayName = "TronWebProto.SellStorageContract"), TronWebProto.UpdateBrokerageContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UpdateBrokerageContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UpdateBrokerageContract.displayName = "TronWebProto.UpdateBrokerageContract"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageBytesContract.prototype.toObject = function(t) {
          return TronWebProto.BuyStorageBytesContract.toObject(t, this)
        }, TronWebProto.BuyStorageBytesContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            bytes: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.BuyStorageBytesContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.BuyStorageBytesContract;
          return TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.BuyStorageBytesContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setBytes(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.BuyStorageBytesContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.BuyStorageBytesContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getBytes()) && e.writeInt64(2, r)
        }, TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.BuyStorageBytesContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.BuyStorageBytesContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.BuyStorageBytesContract.prototype.getBytes = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.BuyStorageBytesContract.prototype.setBytes = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.BuyStorageContract.prototype.toObject = function(t) {
          return TronWebProto.BuyStorageContract.toObject(t, this)
        }, TronWebProto.BuyStorageContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            quant: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.BuyStorageContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.BuyStorageContract;
          return TronWebProto.BuyStorageContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.BuyStorageContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setQuant(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.BuyStorageContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.BuyStorageContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.BuyStorageContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getQuant()) && e.writeInt64(2, r)
        }, TronWebProto.BuyStorageContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.BuyStorageContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.BuyStorageContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.BuyStorageContract.prototype.getQuant = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.BuyStorageContract.prototype.setQuant = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.SellStorageContract.prototype.toObject = function(t) {
          return TronWebProto.SellStorageContract.toObject(t, this)
        }, TronWebProto.SellStorageContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            storageBytes: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.SellStorageContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SellStorageContract;
          return TronWebProto.SellStorageContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SellStorageContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setStorageBytes(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SellStorageContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SellStorageContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SellStorageContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getStorageBytes()) && e.writeInt64(2, r)
        }, TronWebProto.SellStorageContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.SellStorageContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.SellStorageContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.SellStorageContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.SellStorageContract.prototype.getStorageBytes = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.SellStorageContract.prototype.setStorageBytes = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateBrokerageContract.prototype.toObject = function(t) {
          return TronWebProto.UpdateBrokerageContract.toObject(t, this)
        }, TronWebProto.UpdateBrokerageContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            brokerage: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UpdateBrokerageContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UpdateBrokerageContract;
          return TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UpdateBrokerageContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt32(), t.setBrokerage(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UpdateBrokerageContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UpdateBrokerageContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getBrokerage()) && e.writeInt32(2, r)
        }, TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UpdateBrokerageContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UpdateBrokerageContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UpdateBrokerageContract.prototype.getBrokerage = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.UpdateBrokerageContract.prototype.setBrokerage = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, i.object.extend(e, TronWebProto)
      },
      30655: t => {
        "use strict";
        var e = Object.defineProperty || !1;
        if (e) try {
          e({}, "a", {
            value: 1
          })
        } catch {
          e = !1
        }
        t.exports = e
      },
      31252: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, n.default)(t), (0, i.default)(t) && 24 === t.length
        };
        var n = o(r(83399)),
          i = o(r(82002));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      31352: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getJsonRpcIdValidator = e.assertIsJsonRpcError = e.isJsonRpcError = e.assertIsJsonRpcFailure = e.isJsonRpcFailure = e.assertIsJsonRpcSuccess = e.isJsonRpcSuccess = e.assertIsJsonRpcResponse = e.isJsonRpcResponse = e.assertIsPendingJsonRpcResponse = e.isPendingJsonRpcResponse = e.JsonRpcResponseStruct = e.JsonRpcFailureStruct = e.JsonRpcSuccessStruct = e.PendingJsonRpcResponseStruct = e.assertIsJsonRpcRequest = e.isJsonRpcRequest = e.assertIsJsonRpcNotification = e.isJsonRpcNotification = e.JsonRpcNotificationStruct = e.JsonRpcRequestStruct = e.JsonRpcParamsStruct = e.JsonRpcErrorStruct = e.JsonRpcIdStruct = e.JsonRpcVersionStruct = e.jsonrpc2 = e.getJsonSize = e.getSafeJson = e.isValidJson = e.JsonStruct = e.UnsafeJsonStruct = e.exactOptional = e.object = void 0;
        const n = r(35620),
          i = r(74772),
          o = r(15354);

        function s({
          path: t,
          branch: e
        }) {
          const r = t[t.length - 1];
          return (0, o.hasProperty)(e[e.length - 2], r)
        }

        function a(t) {
          return new n.Struct({
            ...t,
            type: "optional " + t.type,
            validator: (e, r) => !s(r) || t.validator(e, r),
            refiner: (e, r) => !s(r) || t.refiner(e, r)
          })
        }

        function u(t) {
          return (0, n.create)(t, e.JsonStruct)
        }
        e.object = t => (0, n.object)(t), e.exactOptional = a, e.UnsafeJsonStruct = (0, n.union)([(0, n.literal)(null), (0, n.boolean)(), (0, n.define)("finite number", t => (0, n.is)(t, (0, n.number)()) && Number.isFinite(t)), (0, n.string)(), (0, n.array)((0, n.lazy)(() => e.UnsafeJsonStruct)), (0, n.record)((0, n.string)(), (0, n.lazy)(() => e.UnsafeJsonStruct))]), e.JsonStruct = (0, n.coerce)(e.UnsafeJsonStruct, (0, n.any)(), t => ((0, i.assertStruct)(t, e.UnsafeJsonStruct), JSON.parse(JSON.stringify(t, (t, e) => {
          if ("__proto__" !== t && "constructor" !== t) return e
        })))), e.isValidJson = function(t) {
          try {
            return u(t), !0
          } catch {
            return !1
          }
        }, e.getSafeJson = u, e.getJsonSize = function(t) {
          (0, i.assertStruct)(t, e.JsonStruct, "Invalid JSON value");
          const r = JSON.stringify(t);
          return (new TextEncoder).encode(r).byteLength
        }, e.jsonrpc2 = "2.0", e.JsonRpcVersionStruct = (0, n.literal)(e.jsonrpc2), e.JsonRpcIdStruct = (0, n.nullable)((0, n.union)([(0, n.number)(), (0, n.string)()])), e.JsonRpcErrorStruct = (0, e.object)({
          code: (0, n.integer)(),
          message: (0, n.string)(),
          data: a(e.JsonStruct),
          stack: a((0, n.string)())
        }), e.JsonRpcParamsStruct = (0, n.union)([(0, n.record)((0, n.string)(), e.JsonStruct), (0, n.array)(e.JsonStruct)]), e.JsonRpcRequestStruct = (0, e.object)({
          id: e.JsonRpcIdStruct,
          jsonrpc: e.JsonRpcVersionStruct,
          method: (0, n.string)(),
          params: a(e.JsonRpcParamsStruct)
        }), e.JsonRpcNotificationStruct = (0, e.object)({
          jsonrpc: e.JsonRpcVersionStruct,
          method: (0, n.string)(),
          params: a(e.JsonRpcParamsStruct)
        }), e.isJsonRpcNotification = function(t) {
          return (0, n.is)(t, e.JsonRpcNotificationStruct)
        }, e.assertIsJsonRpcNotification = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcNotificationStruct, "Invalid JSON-RPC notification", r)
        }, e.isJsonRpcRequest = function(t) {
          return (0, n.is)(t, e.JsonRpcRequestStruct)
        }, e.assertIsJsonRpcRequest = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcRequestStruct, "Invalid JSON-RPC request", r)
        }, e.PendingJsonRpcResponseStruct = (0, n.object)({
          id: e.JsonRpcIdStruct,
          jsonrpc: e.JsonRpcVersionStruct,
          result: (0, n.optional)((0, n.unknown)()),
          error: (0, n.optional)(e.JsonRpcErrorStruct)
        }), e.JsonRpcSuccessStruct = (0, e.object)({
          id: e.JsonRpcIdStruct,
          jsonrpc: e.JsonRpcVersionStruct,
          result: e.JsonStruct
        }), e.JsonRpcFailureStruct = (0, e.object)({
          id: e.JsonRpcIdStruct,
          jsonrpc: e.JsonRpcVersionStruct,
          error: e.JsonRpcErrorStruct
        }), e.JsonRpcResponseStruct = (0, n.union)([e.JsonRpcSuccessStruct, e.JsonRpcFailureStruct]), e.isPendingJsonRpcResponse = function(t) {
          return (0, n.is)(t, e.PendingJsonRpcResponseStruct)
        }, e.assertIsPendingJsonRpcResponse = function(t, r) {
          (0, i.assertStruct)(t, e.PendingJsonRpcResponseStruct, "Invalid pending JSON-RPC response", r)
        }, e.isJsonRpcResponse = function(t) {
          return (0, n.is)(t, e.JsonRpcResponseStruct)
        }, e.assertIsJsonRpcResponse = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcResponseStruct, "Invalid JSON-RPC response", r)
        }, e.isJsonRpcSuccess = function(t) {
          return (0, n.is)(t, e.JsonRpcSuccessStruct)
        }, e.assertIsJsonRpcSuccess = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcSuccessStruct, "Invalid JSON-RPC success response", r)
        }, e.isJsonRpcFailure = function(t) {
          return (0, n.is)(t, e.JsonRpcFailureStruct)
        }, e.assertIsJsonRpcFailure = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcFailureStruct, "Invalid JSON-RPC failure response", r)
        }, e.isJsonRpcError = function(t) {
          return (0, n.is)(t, e.JsonRpcErrorStruct)
        }, e.assertIsJsonRpcError = function(t, r) {
          (0, i.assertStruct)(t, e.JsonRpcErrorStruct, "Invalid JSON-RPC error", r)
        }, e.getJsonRpcIdValidator = function(t) {
          const {
            permitEmptyString: e,
            permitFractions: r,
            permitNull: n
          } = {
            permitEmptyString: !0,
            permitFractions: !1,
            permitNull: !0,
            ...t
          };
          return t => !!("number" == typeof t && (r || Number.isInteger(t)) || "string" == typeof t && (e || t.length > 0) || n && null === t)
        }
      },
      31449: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.fullWidth.test(t) && s.halfWidth.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(29666),
          s = r(49534);
        t.exports = e.default, t.exports.default = e.default
      },
      31459: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.convertToMerkleProof = e.exoticMerkleProof = void 0;
        const n = r(53528),
          i = r(65871);
        e.exoticMerkleProof = function(t, e) {
          const r = new n.BitReader(t);
          if (280 !== t.length) throw Error(`Merkle Proof cell must have exactly (8 + 256 + 16) bits, got "${t.length}"`);
          if (1 !== e.length) throw Error(`Merkle Proof cell must have exactly 1 ref, got "${e.length}"`);
          let i = r.loadUint(8);
          if (3 !== i) throw Error(`Merkle Proof cell must have type 3, got "${i}"`);
          const o = r.loadBuffer(32),
            s = r.loadUint(16),
            a = e[0].hash(0),
            u = e[0].depth(0);
          if (s !== u) throw Error(`Merkle Proof cell ref depth must be exactly "${s}", got "${u}"`);
          if (!o.equals(a)) throw Error(`Merkle Proof cell ref hash must be exactly "${o.toString("hex")}", got "${a.toString("hex")}"`);
          return {
            proofDepth: s,
            proofHash: o
          }
        }, e.convertToMerkleProof = function(t) {
          return (0, i.beginCell)().storeUint(3, 8).storeBuffer(t.hash(0)).storeUint(t.depth(0), 16).storeRef(t).endCell({
            exotic: !0
          })
        }
      },
      31708: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Lock = void 0, e.Lock = class {
          constructor() {
            this.permits = 1, this.promiseResolverQueue = []
          }
          async acquire() {
            return this.permits > 0 ? (this.permits -= 1, Promise.resolve(!0)) : new Promise(t => this.promiseResolverQueue.push(t))
          }
          release() {
            if (this.permits += 1, this.permits > 1 && this.promiseResolverQueue.length > 0) console.warn("Lock.permits should never be > 0 when there is someone waiting.");
            else if (1 === this.permits && this.promiseResolverQueue.length > 0) {
              this.permits -= 1;
              const t = this.promiseResolverQueue.shift();
              t && t(!0)
            }
          }
        }
      },
      31729: (t, e, r) => {
        const n = r(30144);
        t.exports = (t, e) => {
          const r = n(t, e);
          return r && r.prerelease.length ? r.prerelease : null
        }
      },
      31954: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[A-Z]{2}[0-9A-Z]{3}\d{2}\d{5}$/;
        t.exports = e.default, t.exports.default = e.default
      },
      32019: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.keccak512 = e.keccak384 = e.keccak256 = e.keccak224 = void 0;
        const n = r(27563),
          i = r(82672);
        e.keccak224 = (0, i.wrapHash)(n.keccak_224), e.keccak256 = (() => {
          const t = (0, i.wrapHash)(n.keccak_256);
          return t.create = n.keccak_256.create, t
        })(), e.keccak384 = (0, i.wrapHash)(n.keccak_384), e.keccak512 = (0, i.wrapHash)(n.keccak_512)
      },
      32337: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, o.default)(t), 0 !== t.indexOf("mailto:")) return !1;
          var r = a(t.replace("mailto:", "").split("?"), 2),
            s = r[0],
            c = void 0 === s ? "" : s,
            f = r[1],
            l = void 0 === f ? "" : f;
          if (!c && !l) return !0;
          var h = function(t) {
            var e = new Set(["subject", "body", "cc", "bcc"]),
              r = {
                cc: "",
                bcc: ""
              },
              n = !1,
              i = t.split("&");
            if (i.length > 4) return !1;
            var o, s = function(t) {
              var e;
              if (typeof Symbol > "u" || null == t[Symbol.iterator]) {
                if (Array.isArray(t) || (e = u(t))) {
                  e && (t = e);
                  var r = 0,
                    n = function() {};
                  return {
                    s: n,
                    n: function() {
                      return r < t.length ? {
                        done: !1,
                        value: t[r++]
                      } : {
                        done: !0
                      }
                    },
                    e: function(t) {
                      throw t
                    },
                    f: n
                  }
                }
                throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
              }
              var i, o = !0,
                s = !1;
              return {
                s: function() {
                  e = t[Symbol.iterator]()
                },
                n: function() {
                  var t = e.next();
                  return o = t.done, t
                },
                e: function(t) {
                  s = !0, i = t
                },
                f: function() {
                  try {
                    !o && null != e.return && e.return()
                  } finally {
                    if (s) throw i
                  }
                }
              }
            }(i);
            try {
              for (s.s(); !(o = s.n()).done;) {
                var c = a(o.value.split("="), 2),
                  f = c[0],
                  l = c[1];
                if (f && !e.has(f)) {
                  n = !0;
                  break
                }
                l && ("cc" === f || "bcc" === f) && (r[f] = l), f && e.delete(f)
              }
            } catch (t) {
              s.e(t)
            } finally {
              s.f()
            }
            return !n && r
          }(l);
          return !!h && "".concat(c, ",").concat(h.cc, ",").concat(h.bcc).split(",").every(function(t) {
            return !(t = (0, n.default)(t, " ")) || (0, i.default)(t, e)
          })
        };
        var n = s(r(30317)),
          i = s(r(69517)),
          o = s(r(83399));

        function s(t) {
          return t && t._ ? t : {
            default: t
          }
        }

        function a(t, e) {
          return function(t) {
            if (Array.isArray(t)) return t
          }(t) || function(t, e) {
            if ("u" >= typeof Symbol && Symbol.iterator in Object(t)) {
              var r = [],
                n = !0,
                i = !1,
                o = void 0;
              try {
                for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !e || r.length !== e); n = !0);
              } catch (t) {
                i = !0, o = t
              } finally {
                try {
                  !n && null != a.return && a.return()
                } finally {
                  if (i) throw o
                }
              }
              return r
            }
          }(t, e) || u(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
          }()
        }

        function u(t, e) {
          if (t) {
            if ("string" == typeof t) return c(t, e);
            var r = {}.toString.call(t).slice(8, -1);
            if ("Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r) return Array.from(t);
            if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return c(t, e)
          }
        }

        function c(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = Array(e); e > r; r++) n[r] = t[r];
          return n
        }
        t.exports = e.default, t.exports.default = e.default
      },
      32370: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha512 = e.sha256 = e.pbkdf2_sha512 = e.hmac_sha512 = e.getSecureRandomWords = e.getSecureRandomBytes = void 0;
        var n = r(36307);
        Object.defineProperty(e, "getSecureRandomBytes", {
          enumerable: !0,
          get: function() {
            return n.getSecureRandomBytes
          }
        }), Object.defineProperty(e, "getSecureRandomWords", {
          enumerable: !0,
          get: function() {
            return n.getSecureRandomWords
          }
        });
        var i = r(99967);
        Object.defineProperty(e, "hmac_sha512", {
          enumerable: !0,
          get: function() {
            return i.hmac_sha512
          }
        });
        var o = r(62441);
        Object.defineProperty(e, "pbkdf2_sha512", {
          enumerable: !0,
          get: function() {
            return o.pbkdf2_sha512
          }
        });
        var s = r(73150);
        Object.defineProperty(e, "sha256", {
          enumerable: !0,
          get: function() {
            return s.sha256
          }
        });
        var a = r(43999);
        Object.defineProperty(e, "sha512", {
          enumerable: !0,
          get: function() {
            return a.sha512
          }
        })
      },
      32423: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeShardIdent = e.loadShardIdent = void 0, e.loadShardIdent = function(t) {
          if (0 !== t.loadUint(2)) throw Error("Invalid data");
          return {
            shardPrefixBits: t.loadUint(6),
            workchainId: t.loadInt(32),
            shardPrefix: t.loadUintBig(64)
          }
        }, e.storeShardIdent = function(t) {
          return e => {
            e.storeUint(0, 2), e.storeUint(t.shardPrefixBits, 6), e.storeInt(t.workchainId, 32), e.storeUint(t.shardPrefix, 64)
          }
        }
      },
      32644: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.signPayload = function(t, e, r) {
          return "secretKey" in t ? r((0, n.sign)(e.endCell().hash(), t.secretKey), e) : t.signer(e.endCell()).then(t => r(t, e))
        };
        const n = r(75269)
      },
      32938: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e) => new n(t, e).major
      },
      32955: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.shake256 = e.shake128 = e.keccak_512 = e.keccak_384 = e.keccak_256 = e.keccak_224 = e.sha3_512 = e.sha3_384 = e.sha3_256 = e.sha3_224 = e.Keccak = void 0, e.keccakP = v;
        const n = r(22318),
          i = r(99175),
          o = BigInt(0),
          s = BigInt(1),
          a = BigInt(2),
          u = BigInt(7),
          c = BigInt(256),
          f = BigInt(113),
          l = [],
          h = [],
          d = [];
        for (let t = 0, e = s, r = 1, n = 0; 24 > t; t++) {
          [r, n] = [n, (2 * r + 3 * n) % 5], l.push(2 * (5 * n + r)), h.push((t + 1) * (t + 2) / 2 % 64);
          let i = o;
          for (let t = 0; 7 > t; t++) e = (e << s ^ (e >> u) * f) % c, e & a && (i ^= s << (s << BigInt(t)) - s);
          d.push(i)
        }
        const p = (0, n.split)(d, !0),
          b = p[0],
          m = p[1],
          y = (t, e, r) => r > 32 ? (0, n.rotlBH)(t, e, r) : (0, n.rotlSH)(t, e, r),
          g = (t, e, r) => r > 32 ? (0, n.rotlBL)(t, e, r) : (0, n.rotlSL)(t, e, r);

        function v(t, e = 24) {
          const r = new Uint32Array(10);
          for (let n = 24 - e; 24 > n; n++) {
            for (let e = 0; 10 > e; e++) r[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
            for (let e = 0; 10 > e; e += 2) {
              const n = (e + 8) % 10,
                i = (e + 2) % 10,
                o = r[i],
                s = r[i + 1],
                a = y(o, s, 1) ^ r[n],
                u = g(o, s, 1) ^ r[n + 1];
              for (let r = 0; 50 > r; r += 10) t[e + r] ^= a, t[e + r + 1] ^= u
            }
            let e = t[2],
              i = t[3];
            for (let r = 0; 24 > r; r++) {
              const n = h[r],
                o = y(e, i, n),
                s = g(e, i, n),
                a = l[r];
              e = t[a], i = t[a + 1], t[a] = o, t[a + 1] = s
            }
            for (let e = 0; 50 > e; e += 10) {
              for (let n = 0; 10 > n; n++) r[n] = t[e + n];
              for (let n = 0; 10 > n; n++) t[e + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10]
            }
            t[0] ^= b[n], t[1] ^= m[n]
          }(0, i.clean)(r)
        }
        class w extends i.Hash {
          constructor(t, e, r, n = !1, o = 24) {
            if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = n, this.rounds = o, (0, i.anumber)(r), 0 >= t || t >= 200) throw Error("only keccak-f1600 function is supported");
            this.state = new Uint8Array(200), this.state32 = (0, i.u32)(this.state)
          }
          clone() {
            return this.jt()
          }
          keccak() {
            (0, i.swap32IfBE)(this.state32), v(this.state32, this.rounds), (0, i.swap32IfBE)(this.state32), this.posOut = 0, this.pos = 0
          }
          update(t) {
            (0, i.aexists)(this), t = (0, i.toBytes)(t), (0, i.abytes)(t);
            const {
              blockLen: e,
              state: r
            } = this, n = t.length;
            for (let i = 0; n > i;) {
              const o = Math.min(e - this.pos, n - i);
              for (let e = 0; o > e; e++) r[this.pos++] ^= t[i++];
              this.pos === e && this.keccak()
            }
            return this
          }
          finish() {
            if (this.finished) return;
            this.finished = !0;
            const {
              state: t,
              suffix: e,
              pos: r,
              blockLen: n
            } = this;
            t[r] ^= e, !!(128 & e) && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak()
          }
          writeInto(t) {
            (0, i.aexists)(this, !1), (0, i.abytes)(t), this.finish();
            const e = this.state,
              {
                blockLen: r
              } = this;
            for (let n = 0, i = t.length; i > n;) {
              this.posOut >= r && this.keccak();
              const o = Math.min(r - this.posOut, i - n);
              t.set(e.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o
            }
            return t
          }
          xofInto(t) {
            if (!this.enableXOF) throw Error("XOF is not possible for this instance");
            return this.writeInto(t)
          }
          xof(t) {
            return (0, i.anumber)(t), this.xofInto(new Uint8Array(t))
          }
          digestInto(t) {
            if ((0, i.aoutput)(t, this), this.finished) throw Error("digest() was already called");
            return this.writeInto(t), this.destroy(), t
          }
          digest() {
            return this.digestInto(new Uint8Array(this.outputLen))
          }
          destroy() {
            this.destroyed = !0, (0, i.clean)(this.state)
          }
          jt(t) {
            const {
              blockLen: e,
              suffix: r,
              outputLen: n,
              rounds: i,
              enableXOF: o
            } = this;
            return t || (t = new w(e, r, n, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = r, t.outputLen = n, t.enableXOF = o, t.destroyed = this.destroyed, t
          }
        }
        e.Keccak = w;
        const A = (t, e, r) => (0, i.createHasher)(() => new w(e, t, r));
        e.sha3_224 = A(6, 144, 28), e.sha3_256 = A(6, 136, 32), e.sha3_384 = A(6, 104, 48), e.sha3_512 = A(6, 72, 64), e.keccak_224 = A(1, 144, 28), e.keccak_256 = A(1, 136, 32), e.keccak_384 = A(1, 104, 48), e.keccak_512 = A(1, 72, 64);
        const T = (t, e, r) => (0, i.createXOFer)((n = {}) => new w(e, t, void 0 === n.dkLen ? r : n.dkLen, !0));
        e.shake128 = T(31, 168, 16), e.shake256 = T(31, 136, 32)
      },
      33537: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(67775), e), i(r(49334), e), i(r(73255), e)
      },
      33752: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t) ? parseFloat(t) : NaN
        };
        var n, i = (n = r(50995)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      33906: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t, {
            min: 0,
            max: 65535
          })
        };
        var n, i = (n = r(76084)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      33910: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.serializeDict = e.detectLabelType = e.writeLabelSame = e.writeLabelLong = e.writeLabelShort = e.buildTree = void 0;
        const n = r(65871),
          i = r(47182);

        function o(t, e) {
          for (; t.length < e;) t = "0" + t;
          return t
        }

        function s(t, e) {
          if (0 === t.size) throw Error("Internal inconsistency");
          if (1 === t.size) return {
            type: "leaf",
            value: Array.from(t.values())[0]
          };
          let {
            left: r,
            right: n
          } = function(t, e) {
            if (0 === t.size) throw Error("Internal inconsistency");
            let r = new Map,
              n = new Map;
            for (let [i, o] of t.entries()) "0" === i[e] ? r.set(i, o) : n.set(i, o);
            if (0 === r.size) throw Error("Internal inconsistency. Left emtpy.");
            if (0 === n.size) throw Error("Internal inconsistency. Right emtpy.");
            return {
              left: r,
              right: n
            }
          }(t, e);
          return {
            type: "fork",
            left: a(r, e + 1),
            right: a(n, e + 1)
          }
        }

        function a(t, e = 0) {
          if (0 === t.size) throw Error("Internal inconsistency");
          const r = (0, i.findCommonPrefix)(Array.from(t.keys()), e);
          return {
            label: r,
            node: s(t, r.length + e)
          }
        }

        function u(t, e) {
          let r = new Map;
          for (let n of Array.from(t.keys())) {
            const i = o(n.toString(2), e);
            r.set(i, t.get(n))
          }
          return a(r)
        }

        function c(t, e) {
          e.storeBit(0);
          for (let r = 0; r < t.length; r++) e.storeBit(1);
          return e.storeBit(0), t.length > 0 && e.storeUint(BigInt("0b" + t), t.length), e
        }

        function f(t, e, r) {
          r.storeBit(1), r.storeBit(0);
          let n = Math.ceil(Math.log2(e + 1));
          return r.storeUint(t.length, n), t.length > 0 && r.storeUint(BigInt("0b" + t), t.length), r
        }

        function l(t, e, r, n) {
          n.storeBit(1), n.storeBit(1), n.storeBit(t);
          let i = Math.ceil(Math.log2(r + 1));
          n.storeUint(e, i)
        }

        function h(t, e) {
          let r = "short",
            n = function(t) {
              return 1 + t.length + 1 + t.length
            }(t),
            i = function(t, e) {
              return 2 + Math.ceil(Math.log2(e + 1)) + t.length
            }(t, e);
          if (n > i && (n = i, r = "long"), function(t) {
              if (0 === t.length || 1 === t.length) return !0;
              for (let e = 1; e < t.length; e++)
                if (t[e] !== t[0]) return !1;
              return !0
            }(t)) {
            let t = function(t) {
              return 3 + Math.ceil(Math.log2(t + 1))
            }(e);
            n > t && (n = t, r = "same")
          }
          return r
        }

        function d(t, e, r, i) {
          (function(t, e, r) {
            let n = h(t, e);
            "short" === n ? c(t, r) : "long" === n ? f(t, e, r) : "same" === n && l("1" === t[0], t.length, e, r)
          })(t.label, e, i),
          function(t, e, r, i) {
            if ("leaf" === t.type && r(t.value, i), "fork" === t.type) {
              const o = (0, n.beginCell)(),
                s = (0, n.beginCell)();
              d(t.left, e - 1, r, o), d(t.right, e - 1, r, s), i.storeRef(o), i.storeRef(s)
            }
          }(t.node, e - t.label.length, r, i)
        }
        e.buildTree = u, e.writeLabelShort = c, e.writeLabelLong = f, e.writeLabelSame = l, e.detectLabelType = h, e.serializeDict = function(t, e, r, n) {
          d(u(t, e), e, r, n)
        }
      },
      33973: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), RegExp("^[a-fA-F0-9]{".concat(o[e], "}$")).test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            md5: 32,
            md4: 32,
            sha1: 40,
            sha256: 64,
            sha384: 96,
            sha512: 128,
            ripemd128: 32,
            ripemd160: 40,
            tiger128: 32,
            tiger160: 40,
            tiger192: 48,
            crc32: 8,
            crc32b: 8
          };
        t.exports = e.default, t.exports.default = e.default
      },
      34175: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.unpack = e.pack = e.isDynamicParser = e.getParser = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(22391),
          s = r(78366),
          a = r(76291);
        e.getParser = t => {
          const e = {
              address: s.address,
              array: s.array,
              bool: s.bool,
              bytes: s.bytes,
              fixedBytes: s.fixedBytes,
              function: s.fn,
              number: s.number,
              string: s.string,
              tuple: s.tuple
            },
            r = e[t];
          if (r) return r;
          const n = Object.values(e).find(e => e.isType(t));
          if (n) return n;
          throw new i.ParserError(`The type "${t}" is not supported.`)
        }, e.isDynamicParser = (t, e) => {
          const {
            isDynamic: r
          } = t;
          return "function" == typeof r ? r(e) : r
        }, e.pack = ({
          types: t,
          values: r,
          packed: o = !1,
          tight: s = !1,
          arrayPacked: u = !1,
          byteArray: c = new Uint8Array
        }) => {
          (0, n.assert)(t.length === r.length, new i.ParserError(`The number of types (${t.length}) does not match the number of values (${r.length}).`));
          const {
            staticBuffer: f,
            dynamicBuffer: l,
            pointers: h
          } = t.reduce(({
            staticBuffer: t,
            dynamicBuffer: i,
            pointers: a
          }, c, f) => {
            const l = (0, e.getParser)(c),
              h = r[f];
            return o || u || !(0, e.isDynamicParser)(l, c) ? {
              staticBuffer: l.encode({
                buffer: t,
                value: h,
                type: c,
                packed: o,
                tight: s
              }),
              dynamicBuffer: i,
              pointers: a
            } : {
              staticBuffer: (0, n.concatBytes)([t, new Uint8Array(32)]),
              dynamicBuffer: l.encode({
                buffer: i,
                value: h,
                type: c,
                packed: o,
                tight: s
              }),
              pointers: [...a, {
                position: t.length,
                pointer: i.length
              }]
            }
          }, {
            staticBuffer: new Uint8Array,
            dynamicBuffer: new Uint8Array,
            pointers: []
          });
          (0, n.assert)(!o && !u || 0 === l.length, new i.ParserError("Invalid pack state."));
          const d = f.length,
            p = h.reduce((t, {
              pointer: e,
              position: r
            }) => {
              const i = (0, a.padStart)((0, n.numberToBytes)(d + e));
              return (0, a.set)(t, i, r)
            }, f);
          return (0, n.concatBytes)([c, p, l])
        }, e.unpack = (t, r) => {
          const s = (0, o.iterate)(r);
          return t.map(t => {
            const {
              value: {
                value: o,
                skip: a
              },
              done: u
            } = s.next();
            (0, n.assert)(!u, new i.ParserError(`The encoded value is invalid for the provided types. Reached end of buffer while attempting to parse "${t}".`));
            const c = (0, e.getParser)(t);
            if ((0, e.isDynamicParser)(c, t)) {
              const e = (0, n.bytesToNumber)(o.subarray(0, 32)),
                i = r.subarray(e);
              return c.decode({
                type: t,
                value: i,
                skip: a
              })
            }
            return c.decode({
              type: t,
              value: o,
              skip: a
            })
          })
        }
      },
      34382: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.paddedBufferToBits = e.bitsToPaddedBuffer = void 0;
        const n = r(49924),
          i = r(62386);
        e.bitsToPaddedBuffer = function(t) {
          let e = new n.BitBuilder(8 * Math.ceil(t.length / 8));
          e.writeBits(t);
          let r = 8 * Math.ceil(t.length / 8) - t.length;
          for (let t = 0; r > t; t++) 0 === t ? e.writeBit(1) : e.writeBit(0);
          return e.buffer()
        }, e.paddedBufferToBits = function(t) {
          let e = 0;
          for (let r = t.length - 1; r >= 0; r--)
            if (0 !== t[r]) {
              const n = t[r];
              let i = n & -n;
              !(1 & i) && (i = Math.log2(i) + 1), r > 0 && (e = r << 3), e += 8 - i;
              break
            } return new i.BitString(t, 0, e)
        }
      },
      34654: (t, e) => {
        "use strict";
        var r, n;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.CellType = void 0, (n = r || (e.CellType = r = {}))[n.Ordinary = -1] = "Ordinary", n[n.PrunedBranch = 1] = "PrunedBranch", n[n.Library = 2] = "Library", n[n.MerkleProof = 3] = "MerkleProof", n[n.MerkleUpdate = 4] = "MerkleUpdate"
      },
      35345: t => {
        "use strict";
        t.exports = URIError
      },
      35372: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function t(e) {
          var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
          return (0, i.default)(e), (r += "") ? "4" === r ? a.test(e) : "6" === r && c.test(e) : t(e, 4) || t(e, 6)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])",
          s = "(".concat(o, "[.]){3}").concat(o),
          a = RegExp("^".concat(s, "$")),
          u = "(?:[0-9a-fA-F]{1,4})",
          c = RegExp("^(" + "(?:".concat(u, ":){7}(?:").concat(u, "|:)|") + "(?:".concat(u, ":){6}(?:").concat(s, "|:").concat(u, "|:)|") + "(?:".concat(u, ":){5}(?::").concat(s, "|(:").concat(u, "){1,2}|:)|") + "(?:".concat(u, ":){4}(?:(:").concat(u, "){0,1}:").concat(s, "|(:").concat(u, "){1,3}|:)|") + "(?:".concat(u, ":){3}(?:(:").concat(u, "){0,2}:").concat(s, "|(:").concat(u, "){1,4}|:)|") + "(?:".concat(u, ":){2}(?:(:").concat(u, "){0,3}:").concat(s, "|(:").concat(u, "){1,5}|:)|") + "(?:".concat(u, ":){1}(?:(:").concat(u, "){0,4}:").concat(s, "|(:").concat(u, "){1,6}|:)|") + "(?::((?::".concat(u, "){0,5}:").concat(s, "|(?::").concat(u, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
        t.exports = e.default, t.exports.default = e.default
      },
      35546: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.assertIsString = e.assertIsArray = e.assertIsBuffer = e.assertIsHexString = void 0;
        const i = r(59498);
        e.assertIsHexString = function(t) {
          if (!(0, i.isHexString)(t)) throw Error("This method only supports 0x-prefixed hex strings but input was: " + t)
        }, e.assertIsBuffer = function(t) {
          if (!n.isBuffer(t)) throw Error("This method only supports Buffer but input was: " + t)
        }, e.assertIsArray = function(t) {
          if (!Array.isArray(t)) throw Error("This method only supports number arrays but input was: " + t)
        }, e.assertIsString = function(t) {
          if ("string" != typeof t) throw Error("This method only supports strings but input was: " + t)
        }
      },
      35580: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => n(t, e, r) > 0
      },
      35620: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(27754), e), i(r(99067), e), i(r(91704), e), i(r(50401), e), i(r(67792), e), i(r(65991), e)
      },
      35680: (t, e, r) => {
        "use strict";
        var n = r(25767);
        t.exports = function(t) {
          return !!n(t)
        }
      },
      35726: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionBouncePhase = e.loadTransactionBouncePhase = void 0;
        const n = r(92577);
        e.loadTransactionBouncePhase = function(t) {
          return t.loadBit() ? {
            type: "ok",
            messageSize: (0, n.loadStorageUsed)(t),
            messageFees: t.loadCoins(),
            forwardFees: t.loadCoins()
          } : t.loadBit() ? {
            type: "no-funds",
            messageSize: (0, n.loadStorageUsed)(t),
            requiredForwardFees: t.loadCoins()
          } : {
            type: "negative-funds"
          }
        }, e.storeTransactionBouncePhase = function(t) {
          return e => {
            if ("ok" === t.type) e.storeBit(!0), e.store((0, n.storeStorageUsed)(t.messageSize)), e.storeCoins(t.messageFees), e.storeCoins(t.forwardFees);
            else if ("negative-funds" === t.type) e.storeBit(!1), e.storeBit(!1);
            else {
              if ("no-funds" !== t.type) throw Error("Invalid TransactionBouncePhase type");
              e.storeBit(!1), e.storeBit(!0), e.store((0, n.storeStorageUsed)(t.messageSize)), e.storeCoins(t.requiredForwardFees)
            }
          }
        }
      },
      35735: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.deriveEd25519Path = e.deriveED25519HardenedKey = e.getED25519MasterKeyFromSeed = void 0;
        const i = r(4870),
          o = 2147483648;
        async function s(t) {
          const e = await (0, i.hmac_sha512)("ed25519 seed", t);
          return {
            key: e.slice(0, 32),
            chainCode: e.slice(32)
          }
        }
        async function a(t, e) {
          if (e >= o) throw Error("Key index must be less than offset");
          const r = n.alloc(4);
          r.writeUInt32BE(e + o, 0);
          const s = n.concat([n.alloc(1, 0), t.key, r]),
            a = await (0, i.hmac_sha512)(t.chainCode, s);
          return {
            key: a.slice(0, 32),
            chainCode: a.slice(32)
          }
        }
        e.getED25519MasterKeyFromSeed = s, e.deriveED25519HardenedKey = a, e.deriveEd25519Path = async function(t, e) {
          let r = await s(t),
            n = [...e];
          for (; n.length > 0;) {
            let t = n[0];
            n = n.slice(1), r = await a(r, t)
          }
          return r.key
        }
      },
      36307: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getSecureRandomWords = e.getSecureRandomBytes = void 0, e.getSecureRandomBytes = function(t) {
          return n.from(window.crypto.getRandomValues(new Uint8Array(t)))
        }, e.getSecureRandomWords = function(t) {
          return window.crypto.getRandomValues(new Uint16Array(t))
        }
      },
      36556: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(73126),
          o = i([n("%String.prototype.indexOf%")]);
        t.exports = function(t, e) {
          var r = n(t, !!e);
          return "function" == typeof r && o(t, ".prototype.") > -1 ? i([r]) : r
        }
      },
      36576: (t, e, r) => {
        "use strict";
        var n = r(9394),
          i = r(38452);
        t.exports = function() {
          var t = n();
          return i(Object, {
            is: t
          }, {
            is: function() {
              return Object.is !== t
            }
          }), t
        }
      },
      37007: t => {
        "use strict";
        var e, r = "object" == typeof Reflect ? Reflect : null,
          n = r && "function" == typeof r.apply ? r.apply : function(t, e, r) {
            return function() {}.apply.call(t, e, r)
          };
        e = r && "function" == typeof r.ownKeys ? r.ownKeys : Object.getOwnPropertySymbols ? function(t) {
          return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))
        } : function(t) {
          return Object.getOwnPropertyNames(t)
        };
        var i = Number.isNaN || function(t) {
          return t != t
        };

        function o() {
          o.init.call(this)
        }
        t.exports = o, t.exports.once = function(t, e) {
          return new Promise(function(r, n) {
            function i(r) {
              t.removeListener(e, o), n(r)
            }

            function o() {
              "function" == typeof t.removeListener && t.removeListener("error", i), r([].slice.call(arguments))
            }
            b(t, e, o, {
              once: !0
            }), "error" !== e && function(t, e) {
              "function" == typeof t.on && b(t, "error", e, {
                once: !0
              })
            }(t, i)
          })
        }, o.EventEmitter = o, o.prototype.ye = void 0, o.prototype.Ae = 0, o.prototype.We = void 0;
        var s = 10;

        function a(t) {
          if ("function" != typeof t) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof t)
        }

        function u(t) {
          return void 0 === t.We ? o.defaultMaxListeners : t.We
        }

        function c(t, e, r, n) {
          var i, o, s;
          if (a(r), void 0 === (o = t.ye) ? (o = t.ye = Object.create(null), t.Ae = 0) : (void 0 !== o.newListener && (t.emit("newListener", e, r.listener ? r.listener : r), o = t.ye), s = o[e]), void 0 === s) s = o[e] = r, ++t.Ae;
          else if ("function" == typeof s ? s = o[e] = n ? [r, s] : [s, r] : n ? s.unshift(r) : s.push(r), (i = u(t)) > 0 && s.length > i && !s.warned) {
            s.warned = !0;
            var c = Error("Possible EventEmitter memory leak detected. " + s.length + " " + e + " listeners added. Use emitter.setMaxListeners() to increase limit");
            c.name = "MaxListenersExceededWarning", c.emitter = t, c.type = e, c.count = s.length,
              function(t) {
                console && console.warn && console.warn(t)
              }(c)
          }
          return t
        }

        function f() {
          if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
        }

        function l(t, e, r) {
          var n = {
              fired: !1,
              wrapFn: void 0,
              target: t,
              type: e,
              listener: r
            },
            i = f.bind(n);
          return i.listener = r, n.wrapFn = i, i
        }

        function h(t, e, r) {
          var n = t.ye;
          if (void 0 === n) return [];
          var i = n[e];
          return void 0 === i ? [] : "function" == typeof i ? r ? [i.listener || i] : [i] : r ? function(t) {
            for (var e = Array(t.length), r = 0; r < e.length; ++r) e[r] = t[r].listener || t[r];
            return e
          }(i) : p(i, i.length)
        }

        function d(t) {
          var e = this.ye;
          if (void 0 !== e) {
            var r = e[t];
            if ("function" == typeof r) return 1;
            if (void 0 !== r) return r.length
          }
          return 0
        }

        function p(t, e) {
          for (var r = Array(e), n = 0; e > n; ++n) r[n] = t[n];
          return r
        }

        function b(t, e, r, n) {
          if ("function" == typeof t.on) n.once ? t.once(e, r) : t.on(e, r);
          else {
            if ("function" != typeof t.addEventListener) throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof t);
            t.addEventListener(e, function i(o) {
              n.once && t.removeEventListener(e, i), r(o)
            })
          }
        }
        Object.defineProperty(o, "defaultMaxListeners", {
          enumerable: !0,
          get: function() {
            return s
          },
          set: function(t) {
            if ("number" != typeof t || 0 > t || i(t)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + t + ".");
            s = t
          }
        }), o.init = function() {
          (void 0 === this.ye || this.ye === Object.getPrototypeOf(this).ye) && (this.ye = Object.create(null), this.Ae = 0), this.We = this.We || void 0
        }, o.prototype.setMaxListeners = function(t) {
          if ("number" != typeof t || 0 > t || i(t)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
          return this.We = t, this
        }, o.prototype.getMaxListeners = function() {
          return u(this)
        }, o.prototype.emit = function(t) {
          for (var e = [], r = 1; arguments.length > r; r++) e.push(arguments[r]);
          var i = "error" === t,
            o = this.ye;
          if (void 0 !== o) i = i && void 0 === o.error;
          else if (!i) return !1;
          if (i) {
            var s;
            if (e.length > 0 && (s = e[0]), s instanceof Error) throw s;
            var a = Error("Unhandled error." + (s ? " (" + s.message + ")" : ""));
            throw a.context = s, a
          }
          var u = o[t];
          if (void 0 === u) return !1;
          if ("function" == typeof u) n(u, this, e);
          else {
            var c = u.length,
              f = p(u, c);
            for (r = 0; c > r; ++r) n(f[r], this, e)
          }
          return !0
        }, o.prototype.addListener = function(t, e) {
          return c(this, t, e, !1)
        }, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
          return c(this, t, e, !0)
        }, o.prototype.once = function(t, e) {
          return a(e), this.on(t, l(this, t, e)), this
        }, o.prototype.prependOnceListener = function(t, e) {
          return a(e), this.prependListener(t, l(this, t, e)), this
        }, o.prototype.removeListener = function(t, e) {
          var r, n, i, o, s;
          if (a(e), void 0 === (n = this.ye)) return this;
          if (void 0 === (r = n[t])) return this;
          if (r === e || r.listener === e) 0 === --this.Ae ? this.ye = Object.create(null) : (delete n[t], n.removeListener && this.emit("removeListener", t, r.listener || e));
          else if ("function" != typeof r) {
            for (i = -1, o = r.length - 1; o >= 0; o--)
              if (r[o] === e || r[o].listener === e) {
                s = r[o].listener, i = o;
                break
              } if (0 > i) return this;
            0 === i ? r.shift() : function(t, e) {
              for (; e + 1 < t.length; e++) t[e] = t[e + 1];
              t.pop()
            }(r, i), 1 === r.length && (n[t] = r[0]), void 0 !== n.removeListener && this.emit("removeListener", t, s || e)
          }
          return this
        }, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
          var e, r, n;
          if (void 0 === (r = this.ye)) return this;
          if (void 0 === r.removeListener) return 0 === arguments.length ? (this.ye = Object.create(null), this.Ae = 0) : void 0 !== r[t] && (0 === --this.Ae ? this.ye = Object.create(null) : delete r[t]), this;
          if (0 === arguments.length) {
            var i, o = Object.keys(r);
            for (n = 0; n < o.length; ++n) "removeListener" !== (i = o[n]) && this.removeAllListeners(i);
            return this.removeAllListeners("removeListener"), this.ye = Object.create(null), this.Ae = 0, this
          }
          if ("function" == typeof(e = r[t])) this.removeListener(t, e);
          else if (void 0 !== e)
            for (n = e.length - 1; n >= 0; n--) this.removeListener(t, e[n]);
          return this
        }, o.prototype.listeners = function(t) {
          return h(this, t, !0)
        }, o.prototype.rawListeners = function(t) {
          return h(this, t, !1)
        }, o.listenerCount = function(t, e) {
          return "function" == typeof t.listenerCount ? t.listenerCount(e) : d.call(t, e)
        }, o.prototype.listenerCount = d, o.prototype.eventNames = function() {
          return this.Ae > 0 ? e(this.ye) : []
        }
      },
      37380: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Withdrawal = void 0;
        const i = r(86727),
          o = r(77312),
          s = r(42666);
        class a {
          constructor(t, e, r, n) {
            this.index = t, this.validatorIndex = e, this.address = r, this.amount = n
          }
          static fromWithdrawalData(t) {
            const {
              index: e,
              validatorIndex: r,
              address: n,
              amount: o
            } = t, u = (0, s.toType)(e, s.TypeOutput.BigInt), c = (0, s.toType)(r, s.TypeOutput.BigInt), f = new i.Address((0, s.toType)(n, s.TypeOutput.Buffer)), l = (0, s.toType)(o, s.TypeOutput.BigInt);
            return new a(u, c, f, l)
          }
          static fromValuesArray(t) {
            if (4 !== t.length) throw Error("Invalid withdrawalArray length expected=4 actual=" + t.length);
            const [e, r, n, i] = t;
            return a.fromWithdrawalData({
              index: e,
              validatorIndex: r,
              address: n,
              amount: i
            })
          }
          static toBufferArray(t) {
            const {
              index: e,
              validatorIndex: r,
              address: o,
              amount: a
            } = t, u = (0, s.toType)(e, s.TypeOutput.BigInt) === BigInt(0) ? n.alloc(0) : (0, s.toType)(e, s.TypeOutput.Buffer), c = (0, s.toType)(r, s.TypeOutput.BigInt) === BigInt(0) ? n.alloc(0) : (0, s.toType)(r, s.TypeOutput.Buffer);
            let f;
            return f = o instanceof i.Address ? o.buf : (0, s.toType)(o, s.TypeOutput.Buffer), [u, c, f, (0, s.toType)(a, s.TypeOutput.BigInt) === BigInt(0) ? n.alloc(0) : (0, s.toType)(a, s.TypeOutput.Buffer)]
          }
          raw() {
            return a.toBufferArray(this)
          }
          toValue() {
            return {
              index: this.index,
              validatorIndex: this.validatorIndex,
              address: this.address.buf,
              amount: this.amount
            }
          }
          toJSON() {
            return {
              index: (0, o.bigIntToHex)(this.index),
              validatorIndex: (0, o.bigIntToHex)(this.validatorIndex),
              address: "0x" + this.address.buf.toString("hex"),
              amount: (0, o.bigIntToHex)(this.amount)
            }
          }
        }
        e.Withdrawal = a
      },
      37612: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), t === t.toLowerCase()
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      37653: (t, e, r) => {
        "use strict";
        var n = r(38452),
          i = r(10487),
          o = r(89211),
          s = r(9394),
          a = r(36576),
          u = i(s(), Object);
        n(u, {
          getPolyfill: s,
          implementation: o,
          shim: a
        }), t.exports = u
      },
      37720: (t, e, r) => {
        "use strict";
        var n = r(74765),
          i = {}.hasOwnProperty,
          o = Array.isArray,
          s = function() {
            for (var t = [], e = 0; 256 > e; ++e) t.push("%" + ((16 > e ? "0" : "") + e.toString(16)).toUpperCase());
            return t
          }(),
          a = function(t, e) {
            for (var r = e && e.plainObjects ? {
                __proto__: null
              } : {}, n = 0; n < t.length; ++n) "u" > typeof t[n] && (r[n] = t[n]);
            return r
          },
          u = 1024;
        t.exports = {
          arrayToObject: a,
          assign: function(t, e) {
            return Object.keys(e).reduce(function(t, r) {
              return t[r] = e[r], t
            }, t)
          },
          combine: function(t, e) {
            return [].concat(t, e)
          },
          compact: function(t) {
            for (var e = [{
                obj: {
                  o: t
                },
                prop: "o"
              }], r = [], n = 0; n < e.length; ++n)
              for (var i = e[n], s = i.obj[i.prop], a = Object.keys(s), u = 0; u < a.length; ++u) {
                var c = a[u],
                  f = s[c];
                "object" == typeof f && null !== f && -1 === r.indexOf(f) && (e.push({
                  obj: s,
                  prop: c
                }), r.push(f))
              }
            return function(t) {
              for (; t.length > 1;) {
                var e = t.pop(),
                  r = e.obj[e.prop];
                if (o(r)) {
                  for (var n = [], i = 0; i < r.length; ++i) "u" > typeof r[i] && n.push(r[i]);
                  e.obj[e.prop] = n
                }
              }
            }(e), t
          },
          decode: function(t, e, r) {
            var n = t.replace(/\+/g, " ");
            if ("iso-8859-1" === r) return n.replace(/%[0-9a-f]{2}/gi, unescape);
            try {
              return decodeURIComponent(n)
            } catch {
              return n
            }
          },
          encode: function(t, e, r, i, o) {
            if (0 === t.length) return t;
            var a = t;
            if ("symbol" == typeof t ? a = Symbol.prototype.toString.call(t) : "string" != typeof t && (a = t + ""), "iso-8859-1" === r) return escape(a).replace(/%u[0-9a-f]{4}/gi, function(t) {
              return "%26%23" + parseInt(t.slice(2), 16) + "%3B"
            });
            for (var c = "", f = 0; f < a.length; f += u) {
              for (var l = a.length < u ? a : a.slice(f, f + u), h = [], d = 0; d < l.length; ++d) {
                var p = l.charCodeAt(d);
                45 !== p && 46 !== p && 95 !== p && 126 !== p && (48 > p || p > 57) && (65 > p || p > 90) && (97 > p || p > 122) && (o !== n.RFC1738 || 40 !== p && 41 !== p) ? 128 > p ? h[h.length] = s[p] : 2048 > p ? h[h.length] = s[192 | p >> 6] + s[128 | 63 & p] : p >= 55296 && 57344 > p ? (d += 1, p = 65536 + ((1023 & p) << 10 | 1023 & l.charCodeAt(d)), h[h.length] = s[240 | p >> 18] + s[128 | p >> 12 & 63] + s[128 | p >> 6 & 63] + s[128 | 63 & p]) : h[h.length] = s[224 | p >> 12] + s[128 | p >> 6 & 63] + s[128 | 63 & p] : h[h.length] = l.charAt(d)
              }
              c += h.join("")
            }
            return c
          },
          isBuffer: function(t) {
            return !(!t || "object" != typeof t || !(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t)))
          },
          isRegExp: function(t) {
            return "[object RegExp]" === {}.toString.call(t)
          },
          maybeMap: function(t, e) {
            if (o(t)) {
              for (var r = [], n = 0; n < t.length; n += 1) r.push(e(t[n]));
              return r
            }
            return e(t)
          },
          merge: function t(e, r, n) {
            if (!r) return e;
            if ("object" != typeof r && "function" != typeof r) {
              if (o(e)) e.push(r);
              else {
                if (!e || "object" != typeof e) return [e, r];
                (n && (n.plainObjects || n.allowPrototypes) || !i.call(Object.prototype, r)) && (e[r] = !0)
              }
              return e
            }
            if (!e || "object" != typeof e) return [e].concat(r);
            var s = e;
            return o(e) && !o(r) && (s = a(e, n)), o(e) && o(r) ? (r.forEach(function(r, o) {
              if (i.call(e, o)) {
                var s = e[o];
                s && "object" == typeof s && r && "object" == typeof r ? e[o] = t(s, r, n) : e.push(r)
              } else e[o] = r
            }), e) : Object.keys(r).reduce(function(e, o) {
              var s = r[o];
              return i.call(e, o) ? e[o] = t(e[o], s, n) : e[o] = s, e
            }, s)
          }
        }
      },
      38075: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(10487),
          o = i(n("String.prototype.indexOf"));
        t.exports = function(t, e) {
          var r = n(t, !!e);
          return "function" == typeof r && o(t, ".prototype.") > -1 ? i(r) : r
        }
      },
      38108: (t, e, r) => {
        var n = r(65339),
          i = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof i && i || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        n.exportSymbol("TronWebProto.ResourceCode", null, i), TronWebProto.ResourceCode = {
          BANDWIDTH: 0,
          ENERGY: 1,
          TRON_POWER: 2
        }, n.object.extend(e, TronWebProto)
      },
      38403: (t, e, r) => {
        "use strict";
        var n = r(1189),
          i = r(41333)(),
          o = r(36556),
          s = r(79612),
          a = o("Array.prototype.push"),
          u = o("Object.prototype.propertyIsEnumerable"),
          c = i ? s.getOwnPropertySymbols : null;
        t.exports = function(t, e) {
          if (null == t) throw new TypeError("target must be an object");
          var r = s(t);
          if (1 === arguments.length) return r;
          for (var o = 1; arguments.length > o; ++o) {
            var f = s(arguments[o]),
              l = n(f),
              h = i && (s.getOwnPropertySymbols || c);
            if (h)
              for (var d = h(f), p = 0; p < d.length; ++p) {
                var b = d[p];
                u(f, b) && a(l, b)
              }
            for (var m = 0; m < l.length; ++m) {
              var y = l[m];
              if (u(f, y)) {
                var g = f[y];
                r[y] = g
              }
            }
          }
          return r
        }
      },
      38452: (t, e, r) => {
        "use strict";
        var n = r(1189),
          i = "function" == typeof Symbol && "symbol" == typeof Symbol("foo"),
          o = {}.toString,
          s = [].concat,
          a = r(30041),
          u = r(30592)(),
          c = function(t, e, r, n) {
            if (e in t)
              if (!0 === n) {
                if (t[e] === r) return
              } else if (! function(t) {
                return "function" == typeof t && "[object Function]" === o.call(t)
              }(n) || !n()) return;
            u ? a(t, e, r, !0) : a(t, e, r)
          },
          f = function(t, e) {
            var r = arguments.length > 2 ? arguments[2] : {},
              o = n(e);
            i && (o = s.call(o, Object.getOwnPropertySymbols(e)));
            for (var a = 0; a < o.length; a += 1) c(t, o[a], e[o[a]], r[o[a]])
          };
        f.supportsDescriptors = !!u, t.exports = f
      },
      39209: (t, e, r) => {
        "use strict";
        var n = r(76578),
          i = typeof globalThis > "u" ? r.g : globalThis;
        t.exports = function() {
          for (var t = [], e = 0; e < n.length; e++) "function" == typeof i[n[e]] && (t[t.length] = n[e]);
          return t
        }
      },
      39404: function(t, e, r) {
        ! function(t, e) {
          "use strict";

          function n(t, e) {
            if (!t) throw Error(e || "Assertion failed")
          }

          function i(t, e) {
            t.super_ = e;
            var r = function() {};
            r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
          }

          function o(t, e, r) {
            if (o.isBN(t)) return t;
            this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== t && (("le" === e || "be" === e) && (r = e, e = 10), this.ht(t || 0, e || 10, r || "be"))
          }
          var s;
          "object" == typeof t ? t.exports = o : e.BN = o, o.BN = o, o.wordSize = 26;
          try {
            s = "u" > typeof window && "u" > typeof window.Buffer ? window.Buffer : r(47790).Buffer
          } catch {}

          function a(t, e) {
            var r = t.charCodeAt(e);
            return 48 > r || r > 57 ? 65 > r || r > 70 ? 97 > r || r > 102 ? void n(!1, "Invalid character in " + t) : r - 87 : r - 55 : r - 48
          }

          function u(t, e, r) {
            var n = a(t, r);
            return r - 1 >= e && (n |= a(t, r - 1) << 4), n
          }

          function c(t, e, r, i) {
            for (var o = 0, s = 0, a = Math.min(t.length, r), u = e; a > u; u++) {
              var c = t.charCodeAt(u) - 48;
              o *= i, s = 49 > c ? 17 > c ? c : c - 17 + 10 : c - 49 + 10, n(c >= 0 && i > s, "Invalid character"), o += s
            }
            return o
          }

          function f(t, e) {
            t.words = e.words, t.length = e.length, t.negative = e.negative, t.red = e.red
          }
          if (o.isBN = function(t) {
              return t instanceof o || null !== t && "object" == typeof t && t.constructor.wordSize === o.wordSize && Array.isArray(t.words)
            }, o.max = function(t, e) {
              return t.cmp(e) > 0 ? t : e
            }, o.min = function(t, e) {
              return 0 > t.cmp(e) ? t : e
            }, o.prototype.ht = function(t, e, r) {
              if ("number" == typeof t) return this.Me(t, e, r);
              if ("object" == typeof t) return this.Ce(t, e, r);
              "hex" === e && (e = 16), n(e === (0 | e) && e >= 2 && 36 >= e);
              var i = 0;
              "-" === (t = t.toString().replace(/\s+/g, ""))[0] && (i++, this.negative = 1), i < t.length && (16 === e ? this.Re(t, i, r) : (this.Ne(t, e, i), "le" === r && this.Ce(this.toArray(), e, r)))
            }, o.prototype.Me = function(t, e, r) {
              0 > t && (this.negative = 1, t = -t), 67108864 > t ? (this.words = [67108863 & t], this.length = 1) : 4503599627370496 > t ? (this.words = [67108863 & t, t / 67108864 & 67108863], this.length = 2) : (n(9007199254740992 > t), this.words = [67108863 & t, t / 67108864 & 67108863, 1], this.length = 3), "le" === r && this.Ce(this.toArray(), e, r)
            }, o.prototype.Ce = function(t, e, r) {
              if (n("number" == typeof t.length), 0 >= t.length) return this.words = [0], this.length = 1, this;
              this.length = Math.ceil(t.length / 3), this.words = Array(this.length);
              for (var i = 0; i < this.length; i++) this.words[i] = 0;
              var o, s, a = 0;
              if ("be" === r)
                for (i = t.length - 1, o = 0; i >= 0; i -= 3) s = t[i] | t[i - 1] << 8 | t[i - 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
              else if ("le" === r)
                for (i = 0, o = 0; i < t.length; i += 3) s = t[i] | t[i + 1] << 8 | t[i + 2] << 16, this.words[o] |= s << a & 67108863, this.words[o + 1] = s >>> 26 - a & 67108863, (a += 24) >= 26 && (a -= 26, o++);
              return this._e()
            }, o.prototype.Re = function(t, e, r) {
              this.length = Math.ceil((t.length - e) / 6), this.words = Array(this.length);
              for (var n = 0; n < this.length; n++) this.words[n] = 0;
              var i, o = 0,
                s = 0;
              if ("be" === r)
                for (n = t.length - 1; n >= e; n -= 2) i = u(t, e, n) << o, this.words[s] |= 67108863 & i, 18 > o ? o += 8 : (o -= 18, s += 1, this.words[s] |= i >>> 26);
              else
                for (n = (t.length - e) % 2 == 0 ? e + 1 : e; n < t.length; n += 2) i = u(t, e, n) << o, this.words[s] |= 67108863 & i, 18 > o ? o += 8 : (o -= 18, s += 1, this.words[s] |= i >>> 26);
              this._e()
            }, o.prototype.Ne = function(t, e, r) {
              this.words = [0], this.length = 1;
              for (var n = 0, i = 1; 67108863 >= i; i *= e) n++;
              n--, i = i / e | 0;
              for (var o = t.length - r, s = o % n, a = Math.min(o, o - s) + r, u = 0, f = r; a > f; f += n) u = c(t, f, f + n, e), this.imuln(i), 67108864 > this.words[0] + u ? this.words[0] += u : this.De(u);
              if (0 !== s) {
                var l = 1;
                for (u = c(t, f, t.length, e), f = 0; s > f; f++) l *= e;
                this.imuln(l), 67108864 > this.words[0] + u ? this.words[0] += u : this.De(u)
              }
              this._e()
            }, o.prototype.copy = function(t) {
              t.words = Array(this.length);
              for (var e = 0; e < this.length; e++) t.words[e] = this.words[e];
              t.length = this.length, t.negative = this.negative, t.red = this.red
            }, o.prototype.Ue = function(t) {
              f(t, this)
            }, o.prototype.clone = function() {
              var t = new o(null);
              return this.copy(t), t
            }, o.prototype.Le = function(t) {
              for (; this.length < t;) this.words[this.length++] = 0;
              return this
            }, o.prototype._e = function() {
              for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;
              return this.Fe()
            }, o.prototype.Fe = function() {
              return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this
            }, "u" > typeof Symbol && "function" == typeof Symbol.for) try {
            o.prototype[Symbol.for("nodejs.util.inspect.custom")] = l
          } catch {
            o.prototype.inspect = l
          } else o.prototype.inspect = l;

          function l() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
          }
          var h = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            p = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

          function b(t, e, r) {
            r.negative = e.negative ^ t.negative;
            var n = t.length + e.length | 0;
            r.length = n, n = n - 1 | 0;
            var i = 0 | t.words[0],
              o = 0 | e.words[0],
              s = i * o,
              a = 67108863 & s,
              u = s / 67108864 | 0;
            r.words[0] = a;
            for (var c = 1; n > c; c++) {
              for (var f = u >>> 26, l = 67108863 & u, h = Math.min(c, e.length - 1), d = Math.max(0, c - t.length + 1); h >= d; d++) {
                var p = c - d | 0;
                f += (s = (i = 0 | t.words[p]) * (o = 0 | e.words[d]) + l) / 67108864 | 0, l = 67108863 & s
              }
              r.words[c] = 0 | l, u = 0 | f
            }
            return 0 !== u ? r.words[c] = 0 | u : r.length--, r._e()
          }
          o.prototype.toString = function(t, e) {
            var r;
            if (e = 0 | e || 1, 16 === (t = t || 10) || "hex" === t) {
              r = "";
              for (var i = 0, o = 0, s = 0; s < this.length; s++) {
                var a = this.words[s],
                  u = (16777215 & (a << i | o)).toString(16);
                o = a >>> 24 - i & 16777215, (i += 2) >= 26 && (i -= 26, s--), r = 0 !== o || s !== this.length - 1 ? h[6 - u.length] + u + r : u + r
              }
              for (0 !== o && (r = o.toString(16) + r); r.length % e !== 0;) r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r
            }
            if (t === (0 | t) && t >= 2 && 36 >= t) {
              var c = d[t],
                f = p[t];
              r = "";
              var l = this.clone();
              for (l.negative = 0; !l.isZero();) {
                var b = l.modrn(f).toString(t);
                r = (l = l.idivn(f)).isZero() ? b + r : h[c - b.length] + b + r
              }
              for (this.isZero() && (r = "0" + r); r.length % e !== 0;) r = "0" + r;
              return 0 !== this.negative && (r = "-" + r), r
            }
            n(!1, "Base should be between 2 and 36")
          }, o.prototype.toNumber = function() {
            var t = this.words[0];
            return 2 === this.length ? t += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? t += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && n(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -t : t
          }, o.prototype.toJSON = function() {
            return this.toString(16, 2)
          }, s && (o.prototype.toBuffer = function(t, e) {
            return this.toArrayLike(s, t, e)
          }), o.prototype.toArray = function(t, e) {
            return this.toArrayLike(Array, t, e)
          }, o.prototype.toArrayLike = function(t, e, r) {
            this._e();
            var i = this.byteLength(),
              o = r || Math.max(1, i);
            n(o >= i, "byte array longer than desired length"), n(o > 0, "Requested array length <= 0");
            var s = function(t, e) {
              return t.allocUnsafe ? t.allocUnsafe(e) : new t(e)
            }(t, o);
            return this["_toArrayLike" + ("le" === e ? "LE" : "BE")](s, i), s
          }, o.prototype.$e = function(t, e) {
            for (var r = 0, n = 0, i = 0, o = 0; i < this.length; i++) {
              var s = this.words[i] << o | n;
              t[r++] = 255 & s, r < t.length && (t[r++] = s >> 8 & 255), r < t.length && (t[r++] = s >> 16 & 255), 6 === o ? (r < t.length && (t[r++] = s >> 24 & 255), n = 0, o = 0) : (n = s >>> 24, o += 2)
            }
            if (r < t.length)
              for (t[r++] = n; r < t.length;) t[r++] = 0
          }, o.prototype.ze = function(t, e) {
            for (var r = t.length - 1, n = 0, i = 0, o = 0; i < this.length; i++) {
              var s = this.words[i] << o | n;
              t[r--] = 255 & s, r >= 0 && (t[r--] = s >> 8 & 255), r >= 0 && (t[r--] = s >> 16 & 255), 6 === o ? (r >= 0 && (t[r--] = s >> 24 & 255), n = 0, o = 0) : (n = s >>> 24, o += 2)
            }
            if (r >= 0)
              for (t[r--] = n; r >= 0;) t[r--] = 0
          }, o.prototype.He = Math.clz32 ? function(t) {
            return 32 - Math.clz32(t)
          } : function(t) {
            var e = t,
              r = 0;
            return e >= 4096 && (r += 13, e >>>= 13), e >= 64 && (r += 7, e >>>= 7), e >= 8 && (r += 4, e >>>= 4), e >= 2 && (r += 2, e >>>= 2), r + e
          }, o.prototype.Ge = function(t) {
            if (0 === t) return 26;
            var e = t,
              r = 0;
            return !(8191 & e) && (r += 13, e >>>= 13), !(127 & e) && (r += 7, e >>>= 7), !(15 & e) && (r += 4, e >>>= 4), !(3 & e) && (r += 2, e >>>= 2), !(1 & e) && r++, r
          }, o.prototype.bitLength = function() {
            var t = this.words[this.length - 1],
              e = this.He(t);
            return 26 * (this.length - 1) + e
          }, o.prototype.zeroBits = function() {
            if (this.isZero()) return 0;
            for (var t = 0, e = 0; e < this.length; e++) {
              var r = this.Ge(this.words[e]);
              if (t += r, 26 !== r) break
            }
            return t
          }, o.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
          }, o.prototype.toTwos = function(t) {
            return 0 !== this.negative ? this.abs().inotn(t).iaddn(1) : this.clone()
          }, o.prototype.fromTwos = function(t) {
            return this.testn(t - 1) ? this.notn(t).iaddn(1).ineg() : this.clone()
          }, o.prototype.isNeg = function() {
            return 0 !== this.negative
          }, o.prototype.neg = function() {
            return this.clone().ineg()
          }, o.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1), this
          }, o.prototype.iuor = function(t) {
            for (; this.length < t.length;) this.words[this.length++] = 0;
            for (var e = 0; e < t.length; e++) this.words[e] = this.words[e] | t.words[e];
            return this._e()
          }, o.prototype.ior = function(t) {
            return n(0 === (this.negative | t.negative)), this.iuor(t)
          }, o.prototype.or = function(t) {
            return this.length > t.length ? this.clone().ior(t) : t.clone().ior(this)
          }, o.prototype.uor = function(t) {
            return this.length > t.length ? this.clone().iuor(t) : t.clone().iuor(this)
          }, o.prototype.iuand = function(t) {
            var e;
            e = this.length > t.length ? t : this;
            for (var r = 0; r < e.length; r++) this.words[r] = this.words[r] & t.words[r];
            return this.length = e.length, this._e()
          }, o.prototype.iand = function(t) {
            return n(0 === (this.negative | t.negative)), this.iuand(t)
          }, o.prototype.and = function(t) {
            return this.length > t.length ? this.clone().iand(t) : t.clone().iand(this)
          }, o.prototype.uand = function(t) {
            return this.length > t.length ? this.clone().iuand(t) : t.clone().iuand(this)
          }, o.prototype.iuxor = function(t) {
            var e, r;
            this.length > t.length ? (e = this, r = t) : (e = t, r = this);
            for (var n = 0; n < r.length; n++) this.words[n] = e.words[n] ^ r.words[n];
            if (this !== e)
              for (; n < e.length; n++) this.words[n] = e.words[n];
            return this.length = e.length, this._e()
          }, o.prototype.ixor = function(t) {
            return n(0 === (this.negative | t.negative)), this.iuxor(t)
          }, o.prototype.xor = function(t) {
            return this.length > t.length ? this.clone().ixor(t) : t.clone().ixor(this)
          }, o.prototype.uxor = function(t) {
            return this.length > t.length ? this.clone().iuxor(t) : t.clone().iuxor(this)
          }, o.prototype.inotn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = 0 | Math.ceil(t / 26),
              r = t % 26;
            this.Le(e), r > 0 && e--;
            for (var i = 0; e > i; i++) this.words[i] = 67108863 & ~this.words[i];
            return r > 0 && (this.words[i] = ~this.words[i] & 67108863 >> 26 - r), this._e()
          }, o.prototype.notn = function(t) {
            return this.clone().inotn(t)
          }, o.prototype.setn = function(t, e) {
            n("number" == typeof t && t >= 0);
            var r = t / 26 | 0,
              i = t % 26;
            return this.Le(r + 1), this.words[r] = e ? this.words[r] | 1 << i : this.words[r] & ~(1 << i), this._e()
          }, o.prototype.iadd = function(t) {
            var e, r, n;
            if (0 !== this.negative && 0 === t.negative) return this.negative = 0, e = this.isub(t), this.negative ^= 1, this.Fe();
            if (0 === this.negative && 0 !== t.negative) return t.negative = 0, e = this.isub(t), t.negative = 1, e.Fe();
            this.length > t.length ? (r = this, n = t) : (r = t, n = this);
            for (var i = 0, o = 0; o < n.length; o++) e = (0 | r.words[o]) + (0 | n.words[o]) + i, this.words[o] = 67108863 & e, i = e >>> 26;
            for (; 0 !== i && o < r.length; o++) e = (0 | r.words[o]) + i, this.words[o] = 67108863 & e, i = e >>> 26;
            if (this.length = r.length, 0 !== i) this.words[this.length] = i, this.length++;
            else if (r !== this)
              for (; o < r.length; o++) this.words[o] = r.words[o];
            return this
          }, o.prototype.add = function(t) {
            var e;
            return 0 !== t.negative && 0 === this.negative ? (t.negative = 0, e = this.sub(t), t.negative ^= 1, e) : 0 === t.negative && 0 !== this.negative ? (this.negative = 0, e = t.sub(this), this.negative = 1, e) : this.length > t.length ? this.clone().iadd(t) : t.clone().iadd(this)
          }, o.prototype.isub = function(t) {
            if (0 !== t.negative) {
              t.negative = 0;
              var e = this.iadd(t);
              return t.negative = 1, e.Fe()
            }
            if (0 !== this.negative) return this.negative = 0, this.iadd(t), this.negative = 1, this.Fe();
            var r, n, i = this.cmp(t);
            if (0 === i) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
            i > 0 ? (r = this, n = t) : (r = t, n = this);
            for (var o = 0, s = 0; s < n.length; s++) o = (e = (0 | r.words[s]) - (0 | n.words[s]) + o) >> 26, this.words[s] = 67108863 & e;
            for (; 0 !== o && s < r.length; s++) o = (e = (0 | r.words[s]) + o) >> 26, this.words[s] = 67108863 & e;
            if (0 === o && s < r.length && r !== this)
              for (; s < r.length; s++) this.words[s] = r.words[s];
            return this.length = Math.max(this.length, s), r !== this && (this.negative = 1), this._e()
          }, o.prototype.sub = function(t) {
            return this.clone().isub(t)
          };
          var m = function(t, e, r) {
            var n, i, o, s = t.words,
              a = e.words,
              u = r.words,
              c = 0,
              f = 0 | s[0],
              l = 8191 & f,
              h = f >>> 13,
              d = 0 | s[1],
              p = 8191 & d,
              b = d >>> 13,
              m = 0 | s[2],
              y = 8191 & m,
              g = m >>> 13,
              v = 0 | s[3],
              w = 8191 & v,
              A = v >>> 13,
              T = 0 | s[4],
              E = 8191 & T,
              P = T >>> 13,
              k = 0 | s[5],
              x = 8191 & k,
              I = k >>> 13,
              S = 0 | s[6],
              O = 8191 & S,
              B = S >>> 13,
              W = 0 | s[7],
              M = 8191 & W,
              C = W >>> 13,
              R = 0 | s[8],
              N = 8191 & R,
              j = R >>> 13,
              _ = 0 | s[9],
              D = 8191 & _,
              U = _ >>> 13,
              L = 0 | a[0],
              F = 8191 & L,
              $ = L >>> 13,
              z = 0 | a[1],
              H = 8191 & z,
              G = z >>> 13,
              K = 0 | a[2],
              V = 8191 & K,
              Z = K >>> 13,
              q = 0 | a[3],
              J = 8191 & q,
              Y = q >>> 13,
              Q = 0 | a[4],
              X = 8191 & Q,
              tt = Q >>> 13,
              et = 0 | a[5],
              rt = 8191 & et,
              nt = et >>> 13,
              it = 0 | a[6],
              ot = 8191 & it,
              st = it >>> 13,
              at = 0 | a[7],
              ut = 8191 & at,
              ct = at >>> 13,
              ft = 0 | a[8],
              lt = 8191 & ft,
              ht = ft >>> 13,
              dt = 0 | a[9],
              pt = 8191 & dt,
              bt = dt >>> 13;
            r.negative = t.negative ^ e.negative, r.length = 19;
            var mt = (c + (n = Math.imul(l, F)) | 0) + ((8191 & (i = (i = Math.imul(l, $)) + Math.imul(h, F) | 0)) << 13) | 0;
            c = ((o = Math.imul(h, $)) + (i >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, n = Math.imul(p, F), i = (i = Math.imul(p, $)) + Math.imul(b, F) | 0, o = Math.imul(b, $);
            var yt = (c + (n = n + Math.imul(l, H) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, G) | 0) + Math.imul(h, H) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, G) | 0) + (i >>> 13) | 0) + (yt >>> 26) | 0, yt &= 67108863, n = Math.imul(y, F), i = (i = Math.imul(y, $)) + Math.imul(g, F) | 0, o = Math.imul(g, $), n = n + Math.imul(p, H) | 0, i = (i = i + Math.imul(p, G) | 0) + Math.imul(b, H) | 0, o = o + Math.imul(b, G) | 0;
            var gt = (c + (n = n + Math.imul(l, V) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, Z) | 0) + Math.imul(h, V) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, Z) | 0) + (i >>> 13) | 0) + (gt >>> 26) | 0, gt &= 67108863, n = Math.imul(w, F), i = (i = Math.imul(w, $)) + Math.imul(A, F) | 0, o = Math.imul(A, $), n = n + Math.imul(y, H) | 0, i = (i = i + Math.imul(y, G) | 0) + Math.imul(g, H) | 0, o = o + Math.imul(g, G) | 0, n = n + Math.imul(p, V) | 0, i = (i = i + Math.imul(p, Z) | 0) + Math.imul(b, V) | 0, o = o + Math.imul(b, Z) | 0;
            var vt = (c + (n = n + Math.imul(l, J) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, Y) | 0) + Math.imul(h, J) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, Y) | 0) + (i >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, n = Math.imul(E, F), i = (i = Math.imul(E, $)) + Math.imul(P, F) | 0, o = Math.imul(P, $), n = n + Math.imul(w, H) | 0, i = (i = i + Math.imul(w, G) | 0) + Math.imul(A, H) | 0, o = o + Math.imul(A, G) | 0, n = n + Math.imul(y, V) | 0, i = (i = i + Math.imul(y, Z) | 0) + Math.imul(g, V) | 0, o = o + Math.imul(g, Z) | 0, n = n + Math.imul(p, J) | 0, i = (i = i + Math.imul(p, Y) | 0) + Math.imul(b, J) | 0, o = o + Math.imul(b, Y) | 0;
            var wt = (c + (n = n + Math.imul(l, X) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, tt) | 0) + Math.imul(h, X) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, tt) | 0) + (i >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, n = Math.imul(x, F), i = (i = Math.imul(x, $)) + Math.imul(I, F) | 0, o = Math.imul(I, $), n = n + Math.imul(E, H) | 0, i = (i = i + Math.imul(E, G) | 0) + Math.imul(P, H) | 0, o = o + Math.imul(P, G) | 0, n = n + Math.imul(w, V) | 0, i = (i = i + Math.imul(w, Z) | 0) + Math.imul(A, V) | 0, o = o + Math.imul(A, Z) | 0, n = n + Math.imul(y, J) | 0, i = (i = i + Math.imul(y, Y) | 0) + Math.imul(g, J) | 0, o = o + Math.imul(g, Y) | 0, n = n + Math.imul(p, X) | 0, i = (i = i + Math.imul(p, tt) | 0) + Math.imul(b, X) | 0, o = o + Math.imul(b, tt) | 0;
            var At = (c + (n = n + Math.imul(l, rt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, nt) | 0) + Math.imul(h, rt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, nt) | 0) + (i >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, n = Math.imul(O, F), i = (i = Math.imul(O, $)) + Math.imul(B, F) | 0, o = Math.imul(B, $), n = n + Math.imul(x, H) | 0, i = (i = i + Math.imul(x, G) | 0) + Math.imul(I, H) | 0, o = o + Math.imul(I, G) | 0, n = n + Math.imul(E, V) | 0, i = (i = i + Math.imul(E, Z) | 0) + Math.imul(P, V) | 0, o = o + Math.imul(P, Z) | 0, n = n + Math.imul(w, J) | 0, i = (i = i + Math.imul(w, Y) | 0) + Math.imul(A, J) | 0, o = o + Math.imul(A, Y) | 0, n = n + Math.imul(y, X) | 0, i = (i = i + Math.imul(y, tt) | 0) + Math.imul(g, X) | 0, o = o + Math.imul(g, tt) | 0, n = n + Math.imul(p, rt) | 0, i = (i = i + Math.imul(p, nt) | 0) + Math.imul(b, rt) | 0, o = o + Math.imul(b, nt) | 0;
            var Tt = (c + (n = n + Math.imul(l, ot) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, st) | 0) + Math.imul(h, ot) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, st) | 0) + (i >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, n = Math.imul(M, F), i = (i = Math.imul(M, $)) + Math.imul(C, F) | 0, o = Math.imul(C, $), n = n + Math.imul(O, H) | 0, i = (i = i + Math.imul(O, G) | 0) + Math.imul(B, H) | 0, o = o + Math.imul(B, G) | 0, n = n + Math.imul(x, V) | 0, i = (i = i + Math.imul(x, Z) | 0) + Math.imul(I, V) | 0, o = o + Math.imul(I, Z) | 0, n = n + Math.imul(E, J) | 0, i = (i = i + Math.imul(E, Y) | 0) + Math.imul(P, J) | 0, o = o + Math.imul(P, Y) | 0, n = n + Math.imul(w, X) | 0, i = (i = i + Math.imul(w, tt) | 0) + Math.imul(A, X) | 0, o = o + Math.imul(A, tt) | 0, n = n + Math.imul(y, rt) | 0, i = (i = i + Math.imul(y, nt) | 0) + Math.imul(g, rt) | 0, o = o + Math.imul(g, nt) | 0, n = n + Math.imul(p, ot) | 0, i = (i = i + Math.imul(p, st) | 0) + Math.imul(b, ot) | 0, o = o + Math.imul(b, st) | 0;
            var Et = (c + (n = n + Math.imul(l, ut) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, ct) | 0) + Math.imul(h, ut) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, ct) | 0) + (i >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, n = Math.imul(N, F), i = (i = Math.imul(N, $)) + Math.imul(j, F) | 0, o = Math.imul(j, $), n = n + Math.imul(M, H) | 0, i = (i = i + Math.imul(M, G) | 0) + Math.imul(C, H) | 0, o = o + Math.imul(C, G) | 0, n = n + Math.imul(O, V) | 0, i = (i = i + Math.imul(O, Z) | 0) + Math.imul(B, V) | 0, o = o + Math.imul(B, Z) | 0, n = n + Math.imul(x, J) | 0, i = (i = i + Math.imul(x, Y) | 0) + Math.imul(I, J) | 0, o = o + Math.imul(I, Y) | 0, n = n + Math.imul(E, X) | 0, i = (i = i + Math.imul(E, tt) | 0) + Math.imul(P, X) | 0, o = o + Math.imul(P, tt) | 0, n = n + Math.imul(w, rt) | 0, i = (i = i + Math.imul(w, nt) | 0) + Math.imul(A, rt) | 0, o = o + Math.imul(A, nt) | 0, n = n + Math.imul(y, ot) | 0, i = (i = i + Math.imul(y, st) | 0) + Math.imul(g, ot) | 0, o = o + Math.imul(g, st) | 0, n = n + Math.imul(p, ut) | 0, i = (i = i + Math.imul(p, ct) | 0) + Math.imul(b, ut) | 0, o = o + Math.imul(b, ct) | 0;
            var Pt = (c + (n = n + Math.imul(l, lt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, ht) | 0) + Math.imul(h, lt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, ht) | 0) + (i >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, n = Math.imul(D, F), i = (i = Math.imul(D, $)) + Math.imul(U, F) | 0, o = Math.imul(U, $), n = n + Math.imul(N, H) | 0, i = (i = i + Math.imul(N, G) | 0) + Math.imul(j, H) | 0, o = o + Math.imul(j, G) | 0, n = n + Math.imul(M, V) | 0, i = (i = i + Math.imul(M, Z) | 0) + Math.imul(C, V) | 0, o = o + Math.imul(C, Z) | 0, n = n + Math.imul(O, J) | 0, i = (i = i + Math.imul(O, Y) | 0) + Math.imul(B, J) | 0, o = o + Math.imul(B, Y) | 0, n = n + Math.imul(x, X) | 0, i = (i = i + Math.imul(x, tt) | 0) + Math.imul(I, X) | 0, o = o + Math.imul(I, tt) | 0, n = n + Math.imul(E, rt) | 0, i = (i = i + Math.imul(E, nt) | 0) + Math.imul(P, rt) | 0, o = o + Math.imul(P, nt) | 0, n = n + Math.imul(w, ot) | 0, i = (i = i + Math.imul(w, st) | 0) + Math.imul(A, ot) | 0, o = o + Math.imul(A, st) | 0, n = n + Math.imul(y, ut) | 0, i = (i = i + Math.imul(y, ct) | 0) + Math.imul(g, ut) | 0, o = o + Math.imul(g, ct) | 0, n = n + Math.imul(p, lt) | 0, i = (i = i + Math.imul(p, ht) | 0) + Math.imul(b, lt) | 0, o = o + Math.imul(b, ht) | 0;
            var kt = (c + (n = n + Math.imul(l, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(l, bt) | 0) + Math.imul(h, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(h, bt) | 0) + (i >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, n = Math.imul(D, H), i = (i = Math.imul(D, G)) + Math.imul(U, H) | 0, o = Math.imul(U, G), n = n + Math.imul(N, V) | 0, i = (i = i + Math.imul(N, Z) | 0) + Math.imul(j, V) | 0, o = o + Math.imul(j, Z) | 0, n = n + Math.imul(M, J) | 0, i = (i = i + Math.imul(M, Y) | 0) + Math.imul(C, J) | 0, o = o + Math.imul(C, Y) | 0, n = n + Math.imul(O, X) | 0, i = (i = i + Math.imul(O, tt) | 0) + Math.imul(B, X) | 0, o = o + Math.imul(B, tt) | 0, n = n + Math.imul(x, rt) | 0, i = (i = i + Math.imul(x, nt) | 0) + Math.imul(I, rt) | 0, o = o + Math.imul(I, nt) | 0, n = n + Math.imul(E, ot) | 0, i = (i = i + Math.imul(E, st) | 0) + Math.imul(P, ot) | 0, o = o + Math.imul(P, st) | 0, n = n + Math.imul(w, ut) | 0, i = (i = i + Math.imul(w, ct) | 0) + Math.imul(A, ut) | 0, o = o + Math.imul(A, ct) | 0, n = n + Math.imul(y, lt) | 0, i = (i = i + Math.imul(y, ht) | 0) + Math.imul(g, lt) | 0, o = o + Math.imul(g, ht) | 0;
            var xt = (c + (n = n + Math.imul(p, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(p, bt) | 0) + Math.imul(b, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(b, bt) | 0) + (i >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, n = Math.imul(D, V), i = (i = Math.imul(D, Z)) + Math.imul(U, V) | 0, o = Math.imul(U, Z), n = n + Math.imul(N, J) | 0, i = (i = i + Math.imul(N, Y) | 0) + Math.imul(j, J) | 0, o = o + Math.imul(j, Y) | 0, n = n + Math.imul(M, X) | 0, i = (i = i + Math.imul(M, tt) | 0) + Math.imul(C, X) | 0, o = o + Math.imul(C, tt) | 0, n = n + Math.imul(O, rt) | 0, i = (i = i + Math.imul(O, nt) | 0) + Math.imul(B, rt) | 0, o = o + Math.imul(B, nt) | 0, n = n + Math.imul(x, ot) | 0, i = (i = i + Math.imul(x, st) | 0) + Math.imul(I, ot) | 0, o = o + Math.imul(I, st) | 0, n = n + Math.imul(E, ut) | 0, i = (i = i + Math.imul(E, ct) | 0) + Math.imul(P, ut) | 0, o = o + Math.imul(P, ct) | 0, n = n + Math.imul(w, lt) | 0, i = (i = i + Math.imul(w, ht) | 0) + Math.imul(A, lt) | 0, o = o + Math.imul(A, ht) | 0;
            var It = (c + (n = n + Math.imul(y, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(y, bt) | 0) + Math.imul(g, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(g, bt) | 0) + (i >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, n = Math.imul(D, J), i = (i = Math.imul(D, Y)) + Math.imul(U, J) | 0, o = Math.imul(U, Y), n = n + Math.imul(N, X) | 0, i = (i = i + Math.imul(N, tt) | 0) + Math.imul(j, X) | 0, o = o + Math.imul(j, tt) | 0, n = n + Math.imul(M, rt) | 0, i = (i = i + Math.imul(M, nt) | 0) + Math.imul(C, rt) | 0, o = o + Math.imul(C, nt) | 0, n = n + Math.imul(O, ot) | 0, i = (i = i + Math.imul(O, st) | 0) + Math.imul(B, ot) | 0, o = o + Math.imul(B, st) | 0, n = n + Math.imul(x, ut) | 0, i = (i = i + Math.imul(x, ct) | 0) + Math.imul(I, ut) | 0, o = o + Math.imul(I, ct) | 0, n = n + Math.imul(E, lt) | 0, i = (i = i + Math.imul(E, ht) | 0) + Math.imul(P, lt) | 0, o = o + Math.imul(P, ht) | 0;
            var St = (c + (n = n + Math.imul(w, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(w, bt) | 0) + Math.imul(A, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(A, bt) | 0) + (i >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, n = Math.imul(D, X), i = (i = Math.imul(D, tt)) + Math.imul(U, X) | 0, o = Math.imul(U, tt), n = n + Math.imul(N, rt) | 0, i = (i = i + Math.imul(N, nt) | 0) + Math.imul(j, rt) | 0, o = o + Math.imul(j, nt) | 0, n = n + Math.imul(M, ot) | 0, i = (i = i + Math.imul(M, st) | 0) + Math.imul(C, ot) | 0, o = o + Math.imul(C, st) | 0, n = n + Math.imul(O, ut) | 0, i = (i = i + Math.imul(O, ct) | 0) + Math.imul(B, ut) | 0, o = o + Math.imul(B, ct) | 0, n = n + Math.imul(x, lt) | 0, i = (i = i + Math.imul(x, ht) | 0) + Math.imul(I, lt) | 0, o = o + Math.imul(I, ht) | 0;
            var Ot = (c + (n = n + Math.imul(E, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(E, bt) | 0) + Math.imul(P, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(P, bt) | 0) + (i >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, n = Math.imul(D, rt), i = (i = Math.imul(D, nt)) + Math.imul(U, rt) | 0, o = Math.imul(U, nt), n = n + Math.imul(N, ot) | 0, i = (i = i + Math.imul(N, st) | 0) + Math.imul(j, ot) | 0, o = o + Math.imul(j, st) | 0, n = n + Math.imul(M, ut) | 0, i = (i = i + Math.imul(M, ct) | 0) + Math.imul(C, ut) | 0, o = o + Math.imul(C, ct) | 0, n = n + Math.imul(O, lt) | 0, i = (i = i + Math.imul(O, ht) | 0) + Math.imul(B, lt) | 0, o = o + Math.imul(B, ht) | 0;
            var Bt = (c + (n = n + Math.imul(x, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(x, bt) | 0) + Math.imul(I, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(I, bt) | 0) + (i >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, n = Math.imul(D, ot), i = (i = Math.imul(D, st)) + Math.imul(U, ot) | 0, o = Math.imul(U, st), n = n + Math.imul(N, ut) | 0, i = (i = i + Math.imul(N, ct) | 0) + Math.imul(j, ut) | 0, o = o + Math.imul(j, ct) | 0, n = n + Math.imul(M, lt) | 0, i = (i = i + Math.imul(M, ht) | 0) + Math.imul(C, lt) | 0, o = o + Math.imul(C, ht) | 0;
            var Wt = (c + (n = n + Math.imul(O, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(O, bt) | 0) + Math.imul(B, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(B, bt) | 0) + (i >>> 13) | 0) + (Wt >>> 26) | 0, Wt &= 67108863, n = Math.imul(D, ut), i = (i = Math.imul(D, ct)) + Math.imul(U, ut) | 0, o = Math.imul(U, ct), n = n + Math.imul(N, lt) | 0, i = (i = i + Math.imul(N, ht) | 0) + Math.imul(j, lt) | 0, o = o + Math.imul(j, ht) | 0;
            var Mt = (c + (n = n + Math.imul(M, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(M, bt) | 0) + Math.imul(C, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(C, bt) | 0) + (i >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, n = Math.imul(D, lt), i = (i = Math.imul(D, ht)) + Math.imul(U, lt) | 0, o = Math.imul(U, ht);
            var Ct = (c + (n = n + Math.imul(N, pt) | 0) | 0) + ((8191 & (i = (i = i + Math.imul(N, bt) | 0) + Math.imul(j, pt) | 0)) << 13) | 0;
            c = ((o = o + Math.imul(j, bt) | 0) + (i >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863;
            var Rt = (c + (n = Math.imul(D, pt)) | 0) + ((8191 & (i = (i = Math.imul(D, bt)) + Math.imul(U, pt) | 0)) << 13) | 0;
            return c = ((o = Math.imul(U, bt)) + (i >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, u[0] = mt, u[1] = yt, u[2] = gt, u[3] = vt, u[4] = wt, u[5] = At, u[6] = Tt, u[7] = Et, u[8] = Pt, u[9] = kt, u[10] = xt, u[11] = It, u[12] = St, u[13] = Ot, u[14] = Bt, u[15] = Wt, u[16] = Mt, u[17] = Ct, u[18] = Rt, 0 !== c && (u[19] = c, r.length++), r
          };

          function y(t, e, r) {
            r.negative = e.negative ^ t.negative, r.length = t.length + e.length;
            for (var n = 0, i = 0, o = 0; o < r.length - 1; o++) {
              var s = i;
              i = 0;
              for (var a = 67108863 & n, u = Math.min(o, e.length - 1), c = Math.max(0, o - t.length + 1); u >= c; c++) {
                var f = o - c,
                  l = (0 | t.words[f]) * (0 | e.words[c]),
                  h = 67108863 & l;
                a = 67108863 & (h = h + a | 0), i += (s = (s = s + (l / 67108864 | 0) | 0) + (h >>> 26) | 0) >>> 26, s &= 67108863
              }
              r.words[o] = a, n = s, s = i
            }
            return 0 !== n ? r.words[o] = n : r.length--, r._e()
          }

          function g(t, e, r) {
            return y(t, e, r)
          }

          function v(t, e) {
            this.x = t, this.y = e
          }
          Math.imul || (m = b), o.prototype.mulTo = function(t, e) {
            var r = this.length + t.length;
            return 10 === this.length && 10 === t.length ? m(this, t, e) : 63 > r ? b(this, t, e) : 1024 > r ? y(this, t, e) : g(this, t, e)
          }, v.prototype.makeRBT = function(t) {
            for (var e = Array(t), r = o.prototype.He(t) - 1, n = 0; t > n; n++) e[n] = this.revBin(n, r, t);
            return e
          }, v.prototype.revBin = function(t, e, r) {
            if (0 === t || t === r - 1) return t;
            for (var n = 0, i = 0; e > i; i++) n |= (1 & t) << e - i - 1, t >>= 1;
            return n
          }, v.prototype.permute = function(t, e, r, n, i, o) {
            for (var s = 0; o > s; s++) n[s] = e[t[s]], i[s] = r[t[s]]
          }, v.prototype.transform = function(t, e, r, n, i, o) {
            this.permute(o, t, e, r, n, i);
            for (var s = 1; i > s; s <<= 1)
              for (var a = s << 1, u = Math.cos(2 * Math.PI / a), c = Math.sin(2 * Math.PI / a), f = 0; i > f; f += a)
                for (var l = u, h = c, d = 0; s > d; d++) {
                  var p = r[f + d],
                    b = n[f + d],
                    m = r[f + d + s],
                    y = n[f + d + s],
                    g = l * m - h * y;
                  y = l * y + h * m, m = g, r[f + d] = p + m, n[f + d] = b + y, r[f + d + s] = p - m, n[f + d + s] = b - y, d !== a && (g = u * l - c * h, h = u * h + c * l, l = g)
                }
          }, v.prototype.guessLen13b = function(t, e) {
            var r = 1 | Math.max(e, t),
              n = 1 & r,
              i = 0;
            for (r = r / 2 | 0; r; r >>>= 1) i++;
            return 1 << i + 1 + n
          }, v.prototype.conjugate = function(t, e, r) {
            if (r > 1)
              for (var n = 0; r / 2 > n; n++) {
                var i = t[n];
                t[n] = t[r - n - 1], t[r - n - 1] = i, i = e[n], e[n] = -e[r - n - 1], e[r - n - 1] = -i
              }
          }, v.prototype.normalize13b = function(t, e) {
            for (var r = 0, n = 0; e / 2 > n; n++) {
              var i = 8192 * Math.round(t[2 * n + 1] / e) + Math.round(t[2 * n] / e) + r;
              t[n] = 67108863 & i, r = 67108864 > i ? 0 : i / 67108864 | 0
            }
            return t
          }, v.prototype.convert13b = function(t, e, r, i) {
            for (var o = 0, s = 0; e > s; s++) o += 0 | t[s], r[2 * s] = 8191 & o, o >>>= 13, r[2 * s + 1] = 8191 & o, o >>>= 13;
            for (s = 2 * e; i > s; ++s) r[s] = 0;
            n(0 === o), n(!(-8192 & o))
          }, v.prototype.stub = function(t) {
            for (var e = Array(t), r = 0; t > r; r++) e[r] = 0;
            return e
          }, v.prototype.mulp = function(t, e, r) {
            var n = 2 * this.guessLen13b(t.length, e.length),
              i = this.makeRBT(n),
              o = this.stub(n),
              s = Array(n),
              a = Array(n),
              u = Array(n),
              c = Array(n),
              f = Array(n),
              l = Array(n),
              h = r.words;
            h.length = n, this.convert13b(t.words, t.length, s, n), this.convert13b(e.words, e.length, c, n), this.transform(s, o, a, u, n, i), this.transform(c, o, f, l, n, i);
            for (var d = 0; n > d; d++) {
              var p = a[d] * f[d] - u[d] * l[d];
              u[d] = a[d] * l[d] + u[d] * f[d], a[d] = p
            }
            return this.conjugate(a, u, n), this.transform(a, u, h, o, n, i), this.conjugate(h, o, n), this.normalize13b(h, n), r.negative = t.negative ^ e.negative, r.length = t.length + e.length, r._e()
          }, o.prototype.mul = function(t) {
            var e = new o(null);
            return e.words = Array(this.length + t.length), this.mulTo(t, e)
          }, o.prototype.mulf = function(t) {
            var e = new o(null);
            return e.words = Array(this.length + t.length), g(this, t, e)
          }, o.prototype.imul = function(t) {
            return this.clone().mulTo(t, this)
          }, o.prototype.imuln = function(t) {
            var e = 0 > t;
            e && (t = -t), n("number" == typeof t), n(67108864 > t);
            for (var r = 0, i = 0; i < this.length; i++) {
              var o = (0 | this.words[i]) * t,
                s = (67108863 & o) + (67108863 & r);
              r >>= 26, r += o / 67108864 | 0, r += s >>> 26, this.words[i] = 67108863 & s
            }
            return 0 !== r && (this.words[i] = r, this.length++), this.length = 0 === t ? 1 : this.length, e ? this.ineg() : this
          }, o.prototype.muln = function(t) {
            return this.clone().imuln(t)
          }, o.prototype.sqr = function() {
            return this.mul(this)
          }, o.prototype.isqr = function() {
            return this.imul(this.clone())
          }, o.prototype.pow = function(t) {
            var e = function(t) {
              for (var e = Array(t.bitLength()), r = 0; r < e.length; r++) {
                var n = r / 26 | 0,
                  i = r % 26;
                e[r] = t.words[n] >>> i & 1
              }
              return e
            }(t);
            if (0 === e.length) return new o(1);
            for (var r = this, n = 0; n < e.length && 0 === e[n]; n++, r = r.sqr());
            if (++n < e.length)
              for (var i = r.sqr(); n < e.length; n++, i = i.sqr()) 0 !== e[n] && (r = r.mul(i));
            return r
          }, o.prototype.iushln = function(t) {
            n("number" == typeof t && t >= 0);
            var e, r = t % 26,
              i = (t - r) / 26,
              o = 67108863 >>> 26 - r << 26 - r;
            if (0 !== r) {
              var s = 0;
              for (e = 0; e < this.length; e++) {
                var a = this.words[e] & o,
                  u = (0 | this.words[e]) - a << r;
                this.words[e] = u | s, s = a >>> 26 - r
              }
              s && (this.words[e] = s, this.length++)
            }
            if (0 !== i) {
              for (e = this.length - 1; e >= 0; e--) this.words[e + i] = this.words[e];
              for (e = 0; i > e; e++) this.words[e] = 0;
              this.length += i
            }
            return this._e()
          }, o.prototype.ishln = function(t) {
            return n(0 === this.negative), this.iushln(t)
          }, o.prototype.iushrn = function(t, e, r) {
            var i;
            n("number" == typeof t && t >= 0), i = e ? (e - e % 26) / 26 : 0;
            var o = t % 26,
              s = Math.min((t - o) / 26, this.length),
              a = 67108863 ^ 67108863 >>> o << o,
              u = r;
            if (i = Math.max(0, i -= s), u) {
              for (var c = 0; s > c; c++) u.words[c] = this.words[c];
              u.length = s
            }
            if (0 !== s)
              if (this.length > s)
                for (this.length -= s, c = 0; c < this.length; c++) this.words[c] = this.words[c + s];
              else this.words[0] = 0, this.length = 1;
            var f = 0;
            for (c = this.length - 1; !(0 > c || 0 === f && i > c); c--) {
              var l = 0 | this.words[c];
              this.words[c] = f << 26 - o | l >>> o, f = l & a
            }
            return u && 0 !== f && (u.words[u.length++] = f), 0 === this.length && (this.words[0] = 0, this.length = 1), this._e()
          }, o.prototype.ishrn = function(t, e, r) {
            return n(0 === this.negative), this.iushrn(t, e, r)
          }, o.prototype.shln = function(t) {
            return this.clone().ishln(t)
          }, o.prototype.ushln = function(t) {
            return this.clone().iushln(t)
          }, o.prototype.shrn = function(t) {
            return this.clone().ishrn(t)
          }, o.prototype.ushrn = function(t) {
            return this.clone().iushrn(t)
          }, o.prototype.testn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = t % 26,
              r = (t - e) / 26,
              i = 1 << e;
            return this.length > r && !!(this.words[r] & i)
          }, o.prototype.imaskn = function(t) {
            n("number" == typeof t && t >= 0);
            var e = t % 26,
              r = (t - e) / 26;
            if (n(0 === this.negative, "imaskn works only with positive numbers"), this.length <= r) return this;
            if (0 !== e && r++, this.length = Math.min(r, this.length), 0 !== e) {
              var i = 67108863 ^ 67108863 >>> e << e;
              this.words[this.length - 1] &= i
            }
            return this._e()
          }, o.prototype.maskn = function(t) {
            return this.clone().imaskn(t)
          }, o.prototype.iaddn = function(t) {
            return n("number" == typeof t), n(67108864 > t), 0 > t ? this.isubn(-t) : 0 !== this.negative ? 1 !== this.length || (0 | this.words[0]) > t ? (this.negative = 0, this.isubn(t), this.negative = 1, this) : (this.words[0] = t - (0 | this.words[0]), this.negative = 0, this) : this.De(t)
          }, o.prototype.De = function(t) {
            this.words[0] += t;
            for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;
            return this.length = Math.max(this.length, e + 1), this
          }, o.prototype.isubn = function(t) {
            if (n("number" == typeof t), n(67108864 > t), 0 > t) return this.iaddn(-t);
            if (0 !== this.negative) return this.negative = 0, this.iaddn(t), this.negative = 1, this;
            if (this.words[0] -= t, 1 === this.length && 0 > this.words[0]) this.words[0] = -this.words[0], this.negative = 1;
            else
              for (var e = 0; e < this.length && 0 > this.words[e]; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
            return this._e()
          }, o.prototype.addn = function(t) {
            return this.clone().iaddn(t)
          }, o.prototype.subn = function(t) {
            return this.clone().isubn(t)
          }, o.prototype.iabs = function() {
            return this.negative = 0, this
          }, o.prototype.abs = function() {
            return this.clone().iabs()
          }, o.prototype.Ke = function(t, e, r) {
            var i, o = t.length + r;
            this.Le(o);
            var s, a = 0;
            for (i = 0; i < t.length; i++) {
              s = (0 | this.words[i + r]) + a;
              var u = (0 | t.words[i]) * e;
              a = ((s -= 67108863 & u) >> 26) - (u / 67108864 | 0), this.words[i + r] = 67108863 & s
            }
            for (; i < this.length - r; i++) a = (s = (0 | this.words[i + r]) + a) >> 26, this.words[i + r] = 67108863 & s;
            if (0 === a) return this._e();
            for (n(-1 === a), a = 0, i = 0; i < this.length; i++) a = (s = -(0 | this.words[i]) + a) >> 26, this.words[i] = 67108863 & s;
            return this.negative = 1, this._e()
          }, o.prototype.Ve = function(t, e) {
            var r = (this.length, t.length),
              n = this.clone(),
              i = t,
              s = 0 | i.words[i.length - 1];
            0 != (r = 26 - this.He(s)) && (i = i.ushln(r), n.iushln(r), s = 0 | i.words[i.length - 1]);
            var a, u = n.length - i.length;
            if ("mod" !== e) {
              (a = new o(null)).length = u + 1, a.words = Array(a.length);
              for (var c = 0; c < a.length; c++) a.words[c] = 0
            }
            var f = n.clone().Ke(i, 1, u);
            0 === f.negative && (n = f, a && (a.words[u] = 1));
            for (var l = u - 1; l >= 0; l--) {
              var h = 67108864 * (0 | n.words[i.length + l]) + (0 | n.words[i.length + l - 1]);
              for (h = Math.min(h / s | 0, 67108863), n.Ke(i, h, l); 0 !== n.negative;) h--, n.negative = 0, n.Ke(i, 1, l), n.isZero() || (n.negative ^= 1);
              a && (a.words[l] = h)
            }
            return a && a._e(), n._e(), "div" !== e && 0 !== r && n.iushrn(r), {
              div: a || null,
              mod: n
            }
          }, o.prototype.divmod = function(t, e, r) {
            return n(!t.isZero()), this.isZero() ? {
              div: new o(0),
              mod: new o(0)
            } : 0 !== this.negative && 0 === t.negative ? (a = this.neg().divmod(t, e), "mod" !== e && (i = a.div.neg()), "div" !== e && (s = a.mod.neg(), r && 0 !== s.negative && s.iadd(t)), {
              div: i,
              mod: s
            }) : 0 === this.negative && 0 !== t.negative ? (a = this.divmod(t.neg(), e), "mod" !== e && (i = a.div.neg()), {
              div: i,
              mod: a.mod
            }) : 0 !== (this.negative & t.negative) ? (a = this.neg().divmod(t.neg(), e), "div" !== e && (s = a.mod.neg(), r && 0 !== s.negative && s.isub(t)), {
              div: a.div,
              mod: s
            }) : t.length > this.length || 0 > this.cmp(t) ? {
              div: new o(0),
              mod: this
            } : 1 === t.length ? "div" === e ? {
              div: this.divn(t.words[0]),
              mod: null
            } : "mod" === e ? {
              div: null,
              mod: new o(this.modrn(t.words[0]))
            } : {
              div: this.divn(t.words[0]),
              mod: new o(this.modrn(t.words[0]))
            } : this.Ve(t, e);
            var i, s, a
          }, o.prototype.div = function(t) {
            return this.divmod(t, "div", !1).div
          }, o.prototype.mod = function(t) {
            return this.divmod(t, "mod", !1).mod
          }, o.prototype.umod = function(t) {
            return this.divmod(t, "mod", !0).mod
          }, o.prototype.divRound = function(t) {
            var e = this.divmod(t);
            if (e.mod.isZero()) return e.div;
            var r = 0 !== e.div.negative ? e.mod.isub(t) : e.mod,
              n = t.ushrn(1),
              i = t.andln(1),
              o = r.cmp(n);
            return 0 > o || 1 === i && 0 === o ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1)
          }, o.prototype.modrn = function(t) {
            var e = 0 > t;
            e && (t = -t), n(67108863 >= t);
            for (var r = (1 << 26) % t, i = 0, o = this.length - 1; o >= 0; o--) i = (r * i + (0 | this.words[o])) % t;
            return e ? -i : i
          }, o.prototype.modn = function(t) {
            return this.modrn(t)
          }, o.prototype.idivn = function(t) {
            var e = 0 > t;
            e && (t = -t), n(67108863 >= t);
            for (var r = 0, i = this.length - 1; i >= 0; i--) {
              var o = (0 | this.words[i]) + 67108864 * r;
              this.words[i] = o / t | 0, r = o % t
            }
            return this._e(), e ? this.ineg() : this
          }, o.prototype.divn = function(t) {
            return this.clone().idivn(t)
          }, o.prototype.egcd = function(t) {
            n(0 === t.negative), n(!t.isZero());
            var e = this,
              r = t.clone();
            e = 0 !== e.negative ? e.umod(t) : e.clone();
            for (var i = new o(1), s = new o(0), a = new o(0), u = new o(1), c = 0; e.isEven() && r.isEven();) e.iushrn(1), r.iushrn(1), ++c;
            for (var f = r.clone(), l = e.clone(); !e.isZero();) {
              for (var h = 0, d = 1; 0 === (e.words[0] & d) && 26 > h; ++h, d <<= 1);
              if (h > 0)
                for (e.iushrn(h); h-- > 0;)(i.isOdd() || s.isOdd()) && (i.iadd(f), s.isub(l)), i.iushrn(1), s.iushrn(1);
              for (var p = 0, b = 1; 0 === (r.words[0] & b) && 26 > p; ++p, b <<= 1);
              if (p > 0)
                for (r.iushrn(p); p-- > 0;)(a.isOdd() || u.isOdd()) && (a.iadd(f), u.isub(l)), a.iushrn(1), u.iushrn(1);
              0 > e.cmp(r) ? (r.isub(e), a.isub(i), u.isub(s)) : (e.isub(r), i.isub(a), s.isub(u))
            }
            return {
              a: a,
              b: u,
              gcd: r.iushln(c)
            }
          }, o.prototype.Ze = function(t) {
            n(0 === t.negative), n(!t.isZero());
            var e, r = this,
              i = t.clone();
            r = 0 !== r.negative ? r.umod(t) : r.clone();
            for (var s = new o(1), a = new o(0), u = i.clone(); r.cmpn(1) > 0 && i.cmpn(1) > 0;) {
              for (var c = 0, f = 1; 0 === (r.words[0] & f) && 26 > c; ++c, f <<= 1);
              if (c > 0)
                for (r.iushrn(c); c-- > 0;) s.isOdd() && s.iadd(u), s.iushrn(1);
              for (var l = 0, h = 1; 0 === (i.words[0] & h) && 26 > l; ++l, h <<= 1);
              if (l > 0)
                for (i.iushrn(l); l-- > 0;) a.isOdd() && a.iadd(u), a.iushrn(1);
              0 > r.cmp(i) ? (i.isub(r), a.isub(s)) : (r.isub(i), s.isub(a))
            }
            return 0 > (e = 0 === r.cmpn(1) ? s : a).cmpn(0) && e.iadd(t), e
          }, o.prototype.gcd = function(t) {
            if (this.isZero()) return t.abs();
            if (t.isZero()) return this.abs();
            var e = this.clone(),
              r = t.clone();
            e.negative = 0, r.negative = 0;
            for (var n = 0; e.isEven() && r.isEven(); n++) e.iushrn(1), r.iushrn(1);
            for (;;) {
              for (; e.isEven();) e.iushrn(1);
              for (; r.isEven();) r.iushrn(1);
              var i = e.cmp(r);
              if (0 > i) {
                var o = e;
                e = r, r = o
              } else if (0 === i || 0 === r.cmpn(1)) break;
              e.isub(r)
            }
            return r.iushln(n)
          }, o.prototype.invm = function(t) {
            return this.egcd(t).a.umod(t)
          }, o.prototype.isEven = function() {
            return !(1 & this.words[0])
          }, o.prototype.isOdd = function() {
            return !(1 & ~this.words[0])
          }, o.prototype.andln = function(t) {
            return this.words[0] & t
          }, o.prototype.bincn = function(t) {
            n("number" == typeof t);
            var e = t % 26,
              r = (t - e) / 26,
              i = 1 << e;
            if (this.length <= r) return this.Le(r + 1), this.words[r] |= i, this;
            for (var o = i, s = r; 0 !== o && s < this.length; s++) {
              var a = 0 | this.words[s];
              o = (a += o) >>> 26, a &= 67108863, this.words[s] = a
            }
            return 0 !== o && (this.words[s] = o, this.length++), this
          }, o.prototype.isZero = function() {
            return 1 === this.length && 0 === this.words[0]
          }, o.prototype.cmpn = function(t) {
            var e, r = 0 > t;
            if (0 !== this.negative && !r) return -1;
            if (0 === this.negative && r) return 1;
            if (this._e(), this.length > 1) e = 1;
            else {
              r && (t = -t), n(67108863 >= t, "Number is too big");
              var i = 0 | this.words[0];
              e = i === t ? 0 : t > i ? -1 : 1
            }
            return 0 !== this.negative ? 0 | -e : e
          }, o.prototype.cmp = function(t) {
            if (0 !== this.negative && 0 === t.negative) return -1;
            if (0 === this.negative && 0 !== t.negative) return 1;
            var e = this.ucmp(t);
            return 0 !== this.negative ? 0 | -e : e
          }, o.prototype.ucmp = function(t) {
            if (this.length > t.length) return 1;
            if (this.length < t.length) return -1;
            for (var e = 0, r = this.length - 1; r >= 0; r--) {
              var n = 0 | this.words[r],
                i = 0 | t.words[r];
              if (n !== i) {
                i > n ? e = -1 : n > i && (e = 1);
                break
              }
            }
            return e
          }, o.prototype.gtn = function(t) {
            return 1 === this.cmpn(t)
          }, o.prototype.gt = function(t) {
            return 1 === this.cmp(t)
          }, o.prototype.gten = function(t) {
            return this.cmpn(t) >= 0
          }, o.prototype.gte = function(t) {
            return this.cmp(t) >= 0
          }, o.prototype.ltn = function(t) {
            return -1 === this.cmpn(t)
          }, o.prototype.lt = function(t) {
            return -1 === this.cmp(t)
          }, o.prototype.lten = function(t) {
            return 0 >= this.cmpn(t)
          }, o.prototype.lte = function(t) {
            return 0 >= this.cmp(t)
          }, o.prototype.eqn = function(t) {
            return 0 === this.cmpn(t)
          }, o.prototype.eq = function(t) {
            return 0 === this.cmp(t)
          }, o.red = function(t) {
            return new x(t)
          }, o.prototype.toRed = function(t) {
            return n(!this.red, "Already a number in reduction context"), n(0 === this.negative, "red works only with positives"), t.convertTo(this).Je(t)
          }, o.prototype.fromRed = function() {
            return n(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this)
          }, o.prototype.Je = function(t) {
            return this.red = t, this
          }, o.prototype.forceRed = function(t) {
            return n(!this.red, "Already a number in reduction context"), this.Je(t)
          }, o.prototype.redAdd = function(t) {
            return n(this.red, "redAdd works only with red numbers"), this.red.add(this, t)
          }, o.prototype.redIAdd = function(t) {
            return n(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, t)
          }, o.prototype.redSub = function(t) {
            return n(this.red, "redSub works only with red numbers"), this.red.sub(this, t)
          }, o.prototype.redISub = function(t) {
            return n(this.red, "redISub works only with red numbers"), this.red.isub(this, t)
          }, o.prototype.redShl = function(t) {
            return n(this.red, "redShl works only with red numbers"), this.red.shl(this, t)
          }, o.prototype.redMul = function(t) {
            return n(this.red, "redMul works only with red numbers"), this.red.Ye(this, t), this.red.mul(this, t)
          }, o.prototype.redIMul = function(t) {
            return n(this.red, "redMul works only with red numbers"), this.red.Ye(this, t), this.red.imul(this, t)
          }, o.prototype.redSqr = function() {
            return n(this.red, "redSqr works only with red numbers"), this.red.Qe(this), this.red.sqr(this)
          }, o.prototype.redISqr = function() {
            return n(this.red, "redISqr works only with red numbers"), this.red.Qe(this), this.red.isqr(this)
          }, o.prototype.redSqrt = function() {
            return n(this.red, "redSqrt works only with red numbers"), this.red.Qe(this), this.red.sqrt(this)
          }, o.prototype.redInvm = function() {
            return n(this.red, "redInvm works only with red numbers"), this.red.Qe(this), this.red.invm(this)
          }, o.prototype.redNeg = function() {
            return n(this.red, "redNeg works only with red numbers"), this.red.Qe(this), this.red.neg(this)
          }, o.prototype.redPow = function(t) {
            return n(this.red && !t.red, "redPow(normalNum)"), this.red.Qe(this), this.red.pow(this, t)
          };
          var w = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
          };

          function A(t, e) {
            this.name = t, this.p = new o(e, 16), this.n = this.p.bitLength(), this.k = new o(1).iushln(this.n).isub(this.p), this.tmp = this.Xe()
          }

          function T() {
            A.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
          }

          function E() {
            A.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
          }

          function P() {
            A.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
          }

          function k() {
            A.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
          }

          function x(t) {
            if ("string" == typeof t) {
              var e = o.tr(t);
              this.m = e.p, this.prime = e
            } else n(t.gtn(1), "modulus must be greater than 1"), this.m = t, this.prime = null
          }

          function I(t) {
            x.call(this, t), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new o(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r.Ze(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv)
          }
          A.prototype.Xe = function() {
            var t = new o(null);
            return t.words = Array(Math.ceil(this.n / 13)), t
          }, A.prototype.ireduce = function(t) {
            var e, r = t;
            do {
              this.split(r, this.tmp), e = (r = (r = this.imulK(r)).iadd(this.tmp)).bitLength()
            } while (e > this.n);
            var n = e < this.n ? -1 : r.ucmp(this.p);
            return 0 === n ? (r.words[0] = 0, r.length = 1) : n > 0 ? r.isub(this.p) : void 0 !== r.strip ? r.strip() : r._e(), r
          }, A.prototype.split = function(t, e) {
            t.iushrn(this.n, 0, e)
          }, A.prototype.imulK = function(t) {
            return t.imul(this.k)
          }, i(T, A), T.prototype.split = function(t, e) {
            for (var r = 4194303, n = Math.min(t.length, 9), i = 0; n > i; i++) e.words[i] = t.words[i];
            if (e.length = n, 9 >= t.length) return t.words[0] = 0, void(t.length = 1);
            var o = t.words[9];
            for (e.words[e.length++] = o & r, i = 10; i < t.length; i++) {
              var s = 0 | t.words[i];
              t.words[i - 10] = (s & r) << 4 | o >>> 22, o = s
            }
            o >>>= 22, t.words[i - 10] = o, 0 === o && t.length > 10 ? t.length -= 10 : t.length -= 9
          }, T.prototype.imulK = function(t) {
            t.words[t.length] = 0, t.words[t.length + 1] = 0, t.length += 2;
            for (var e = 0, r = 0; r < t.length; r++) {
              var n = 0 | t.words[r];
              e += 977 * n, t.words[r] = 67108863 & e, e = 64 * n + (e / 67108864 | 0)
            }
            return 0 === t.words[t.length - 1] && (t.length--, 0 === t.words[t.length - 1] && t.length--), t
          }, i(E, A), i(P, A), i(k, A), k.prototype.imulK = function(t) {
            for (var e = 0, r = 0; r < t.length; r++) {
              var n = 19 * (0 | t.words[r]) + e,
                i = 67108863 & n;
              n >>>= 26, t.words[r] = i, e = n
            }
            return 0 !== e && (t.words[t.length++] = e), t
          }, o.tr = function(t) {
            if (w[t]) return w[t];
            var e;
            if ("k256" === t) e = new T;
            else if ("p224" === t) e = new E;
            else if ("p192" === t) e = new P;
            else {
              if ("p25519" !== t) throw Error("Unknown prime " + t);
              e = new k
            }
            return w[t] = e, e
          }, x.prototype.Qe = function(t) {
            n(0 === t.negative, "red works only with positives"), n(t.red, "red works only with red numbers")
          }, x.prototype.Ye = function(t, e) {
            n(0 === (t.negative | e.negative), "red works only with positives"), n(t.red && t.red === e.red, "red works only with red numbers")
          }, x.prototype.imod = function(t) {
            return this.prime ? this.prime.ireduce(t).Je(this) : (f(t, t.umod(this.m).Je(this)), t)
          }, x.prototype.neg = function(t) {
            return t.isZero() ? t.clone() : this.m.sub(t).Je(this)
          }, x.prototype.add = function(t, e) {
            this.Ye(t, e);
            var r = t.add(e);
            return r.cmp(this.m) >= 0 && r.isub(this.m), r.Je(this)
          }, x.prototype.iadd = function(t, e) {
            this.Ye(t, e);
            var r = t.iadd(e);
            return r.cmp(this.m) >= 0 && r.isub(this.m), r
          }, x.prototype.sub = function(t, e) {
            this.Ye(t, e);
            var r = t.sub(e);
            return 0 > r.cmpn(0) && r.iadd(this.m), r.Je(this)
          }, x.prototype.isub = function(t, e) {
            this.Ye(t, e);
            var r = t.isub(e);
            return 0 > r.cmpn(0) && r.iadd(this.m), r
          }, x.prototype.shl = function(t, e) {
            return this.Qe(t), this.imod(t.ushln(e))
          }, x.prototype.imul = function(t, e) {
            return this.Ye(t, e), this.imod(t.imul(e))
          }, x.prototype.mul = function(t, e) {
            return this.Ye(t, e), this.imod(t.mul(e))
          }, x.prototype.isqr = function(t) {
            return this.imul(t, t.clone())
          }, x.prototype.sqr = function(t) {
            return this.mul(t, t)
          }, x.prototype.sqrt = function(t) {
            if (t.isZero()) return t.clone();
            var e = this.m.andln(3);
            if (n(e % 2 == 1), 3 === e) {
              var r = this.m.add(new o(1)).iushrn(2);
              return this.pow(t, r)
            }
            for (var i = this.m.subn(1), s = 0; !i.isZero() && 0 === i.andln(1);) s++, i.iushrn(1);
            n(!i.isZero());
            var a = new o(1).toRed(this),
              u = a.redNeg(),
              c = this.m.subn(1).iushrn(1),
              f = this.m.bitLength();
            for (f = new o(2 * f * f).toRed(this); 0 !== this.pow(f, c).cmp(u);) f.redIAdd(u);
            for (var l = this.pow(f, i), h = this.pow(t, i.addn(1).iushrn(1)), d = this.pow(t, i), p = s; 0 !== d.cmp(a);) {
              for (var b = d, m = 0; 0 !== b.cmp(a); m++) b = b.redSqr();
              n(p > m);
              var y = this.pow(l, new o(1).iushln(p - m - 1));
              h = h.redMul(y), l = y.redSqr(), d = d.redMul(l), p = m
            }
            return h
          }, x.prototype.invm = function(t) {
            var e = t.Ze(this.m);
            return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e)
          }, x.prototype.pow = function(t, e) {
            if (e.isZero()) return new o(1).toRed(this);
            if (0 === e.cmpn(1)) return t.clone();
            var r = Array(16);
            r[0] = new o(1).toRed(this), r[1] = t;
            for (var n = 2; n < r.length; n++) r[n] = this.mul(r[n - 1], t);
            var i = r[0],
              s = 0,
              a = 0,
              u = e.bitLength() % 26;
            for (0 === u && (u = 26), n = e.length - 1; n >= 0; n--) {
              for (var c = e.words[n], f = u - 1; f >= 0; f--) {
                var l = c >> f & 1;
                i !== r[0] && (i = this.sqr(i)), 0 !== l || 0 !== s ? (s <<= 1, s |= l, (4 === ++a || 0 === n && 0 === f) && (i = this.mul(i, r[s]), a = 0, s = 0)) : a = 0
              }
              u = 26
            }
            return i
          }, x.prototype.convertTo = function(t) {
            var e = t.umod(this.m);
            return e === t ? e.clone() : e
          }, x.prototype.convertFrom = function(t) {
            var e = t.clone();
            return e.red = null, e
          }, o.mont = function(t) {
            return new I(t)
          }, i(I, x), I.prototype.convertTo = function(t) {
            return this.imod(t.ushln(this.shift))
          }, I.prototype.convertFrom = function(t) {
            var e = this.imod(t.mul(this.rinv));
            return e.red = null, e
          }, I.prototype.imul = function(t, e) {
            if (t.isZero() || e.isZero()) return t.words[0] = 0, t.length = 1, t;
            var r = t.imul(e),
              n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
              i = r.isub(n).iushrn(this.shift),
              o = i;
            return 0 > i.cmp(this.m) ? 0 > i.cmpn(0) && (o = i.iadd(this.m)) : o = i.isub(this.m), o.Je(this)
          }, I.prototype.mul = function(t, e) {
            if (t.isZero() || e.isZero()) return new o(0).Je(this);
            var r = t.mul(e),
              n = r.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
              i = r.isub(n).iushrn(this.shift),
              s = i;
            return 0 > i.cmp(this.m) ? 0 > i.cmpn(0) && (s = i.iadd(this.m)) : s = i.isub(this.m), s.Je(this)
          }, I.prototype.invm = function(t) {
            return this.imod(t.Ze(this.m).mul(this.r2)).Je(this)
          }
        }(t = r.nmd(t), this)
      },
      39597: t => {
        "use strict";
        var e = {}.hasOwnProperty,
          r = "~";

        function n() {}

        function i(t, e, r) {
          this.fn = t, this.context = e, this.once = r || !1
        }

        function o(t, e, n, o, s) {
          if ("function" != typeof n) throw new TypeError("The listener must be a function");
          var a = new i(n, o || t, s),
            u = r ? r + e : e;
          return t.ye[u] ? t.ye[u].fn ? t.ye[u] = [t.ye[u], a] : t.ye[u].push(a) : (t.ye[u] = a, t.Ae++), t
        }

        function s(t, e) {
          0 === --t.Ae ? t.ye = new n : delete t.ye[e]
        }

        function a() {
          this.ye = new n, this.Ae = 0
        }
        Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (r = !1)), a.prototype.eventNames = function() {
          var t, n, i = [];
          if (0 === this.Ae) return i;
          for (n in t = this.ye) e.call(t, n) && i.push(r ? n.slice(1) : n);
          return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
        }, a.prototype.listeners = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          if (!n) return [];
          if (n.fn) return [n.fn];
          for (var i = 0, o = n.length, s = Array(o); o > i; i++) s[i] = n[i].fn;
          return s
        }, a.prototype.listenerCount = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          return n ? n.fn ? 1 : n.length : 0
        }, a.prototype.emit = function(t, e, n, i, o, s) {
          var a = r ? r + t : t;
          if (!this.ye[a]) return !1;
          var u, c, f = this.ye[a],
            l = arguments.length;
          if (f.fn) {
            switch (f.once && this.removeListener(t, f.fn, void 0, !0), l) {
              case 1:
                return f.fn.call(f.context), !0;
              case 2:
                return f.fn.call(f.context, e), !0;
              case 3:
                return f.fn.call(f.context, e, n), !0;
              case 4:
                return f.fn.call(f.context, e, n, i), !0;
              case 5:
                return f.fn.call(f.context, e, n, i, o), !0;
              case 6:
                return f.fn.call(f.context, e, n, i, o, s), !0
            }
            for (c = 1, u = Array(l - 1); l > c; c++) u[c - 1] = arguments[c];
            f.fn.apply(f.context, u)
          } else {
            var h, d = f.length;
            for (c = 0; d > c; c++) switch (f[c].once && this.removeListener(t, f[c].fn, void 0, !0), l) {
              case 1:
                f[c].fn.call(f[c].context);
                break;
              case 2:
                f[c].fn.call(f[c].context, e);
                break;
              case 3:
                f[c].fn.call(f[c].context, e, n);
                break;
              case 4:
                f[c].fn.call(f[c].context, e, n, i);
                break;
              default:
                if (!u)
                  for (h = 1, u = Array(l - 1); l > h; h++) u[h - 1] = arguments[h];
                f[c].fn.apply(f[c].context, u)
            }
          }
          return !0
        }, a.prototype.on = function(t, e, r) {
          return o(this, t, e, r, !1)
        }, a.prototype.once = function(t, e, r) {
          return o(this, t, e, r, !0)
        }, a.prototype.removeListener = function(t, e, n, i) {
          var o = r ? r + t : t;
          if (!this.ye[o]) return this;
          if (!e) return s(this, o), this;
          var a = this.ye[o];
          if (a.fn) a.fn === e && (!i || a.once) && (!n || a.context === n) && s(this, o);
          else {
            for (var u = 0, c = [], f = a.length; f > u; u++)(a[u].fn !== e || i && !a[u].once || n && a[u].context !== n) && c.push(a[u]);
            c.length ? this.ye[o] = 1 === c.length ? c[0] : c : s(this, o)
          }
          return this
        }, a.prototype.removeAllListeners = function(t) {
          var e;
          return t ? (e = r ? r + t : t, this.ye[e] && s(this, e)) : (this.ye = new n, this.Ae = 0), this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
      },
      40022: (t, e, r) => {
        "use strict";
        const n = r(24253).v4,
          i = r(73289),
          o = function(t, e) {
            if (!(this instanceof o)) return new o(t, e);
            e || (e = {}), this.options = {
              reviver: "u" > typeof e.reviver ? e.reviver : null,
              replacer: "u" > typeof e.replacer ? e.replacer : null,
              generator: "u" > typeof e.generator ? e.generator : function() {
                return n()
              },
              version: "u" > typeof e.version ? e.version : 2,
              notificationIdNull: "boolean" == typeof e.notificationIdNull && e.notificationIdNull
            }, this.callServer = t
          };
        t.exports = o, o.prototype.request = function(t, e, r, n) {
          const o = this;
          let s = null;
          const a = Array.isArray(t) && "function" == typeof e;
          if (1 === this.options.version && a) throw new TypeError("JSON-RPC 1.0 does not support batching");
          if (a || !a && t && "object" == typeof t && "function" == typeof e) n = e, s = t;
          else {
            "function" == typeof r && (n = r, r = void 0);
            const o = "function" == typeof n;
            try {
              s = i(t, e, r, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
              })
            } catch (t) {
              if (o) return n(t);
              throw t
            }
            if (!o) return s
          }
          let u;
          try {
            u = JSON.stringify(s, this.options.replacer)
          } catch (t) {
            return n(t)
          }
          return this.callServer(u, function(t, e) {
            o.er(t, e, n)
          }), s
        }, o.prototype.er = function(t, e, r) {
          if (t) return void r(t);
          if (!e) return r();
          let n;
          try {
            n = JSON.parse(e, this.options.reviver)
          } catch (t) {
            return r(t)
          }
          if (3 === r.length) {
            if (Array.isArray(n)) {
              const t = function(t) {
                  return "u" > typeof t.error
                },
                e = function(e) {
                  return !t(e)
                };
              return r(null, n.filter(t), n.filter(e))
            }
            return r(null, n.error, n.result)
          }
          r(null, n)
        }
      },
      40345: (t, e, r) => {
        t.exports = r(37007).EventEmitter
      },
      40537: (t, e, r) => {
        var n = r(65606),
          i = Object.getOwnPropertyDescriptors || function(t) {
            for (var e = Object.keys(t), r = {}, n = 0; n < e.length; n++) r[e[n]] = Object.getOwnPropertyDescriptor(t, e[n]);
            return r
          },
          o = /%[sdj%]/g;
        e.format = function(t) {
          if (!v(t)) {
            for (var e = [], r = 0; arguments.length > r; r++) e.push(c(arguments[r]));
            return e.join(" ")
          }
          r = 1;
          for (var n = arguments, i = n.length, s = (t + "").replace(o, function(t) {
              if ("%%" === t) return "%";
              if (r >= i) return t;
              switch (t) {
                case "%s":
                  return n[r++] + "";
                case "%d":
                  return +n[r++];
                case "%j":
                  try {
                    return JSON.stringify(n[r++])
                  } catch {
                    return "[Circular]"
                  }
                default:
                  return t
              }
            }), a = n[r]; i > r; a = n[++r]) y(a) || !T(a) ? s += " " + a : s += " " + c(a);
          return s
        }, e.deprecate = function(t, r) {
          if ("u" > typeof n && !0 === n.noDeprecation) return t;
          if (typeof n > "u") return function() {
            return e.deprecate(t, r).apply(this, arguments)
          };
          var i = !1;
          return function() {
            if (!i) {
              if (n.throwDeprecation) throw Error(r);
              n.traceDeprecation ? console.trace(r) : console.error(r), i = !0
            }
            return t.apply(this, arguments)
          }
        };
        var s = {},
          a = /^$/;
        if ("MISSING_ENV_VAR".NODE_DEBUG) {
          var u = "MISSING_ENV_VAR".NODE_DEBUG;
          u = u.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), a = RegExp("^" + u + "$", "i")
        }

        function c(t, r) {
          var n = {
            seen: [],
            stylize: l
          };
          return arguments.length >= 3 && (n.depth = arguments[2]), arguments.length >= 4 && (n.colors = arguments[3]), m(r) ? n.showHidden = r : r && e.rr(n, r), w(n.showHidden) && (n.showHidden = !1), w(n.depth) && (n.depth = 2), w(n.colors) && (n.colors = !1), w(n.customInspect) && (n.customInspect = !0), n.colors && (n.stylize = f), h(n, t, n.depth)
        }

        function f(t, e) {
          var r = c.styles[e];
          return r ? "[" + c.colors[r][0] + "m" + t + "[" + c.colors[r][1] + "m" : t
        }

        function l(t, e) {
          return t
        }

        function h(t, r, n) {
          if (t.customInspect && r && k(r.inspect) && r.inspect !== e.inspect && (!r.constructor || r.constructor.prototype !== r)) {
            var i = r.inspect(n, t);
            return v(i) || (i = h(t, i, n)), i
          }
          var o = function(t, e) {
            if (w(e)) return t.stylize("undefined", "undefined");
            if (v(e)) {
              var r = "'" + JSON.stringify(e).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
              return t.stylize(r, "string")
            }
            return g(e) ? t.stylize("" + e, "number") : m(e) ? t.stylize("" + e, "boolean") : y(e) ? t.stylize("null", "null") : void 0
          }(t, r);
          if (o) return o;
          var s = Object.keys(r),
            a = function(t) {
              var e = {};
              return t.forEach(function(t, r) {
                e[t] = !0
              }), e
            }(s);
          if (t.showHidden && (s = Object.getOwnPropertyNames(r)), P(r) && (s.indexOf("message") >= 0 || s.indexOf("description") >= 0)) return d(r);
          if (0 === s.length) {
            if (k(r)) {
              var u = r.name ? ": " + r.name : "";
              return t.stylize("[Function" + u + "]", "special")
            }
            if (A(r)) return t.stylize(/t/.toString.call(r), "regexp");
            if (E(r)) return t.stylize(Date.prototype.toString.call(r), "date");
            if (P(r)) return d(r)
          }
          var c, f = "",
            l = !1,
            T = ["{", "}"];
          return b(r) && (l = !0, T = ["[", "]"]), k(r) && (f = " [Function" + (r.name ? ": " + r.name : "") + "]"), A(r) && (f = " " + /t/.toString.call(r)), E(r) && (f = " " + Date.prototype.toUTCString.call(r)), P(r) && (f = " " + d(r)), 0 !== s.length || l && 0 != r.length ? 0 > n ? A(r) ? t.stylize(/t/.toString.call(r), "regexp") : t.stylize("[Object]", "special") : (t.seen.push(r), c = l ? function(t, e, r, n, i) {
            for (var o = [], s = 0, a = e.length; a > s; ++s) O(e, s + "") ? o.push(p(t, e, r, n, s + "", !0)) : o.push("");
            return i.forEach(function(i) {
              i.match(/^\d+$/) || o.push(p(t, e, r, n, i, !0))
            }), o
          }(t, r, n, a, s) : s.map(function(e) {
            return p(t, r, n, a, e, l)
          }), t.seen.pop(), function(t, e, r) {
            var n = t.reduce(function(t, e) {
              return e.indexOf("\n"), t + e.replace(/\u001b\[\d\d?m/g, "").length + 1
            }, 0);
            return n > 60 ? r[0] + ("" === e ? "" : e + "\n ") + " " + t.join(",\n  ") + " " + r[1] : r[0] + e + " " + t.join(", ") + " " + r[1]
          }(c, f, T)) : T[0] + f + T[1]
        }

        function d(t) {
          return "[" + Error.prototype.toString.call(t) + "]"
        }

        function p(t, e, r, n, i, o) {
          var s, a, u;
          if ((u = Object.getOwnPropertyDescriptor(e, i) || {
              value: e[i]
            }).get ? a = u.set ? t.stylize("[Getter/Setter]", "special") : t.stylize("[Getter]", "special") : u.set && (a = t.stylize("[Setter]", "special")), O(n, i) || (s = "[" + i + "]"), a || (0 > t.seen.indexOf(u.value) ? (a = y(r) ? h(t, u.value, null) : h(t, u.value, r - 1)).indexOf("\n") > -1 && (a = o ? a.split("\n").map(function(t) {
              return "  " + t
            }).join("\n").slice(2) : "\n" + a.split("\n").map(function(t) {
              return "   " + t
            }).join("\n")) : a = t.stylize("[Circular]", "special")), w(s)) {
            if (o && i.match(/^\d+$/)) return a;
            (s = JSON.stringify("" + i)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (s = s.slice(1, -1), s = t.stylize(s, "name")) : (s = s.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), s = t.stylize(s, "string"))
          }
          return s + ": " + a
        }

        function b(t) {
          return Array.isArray(t)
        }

        function m(t) {
          return "boolean" == typeof t
        }

        function y(t) {
          return null === t
        }

        function g(t) {
          return "number" == typeof t
        }

        function v(t) {
          return "string" == typeof t
        }

        function w(t) {
          return void 0 === t
        }

        function A(t) {
          return T(t) && "[object RegExp]" === x(t)
        }

        function T(t) {
          return "object" == typeof t && null !== t
        }

        function E(t) {
          return T(t) && "[object Date]" === x(t)
        }

        function P(t) {
          return T(t) && ("[object Error]" === x(t) || t instanceof Error)
        }

        function k(t) {
          return "function" == typeof t
        }

        function x(t) {
          return {}.toString.call(t)
        }

        function I(t) {
          return 10 > t ? "0" + t.toString(10) : t.toString(10)
        }
        e.debuglog = function(t) {
          if (t = t.toUpperCase(), !s[t])
            if (a.test(t)) {
              var r = n.pid;
              s[t] = function() {
                var n = e.format.apply(e, arguments);
                console.error("%s %d: %s", t, r, n)
              }
            } else s[t] = function() {};
          return s[t]
        }, e.inspect = c, c.colors = {
          bold: [1, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          white: [37, 39],
          grey: [90, 39],
          black: [30, 39],
          blue: [34, 39],
          cyan: [36, 39],
          green: [32, 39],
          magenta: [35, 39],
          red: [31, 39],
          yellow: [33, 39]
        }, c.styles = {
          special: "cyan",
          number: "yellow",
          boolean: "yellow",
          undefined: "grey",
          null: "bold",
          string: "green",
          date: "magenta",
          regexp: "red"
        }, e.types = r(49032), e.isArray = b, e.isBoolean = m, e.isNull = y, e.isNullOrUndefined = function(t) {
          return null == t
        }, e.isNumber = g, e.isString = v, e.isSymbol = function(t) {
          return "symbol" == typeof t
        }, e.isUndefined = w, e.isRegExp = A, e.types.isRegExp = A, e.isObject = T, e.isDate = E, e.types.isDate = E, e.isError = P, e.types.isNativeError = P, e.isFunction = k, e.isPrimitive = function(t) {
          return null === t || "boolean" == typeof t || "number" == typeof t || "string" == typeof t || "symbol" == typeof t || typeof t > "u"
        }, e.isBuffer = r(81135);
        var S = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];

        function O(t, e) {
          return {}.hasOwnProperty.call(t, e)
        }
        e.log = function() {
          var t, r;
          console.log("%s - %s", (r = [I((t = new Date).getHours()), I(t.getMinutes()), I(t.getSeconds())].join(":"), [t.getDate(), S[t.getMonth()], r].join(" ")), e.format.apply(e, arguments))
        }, e.inherits = r(56698), e.rr = function(t, e) {
          if (!e || !T(e)) return t;
          for (var r = Object.keys(e), n = r.length; n--;) t[r[n]] = e[r[n]];
          return t
        };
        var B = "u" > typeof Symbol ? Symbol("util.promisify.custom") : void 0;

        function W(t, e) {
          if (!t) {
            var r = Error("Promise was rejected with a falsy value");
            r.reason = t, t = r
          }
          return e(t)
        }
        e.promisify = function(t) {
          if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function');
          if (B && t[B]) {
            var e;
            if ("function" != typeof(e = t[B])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
            return Object.defineProperty(e, B, {
              value: e,
              enumerable: !1,
              writable: !1,
              configurable: !0
            }), e
          }

          function e() {
            for (var e, r, n = new Promise(function(t, n) {
                e = t, r = n
              }), i = [], o = 0; arguments.length > o; o++) i.push(arguments[o]);
            i.push(function(t, n) {
              t ? r(t) : e(n)
            });
            try {
              t.apply(this, i)
            } catch (t) {
              r(t)
            }
            return n
          }
          return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), B && Object.defineProperty(e, B, {
            value: e,
            enumerable: !1,
            writable: !1,
            configurable: !0
          }), Object.defineProperties(e, i(t))
        }, e.promisify.custom = B, e.callbackify = function(t) {
          if ("function" != typeof t) throw new TypeError('The "original" argument must be of type Function');

          function e() {
            for (var e = [], r = 0; arguments.length > r; r++) e.push(arguments[r]);
            var i = e.pop();
            if ("function" != typeof i) throw new TypeError("The last argument must be of type Function");
            var o = this,
              s = function() {
                return i.apply(o, arguments)
              };
            t.apply(this, e).then(function(t) {
              n.nextTick(s.bind(null, null, t))
            }, function(t) {
              n.nextTick(W.bind(null, t, s))
            })
          }
          return Object.setPrototypeOf(e, Object.getPrototypeOf(t)), Object.defineProperties(e, i(t)), e
        }
      },
      40700: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), t === e
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      40714: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getHash = s, e.createCurve = function(t, e) {
          const r = e => (0, o.weierstrass)({
            ...t,
            ...s(e)
          });
          return Object.freeze({
            ...r(e),
            create: r
          })
        };
        const n = r(62031),
          i = r(17412),
          o = r(20489);

        function s(t) {
          return {
            hash: t,
            hmac: (e, ...r) => (0, n.hmac)(t, e, (0, i.concatBytes)(...r)),
            randomBytes: i.randomBytes
          }
        }
      },
      40736: (t, e, r) => {
        t.exports = function(t) {
          function e(t) {
            let r, i, o, s = null;

            function a(...t) {
              if (!a.enabled) return;
              const n = a,
                i = +new Date,
                o = i - (r || i);
              n.diff = o, n.prev = r, n.curr = i, r = i, t[0] = e.coerce(t[0]), "string" != typeof t[0] && t.unshift("%O");
              let s = 0;
              t[0] = t[0].replace(/%([a-zA-Z%])/g, (r, i) => {
                if ("%%" === r) return "%";
                s++;
                const o = e.formatters[i];
                if ("function" == typeof o) {
                  const e = t[s];
                  r = o.call(n, e), t.splice(s, 1), s--
                }
                return r
              }), e.formatArgs.call(n, t), (n.log || e.log).apply(n, t)
            }
            return a.namespace = t, a.useColors = e.useColors(), a.color = e.selectColor(t), a.extend = n, a.destroy = e.destroy, Object.defineProperty(a, "enabled", {
              enumerable: !0,
              configurable: !1,
              get: () => null !== s ? s : (i !== e.namespaces && (i = e.namespaces, o = e.enabled(t)), o),
              set: t => {
                s = t
              }
            }), "function" == typeof e.init && e.init(a), a
          }

          function n(t, r) {
            const n = e(this.namespace + (typeof r > "u" ? ":" : r) + t);
            return n.log = this.log, n
          }

          function i(t, e) {
            let r = 0,
              n = 0,
              i = -1,
              o = 0;
            for (; r < t.length;)
              if (n >= e.length || e[n] !== t[r] && "*" !== e[n]) {
                if (-1 === i) return !1;
                n = i + 1, o++, r = o
              } else "*" === e[n] ? (i = n, o = r, n++) : (r++, n++);
            for (; n < e.length && "*" === e[n];) n++;
            return n === e.length
          }
          return e.debug = e, e.default = e, e.coerce = function(t) {
            return t instanceof Error ? t.stack || t.message : t
          }, e.disable = function() {
            const t = [...e.names, ...e.skips.map(t => "-" + t)].join(",");
            return e.enable(""), t
          }, e.enable = function(t) {
            e.save(t), e.namespaces = t, e.names = [], e.skips = [];
            const r = ("string" == typeof t ? t : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
            for (const t of r) "-" === t[0] ? e.skips.push(t.slice(1)) : e.names.push(t)
          }, e.enabled = function(t) {
            for (const r of e.skips)
              if (i(t, r)) return !1;
            for (const r of e.names)
              if (i(t, r)) return !0;
            return !1
          }, e.humanize = r(6585), e.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")
          }, Object.keys(t).forEach(r => {
            e[r] = t[r]
          }), e.names = [], e.skips = [], e.formatters = {}, e.selectColor = function(t) {
            let r = 0;
            for (let e = 0; e < t.length; e++) r = (r << 5) - r + t.charCodeAt(e), r |= 0;
            return e.colors[Math.abs(r) % e.colors.length]
          }, e.enable(e.load()), e
        }
      },
      40909: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e, r) => {
          const i = new n(t, r),
            o = new n(e, r);
          return i.compare(o) || i.compareBuild(o)
        }
      },
      41080: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.topologicalSort = void 0, e.topologicalSort = function(t) {
          let e = [t],
            r = new Map,
            n = new Set,
            i = [];
          for (; e.length > 0;) {
            const t = [...e];
            e = [];
            for (let i of t) {
              const t = i.hash().toString("hex");
              if (!r.has(t)) {
                n.add(t), r.set(t, {
                  cell: i,
                  refs: i.refs.map(t => t.hash().toString("hex"))
                });
                for (let t of i.refs) e.push(t)
              }
            }
          }
          let o = new Set;

          function s(t) {
            if (!n.has(t)) return;
            if (o.has(t)) throw Error("Not a DAG");
            o.add(t);
            let e = r.get(t).refs;
            for (let t = e.length - 1; t >= 0; t--) s(e[t]);
            i.push(t), o.delete(t), n.delete(t)
          }
          for (; n.size > 0;) s(Array.from(n)[0]);
          let a = new Map;
          for (let t = 0; t < i.length; t++) a.set(i[i.length - t - 1], t);
          let u = [];
          for (let t = i.length - 1; t >= 0; t--) {
            let e = i[t];
            const n = r.get(e);
            u.push({
              cell: n.cell,
              refs: n.refs.map(t => a.get(t))
            })
          }
          return u
        }
      },
      41237: t => {
        "use strict";
        t.exports = EvalError
      },
      41261: (t, e, r) => {
        const n = r(53908),
          i = r(78311),
          o = r(35580);
        t.exports = (t, e) => {
          t = new i(t, e);
          let r = new n("0.0.0");
          if (t.test(r) || (r = new n("0.0.0-0"), t.test(r))) return r;
          r = null;
          for (let e = 0; e < t.set.length; ++e) {
            const i = t.set[e];
            let s = null;
            i.forEach(t => {
              const e = new n(t.semver.version);
              switch (t.operator) {
                case ">":
                  0 === e.prerelease.length ? e.patch++ : e.prerelease.push(0), e.raw = e.format();
                case "":
                case ">=":
                  (!s || o(e, s)) && (s = e);
                  break;
                case "<":
                case "<=":
                  break;
                default:
                  throw Error("Unexpected operation: " + t.operator)
              }
            }), s && (!r || o(r, s)) && (r = s)
          }
          return r && t.test(r) ? r : null
        }
      },
      41333: t => {
        "use strict";
        t.exports = function() {
          if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
          if ("symbol" == typeof Symbol.iterator) return !0;
          var t = {},
            e = Symbol("test"),
            r = Object(e);
          if ("string" == typeof e || "[object Symbol]" !== {}.toString.call(e) || "[object Symbol]" !== {}.toString.call(r)) return !1;
          for (var n in t[e] = 42, t) return !1;
          if ("function" == typeof Object.keys && 0 !== Object.keys(t).length || "function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t).length) return !1;
          var i = Object.getOwnPropertySymbols(t);
          if (1 !== i.length || i[0] !== e || !{}.propertyIsEnumerable.call(t, e)) return !1;
          if ("function" == typeof Object.getOwnPropertyDescriptor) {
            var o = Object.getOwnPropertyDescriptor(t, e);
            if (42 !== o.value || !0 !== o.enumerable) return !1
          }
          return !0
        }
      },
      41653: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("proto.google.protobuf.Any", null, o), proto.google.protobuf.Any = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(proto.google.protobuf.Any, n.Message), i.DEBUG && !COMPILED && (proto.google.protobuf.Any.displayName = "proto.google.protobuf.Any"), n.Message.GENERATE_TO_OBJECT && (proto.google.protobuf.Any.prototype.toObject = function(t) {
          return proto.google.protobuf.Any.toObject(t, this)
        }, proto.google.protobuf.Any.toObject = function(t, e) {
          var r = {
            typeUrl: n.Message.getFieldWithDefault(e, 1, ""),
            value: e.getValue_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), proto.google.protobuf.Any.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new proto.google.protobuf.Any;
          return proto.google.protobuf.Any.deserializeBinaryFromReader(r, e)
        }, proto.google.protobuf.Any.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readString();
              t.setTypeUrl(r);
              break;
            case 2:
              r = e.readBytes(), t.setValue(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, proto.google.protobuf.Any.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return proto.google.protobuf.Any.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, proto.google.protobuf.Any.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getTypeUrl()).length > 0 && e.writeString(1, r), (r = t.getValue_asU8()).length > 0 && e.writeBytes(2, r)
        }, proto.google.protobuf.Any.prototype.getTypeUrl = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, proto.google.protobuf.Any.prototype.setTypeUrl = function(t) {
          return n.Message.setProto3StringField(this, 1, t)
        }, proto.google.protobuf.Any.prototype.getValue = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, proto.google.protobuf.Any.prototype.getValue_asB64 = function() {
          return n.Message.bytesAsB64(this.getValue())
        }, proto.google.protobuf.Any.prototype.getValue_asU8 = function() {
          return n.Message.bytesAsU8(this.getValue())
        }, proto.google.protobuf.Any.prototype.setValue = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, i.object.extend(e, proto.google.protobuf), proto.google.protobuf.Any.prototype.getTypeName = function() {
          return this.getTypeUrl().split("/").pop()
        }, proto.google.protobuf.Any.prototype.pack = function(t, e, r) {
          r || (r = "type.googleapis.com/"), "/" != r.substr(-1) ? this.setTypeUrl(r + "/" + e) : this.setTypeUrl(r + e), this.setValue(t)
        }, proto.google.protobuf.Any.prototype.unpack = function(t, e) {
          return this.getTypeName() == e ? t(this.getValue_asU8()) : null
        }
      },
      41766: (t, e) => {
        "use strict";
        var r, n;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ReserveMode = void 0, (n = r || (e.ReserveMode = r = {}))[n.THIS_AMOUNT = 0] = "THIS_AMOUNT", n[n.LEAVE_THIS_AMOUNT = 1] = "LEAVE_THIS_AMOUNT", n[n.AT_MOST_THIS_AMOUNT = 2] = "AT_MOST_THIS_AMOUNT", n[n.LEAVE_MAX_THIS_AMOUNT = 3] = "LEAVE_MAX_THIS_AMOUNT", n[n.BEFORE_BALANCE_PLUS_THIS_AMOUNT = 4] = "BEFORE_BALANCE_PLUS_THIS_AMOUNT", n[n.LEAVE_BBALANCE_PLUS_THIS_AMOUNT = 5] = "LEAVE_BBALANCE_PLUS_THIS_AMOUNT", n[n.BEFORE_BALANCE_MINUS_THIS_AMOUNT = 12] = "BEFORE_BALANCE_MINUS_THIS_AMOUNT", n[n.LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT = 13] = "LEAVE_BEFORE_BALANCE_MINUS_THIS_AMOUNT"
      },
      41972: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.HttpApi = void 0;
        const o = r(64792),
          s = i(r(59302)),
          a = i(r(86425)),
          u = r(7552),
          c = r(68585).rE,
          f = u.z.object({
            "@type": u.z.literal("ton.blockIdExt"),
            workchain: u.z.number(),
            shard: u.z.string(),
            seqno: u.z.number(),
            root_hash: u.z.string(),
            file_hash: u.z.string()
          }),
          l = u.z.object({
            balance: u.z.union([u.z.number(), u.z.string()]),
            state: u.z.union([u.z.literal("active"), u.z.literal("uninitialized"), u.z.literal("frozen")]),
            data: u.z.string(),
            code: u.z.string(),
            last_transaction_id: u.z.object({
              "@type": u.z.literal("internal.transactionId"),
              lt: u.z.string(),
              hash: u.z.string()
            }),
            block_id: f,
            sync_utime: u.z.number()
          }),
          h = u.z.object({
            "@type": u.z.literal("ok")
          }),
          d = u.z.object({
            "@type": u.z.literal("query.fees"),
            source_fees: u.z.object({
              "@type": u.z.literal("fees"),
              in_fwd_fee: u.z.number(),
              storage_fee: u.z.number(),
              gas_fee: u.z.number(),
              fwd_fee: u.z.number()
            })
          }),
          p = u.z.object({
            gas_used: u.z.number(),
            exit_code: u.z.number(),
            stack: u.z.array(u.z.unknown())
          }),
          b = u.z.union([u.z.object({
            "@type": u.z.literal("msg.dataRaw"),
            body: u.z.string()
          }), u.z.object({
            "@type": u.z.literal("msg.dataText"),
            text: u.z.string()
          }), u.z.object({
            "@type": u.z.literal("msg.dataDecryptedText"),
            text: u.z.string()
          }), u.z.object({
            "@type": u.z.literal("msg.dataEncryptedText"),
            text: u.z.string()
          })]),
          m = u.z.object({
            source: u.z.string(),
            destination: u.z.string(),
            value: u.z.string(),
            fwd_fee: u.z.string(),
            ihr_fee: u.z.string(),
            created_lt: u.z.string(),
            body_hash: u.z.string(),
            msg_data: b,
            message: u.z.string().optional()
          }),
          y = u.z.object({
            data: u.z.string(),
            utime: u.z.number(),
            transaction_id: u.z.object({
              lt: u.z.string(),
              hash: u.z.string()
            }),
            fee: u.z.string(),
            storage_fee: u.z.string(),
            other_fee: u.z.string(),
            in_msg: u.z.union([u.z.undefined(), m]),
            out_msgs: u.z.array(m)
          }),
          g = u.z.array(y),
          v = u.z.object({
            state_root_hash: u.z.string(),
            last: f,
            init: f
          }),
          w = u.z.object({
            shards: u.z.array(f)
          }),
          A = u.z.object({
            "@type": u.z.literal("blocks.shortTxId"),
            mode: u.z.number(),
            account: u.z.string(),
            lt: u.z.string(),
            hash: u.z.string()
          }),
          T = u.z.object({
            id: f,
            req_count: u.z.number(),
            incomplete: u.z.boolean(),
            transactions: u.z.array(A)
          });
        class E {
          constructor(t, e, r, n) {
            this.namespace = t, this.cache = e, this.codec = r, this.keyEncoder = n
          }
          async get(t) {
            let e = await this.cache.get(this.namespace, this.keyEncoder(t));
            if (e) {
              let t = this.codec.safeParse(JSON.parse(e));
              if (t.success) return t.data
            }
            return null
          }
          async set(t, e) {
            null !== e ? await this.cache.set(this.namespace, this.keyEncoder(t), JSON.stringify(e)) : await this.cache.set(this.namespace, this.keyEncoder(t), null)
          }
        }

        function P(t) {
          let e = [];
          for (let r of t)
            if ("int" === r.type) e.push(["num", r.value.toString()]);
            else if ("cell" === r.type) e.push(["tvm.Cell", r.cell.toBoc().toString("base64")]);
          else if ("slice" === r.type) e.push(["tvm.Slice", r.cell.toBoc().toString("base64")]);
          else {
            if ("builder" !== r.type) throw Error("Unsupported stack item type: " + r.type);
            e.push(["tvm.Builder", r.cell.toBoc().toString("base64")])
          }
          return e
        }
        e.HttpApi = class {
          constructor(t, e) {
            this.endpoint = t, this.cache = new o.InMemoryCache, this.parameters = {
              timeout: e?.timeout || 3e4,
              apiKey: e?.apiKey,
              adapter: e?.adapter
            }, this.shardCache = new E("ton-shard", this.cache, u.z.array(f), t => t + ""), this.shardLoader = new s.default(async t => await Promise.all(t.map(async t => {
              const e = await this.shardCache.get(t);
              if (e) return e;
              let r = (await this.doCall("shards", {
                seqno: t
              }, w)).shards;
              return await this.shardCache.set(t, r), r
            }))), this.shardTransactionsCache = new E("ton-shard-tx", this.cache, T, t => t.workchain + ":" + t.shard + ":" + t.seqno), this.shardTransactionsLoader = new s.default(async t => await Promise.all(t.map(async t => {
              const e = await this.shardTransactionsCache.get(t);
              if (e) return e;
              let r = await this.doCall("getBlockTransactions", {
                workchain: t.workchain,
                seqno: t.seqno,
                shard: t.shard
              }, T);
              return await this.shardTransactionsCache.set(t, r), r
            })), {
              cacheKeyFn: t => t.workchain + ":" + t.shard + ":" + t.seqno
            })
          }
          getAddressInformation(t) {
            return this.doCall("getAddressInformation", {
              address: t.toString()
            }, l)
          }
          async getTransactions(t, e) {
            const r = e.inclusive;
            let i;
            delete e.inclusive, e.hash && (i = n.from(e.hash, "base64").toString("hex"));
            let o = e.limit;
            e.hash && e.lt && !0 !== r && o++;
            let s = await this.doCall("getTransactions", {
              address: t.toString(),
              ...e,
              limit: o,
              hash: i
            }, g);
            return s.length > o && (s = s.slice(0, o)), e.hash && e.lt && !0 !== r && s.shift(), s
          }
          async getMasterchainInfo() {
            return await this.doCall("getMasterchainInfo", {}, v)
          }
          async getShards(t) {
            return await this.shardLoader.load(t)
          }
          async getBlockTransactions(t, e, r) {
            return await this.shardTransactionsLoader.load({
              workchain: t,
              seqno: e,
              shard: r
            })
          }
          async getTransaction(t, e, r) {
            let i = n.from(r, "base64").toString("hex");
            return (await this.doCall("getTransactions", {
              address: t.toString(),
              lt: e,
              hash: i,
              limit: 1
            }, g)).find(t => t.transaction_id.lt === e && t.transaction_id.hash === r) || null
          }
          async callGetMethod(t, e, r) {
            return await this.doCall("runGetMethod", {
              address: t.toString(),
              method: e,
              stack: P(r)
            }, p)
          }
          async sendBoc(t) {
            await this.doCall("sendBoc", {
              boc: t.toString("base64")
            }, h)
          }
          async estimateFee(t, e) {
            return await this.doCall("estimateFee", {
              address: t.toString(),
              body: e.body.toBoc().toString("base64"),
              init_data: e.initData ? e.initData.toBoc().toString("base64") : "",
              init_code: e.initCode ? e.initCode.toBoc().toString("base64") : "",
              ignore_chksig: e.ignoreSignature
            }, d)
          }
          async tryLocateResultTx(t, e, r) {
            return await this.doCall("tryLocateResultTx", {
              source: t.toString(),
              destination: e.toString(),
              created_lt: r
            }, y)
          }
          async tryLocateSourceTx(t, e, r) {
            return await this.doCall("tryLocateSourceTx", {
              source: t.toString(),
              destination: e.toString(),
              created_lt: r
            }, y)
          }
          async doCall(t, e, r) {
            let n = {
              "Content-Type": "application/json",
              "X-Ton-Client-Version": c
            };
            this.parameters.apiKey && (n["X-API-Key"] = this.parameters.apiKey);
            let i = await a.default.post(this.endpoint, JSON.stringify({
              id: "1",
              jsonrpc: "2.0",
              method: t,
              params: e
            }), {
              headers: n,
              timeout: this.parameters.timeout,
              adapter: this.parameters.adapter
            });
            if (200 !== i.status || !i.data.ok) throw Error("Received error: " + JSON.stringify(i.data));
            let o = r.safeParse(i.data.result);
            if (o.success) return o.data;
            throw Error("Malformed response: " + o.error.format().Te.join(", "))
          }
        }
      },
      42227: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.MultisigWallet = void 0;
        const i = r(75269),
          o = r(1307),
          s = o.Cell.fromBase64("te6ccgECKwEABBgAART/APSkE/S88sgLAQIBIAIDAgFIBAUE2vIgxwCOgzDbPOCDCNcYIPkBAdMH2zwiwAAToVNxePQOb6Hyn9s8VBq6+RDyoAb0BCD5AQHTH1EYuvKq0z9wUwHwCgHCCAGDCryx8mhTFYBA9A5voSCYDqQgwgryZw7f+COqH1NAufJhVCOjU04gIyEiAgLMBgcCASAMDQIBIAgJAgFmCgsAA9GEAiPymAvHoHN9CYbZ5S7Z4BPHohwhJQAtAKkItdJEqCTItdKlwLUAdAT8ArobBKAATwhbpEx4CBukTDgAdAg10rDAJrUAvALyFjPFszJ4HHXI8gBzxb0AMmACASAODwIBIBQVARW77ZbVA0cFUg2zyCoCAUgQEQIBIBITAXOxHXQgwjXGCD5AQHTB4IB1MTtQ9hTIHj0Dm+h8p/XC/9eMfkQ8qCuAfQEIW6TW3Ey4PkBWNs8AaQBgJwA9rtqA6ADoAPoCAXoCEfyAgPyA3XlP+AXkegAA54tkwAAXrhlXP8EA1WZ2oexAAgEgFhcCASAYGQFRtyVbZ4YmRmpGEAgegc30McJNhFpAADMaYeYuAFrgJhwLb+4cC3d0bhAjAYm1WZtnhqvgb+2xxsoicAgej430pBHEoFpAADHDhBACGuQkuuBk9kUWE5kAOeLKhACQCB6IYFImHFImHFImXEA2YlzNijAjAgEgGhsAF7UGtc4QQDVZnah7EAIBIBwdAgOZOB4fARGsGm2eL4G2CUAjABWt+UEAzJV2oewYQAENqTbPBVfBYCMAFa3f3CCAarM7UPYgAiDbPALyZfgAUENxQxPbPO1UIyoACtP/0wcwBKDbPC+uUyCw8mISsQKkJbNTHLmwJYEA4aojoCi8sPJpggGGoPgBBZcCERACPj4wjo0REB/bPEDXePRDEL0F4lQWW1Rz51YQU9zbPFRxClR6vCQlKCYAIO1E0NMf0wfTB9M/9AT0BNEAXgGOGjDSAAHyo9MH0wdQA9cBIPkBBfkBFbrypFAD4GwhIddKqgIi10m68qtwVCATAAwByMv/ywcE1ts87VT4D3AlblOJvrGYEG4QLVDHXwePGzBUJANQTds8UFWgRlAQSRA6SwlTuds8UFQWf+L4AAeDJaGOLCaAQPSWb6UglDBTA7neII4WODk5CNIAAZfTBzAW8AcFkTDifwgHBZJsMeKz5jAGKicoKQBgcI4pA9CDCNcY0wf0BDBTFnj0Dm+h8qXXC/9URUT5EPKmrlIgsVIDvRShI27mbCIyAH5SML6OIF8D+ACTItdKmALTB9QC+wAC6DJwyMoAQBSAQPRDAvAHjhdxyMsAFMsHEssHWM8BWM8WQBOAQPRDAeIBII6KEEUQNEMA2zztVJJfBuIqABzIyx/LB8sHyz/0APQAyQ==");
        class a {
          constructor(t, e, r, i, a) {
            this.provider = null, this.owners = o.Dictionary.empty(), this.workchain = e, this.walletId = r, this.k = i;
            for (let e = 0; e < t.length; e += 1) this.owners.set(e, n.concat([t[e], n.alloc(1)]));
            this.init = {
              code: s,
              data: (0, o.beginCell)().storeUint(this.walletId, 32).storeUint(this.owners.size, 8).storeUint(this.k, 8).storeUint(0, 64).storeDict(this.owners, o.Dictionary.Keys.Uint(8), o.Dictionary.Values.Buffer(33)).storeBit(0).endCell()
            }, this.address = a?.address || (0, o.contractAddress)(e, this.init), a?.provider ? this.provider = a.provider : a?.client && (this.provider = a.client.provider(this.address, {
              code: this.init.code,
              data: this.init.data
            }))
          }
          static async fromAddress(t, e) {
            let r;
            if (e.provider) r = e.provider;
            else {
              if (!e.client) throw Error("Either provider or client must be specified");
              r = e.client.provider(t, {
                code: null,
                data: null
              })
            }
            const n = (await r.getState()).state;
            if ("active" !== n.type) throw Error("Contract must be active");
            const i = o.Cell.fromBoc(n.data)[0].beginParse(),
              s = i.loadUint(32);
            i.skip(8);
            const u = i.loadUint(8);
            i.skip(64);
            const c = i.loadDict(o.Dictionary.Keys.Uint(8), o.Dictionary.Values.Buffer(33));
            let f = [];
            for (const [t, e] of c) {
              const t = e.subarray(0, 32);
              f.push(t)
            }
            return new a(f, t.workChain, s, u, {
              address: t,
              provider: r,
              client: e.client
            })
          }
          async deployExternal(t) {
            if (!t && !this.provider) throw Error("you must specify provider if there is no such property in MultisigWallet instance");
            t || (t = this.provider), await t.external(o.Cell.EMPTY)
          }
          async deployInternal(t, e = 1000000000n) {
            await t.send({
              sendMode: o.SendMode.PAY_GAS_SEPARATELY + o.SendMode.IGNORE_ERRORS,
              to: this.address,
              value: e,
              init: this.init,
              body: o.Cell.EMPTY,
              bounce: !0
            })
          }
          async sendOrder(t, e, r) {
            if (!r && !this.provider) throw Error("you must specify provider if there is no such property in MultisigWallet instance");
            r || (r = this.provider);
            let n = (0, i.keyPairFromSecretKey)(e).publicKey,
              s = this.getOwnerIdByPubkey(n),
              a = t.toCell(s),
              u = (0, i.sign)(a.hash(), e);
            a = (0, o.beginCell)().storeBuffer(u).storeSlice(a.asSlice()).endCell(), await r.external(a)
          }
          async sendOrderWithoutSecretKey(t, e, r, n) {
            if (!n && !this.provider) throw Error("you must specify provider if there is no such property in MultisigWallet instance");
            n || (n = this.provider);
            let i = t.toCell(r);
            i = (0, o.beginCell)().storeBuffer(e).storeSlice(i.asSlice()).endCell(), await n.external(i)
          }
          getOwnerIdByPubkey(t) {
            for (const [e, r] of this.owners)
              if (r.subarray(0, 32).equals(t)) return e;
            throw Error("public key is not an owner")
          }
        }
        e.MultisigWallet = a
      },
      42230: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.generateMerkleUpdate = void 0;
        const n = r(65871),
          i = r(78981);
        e.generateMerkleUpdate = function(t, e, r, o) {
          const s = (0, i.generateMerkleProof)(t, [e], r).refs[0];
          return t.set(e, o),
            function(t, e) {
              return (0, n.beginCell)().storeUint(4, 8).storeBuffer(t.hash(0)).storeBuffer(e.hash(0)).storeUint(t.depth(0), 16).storeUint(e.depth(0), 16).storeRef(t).storeRef(e).endCell({
                exotic: !0
              })
            }(s, (0, i.generateMerkleProof)(t, [e], r).refs[0])
        }
      },
      42575: t => {
        "use strict";
        var e = {}.hasOwnProperty,
          r = "~";

        function n() {}

        function i(t, e, r) {
          this.fn = t, this.context = e, this.once = r || !1
        }

        function o(t, e, n, o, s) {
          if ("function" != typeof n) throw new TypeError("The listener must be a function");
          var a = new i(n, o || t, s),
            u = r ? r + e : e;
          return t.ye[u] ? t.ye[u].fn ? t.ye[u] = [t.ye[u], a] : t.ye[u].push(a) : (t.ye[u] = a, t.Ae++), t
        }

        function s(t, e) {
          0 === --t.Ae ? t.ye = new n : delete t.ye[e]
        }

        function a() {
          this.ye = new n, this.Ae = 0
        }
        Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (r = !1)), a.prototype.eventNames = function() {
          var t, n, i = [];
          if (0 === this.Ae) return i;
          for (n in t = this.ye) e.call(t, n) && i.push(r ? n.slice(1) : n);
          return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
        }, a.prototype.listeners = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          if (!n) return [];
          if (n.fn) return [n.fn];
          for (var i = 0, o = n.length, s = Array(o); o > i; i++) s[i] = n[i].fn;
          return s
        }, a.prototype.listenerCount = function(t) {
          var e = r ? r + t : t,
            n = this.ye[e];
          return n ? n.fn ? 1 : n.length : 0
        }, a.prototype.emit = function(t, e, n, i, o, s) {
          var a = r ? r + t : t;
          if (!this.ye[a]) return !1;
          var u, c, f = this.ye[a],
            l = arguments.length;
          if (f.fn) {
            switch (f.once && this.removeListener(t, f.fn, void 0, !0), l) {
              case 1:
                return f.fn.call(f.context), !0;
              case 2:
                return f.fn.call(f.context, e), !0;
              case 3:
                return f.fn.call(f.context, e, n), !0;
              case 4:
                return f.fn.call(f.context, e, n, i), !0;
              case 5:
                return f.fn.call(f.context, e, n, i, o), !0;
              case 6:
                return f.fn.call(f.context, e, n, i, o, s), !0
            }
            for (c = 1, u = Array(l - 1); l > c; c++) u[c - 1] = arguments[c];
            f.fn.apply(f.context, u)
          } else {
            var h, d = f.length;
            for (c = 0; d > c; c++) switch (f[c].once && this.removeListener(t, f[c].fn, void 0, !0), l) {
              case 1:
                f[c].fn.call(f[c].context);
                break;
              case 2:
                f[c].fn.call(f[c].context, e);
                break;
              case 3:
                f[c].fn.call(f[c].context, e, n);
                break;
              case 4:
                f[c].fn.call(f[c].context, e, n, i);
                break;
              default:
                if (!u)
                  for (h = 1, u = Array(l - 1); l > h; h++) u[h - 1] = arguments[h];
                f[c].fn.apply(f[c].context, u)
            }
          }
          return !0
        }, a.prototype.on = function(t, e, r) {
          return o(this, t, e, r, !1)
        }, a.prototype.once = function(t, e, r) {
          return o(this, t, e, r, !0)
        }, a.prototype.removeListener = function(t, e, n, i) {
          var o = r ? r + t : t;
          if (!this.ye[o]) return this;
          if (!e) return s(this, o), this;
          var a = this.ye[o];
          if (a.fn) a.fn === e && (!i || a.once) && (!n || a.context === n) && s(this, o);
          else {
            for (var u = 0, c = [], f = a.length; f > u; u++)(a[u].fn !== e || i && !a[u].once || n && a[u].context !== n) && c.push(a[u]);
            c.length ? this.ye[o] = 1 === c.length ? c[0] : c : s(this, o)
          }
          return this
        }, a.prototype.removeAllListeners = function(t) {
          var e;
          return t ? (e = r ? r + t : t, this.ye[e] && s(this, e)) : (this.ye = new n, this.Ae = 0), this
        }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
      },
      42634: () => {},
      42666: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.toType = e.TypeOutput = void 0;
        const n = r(77312),
          i = r(59498);
        var o, s;
        (s = o = e.TypeOutput || (e.TypeOutput = {}))[s.Number = 0] = "Number", s[s.BigInt = 1] = "BigInt", s[s.Buffer = 2] = "Buffer", s[s.PrefixedHexString = 3] = "PrefixedHexString", e.toType = function(t, e) {
          if (null === t) return null;
          if (void 0 === t) return;
          if ("string" == typeof t && !(0, i.isHexString)(t)) throw Error("A string must be provided with a 0x-prefix, given: " + t);
          if ("number" == typeof t && !Number.isSafeInteger(t)) throw Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
          const r = (0, n.toBuffer)(t);
          switch (e) {
            case o.Buffer:
              return r;
            case o.BigInt:
              return (0, n.bufferToBigInt)(r);
            case o.Number: {
              const t = (0, n.bufferToBigInt)(r);
              if (t > BigInt(Number.MAX_SAFE_INTEGER)) throw Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
              return +t
            }
            case o.PrefixedHexString:
              return (0, n.bufferToHex)(r);
            default:
              throw Error("unknown outputType")
          }
        }
      },
      42791: function(t, e, r) {
        var n = r(65606);
        ! function(t) {
          "use strict";
          if (!t.setImmediate) {
            var e, r, i, o = 1,
              s = {},
              a = !1,
              u = t.document,
              c = Object.getPrototypeOf && Object.getPrototypeOf(t);
            c = c && c.setTimeout ? c : t, "[object process]" === {}.toString.call(t.process) ? e = function(t) {
              n.nextTick(function() {
                l(t)
              })
            } : function() {
              if (t.postMessage && !t.importScripts) {
                var e = !0,
                  r = t.onmessage;
                return t.onmessage = function() {
                  e = !1
                }, t.postMessage("", "*"), t.onmessage = r, e
              }
            }() ? (r = "setImmediate$" + Math.random() + "$", i = function(e) {
              e.source === t && "string" == typeof e.data && 0 === e.data.indexOf(r) && l(+e.data.slice(r.length))
            }, t.addEventListener ? t.addEventListener("message", i, !1) : t.attachEvent("onmessage", i), e = function(e) {
              t.postMessage(r + e, "*")
            }) : t.MessageChannel ? function() {
              var t = new MessageChannel;
              t.port1.onmessage = function(t) {
                l(t.data)
              }, e = function(e) {
                t.port2.postMessage(e)
              }
            }() : u && "onreadystatechange" in u.createElement("script") ? function() {
              var t = u.documentElement;
              e = function(e) {
                var r = u.createElement("script");
                r.onreadystatechange = function() {
                  l(e), r.onreadystatechange = null, t.removeChild(r), r = null
                }, t.appendChild(r)
              }
            }() : e = function(t) {
              setTimeout(l, 0, t)
            }, c.setImmediate = function(t) {
              "function" != typeof t && (t = Function("" + t));
              for (var r = Array(arguments.length - 1), n = 0; n < r.length; n++) r[n] = arguments[n + 1];
              var i = {
                callback: t,
                args: r
              };
              return s[o] = i, e(o), o++
            }, c.clearImmediate = f
          }

          function f(t) {
            delete s[t]
          }

          function l(t) {
            if (a) setTimeout(l, 0, t);
            else {
              var e = s[t];
              if (e) {
                a = !0;
                try {
                  ! function(t) {
                    var e = t.callback,
                      r = t.args;
                    switch (r.length) {
                      case 0:
                        e();
                        break;
                      case 1:
                        e(r[0]);
                        break;
                      case 2:
                        e(r[0], r[1]);
                        break;
                      case 3:
                        e(r[0], r[1], r[2]);
                        break;
                      default:
                        e.apply(void 0, r)
                    }
                  }(e)
                } finally {
                  f(t), a = !1
                }
              }
            }
          }
        }(typeof self > "u" ? typeof r.g > "u" ? this : r.g : self)
      },
      43007: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.normalize = e.recoverPublicKey = e.concatSig = e.legacyToBuffer = e.isNullish = e.padWithZeroes = void 0;
        const i = r(68683),
          o = r(65534);

        function s(t, e) {
          if ("" !== t && !/^[a-f0-9]+$/iu.test(t)) throw Error("Expected an unprefixed hex string. Received: " + t);
          if (0 > e) throw Error("Expected a non-negative integer target length. Received: " + e);
          return "".padStart.call(t, e, "0")
        }

        function a(t) {
          return null == t
        }
        e.padWithZeroes = s, e.isNullish = a, e.legacyToBuffer = function(t) {
          return "string" != typeof t || (0, i.isHexString)(t) ? (0, i.toBuffer)(t) : n.from(t)
        }, e.concatSig = function(t, e, r) {
          const n = (0, i.fromSigned)(e),
            a = (0, i.fromSigned)(r),
            u = (0, i.bufferToInt)(t),
            c = s((0, i.toUnsigned)(n).toString("hex"), 64),
            f = s((0, i.toUnsigned)(a).toString("hex"), 64),
            l = (0, o.remove0x)((0, o.numberToHex)(u));
          return (0, o.add0x)(c.concat(f, l))
        }, e.recoverPublicKey = function(t, e) {
          const r = (0, i.fromRpcSig)(e);
          return (0, i.ecrecover)(t, r.v, r.r, r.s)
        }, e.normalize = function(t) {
          if (!a(t)) {
            if ("number" == typeof t) {
              if (0 > t) return "0x";
              const e = (0, o.numberToBytes)(t);
              t = (0, o.bytesToHex)(e)
            }
            if ("string" != typeof t) {
              let e = "eth-sig-util.normalize() requires hex string or integer input.";
              throw e += ` received ${typeof t}: ${t}`, Error(e)
            }
            return (0, o.add0x)(t.toLowerCase())
          }
        }
      },
      43214: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), e ? "1" === t || /^true$/i.test(t) : "0" !== t && !/^false$/i.test(t) && "" !== t
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      43368: (t, e) => {
        "use strict";
        var r, n;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.errorUtil = void 0, (n = r || (e.errorUtil = r = {})).errToObj = t => "string" == typeof t ? {
          message: t
        } : t || {}, n.toString = t => "string" == typeof t ? t : t?.message
      },
      43459: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /[\uD800-\uDBFF][\uDC00-\uDFFF]/;
        t.exports = e.default, t.exports.default = e.default
      },
      43817: (t, e, r) => {
        var n, i = r(65606);
        e = t.exports = tt, n = "object" == typeof i && "MISSING_ENV_VAR".NODE_DEBUG && /\bsemver\b/i.test("MISSING_ENV_VAR".NODE_DEBUG) ? function() {
          var t = [].slice.call(arguments, 0);
          t.unshift("SEMVER"), console.log.apply(console, t)
        } : function() {}, e.SEMVER_SPEC_VERSION = "2.0.0";
        var o = 256,
          s = Number.MAX_SAFE_INTEGER || 9007199254740991,
          a = o - 6,
          u = e.re = [],
          c = e.safeRe = [],
          f = e.src = [],
          l = 0,
          h = "[a-zA-Z0-9-]",
          d = [
            ["\\s", 1],
            ["\\d", o],
            [h, a]
          ];

        function p(t) {
          for (var e = 0; d.length > e; e++) {
            var r = d[e][0],
              n = d[e][1];
            t = t.split(r + "*").join(r + "{0," + n + "}").split(r + "+").join(r + "{1," + n + "}")
          }
          return t
        }
        var b = l++;
        f[b] = "0|[1-9]\\d*";
        var m = l++;
        f[m] = "\\d+";
        var y = l++;
        f[y] = "\\d*[a-zA-Z-]" + h + "*";
        var g = l++;
        f[g] = "(" + f[b] + ")\\.(" + f[b] + ")\\.(" + f[b] + ")";
        var v = l++;
        f[v] = "(" + f[m] + ")\\.(" + f[m] + ")\\.(" + f[m] + ")";
        var w = l++;
        f[w] = "(?:" + f[b] + "|" + f[y] + ")";
        var A = l++;
        f[A] = "(?:" + f[m] + "|" + f[y] + ")";
        var T = l++;
        f[T] = "(?:-(" + f[w] + "(?:\\." + f[w] + ")*))";
        var E = l++;
        f[E] = "(?:-?(" + f[A] + "(?:\\." + f[A] + ")*))";
        var P = l++;
        f[P] = h + "+";
        var k = l++;
        f[k] = "(?:\\+(" + f[P] + "(?:\\." + f[P] + ")*))";
        var x = l++,
          I = "v?" + f[g] + f[T] + "?" + f[k] + "?";
        f[x] = "^" + I + "$";
        var S = "[v=\\s]*" + f[v] + f[E] + "?" + f[k] + "?",
          O = l++;
        f[O] = "^" + S + "$";
        var B = l++;
        f[B] = "((?:<|>)?=?)";
        var W = l++;
        f[W] = f[m] + "|x|X|\\*";
        var M = l++;
        f[M] = f[b] + "|x|X|\\*";
        var C = l++;
        f[C] = "[v=\\s]*(" + f[M] + ")(?:\\.(" + f[M] + ")(?:\\.(" + f[M] + ")(?:" + f[T] + ")?" + f[k] + "?)?)?";
        var R = l++;
        f[R] = "[v=\\s]*(" + f[W] + ")(?:\\.(" + f[W] + ")(?:\\.(" + f[W] + ")(?:" + f[E] + ")?" + f[k] + "?)?)?";
        var N = l++;
        f[N] = "^" + f[B] + "\\s*" + f[C] + "$";
        var j = l++;
        f[j] = "^" + f[B] + "\\s*" + f[R] + "$";
        var _ = l++;
        f[_] = "(?:^|[^\\d])(\\d{1,16})(?:\\.(\\d{1,16}))?(?:\\.(\\d{1,16}))?(?:$|[^\\d])";
        var D = l++;
        f[D] = "(?:~>?)";
        var U = l++;
        f[U] = "(\\s*)" + f[D] + "\\s+", u[U] = RegExp(f[U], "g"), c[U] = RegExp(p(f[U]), "g");
        var L = l++;
        f[L] = "^" + f[D] + f[C] + "$";
        var F = l++;
        f[F] = "^" + f[D] + f[R] + "$";
        var $ = l++;
        f[$] = "(?:\\^)";
        var z = l++;
        f[z] = "(\\s*)" + f[$] + "\\s+", u[z] = RegExp(f[z], "g"), c[z] = RegExp(p(f[z]), "g");
        var H = l++;
        f[H] = "^" + f[$] + f[C] + "$";
        var G = l++;
        f[G] = "^" + f[$] + f[R] + "$";
        var K = l++;
        f[K] = "^" + f[B] + "\\s*(" + S + ")$|^$";
        var V = l++;
        f[V] = "^" + f[B] + "\\s*(" + I + ")$|^$";
        var Z = l++;
        f[Z] = "(\\s*)" + f[B] + "\\s*(" + S + "|" + f[C] + ")", u[Z] = RegExp(f[Z], "g"), c[Z] = RegExp(p(f[Z]), "g");
        var q = l++;
        f[q] = "^\\s*(" + f[C] + ")\\s+-\\s+(" + f[C] + ")\\s*$";
        var J = l++;
        f[J] = "^\\s*(" + f[R] + ")\\s+-\\s+(" + f[R] + ")\\s*$";
        var Y = l++;
        f[Y] = "(<|>)?=?\\s*\\*";
        for (var Q = 0; 35 > Q; Q++) n(Q, f[Q]), u[Q] || (u[Q] = RegExp(f[Q]), c[Q] = RegExp(p(f[Q])));

        function X(t, e) {
          if ((!e || "object" != typeof e) && (e = {
              loose: !!e,
              includePrerelease: !1
            }), t instanceof tt) return t;
          if ("string" != typeof t || t.length > o) return null;
          if (!(e.loose ? c[O] : c[x]).test(t)) return null;
          try {
            return new tt(t, e)
          } catch {
            return null
          }
        }

        function tt(t, e) {
          if ((!e || "object" != typeof e) && (e = {
              loose: !!e,
              includePrerelease: !1
            }), t instanceof tt) {
            if (t.loose === e.loose) return t;
            t = t.version
          } else if ("string" != typeof t) throw new TypeError("Invalid Version: " + t);
          if (t.length > o) throw new TypeError("version is longer than " + o + " characters");
          if (!(this instanceof tt)) return new tt(t, e);
          n("SemVer", t, e), this.options = e, this.loose = !!e.loose;
          var r = t.trim().match(e.loose ? c[O] : c[x]);
          if (!r) throw new TypeError("Invalid Version: " + t);
          if (this.raw = t, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > s || 0 > this.major) throw new TypeError("Invalid major version");
          if (this.minor > s || 0 > this.minor) throw new TypeError("Invalid minor version");
          if (this.patch > s || 0 > this.patch) throw new TypeError("Invalid patch version");
          r[4] ? this.prerelease = r[4].split(".").map(function(t) {
            if (/^[0-9]+$/.test(t)) {
              var e = +t;
              if (e >= 0 && s > e) return e
            }
            return t
          }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format()
        }
        e.parse = X, e.valid = function(t, e) {
          var r = X(t, e);
          return r ? r.version : null
        }, e.clean = function(t, e) {
          var r = X(t.trim().replace(/^[=v]+/, ""), e);
          return r ? r.version : null
        }, e.SemVer = tt, tt.prototype.format = function() {
          return this.version = this.major + "." + this.minor + "." + this.patch, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
        }, tt.prototype.toString = function() {
          return this.version
        }, tt.prototype.compare = function(t) {
          return n("SemVer.compare", this.version, this.options, t), t instanceof tt || (t = new tt(t, this.options)), this.compareMain(t) || this.comparePre(t)
        }, tt.prototype.compareMain = function(t) {
          return t instanceof tt || (t = new tt(t, this.options)), rt(this.major, t.major) || rt(this.minor, t.minor) || rt(this.patch, t.patch)
        }, tt.prototype.comparePre = function(t) {
          if (t instanceof tt || (t = new tt(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
          if (!this.prerelease.length && t.prerelease.length) return 1;
          if (!this.prerelease.length && !t.prerelease.length) return 0;
          var e = 0;
          do {
            var r = this.prerelease[e],
              i = t.prerelease[e];
            if (n("prerelease compare", e, r, i), void 0 === r && void 0 === i) return 0;
            if (void 0 === i) return 1;
            if (void 0 === r) return -1;
            if (r !== i) return rt(r, i)
          } while (++e)
        }, tt.prototype.inc = function(t, e) {
          switch (t) {
            case "premajor":
              this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e);
              break;
            case "preminor":
              this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e);
              break;
            case "prepatch":
              this.prerelease.length = 0, this.inc("patch", e), this.inc("pre", e);
              break;
            case "prerelease":
              0 === this.prerelease.length && this.inc("patch", e), this.inc("pre", e);
              break;
            case "major":
              (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
              break;
            case "minor":
              (0 !== this.patch || 0 === this.prerelease.length) && this.minor++, this.patch = 0, this.prerelease = [];
              break;
            case "patch":
              0 === this.prerelease.length && this.patch++, this.prerelease = [];
              break;
            case "pre":
              if (0 === this.prerelease.length) this.prerelease = [0];
              else {
                for (var r = this.prerelease.length; --r >= 0;) "number" == typeof this.prerelease[r] && (this.prerelease[r]++, r = -2); - 1 === r && this.prerelease.push(0)
              }
              e && (this.prerelease[0] === e ? isNaN(this.prerelease[1]) && (this.prerelease = [e, 0]) : this.prerelease = [e, 0]);
              break;
            default:
              throw Error("invalid increment argument: " + t)
          }
          return this.format(), this.raw = this.version, this
        }, e.inc = function(t, e, r, n) {
          "string" == typeof r && (n = r, r = void 0);
          try {
            return new tt(t, r).inc(e, n).version
          } catch {
            return null
          }
        }, e.diff = function(t, e) {
          if (st(t, e)) return null;
          var r = X(t),
            n = X(e),
            i = "";
          if (r.prerelease.length || n.prerelease.length) {
            i = "pre";
            var o = "prerelease"
          }
          for (var s in r)
            if (("major" === s || "minor" === s || "patch" === s) && r[s] !== n[s]) return i + s;
          return o
        }, e.compareIdentifiers = rt;
        var et = /^[0-9]+$/;

        function rt(t, e) {
          var r = et.test(t),
            n = et.test(e);
          return r && n && (t = +t, e = +e), t === e ? 0 : r && !n ? -1 : n && !r ? 1 : e > t ? -1 : 1
        }

        function nt(t, e, r) {
          return new tt(t, r).compare(new tt(e, r))
        }

        function it(t, e, r) {
          return nt(t, e, r) > 0
        }

        function ot(t, e, r) {
          return 0 > nt(t, e, r)
        }

        function st(t, e, r) {
          return 0 === nt(t, e, r)
        }

        function at(t, e, r) {
          return 0 !== nt(t, e, r)
        }

        function ut(t, e, r) {
          return nt(t, e, r) >= 0
        }

        function ct(t, e, r) {
          return 0 >= nt(t, e, r)
        }

        function ft(t, e, r, n) {
          switch (e) {
            case "===":
              return "object" == typeof t && (t = t.version), "object" == typeof r && (r = r.version), t === r;
            case "!==":
              return "object" == typeof t && (t = t.version), "object" == typeof r && (r = r.version), t !== r;
            case "":
            case "=":
            case "==":
              return st(t, r, n);
            case "!=":
              return at(t, r, n);
            case ">":
              return it(t, r, n);
            case ">=":
              return ut(t, r, n);
            case "<":
              return ot(t, r, n);
            case "<=":
              return ct(t, r, n);
            default:
              throw new TypeError("Invalid operator: " + e)
          }
        }

        function lt(t, e) {
          if ((!e || "object" != typeof e) && (e = {
              loose: !!e,
              includePrerelease: !1
            }), t instanceof lt) {
            if (t.loose === !!e.loose) return t;
            t = t.value
          }
          if (!(this instanceof lt)) return new lt(t, e);
          t = t.trim().split(/\s+/).join(" "), n("comparator", t, e), this.options = e, this.loose = !!e.loose, this.parse(t), this.semver === ht ? this.value = "" : this.value = this.operator + this.semver.version, n("comp", this)
        }
        e.rcompareIdentifiers = function(t, e) {
          return rt(e, t)
        }, e.major = function(t, e) {
          return new tt(t, e).major
        }, e.minor = function(t, e) {
          return new tt(t, e).minor
        }, e.patch = function(t, e) {
          return new tt(t, e).patch
        }, e.compare = nt, e.compareLoose = function(t, e) {
          return nt(t, e, !0)
        }, e.rcompare = function(t, e, r) {
          return nt(e, t, r)
        }, e.sort = function(t, r) {
          return t.sort(function(t, n) {
            return e.compare(t, n, r)
          })
        }, e.rsort = function(t, r) {
          return t.sort(function(t, n) {
            return e.rcompare(t, n, r)
          })
        }, e.gt = it, e.lt = ot, e.eq = st, e.neq = at, e.gte = ut, e.lte = ct, e.cmp = ft, e.Comparator = lt;
        var ht = {};

        function dt(t, e) {
          if ((!e || "object" != typeof e) && (e = {
              loose: !!e,
              includePrerelease: !1
            }), t instanceof dt) return t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease ? t : new dt(t.raw, e);
          if (t instanceof lt) return new dt(t.value, e);
          if (!(this instanceof dt)) return new dt(t, e);
          if (this.options = e, this.loose = !!e.loose, this.includePrerelease = !!e.includePrerelease, this.raw = t.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map(function(t) {
              return this.parseRange(t.trim())
            }, this).filter(function(t) {
              return t.length
            }), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
          this.format()
        }

        function pt(t) {
          return !t || "x" === t.toLowerCase() || "*" === t
        }

        function bt(t, e, r, n, i, o, s, a, u, c, f, l, h) {
          return ((e = pt(r) ? "" : pt(n) ? ">=" + r + ".0.0" : pt(i) ? ">=" + r + "." + n + ".0" : ">=" + e) + " " + (a = pt(u) ? "" : pt(c) ? "<" + (+u + 1) + ".0.0" : pt(f) ? "<" + u + "." + (+c + 1) + ".0" : l ? "<=" + u + "." + c + "." + f + "-" + l : "<=" + a)).trim()
        }

        function mt(t, e, r) {
          for (var i = 0; i < t.length; i++)
            if (!t[i].test(e)) return !1;
          if (e.prerelease.length && !r.includePrerelease) {
            for (i = 0; i < t.length; i++)
              if (n(t[i].semver), t[i].semver !== ht && t[i].semver.prerelease.length > 0) {
                var o = t[i].semver;
                if (o.major === e.major && o.minor === e.minor && o.patch === e.patch) return !0
              } return !1
          }
          return !0
        }

        function yt(t, e, r) {
          try {
            e = new dt(e, r)
          } catch {
            return !1
          }
          return e.test(t)
        }

        function gt(t, e, r, n) {
          var i, o, s, a, u;
          switch (t = new tt(t, n), e = new dt(e, n), r) {
            case ">":
              i = it, o = ct, s = ot, a = ">", u = ">=";
              break;
            case "<":
              i = ot, o = ut, s = it, a = "<", u = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"')
          }
          if (yt(t, e, n)) return !1;
          for (var c = 0; c < e.set.length; ++c) {
            var f = e.set[c],
              l = null,
              h = null;
            if (f.forEach(function(t) {
                t.semver === ht && (t = new lt(">=0.0.0")), l = l || t, h = h || t, i(t.semver, l.semver, n) ? l = t : s(t.semver, h.semver, n) && (h = t)
              }), l.operator === a || l.operator === u || (!h.operator || h.operator === a) && o(t, h.semver)) return !1;
            if (h.operator === u && s(t, h.semver)) return !1
          }
          return !0
        }
        lt.prototype.parse = function(t) {
          var e = this.options.loose ? c[K] : c[V],
            r = t.match(e);
          if (!r) throw new TypeError("Invalid comparator: " + t);
          this.operator = r[1], "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new tt(r[2], this.options.loose) : this.semver = ht
        }, lt.prototype.toString = function() {
          return this.value
        }, lt.prototype.test = function(t) {
          return n("Comparator.test", t, this.options.loose), this.semver === ht || ("string" == typeof t && (t = new tt(t, this.options)), ft(t, this.operator, this.semver, this.options))
        }, lt.prototype.intersects = function(t, e) {
          if (!(t instanceof lt)) throw new TypeError("a Comparator is required");
          var r;
          if ((!e || "object" != typeof e) && (e = {
              loose: !!e,
              includePrerelease: !1
            }), "" === this.operator) return r = new dt(t.value, e), yt(this.value, r, e);
          if ("" === t.operator) return r = new dt(this.value, e), yt(t.semver, r, e);
          var n = !(">=" !== this.operator && ">" !== this.operator || ">=" !== t.operator && ">" !== t.operator),
            i = !("<=" !== this.operator && "<" !== this.operator || "<=" !== t.operator && "<" !== t.operator),
            o = this.semver.version === t.semver.version,
            s = !(">=" !== this.operator && "<=" !== this.operator || ">=" !== t.operator && "<=" !== t.operator),
            a = ft(this.semver, "<", t.semver, e) && (">=" === this.operator || ">" === this.operator) && ("<=" === t.operator || "<" === t.operator),
            u = ft(this.semver, ">", t.semver, e) && ("<=" === this.operator || "<" === this.operator) && (">=" === t.operator || ">" === t.operator);
          return n || i || o && s || a || u
        }, e.Range = dt, dt.prototype.format = function() {
          return this.range = this.set.map(function(t) {
            return t.join(" ").trim()
          }).join("||").trim(), this.range
        }, dt.prototype.toString = function() {
          return this.range
        }, dt.prototype.parseRange = function(t) {
          var e = this.options.loose,
            r = e ? c[J] : c[q];
          t = t.replace(r, bt), n("hyphen replace", t), t = t.replace(c[Z], "$1$2$3"), n("comparator trim", t, c[Z]), t = (t = t.replace(c[U], "$1~")).replace(c[z], "$1^");
          var i = e ? c[K] : c[V],
            o = t.split(" ").map(function(t) {
              return function(t, e) {
                return n("comp", t, e), t = function(t, e) {
                  return t.trim().split(/\s+/).map(function(t) {
                    return function(t, e) {
                      n("caret", t, e);
                      var r = e.loose ? c[G] : c[H];
                      return t.replace(r, function(e, r, i, o, s) {
                        var a;
                        return n("caret", t, e, r, i, o, s), pt(r) ? a = "" : pt(i) ? a = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0" : pt(o) ? a = "0" === r ? ">=" + r + "." + i + ".0 <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + ".0 <" + (+r + 1) + ".0.0" : s ? (n("replaceCaret pr", s), a = "0" === r ? "0" === i ? ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + i + "." + (+o + 1) : ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + "." + o + "-" + s + " <" + (+r + 1) + ".0.0") : (n("no pr"), a = "0" === r ? "0" === i ? ">=" + r + "." + i + "." + o + " <" + r + "." + i + "." + (+o + 1) : ">=" + r + "." + i + "." + o + " <" + r + "." + (+i + 1) + ".0" : ">=" + r + "." + i + "." + o + " <" + (+r + 1) + ".0.0"), n("caret return", a), a
                      })
                    }(t, e)
                  }).join(" ")
                }(t, e), n("caret", t), t = function(t, e) {
                  return t.trim().split(/\s+/).map(function(t) {
                    return function(t, e) {
                      var r = e.loose ? c[F] : c[L];
                      return t.replace(r, function(e, r, i, o, s) {
                        var a;
                        return n("tilde", t, e, r, i, o, s), pt(r) ? a = "" : pt(i) ? a = ">=" + r + ".0.0 <" + (+r + 1) + ".0.0" : pt(o) ? a = ">=" + r + "." + i + ".0 <" + r + "." + (+i + 1) + ".0" : s ? (n("replaceTilde pr", s), a = ">=" + r + "." + i + "." + o + "-" + s + " <" + r + "." + (+i + 1) + ".0") : a = ">=" + r + "." + i + "." + o + " <" + r + "." + (+i + 1) + ".0", n("tilde return", a), a
                      })
                    }(t, e)
                  }).join(" ")
                }(t, e), n("tildes", t), t = function(t, e) {
                  return n("replaceXRanges", t, e), t.split(/\s+/).map(function(t) {
                    return function(t, e) {
                      t = t.trim();
                      var r = e.loose ? c[j] : c[N];
                      return t.replace(r, function(e, r, i, o, s, a) {
                        n("xRange", t, e, r, i, o, s, a);
                        var u = pt(i),
                          c = u || pt(o),
                          f = c || pt(s);
                        return "=" === r && f && (r = ""), u ? e = ">" === r || "<" === r ? "<0.0.0" : "*" : r && f ? (c && (o = 0), s = 0, ">" === r ? (r = ">=", c ? (i = +i + 1, o = 0, s = 0) : (o = +o + 1, s = 0)) : "<=" === r && (r = "<", c ? i = +i + 1 : o = +o + 1), e = r + i + "." + o + "." + s) : c ? e = ">=" + i + ".0.0 <" + (+i + 1) + ".0.0" : f && (e = ">=" + i + "." + o + ".0 <" + i + "." + (+o + 1) + ".0"), n("xRange return", e), e
                      })
                    }(t, e)
                  }).join(" ")
                }(t, e), n("xrange", t), t = function(t, e) {
                  return n("replaceStars", t, e), t.trim().replace(c[Y], "")
                }(t, e), n("stars", t), t
              }(t, this.options)
            }, this).join(" ").split(/\s+/);
          return this.options.loose && (o = o.filter(function(t) {
            return !!t.match(i)
          })), o.map(function(t) {
            return new lt(t, this.options)
          }, this)
        }, dt.prototype.intersects = function(t, e) {
          if (!(t instanceof dt)) throw new TypeError("a Range is required");
          return this.set.some(function(r) {
            return r.every(function(r) {
              return t.set.some(function(t) {
                return t.every(function(t) {
                  return r.intersects(t, e)
                })
              })
            })
          })
        }, e.toComparators = function(t, e) {
          return new dt(t, e).set.map(function(t) {
            return t.map(function(t) {
              return t.value
            }).join(" ").trim().split(" ")
          })
        }, dt.prototype.test = function(t) {
          if (!t) return !1;
          "string" == typeof t && (t = new tt(t, this.options));
          for (var e = 0; e < this.set.length; e++)
            if (mt(this.set[e], t, this.options)) return !0;
          return !1
        }, e.satisfies = yt, e.maxSatisfying = function(t, e, r) {
          var n = null,
            i = null;
          try {
            var o = new dt(e, r)
          } catch {
            return null
          }
          return t.forEach(function(t) {
            o.test(t) && (!n || -1 === i.compare(t)) && (i = new tt(n = t, r))
          }), n
        }, e.minSatisfying = function(t, e, r) {
          var n = null,
            i = null;
          try {
            var o = new dt(e, r)
          } catch {
            return null
          }
          return t.forEach(function(t) {
            o.test(t) && (!n || 1 === i.compare(t)) && (i = new tt(n = t, r))
          }), n
        }, e.minVersion = function(t, e) {
          t = new dt(t, e);
          var r = new tt("0.0.0");
          if (t.test(r) || (r = new tt("0.0.0-0"), t.test(r))) return r;
          r = null;
          for (var n = 0; n < t.set.length; ++n) t.set[n].forEach(function(t) {
            var e = new tt(t.semver.version);
            switch (t.operator) {
              case ">":
                0 === e.prerelease.length ? e.patch++ : e.prerelease.push(0), e.raw = e.format();
              case "":
              case ">=":
                (!r || it(r, e)) && (r = e);
                break;
              case "<":
              case "<=":
                break;
              default:
                throw Error("Unexpected operation: " + t.operator)
            }
          });
          return r && t.test(r) ? r : null
        }, e.validRange = function(t, e) {
          try {
            return new dt(t, e).range || "*"
          } catch {
            return null
          }
        }, e.ltr = function(t, e, r) {
          return gt(t, e, "<", r)
        }, e.gtr = function(t, e, r) {
          return gt(t, e, ">", r)
        }, e.outside = gt, e.prerelease = function(t, e) {
          var r = X(t, e);
          return r && r.prerelease.length ? r.prerelease : null
        }, e.intersects = function(t, e, r) {
          return t = new dt(t, r), e = new dt(e, r), t.intersects(e)
        }, e.coerce = function(t) {
          if (t instanceof tt) return t;
          if ("string" != typeof t) return null;
          var e = t.match(c[_]);
          return null == e ? null : X(e[1] + "." + (e[2] || "0") + "." + (e[3] || "0"))
        }
      },
      43927: (t, e, r) => {
        const n = r(40909);
        t.exports = (t, e) => t.sort((t, r) => n(t, r, e))
      },
      43999: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha512 = void 0, e.sha512 = async function(t) {
          return "string" == typeof t ? n.from(await crypto.subtle.digest("SHA-512", n.from(t, "utf-8"))) : n.from(await crypto.subtle.digest("SHA-512", t))
        }
      },
      44117: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.TupleBuilder = void 0;
        const n = r(65871),
          i = r(66902),
          o = r(56906);
        e.TupleBuilder = class {
          constructor() {
            this.nr = []
          }
          writeNumber(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "int",
              value: BigInt(t)
            })
          }
          writeBoolean(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "int",
              value: t ? -1n : 0n
            })
          }
          writeBuffer(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "slice",
              cell: (0, n.beginCell)().storeBuffer(t).endCell()
            })
          }
          writeString(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "slice",
              cell: (0, n.beginCell)().storeStringTail(t).endCell()
            })
          }
          writeCell(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : t instanceof i.Cell ? this.nr.push({
              type: "cell",
              cell: t
            }) : t instanceof o.Slice && this.nr.push({
              type: "cell",
              cell: t.asCell()
            })
          }
          writeSlice(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : t instanceof i.Cell ? this.nr.push({
              type: "slice",
              cell: t
            }) : t instanceof o.Slice && this.nr.push({
              type: "slice",
              cell: t.asCell()
            })
          }
          writeBuilder(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : t instanceof i.Cell ? this.nr.push({
              type: "builder",
              cell: t
            }) : t instanceof o.Slice && this.nr.push({
              type: "builder",
              cell: t.asCell()
            })
          }
          writeTuple(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "tuple",
              items: t
            })
          }
          writeAddress(t) {
            null == t ? this.nr.push({
              type: "null"
            }) : this.nr.push({
              type: "slice",
              cell: (0, n.beginCell)().storeAddress(t).endCell()
            })
          }
          build() {
            return [...this.nr]
          }
        }
      },
      44281: (t, e) => {
        "use strict";

        function r(t, e, r) {
          return t >= e && r >= t
        }

        function n(t) {
          if (void 0 === t) return {};
          if (t === Object(t)) return t;
          throw TypeError("Could not convert argument to dictionary")
        }

        function i(t) {
          this.tokens = [].slice.call(t)
        }
        i.prototype = {
          endOfStream: function() {
            return !this.tokens.length
          },
          read: function() {
            return this.tokens.length ? this.tokens.shift() : -1
          },
          prepend: function(t) {
            if (Array.isArray(t))
              for (var e = t; e.length;) this.tokens.unshift(e.pop());
            else this.tokens.unshift(t)
          },
          push: function(t) {
            if (Array.isArray(t))
              for (var e = t; e.length;) this.tokens.push(e.shift());
            else this.tokens.push(t)
          }
        };
        var o = -1;

        function s(t, e) {
          if (t) throw TypeError("Decoder error");
          return e || 65533
        }
        var a = "utf-8";

        function u(t, e) {
          if (!(this instanceof u)) return new u(t, e);
          if ((t = void 0 !== t ? (t + "").toLowerCase() : a) !== a) throw Error("Encoding not supported. Only utf-8 is supported");
          e = n(e), this.ir = !1, this.sr = !1, this.ur = null, this.cr = !!e.fatal, this.lr = !!e.ignoreBOM, Object.defineProperty(this, "encoding", {
            value: "utf-8"
          }), Object.defineProperty(this, "fatal", {
            value: this.cr
          }), Object.defineProperty(this, "ignoreBOM", {
            value: this.lr
          })
        }

        function c(t, e) {
          if (!(this instanceof c)) return new c(t, e);
          if ((t = void 0 !== t ? (t + "").toLowerCase() : a) !== a) throw Error("Encoding not supported. Only utf-8 is supported");
          e = n(e), this.ir = !1, this.hr = null, this.dr = {
            fatal: !!e.fatal
          }, Object.defineProperty(this, "encoding", {
            value: "utf-8"
          })
        }

        function f(t) {
          var e = t.fatal,
            n = 0,
            i = 0,
            a = 0,
            u = 128,
            c = 191;
          this.handler = function(t, f) {
            if (-1 === f && 0 !== a) return a = 0, s(e);
            if (-1 === f) return o;
            if (0 === a) {
              if (r(f, 0, 127)) return f;
              if (r(f, 194, 223)) a = 1, n = f - 192;
              else if (r(f, 224, 239)) 224 === f && (u = 160), 237 === f && (c = 159), a = 2, n = f - 224;
              else {
                if (!r(f, 240, 244)) return s(e);
                240 === f && (u = 144), 244 === f && (c = 143), a = 3, n = f - 240
              }
              return n <<= 6 * a, null
            }
            if (!r(f, u, c)) return n = a = i = 0, u = 128, c = 191, t.prepend(f), s(e);
            if (u = 128, c = 191, n += f - 128 << 6 * (a - (i += 1)), i !== a) return null;
            var l = n;
            return n = a = i = 0, l
          }
        }

        function l(t) {
          t.fatal, this.handler = function(t, e) {
            if (-1 === e) return o;
            if (r(e, 0, 127)) return e;
            var n, i;
            r(e, 128, 2047) ? (n = 1, i = 192) : r(e, 2048, 65535) ? (n = 2, i = 224) : r(e, 65536, 1114111) && (n = 3, i = 240);
            for (var s = [(e >> 6 * n) + i]; n > 0;) {
              var a = e >> 6 * (n - 1);
              s.push(128 | 63 & a), n -= 1
            }
            return s
          }
        }
        u.prototype = {
          decode: function(t, e) {
            var r;
            r = "object" == typeof t && t instanceof ArrayBuffer ? new Uint8Array(t) : "object" == typeof t && "buffer" in t && t.buffer instanceof ArrayBuffer ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : new Uint8Array(0), e = n(e), this.ir || (this.ur = new f({
              fatal: this.cr
            }), this.sr = !1), this.ir = !!e.stream;
            for (var s, a = new i(r), u = []; !a.endOfStream() && (s = this.ur.handler(a, a.read())) !== o;) null !== s && (Array.isArray(s) ? u.push.apply(u, s) : u.push(s));
            if (!this.ir) {
              do {
                if ((s = this.ur.handler(a, a.read())) === o) break;
                null !== s && (Array.isArray(s) ? u.push.apply(u, s) : u.push(s))
              } while (!a.endOfStream());
              this.ur = null
            }
            return u.length && -1 !== ["utf-8"].indexOf(this.encoding) && !this.lr && !this.sr && (65279 === u[0] ? (this.sr = !0, u.shift()) : this.sr = !0),
              function(t) {
                for (var e = "", r = 0; r < t.length; ++r) {
                  var n = t[r];
                  e += n > 65535 ? String.fromCharCode(55296 + ((n -= 65536) >> 10), 56320 + (1023 & n)) : String.fromCharCode(n)
                }
                return e
              }(u)
          }
        }, c.prototype = {
          encode: function(t, e) {
            t = t ? t + "" : "", e = n(e), this.ir || (this.hr = new l(this.dr)), this.ir = !!e.stream;
            for (var r, s = [], a = new i(function(t) {
                for (var e = t + "", r = e.length, n = 0, i = []; r > n;) {
                  var o = e.charCodeAt(n);
                  if (55296 > o || o > 57343) i.push(o);
                  else if (56320 > o || o > 57343) {
                    if (o >= 55296 && 56319 >= o)
                      if (n === r - 1) i.push(65533);
                      else {
                        var s = t.charCodeAt(n + 1);
                        if (56320 > s || s > 57343) i.push(65533);
                        else {
                          var a = 1023 & o,
                            u = 1023 & s;
                          i.push(65536 + (a << 10) + u), n += 1
                        }
                      }
                  } else i.push(65533);
                  n += 1
                }
                return i
              }(t)); !a.endOfStream() && (r = this.hr.handler(a, a.read())) !== o;) Array.isArray(r) ? s.push.apply(s, r) : s.push(r);
            if (!this.ir) {
              for (;
                (r = this.hr.handler(a, a.read())) !== o;) Array.isArray(r) ? s.push.apply(s, r) : s.push(r);
              this.hr = null
            }
            return new Uint8Array(s)
          }
        }, e.TextEncoder = c, e.TextDecoder = u
      },
      44442: t => {
        "use strict";
        t.exports = function() {
          this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
        }
      },
      44834: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.iso7064Check = function(t) {
          for (var e = 10, r = 0; r < t.length - 1; r++) e = (parseInt(t[r], 10) + e) % 10 == 0 ? 9 : (parseInt(t[r], 10) + e) % 10 * 2 % 11;
          return (e = 1 === e ? 0 : 11 - e) === parseInt(t[10], 10)
        }, e.luhnCheck = function(t) {
          for (var e = 0, r = !1, n = t.length - 1; n >= 0; n--) {
            if (r) {
              var i = 2 * parseInt(t[n], 10);
              e += i > 9 ? i.toString().split("").map(function(t) {
                return parseInt(t, 10)
              }).reduce(function(t, e) {
                return t + e
              }, 0) : i
            } else e += parseInt(t[n], 10);
            r = !r
          }
          return e % 10 == 0
        }, e.reverseMultiplyAndSum = function(t, e) {
          for (var r = 0, n = 0; n < t.length; n++) r += t[n] * (e - n);
          return r
        }, e.verhoeffCheck = function(t) {
          for (var e = [
              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
              [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],
              [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],
              [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],
              [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],
              [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],
              [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],
              [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],
              [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],
              [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
            ], r = [
              [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
              [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],
              [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],
              [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],
              [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],
              [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],
              [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],
              [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]
            ], n = t.split("").reverse().join(""), i = 0, o = 0; o < n.length; o++) i = e[i][r[o % 8][parseInt(n[o], 10)]];
          return 0 === i
        }
      },
      45062: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.compactBytesToNibbles = e.bytesToNibbles = e.nibblesToCompactBytes = e.nibblesToBytes = e.hasTerminator = void 0, e.hasTerminator = t => t.length > 0 && 16 === t[t.length - 1], e.nibblesToBytes = (t, e) => {
          for (let r = 0, n = 0; n < t.length; r += 1, n += 2) e[r] = t[n] << 4 | t[n + 1]
        }, e.nibblesToCompactBytes = t => {
          let r = 0;
          (0, e.hasTerminator)(t) && (r = 1, t = t.subarray(0, t.length - 1));
          const n = new Uint8Array(t.length / 2 + 1);
          return n[0] = r << 5, !(1 & ~t.length) && (n[0] |= 16, n[0] |= t[0], t = t.subarray(1)), (0, e.nibblesToBytes)(t, n.subarray(1)), n
        }, e.bytesToNibbles = t => {
          const e = 2 * t.length + 1,
            r = new Uint8Array(e);
          for (let e = 0; e < t.length; e++) {
            const n = t[e];
            r[2 * e] = n / 16, r[2 * e + 1] = n % 16
          }
          return r[e - 1] = 16, r
        }, e.compactBytesToNibbles = t => {
          if (0 === t.length) return t;
          let r = (0, e.bytesToNibbles)(t);
          2 > r[0] && (r = r.subarray(0, r.length - 1));
          const n = 2 - (1 & r[0]);
          return r.subarray(n)
        }
      },
      45412: (t, e, r) => {
        "use strict";
        var n, i = r(65606);
        t.exports = k, k.ReadableState = P, r(37007).EventEmitter;
        var o, s = function(t, e) {
            return t.listeners(e).length
          },
          a = r(40345),
          u = r(48287).Buffer,
          c = ("u" > typeof r.g ? r.g : "u" > typeof window ? window : "u" > typeof self ? self : {}).Uint8Array || function() {},
          f = r(79838);
        o = f && f.debuglog ? f.debuglog("stream") : function() {};
        var l, h, d, p = r(80345),
          b = r(75896),
          m = r(65291).getHighWaterMark,
          y = r(86048).F,
          g = y.ERR_INVALID_ARG_TYPE,
          v = y.ERR_STREAM_PUSH_AFTER_EOF,
          w = y.ERR_METHOD_NOT_IMPLEMENTED,
          A = y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
        r(56698)(k, a);
        var T = b.errorOrDestroy,
          E = ["error", "close", "destroy", "pause", "resume"];

        function P(t, e, i) {
          n = n || r(25382), t = t || {}, "boolean" != typeof i && (i = e instanceof n), this.objectMode = !!t.objectMode, i && (this.objectMode = this.objectMode || !!t.readableObjectMode), this.highWaterMark = m(this, t, "readableHighWaterMark", i), this.buffer = new p, this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== t.emitClose, this.autoDestroy = !!t.autoDestroy, this.destroyed = !1, this.defaultEncoding = t.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, t.encoding && (l || (l = r(83141).I), this.decoder = new l(t.encoding), this.encoding = t.encoding)
        }

        function k(t) {
          if (n = n || r(25382), !(this instanceof k)) return new k(t);
          var e = this instanceof n;
          this.rt = new P(t, this, e), this.readable = !0, t && ("function" == typeof t.read && (this.xt = t.read), "function" == typeof t.destroy && (this.Ct = t.destroy)), a.call(this)
        }

        function x(t, e, r, n, i) {
          o("readableAddChunk", e);
          var s, a = t.rt;
          if (null === e) a.reading = !1,
            function(t, e) {
              if (o("onEofChunk"), !e.ended) {
                if (e.decoder) {
                  var r = e.decoder.end();
                  r && r.length && (e.buffer.push(r), e.length += e.objectMode ? 1 : r.length)
                }
                e.ended = !0, e.sync ? B(t) : (e.needReadable = !1, e.emittedReadable || (e.emittedReadable = !0, W(t)))
              }
            }(t, a);
          else if (i || (s = function(t, e) {
              var r;
              return ! function(t) {
                return u.isBuffer(t) || t instanceof c
              }(e) && "string" != typeof e && void 0 !== e && !t.objectMode && (r = new g("chunk", ["string", "Buffer", "Uint8Array"], e)), r
            }(a, e)), s) T(t, s);
          else if (a.objectMode || e && e.length > 0)
            if ("string" != typeof e && !a.objectMode && Object.getPrototypeOf(e) !== u.prototype && (e = function(t) {
                return u.from(t)
              }(e)), n) a.endEmitted ? T(t, new A) : I(t, a, e, !0);
            else if (a.ended) T(t, new v);
          else {
            if (a.destroyed) return !1;
            a.reading = !1, a.decoder && !r ? (e = a.decoder.write(e), a.objectMode || 0 !== e.length ? I(t, a, e, !1) : M(t, a)) : I(t, a, e, !1)
          } else n || (a.reading = !1, M(t, a));
          return !a.ended && (a.length < a.highWaterMark || 0 === a.length)
        }

        function I(t, e, r, n) {
          e.flowing && 0 === e.length && !e.sync ? (e.awaitDrain = 0, t.emit("data", r)) : (e.length += e.objectMode ? 1 : r.length, n ? e.buffer.unshift(r) : e.buffer.push(r), e.needReadable && B(t)), M(t, e)
        }
        Object.defineProperty(k.prototype, "destroyed", {
          enumerable: !1,
          get: function() {
            return void 0 !== this.rt && this.rt.destroyed
          },
          set: function(t) {
            this.rt && (this.rt.destroyed = t)
          }
        }), k.prototype.destroy = b.destroy, k.prototype.Nt = b.undestroy, k.prototype.Ct = function(t, e) {
          e(t)
        }, k.prototype.push = function(t, e) {
          var r, n = this.rt;
          return n.objectMode ? r = !0 : "string" == typeof t && ((e = e || n.defaultEncoding) !== n.encoding && (t = u.from(t, e), e = ""), r = !0), x(this, t, e, !1, r)
        }, k.prototype.unshift = function(t) {
          return x(this, t, null, !0, !1)
        }, k.prototype.isPaused = function() {
          return !1 === this.rt.flowing
        }, k.prototype.setEncoding = function(t) {
          l || (l = r(83141).I);
          var e = new l(t);
          this.rt.decoder = e, this.rt.encoding = this.rt.decoder.encoding;
          for (var n = this.rt.buffer.head, i = ""; null !== n;) i += e.write(n.data), n = n.next;
          return this.rt.buffer.clear(), "" !== i && this.rt.buffer.push(i), this.rt.length = i.length, this
        };
        var S = 1073741824;

        function O(t, e) {
          return 0 >= t || 0 === e.length && e.ended ? 0 : e.objectMode ? 1 : t != t ? e.flowing && e.length ? e.buffer.head.data.length : e.length : (t > e.highWaterMark && (e.highWaterMark = function(t) {
            return S > t ? (t--, t |= t >>> 1, t |= t >>> 2, t |= t >>> 4, t |= t >>> 8, t |= t >>> 16, t++) : t = S, t
          }(t)), t > e.length ? e.ended ? e.length : (e.needReadable = !0, 0) : t)
        }

        function B(t) {
          var e = t.rt;
          o("emitReadable", e.needReadable, e.emittedReadable), e.needReadable = !1, e.emittedReadable || (o("emitReadable", e.flowing), e.emittedReadable = !0, i.nextTick(W, t))
        }

        function W(t) {
          var e = t.rt;
          o("emitReadable_", e.destroyed, e.length, e.ended), !e.destroyed && (e.length || e.ended) && (t.emit("readable"), e.emittedReadable = !1), e.needReadable = !e.flowing && !e.ended && e.length <= e.highWaterMark, _(t)
        }

        function M(t, e) {
          e.readingMore || (e.readingMore = !0, i.nextTick(C, t, e))
        }

        function C(t, e) {
          for (; !e.reading && !e.ended && (e.length < e.highWaterMark || e.flowing && 0 === e.length);) {
            var r = e.length;
            if (o("maybeReadMore read 0"), t.read(0), r === e.length) break
          }
          e.readingMore = !1
        }

        function R(t) {
          var e = t.rt;
          e.readableListening = t.listenerCount("readable") > 0, e.resumeScheduled && !e.paused ? e.flowing = !0 : t.listenerCount("data") > 0 && t.resume()
        }

        function N(t) {
          o("readable nexttick read 0"), t.read(0)
        }

        function j(t, e) {
          o("resume", e.reading), e.reading || t.read(0), e.resumeScheduled = !1, t.emit("resume"), _(t), e.flowing && !e.reading && t.read(0)
        }

        function _(t) {
          var e = t.rt;
          for (o("flow", e.flowing); e.flowing && null !== t.read(););
        }

        function D(t, e) {
          return 0 === e.length ? null : (e.objectMode ? r = e.buffer.shift() : t && t < e.length ? r = e.buffer.consume(t, e.decoder) : (r = e.decoder ? e.buffer.join("") : 1 === e.buffer.length ? e.buffer.first() : e.buffer.concat(e.length), e.buffer.clear()), r);
          var r
        }

        function U(t) {
          var e = t.rt;
          o("endReadable", e.endEmitted), e.endEmitted || (e.ended = !0, i.nextTick(L, e, t))
        }

        function L(t, e) {
          if (o("endReadableNT", t.endEmitted, t.length), !t.endEmitted && 0 === t.length && (t.endEmitted = !0, e.readable = !1, e.emit("end"), t.autoDestroy)) {
            var r = e.Wt;
            (!r || r.autoDestroy && r.finished) && e.destroy()
          }
        }

        function F(t, e) {
          for (var r = 0, n = t.length; n > r; r++)
            if (t[r] === e) return r;
          return -1
        }
        k.prototype.read = function(t) {
          o("read", t), t = parseInt(t, 10);
          var e = this.rt,
            r = t;
          if (0 !== t && (e.emittedReadable = !1), 0 === t && e.needReadable && ((0 !== e.highWaterMark ? e.length >= e.highWaterMark : e.length > 0) || e.ended)) return o("read: emitReadable", e.length, e.ended), 0 === e.length && e.ended ? U(this) : B(this), null;
          if (0 === (t = O(t, e)) && e.ended) return 0 === e.length && U(this), null;
          var n, i = e.needReadable;
          return o("need readable", i), (0 === e.length || e.length - t < e.highWaterMark) && o("length less than watermark", i = !0), e.ended || e.reading ? o("reading or ended", i = !1) : i && (o("do read"), e.reading = !0, e.sync = !0, 0 === e.length && (e.needReadable = !0), this.xt(e.highWaterMark), e.sync = !1, e.reading || (t = O(r, e))), null === (n = t > 0 ? D(t, e) : null) ? (e.needReadable = e.length <= e.highWaterMark, t = 0) : (e.length -= t, e.awaitDrain = 0), 0 === e.length && (e.ended || (e.needReadable = !0), r !== t && e.ended && U(this)), null !== n && this.emit("data", n), n
        }, k.prototype.xt = function(t) {
          T(this, new w("_read()"))
        }, k.prototype.pipe = function(t, e) {
          var r = this,
            n = this.rt;
          switch (n.pipesCount) {
            case 0:
              n.pipes = t;
              break;
            case 1:
              n.pipes = [n.pipes, t];
              break;
            default:
              n.pipes.push(t)
          }
          n.pipesCount += 1, o("pipe count=%d opts=%j", n.pipesCount, e);
          var a = e && !1 === e.end || t === i.stdout || t === i.stderr ? b : u;

          function u() {
            o("onend"), t.end()
          }
          n.endEmitted ? i.nextTick(a) : r.once("end", a), t.on("unpipe", function e(i, s) {
            o("onunpipe"), i === r && s && !1 === s.hasUnpiped && (s.hasUnpiped = !0, o("cleanup"), t.removeListener("close", d), t.removeListener("finish", p), t.removeListener("drain", c), t.removeListener("error", h), t.removeListener("unpipe", e), r.removeListener("end", u), r.removeListener("end", b), r.removeListener("data", l), f = !0, n.awaitDrain && (!t.Wt || t.Wt.needDrain) && c())
          });
          var c = function(t) {
            return function() {
              var e = t.rt;
              o("pipeOnDrain", e.awaitDrain), e.awaitDrain && e.awaitDrain--, 0 === e.awaitDrain && s(t, "data") && (e.flowing = !0, _(t))
            }
          }(r);
          t.on("drain", c);
          var f = !1;

          function l(e) {
            o("ondata");
            var i = t.write(e);
            o("dest.write", i), !1 === i && ((1 === n.pipesCount && n.pipes === t || n.pipesCount > 1 && -1 !== F(n.pipes, t)) && !f && (o("false write response, pause", n.awaitDrain), n.awaitDrain++), r.pause())
          }

          function h(e) {
            o("onerror", e), b(), t.removeListener("error", h), 0 === s(t, "error") && T(t, e)
          }

          function d() {
            t.removeListener("finish", p), b()
          }

          function p() {
            o("onfinish"), t.removeListener("close", d), b()
          }

          function b() {
            o("unpipe"), r.unpipe(t)
          }
          return r.on("data", l),
            function(t, e, r) {
              if ("function" == typeof t.prependListener) return t.prependListener(e, r);
              t.ye && t.ye[e] ? Array.isArray(t.ye[e]) ? t.ye[e].unshift(r) : t.ye[e] = [r, t.ye[e]] : t.on(e, r)
            }(t, "error", h), t.once("close", d), t.once("finish", p), t.emit("pipe", r), n.flowing || (o("pipe resume"), r.resume()), t
        }, k.prototype.unpipe = function(t) {
          var e = this.rt,
            r = {
              hasUnpiped: !1
            };
          if (0 === e.pipesCount) return this;
          if (1 === e.pipesCount) return t && t !== e.pipes || (t || (t = e.pipes), e.pipes = null, e.pipesCount = 0, e.flowing = !1, t && t.emit("unpipe", this, r)), this;
          if (!t) {
            var n = e.pipes,
              i = e.pipesCount;
            e.pipes = null, e.pipesCount = 0, e.flowing = !1;
            for (var o = 0; i > o; o++) n[o].emit("unpipe", this, {
              hasUnpiped: !1
            });
            return this
          }
          var s = F(e.pipes, t);
          return -1 === s || (e.pipes.splice(s, 1), e.pipesCount -= 1, 1 === e.pipesCount && (e.pipes = e.pipes[0]), t.emit("unpipe", this, r)), this
        }, k.prototype.on = function(t, e) {
          var r = a.prototype.on.call(this, t, e),
            n = this.rt;
          return "data" === t ? (n.readableListening = this.listenerCount("readable") > 0, !1 !== n.flowing && this.resume()) : "readable" === t && !n.endEmitted && !n.readableListening && (n.readableListening = n.needReadable = !0, n.flowing = !1, n.emittedReadable = !1, o("on readable", n.length, n.reading), n.length ? B(this) : n.reading || i.nextTick(N, this)), r
        }, k.prototype.addListener = k.prototype.on, k.prototype.removeListener = function(t, e) {
          var r = a.prototype.removeListener.call(this, t, e);
          return "readable" === t && i.nextTick(R, this), r
        }, k.prototype.removeAllListeners = function(t) {
          var e = a.prototype.removeAllListeners.apply(this, arguments);
          return ("readable" === t || void 0 === t) && i.nextTick(R, this), e
        }, k.prototype.resume = function() {
          var t = this.rt;
          return t.flowing || (o("resume"), t.flowing = !t.readableListening, function(t, e) {
            e.resumeScheduled || (e.resumeScheduled = !0, i.nextTick(j, t, e))
          }(this, t)), t.paused = !1, this
        }, k.prototype.pause = function() {
          return o("call pause flowing=%j", this.rt.flowing), !1 !== this.rt.flowing && (o("pause"), this.rt.flowing = !1, this.emit("pause")), this.rt.paused = !0, this
        }, k.prototype.wrap = function(t) {
          var e = this,
            r = this.rt,
            n = !1;
          for (var i in t.on("end", function() {
              if (o("wrapped end"), r.decoder && !r.ended) {
                var t = r.decoder.end();
                t && t.length && e.push(t)
              }
              e.push(null)
            }), t.on("data", function(i) {
              o("wrapped data"), r.decoder && (i = r.decoder.write(i)), r.objectMode && null == i || !(r.objectMode || i && i.length) || e.push(i) || (n = !0, t.pause())
            }), t) void 0 === this[i] && "function" == typeof t[i] && (this[i] = function(e) {
            return function() {
              return t[e].apply(t, arguments)
            }
          }(i));
          for (var s = 0; E.length > s; s++) t.on(E[s], this.emit.bind(this, E[s]));
          return this.xt = function(e) {
            o("wrapped _read", e), n && (n = !1, t.resume())
          }, this
        }, "function" == typeof Symbol && (k.prototype[Symbol.asyncIterator] = function() {
          return void 0 === h && (h = r(2955)), h(this)
        }), Object.defineProperty(k.prototype, "readableHighWaterMark", {
          enumerable: !1,
          get: function() {
            return this.rt.highWaterMark
          }
        }), Object.defineProperty(k.prototype, "readableBuffer", {
          enumerable: !1,
          get: function() {
            return this.rt && this.rt.buffer
          }
        }), Object.defineProperty(k.prototype, "readableFlowing", {
          enumerable: !1,
          get: function() {
            return this.rt.flowing
          },
          set: function(t) {
            this.rt && (this.rt.flowing = t)
          }
        }), k.pr = D, Object.defineProperty(k.prototype, "readableLength", {
          enumerable: !1,
          get: function() {
            return this.rt.length
          }
        }), "function" == typeof Symbol && (k.from = function(t, e) {
          return void 0 === d && (d = r(55157)), d(k, t, e)
        })
      },
      45467: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = 1 >= arguments.length || void 0 === arguments[1] || arguments[1];
          return (0, i.default)(t), e ? o.test(t) || s.test(t) || a.test(t) || u.test(t) : o.test(t) || s.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^rgb\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){2}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\)$/,
          s = /^rgba\((([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/,
          a = /^rgb\((([0-9]%|[1-9][0-9]%|100%),){2}([0-9]%|[1-9][0-9]%|100%)\)$/,
          u = /^rgba\((([0-9]%|[1-9][0-9]%|100%),){3}(0?\.\d|1(\.0)?|0(\.0)?)\)$/;
        t.exports = e.default, t.exports.default = e.default
      },
      45772: (t, e) => {
        "use strict";

        function r(t) {
          return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return "object" === r(t) && null !== t ? t = "function" == typeof t.toString ? t.toString() : "[object Object]" : (null === t || typeof t > "u" || isNaN(t) && !t.length) && (t = ""), t + ""
        }, t.exports = e.default, t.exports.default = e.default
      },
      45777: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isISO6346 = a, e.isFreightContainerID = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[A-Z]{3}(U[0-9]{7})|([J,Z][0-9]{6,7})$/,
          s = /^[0-9]$/;

        function a(t) {
          if ((0, i.default)(t), t = t.toUpperCase(), !o.test(t)) return !1;
          if (11 === t.length) {
            for (var e = 0, r = 0; r < t.length - 1; r++)
              if (s.test(t[r])) e += t[r] * Math.pow(2, r);
              else {
                var n = t.charCodeAt(r) - 55;
                e += (11 > n ? n : 11 > n || n > 20 ? 21 > n || n > 30 ? 34 + n % 31 : 23 + n % 21 : 12 + n % 11) * Math.pow(2, r)
              } var a = e % 11;
            return +t[t.length - 1] === a
          }
          return !0
        }
        var u = a;
        e.isFreightContainerID = u
      },
      45926: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, i.default)(t), (e = (0, n.default)(e, u)).locale in s.decimal) return !(0, o.default)(c, t.replace(/ /g, "")) && function(t) {
            return RegExp("^[-+]?([0-9]+)?(\\".concat(s.decimal[t.locale], "[0-9]{").concat(t.decimal_digits, "})").concat(t.force_decimal ? "" : "?", "$"))
          }(e).test(t);
          throw Error("Invalid locale '".concat(e.locale, "'"))
        };
        var n = a(r(71229)),
          i = a(r(83399)),
          o = a(r(79265)),
          s = r(13237);

        function a(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var u = {
            force_decimal: !1,
            decimal_digits: "1,",
            locale: "en-US"
          },
          c = ["", "-", "+"];
        t.exports = e.default, t.exports.default = e.default
      },
      46170: (t, e, r) => {
        const n = r(53908),
          i = r(30144),
          {
            safeRe: o,
            t: s
          } = r(99718);
        t.exports = (t, e) => {
          if (t instanceof n) return t;
          if ("number" == typeof t && (t += ""), "string" != typeof t) return null;
          let r = null;
          if ((e = e || {}).rtl) {
            const n = e.includePrerelease ? o[s.COERCERTLFULL] : o[s.COERCERTL];
            let i;
            for (;
              (i = n.exec(t)) && (!r || r.index + r[0].length !== t.length);)(!r || i.index + i[0].length !== r.index + r[0].length) && (r = i), n.lastIndex = i.index + i[1].length + i[2].length;
            n.lastIndex = -1
          } else r = t.match(e.includePrerelease ? o[s.COERCEFULL] : o[s.COERCE]);
          if (null === r) return null;
          const a = r[2],
            u = r[3] || "0",
            c = r[4] || "0",
            f = e.includePrerelease && r[5] ? "-" + r[5] : "",
            l = e.includePrerelease && r[6] ? "+" + r[6] : "";
          return i(`${a}.${u}.${c}${f}${l}`, e)
        }
      },
      46254: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e) => new n(t, e).minor
      },
      46255: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          var r, n;
          (0, i.default)(t), "object" === o(e) ? (r = e.min || 0, n = e.max) : (r = arguments[1], n = arguments[2]);
          var s = encodeURI(t).split(/%..|./).length - 1;
          return s >= r && (typeof n > "u" || n >= s)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };

        function o(t) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        t.exports = e.default, t.exports.default = e.default
      },
      46815: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.deriveMnemonicsPath = e.deriveMnemonicHardenedKey = e.getMnemonicsMasterKeyFromSeed = void 0;
        const i = r(10132),
          o = r(4870),
          s = 2147483648;
        async function a(t) {
          const e = await (0, o.hmac_sha512)("TON Mnemonics HD seed", t);
          return {
            key: e.slice(0, 32),
            chainCode: e.slice(32)
          }
        }
        async function u(t, e) {
          if (e >= s) throw Error("Key index must be less than offset");
          const r = n.alloc(4);
          r.writeUInt32BE(e + s, 0);
          const i = n.concat([n.alloc(1, 0), t.key, r]),
            a = await (0, o.hmac_sha512)(t.chainCode, i);
          return {
            key: a.slice(0, 32),
            chainCode: a.slice(32)
          }
        }
        e.getMnemonicsMasterKeyFromSeed = a, e.deriveMnemonicHardenedKey = u, e.deriveMnemonicsPath = async function(t, e, r = 24, n) {
          let o = await a(t),
            s = [...e];
          for (; s.length > 0;) {
            let t = s[0];
            s = s.slice(1), o = await u(o, t)
          }
          return await (0, i.mnemonicFromRandomSeed)(o.key, r, n)
        }
      },
      47119: t => {
        "use strict";
        t.exports = "u" > typeof Reflect && Reflect && Reflect.apply
      },
      47168: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bool = e.getBooleanValue = void 0;
        const n = r(35620),
          i = r(65534),
          o = r(49334),
          s = r(1201),
          a = (0, n.coerce)((0, n.boolean)(), (0, n.union)([(0, n.literal)("true"), (0, n.literal)("false")]), t => "true" === t);
        e.getBooleanValue = t => {
          try {
            return (0, n.create)(t, a) ? BigInt(1) : BigInt(0)
          } catch {
            throw new o.ParserError(`Invalid boolean value. Expected a boolean literal, or the string "true" or "false", but received "${t}".`)
          }
        }, e.bool = {
          isDynamic: !1,
          isType: t => "bool" === t,
          getByteLength: () => 32,
          encode({
            buffer: t,
            value: r,
            packed: n,
            tight: o
          }) {
            const a = (0, e.getBooleanValue)(r);
            return n ? (0, i.concatBytes)([t, (0, i.bigIntToBytes)(a)]) : s.number.encode({
              type: "uint256",
              buffer: t,
              value: a,
              packed: n,
              tight: o
            })
          },
          decode: t => s.number.decode({
            ...t,
            type: "uint256"
          }) === BigInt(1)
        }
      },
      47182: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.findCommonPrefix = void 0, e.findCommonPrefix = function(t, e = 0) {
          if (0 === t.length) return "";
          let r = t[0].slice(e);
          for (let n = 1; n < t.length; n++) {
            const i = t[n];
            for (; i.indexOf(r, e) !== e;)
              if (r = r.substring(0, r.length - 1), "" === r) return r
          }
          return r
        }
      },
      47244: (t, e, r) => {
        "use strict";
        var n = r(49092)(),
          i = r(36556)("Object.prototype.toString"),
          o = function(t) {
            return !(n && t && "object" == typeof t && Symbol.toStringTag in t) && "[object Arguments]" === i(t)
          },
          s = function(t) {
            return !!o(t) || null !== t && "object" == typeof t && "length" in t && "number" == typeof t.length && t.length >= 0 && "[object Array]" !== i(t) && "callee" in t && "[object Function]" === i(t.callee)
          },
          a = function() {
            return o(arguments)
          }();
        o.isLegacyArguments = s, t.exports = a ? o : s
      },
      47293: t => {
        "use strict";
        t.exports = function(t, e) {
          var r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y, g, v, w, A, T, E, P, k, x;
          r = t.state, n = t.next_in, k = t.input, i = n + (t.avail_in - 5), o = t.next_out, x = t.output, s = o - (e - t.avail_out), a = o + (t.avail_out - 257), u = r.dmax, c = r.wsize, f = r.whave, l = r.wnext, h = r.window, d = r.hold, p = r.bits, b = r.lencode, m = r.distcode, y = (1 << r.lenbits) - 1, g = (1 << r.distbits) - 1;
          t: do {
            15 > p && (d += k[n++] << p, p += 8, d += k[n++] << p, p += 8), v = b[d & y];
            e: for (;;) {
              if (d >>>= w = v >>> 24, p -= w, 0 == (w = v >>> 16 & 255)) x[o++] = 65535 & v;
              else {
                if (!(16 & w)) {
                  if (64 & w) {
                    if (32 & w) {
                      r.mode = 12;
                      break t
                    }
                    t.msg = "invalid literal/length code", r.mode = 30;
                    break t
                  }
                  v = b[(65535 & v) + (d & (1 << w) - 1)];
                  continue e
                }
                for (A = 65535 & v, (w &= 15) && (w > p && (d += k[n++] << p, p += 8), A += d & (1 << w) - 1, d >>>= w, p -= w), 15 > p && (d += k[n++] << p, p += 8, d += k[n++] << p, p += 8), v = m[d & g];;) {
                  if (d >>>= w = v >>> 24, p -= w, 16 & (w = v >>> 16 & 255)) {
                    if (T = 65535 & v, (w &= 15) > p && (d += k[n++] << p, w > (p += 8) && (d += k[n++] << p, p += 8)), (T += d & (1 << w) - 1) > u) {
                      t.msg = "invalid distance too far back", r.mode = 30;
                      break t
                    }
                    if (d >>>= w, p -= w, T > (w = o - s)) {
                      if ((w = T - w) > f && r.sane) {
                        t.msg = "invalid distance too far back", r.mode = 30;
                        break t
                      }
                      if (E = 0, P = h, 0 === l) {
                        if (E += c - w, A > w) {
                          A -= w;
                          do {
                            x[o++] = h[E++]
                          } while (--w);
                          E = o - T, P = x
                        }
                      } else if (w > l) {
                        if (E += c + l - w, A > (w -= l)) {
                          A -= w;
                          do {
                            x[o++] = h[E++]
                          } while (--w);
                          if (E = 0, A > l) {
                            A -= w = l;
                            do {
                              x[o++] = h[E++]
                            } while (--w);
                            E = o - T, P = x
                          }
                        }
                      } else if (E += l - w, A > w) {
                        A -= w;
                        do {
                          x[o++] = h[E++]
                        } while (--w);
                        E = o - T, P = x
                      }
                      for (; A > 2;) x[o++] = P[E++], x[o++] = P[E++], x[o++] = P[E++], A -= 3;
                      A && (x[o++] = P[E++], A > 1 && (x[o++] = P[E++]))
                    } else {
                      E = o - T;
                      do {
                        x[o++] = x[E++], x[o++] = x[E++], x[o++] = x[E++], A -= 3
                      } while (A > 2);
                      A && (x[o++] = x[E++], A > 1 && (x[o++] = x[E++]))
                    }
                    break
                  }
                  if (64 & w) {
                    t.msg = "invalid distance code", r.mode = 30;
                    break t
                  }
                  v = m[(65535 & v) + (d & (1 << w) - 1)]
                }
              }
              break
            }
          } while (i > n && a > o);
          n -= A = p >> 3, d &= (1 << (p -= A << 3)) - 1, t.next_in = n, t.next_out = o, t.avail_in = i > n ? i - n + 5 : 5 - (n - i), t.avail_out = a > o ? a - o + 257 : 257 - (o - a), r.hold = d, r.bits = p
        }
      },
      47790: () => {},
      48033: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.has(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = new Set(["aa", "ab", "ae", "af", "ak", "am", "an", "ar", "as", "av", "ay", "az", "az", "ba", "be", "bg", "bh", "bi", "bm", "bn", "bo", "br", "bs", "ca", "ce", "ch", "co", "cr", "cs", "cu", "cv", "cy", "da", "de", "dv", "dz", "ee", "el", "en", "eo", "es", "et", "eu", "fa", "ff", "fi", "fj", "fo", "fr", "fy", "ga", "gd", "gl", "gn", "gu", "gv", "ha", "he", "hi", "ho", "hr", "ht", "hu", "hy", "hz", "ia", "id", "ie", "ig", "ii", "ik", "io", "is", "it", "iu", "ja", "jv", "ka", "kg", "ki", "kj", "kk", "kl", "km", "kn", "ko", "kr", "ks", "ku", "kv", "kw", "ky", "la", "lb", "lg", "li", "ln", "lo", "lt", "lu", "lv", "mg", "mh", "mi", "mk", "ml", "mn", "mr", "ms", "mt", "my", "na", "nb", "nd", "ne", "ng", "nl", "nn", "no", "nr", "nv", "ny", "oc", "oj", "om", "or", "os", "pa", "pi", "pl", "ps", "pt", "qu", "rm", "rn", "ro", "ru", "rw", "sa", "sc", "sd", "se", "sg", "si", "sk", "sl", "sm", "sn", "so", "sq", "sr", "ss", "st", "su", "sv", "sw", "ta", "te", "tg", "th", "ti", "tk", "tl", "tn", "to", "tr", "ts", "tt", "tw", "ty", "ug", "uk", "ur", "uz", "ve", "vi", "vo", "wa", "wo", "xh", "yi", "yo", "za", "zh", "zu"]);
        t.exports = e.default, t.exports.default = e.default
      },
      48178: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.MessageValue = e.storeMessage = e.loadMessage = void 0;
        const n = r(65871),
          i = r(60445),
          o = r(22738);

        function s(t) {
          const e = (0, i.loadCommonMessageInfo)(t);
          let r = null;
          return t.loadBit() && (r = t.loadBit() ? (0, o.loadStateInit)(t.loadRef().beginParse()) : (0, o.loadStateInit)(t)), {
            info: e,
            init: r,
            body: t.loadBit() ? t.loadRef() : t.asCell()
          }
        }

        function a(t, e) {
          return r => {
            if (r.store((0, i.storeCommonMessageInfo)(t.info)), t.init) {
              r.storeBit(!0);
              let i = (0, n.beginCell)().store((0, o.storeStateInit)(t.init)),
                s = !1;
              s = !(!e || !e.forceRef) || r.availableBits - 2 < i.bits + t.body.bits.length, s ? (r.storeBit(!0), r.storeRef(i)) : (r.storeBit(!1), r.storeBuilder(i))
            } else r.storeBit(!1);
            let s = !1;
            s = !(!e || !e.forceRef) || r.availableBits - 1 < t.body.bits.length || r.refs + t.body.refs.length > 4, s ? (r.storeBit(!0), r.storeRef(t.body)) : (r.storeBit(!1), r.storeBuilder(t.body.asBuilder()))
          }
        }
        e.loadMessage = s, e.storeMessage = a, e.MessageValue = {
          serialize(t, e) {
            e.storeRef((0, n.beginCell)().store(a(t)))
          },
          parse: t => s(t.loadRef().beginParse())
        }
      },
      48184: (t, e, r) => {
        "use strict";
        var n, i = r(36556),
          o = r(99721)(/^\s*(?:function)?\*/),
          s = r(49092)(),
          a = r(93628),
          u = i("Object.prototype.toString"),
          c = i("Function.prototype.toString");
        t.exports = function(t) {
          if ("function" != typeof t) return !1;
          if (o(c(t))) return !0;
          if (!s) return "[object GeneratorFunction]" === u(t);
          if (!a) return !1;
          if (typeof n > "u") {
            var e = function() {
              if (!s) return !1;
              try {
                return Function("return function*() {}")()
              } catch {}
            }();
            n = !!e && a(e)
          }
          return a(t) === n
        }
      },
      48287: (t, e, r) => {
        "use strict";
        const n = r(67526),
          i = r(251),
          o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        e.Buffer = u, e.SlowBuffer = function(t) {
          return +t != t && (t = 0), u.alloc(+t)
        }, e.INSPECT_MAX_BYTES = 50;
        const s = 2147483647;

        function a(t) {
          if (t > s) throw new RangeError('The value "' + t + '" is invalid for option "size"');
          const e = new Uint8Array(t);
          return Object.setPrototypeOf(e, u.prototype), e
        }

        function u(t, e, r) {
          if ("number" == typeof t) {
            if ("string" == typeof e) throw new TypeError('The "string" argument must be of type string. Received type number');
            return l(t)
          }
          return c(t, e, r)
        }

        function c(t, e, r) {
          if ("string" == typeof t) return function(t, e) {
            if (("string" != typeof e || "" === e) && (e = "utf8"), !u.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
            const r = 0 | b(t, e);
            let n = a(r);
            const i = n.write(t, e);
            return i !== r && (n = n.slice(0, i)), n
          }(t, e);
          if (ArrayBuffer.isView(t)) return function(t) {
            if (q(t, Uint8Array)) {
              const e = new Uint8Array(t);
              return d(e.buffer, e.byteOffset, e.byteLength)
            }
            return h(t)
          }(t);
          if (null == t) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t);
          if (q(t, ArrayBuffer) || t && q(t.buffer, ArrayBuffer) || "u" > typeof SharedArrayBuffer && (q(t, SharedArrayBuffer) || t && q(t.buffer, SharedArrayBuffer))) return d(t, e, r);
          if ("number" == typeof t) throw new TypeError('The "value" argument must not be of type number. Received type number');
          const n = t.valueOf && t.valueOf();
          if (null != n && n !== t) return u.from(n, e, r);
          const i = function(t) {
            if (u.isBuffer(t)) {
              const e = 0 | p(t.length),
                r = a(e);
              return 0 === r.length || t.copy(r, 0, 0, e), r
            }
            return void 0 !== t.length ? "number" != typeof t.length || J(t.length) ? a(0) : h(t) : "Buffer" === t.type && Array.isArray(t.data) ? h(t.data) : void 0
          }(t);
          if (i) return i;
          if ("u" > typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t[Symbol.toPrimitive]) return u.from(t[Symbol.toPrimitive]("string"), e, r);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t)
        }

        function f(t) {
          if ("number" != typeof t) throw new TypeError('"size" argument must be of type number');
          if (0 > t) throw new RangeError('The value "' + t + '" is invalid for option "size"')
        }

        function l(t) {
          return f(t), a(0 > t ? 0 : 0 | p(t))
        }

        function h(t) {
          const e = 0 > t.length ? 0 : 0 | p(t.length),
            r = a(e);
          for (let n = 0; e > n; n += 1) r[n] = 255 & t[n];
          return r
        }

        function d(t, e, r) {
          if (0 > e || t.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
          if (t.byteLength < e + (r || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let n;
          return n = void 0 === e && void 0 === r ? new Uint8Array(t) : void 0 === r ? new Uint8Array(t, e) : new Uint8Array(t, e, r), Object.setPrototypeOf(n, u.prototype), n
        }

        function p(t) {
          if (t >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
          return 0 | t
        }

        function b(t, e) {
          if (u.isBuffer(t)) return t.length;
          if (ArrayBuffer.isView(t) || q(t, ArrayBuffer)) return t.byteLength;
          if ("string" != typeof t) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t);
          const r = t.length,
            n = arguments.length > 2 && !0 === arguments[2];
          if (!n && 0 === r) return 0;
          let i = !1;
          for (;;) switch (e) {
            case "ascii":
            case "latin1":
            case "binary":
              return r;
            case "utf8":
            case "utf-8":
              return K(t).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r;
            case "hex":
              return r >>> 1;
            case "base64":
              return V(t).length;
            default:
              if (i) return n ? -1 : K(t).length;
              e = ("" + e).toLowerCase(), i = !0
          }
        }

        function m(t, e, r) {
          let n = !1;
          if ((void 0 === e || 0 > e) && (e = 0), e > this.length || ((void 0 === r || r > this.length) && (r = this.length), 0 >= r) || (e >>>= 0) >= (r >>>= 0)) return "";
          for (t || (t = "utf8");;) switch (t) {
            case "hex":
              return B(this, e, r);
            case "utf8":
            case "utf-8":
              return x(this, e, r);
            case "ascii":
              return S(this, e, r);
            case "latin1":
            case "binary":
              return O(this, e, r);
            case "base64":
              return k(this, e, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return W(this, e, r);
            default:
              if (n) throw new TypeError("Unknown encoding: " + t);
              t = (t + "").toLowerCase(), n = !0
          }
        }

        function y(t, e, r) {
          const n = t[e];
          t[e] = t[r], t[r] = n
        }

        function g(t, e, r, n, i) {
          if (0 === t.length) return -1;
          if ("string" == typeof r ? (n = r, r = 0) : r > 2147483647 ? r = 2147483647 : -2147483648 > r && (r = -2147483648), J(r = +r) && (r = i ? 0 : t.length - 1), 0 > r && (r = t.length + r), r < t.length) {
            if (0 > r) {
              if (!i) return -1;
              r = 0
            }
          } else {
            if (i) return -1;
            r = t.length - 1
          }
          if ("string" == typeof e && (e = u.from(e, n)), u.isBuffer(e)) return 0 === e.length ? -1 : v(t, e, r, n, i);
          if ("number" == typeof e) return e &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i ? Uint8Array.prototype.indexOf.call(t, e, r) : Uint8Array.prototype.lastIndexOf.call(t, e, r) : v(t, [e], r, n, i);
          throw new TypeError("val must be string, number or Buffer")
        }

        function v(t, e, r, n, i) {
          let o, s = 1,
            a = t.length,
            u = e.length;
          if (void 0 !== n && ("ucs2" === (n = (n + "").toLowerCase()) || "ucs-2" === n || "utf16le" === n || "utf-16le" === n)) {
            if (2 > t.length || 2 > e.length) return -1;
            s = 2, a /= 2, u /= 2, r /= 2
          }

          function c(t, e) {
            return 1 === s ? t[e] : t.readUInt16BE(e * s)
          }
          if (i) {
            let n = -1;
            for (o = r; a > o; o++)
              if (c(t, o) === c(e, -1 === n ? 0 : o - n)) {
                if (-1 === n && (n = o), o - n + 1 === u) return n * s
              } else - 1 !== n && (o -= o - n), n = -1
          } else
            for (r + u > a && (r = a - u), o = r; o >= 0; o--) {
              let r = !0;
              for (let n = 0; u > n; n++)
                if (c(t, o + n) !== c(e, n)) {
                  r = !1;
                  break
                } if (r) return o
            }
          return -1
        }

        function w(t, e, r, n) {
          r = +r || 0;
          const i = t.length - r;
          n ? (n = +n) > i && (n = i) : n = i;
          const o = e.length;
          let s;
          for (n > o / 2 && (n = o / 2), s = 0; n > s; ++s) {
            const n = parseInt(e.substr(2 * s, 2), 16);
            if (J(n)) return s;
            t[r + s] = n
          }
          return s
        }

        function A(t, e, r, n) {
          return Z(K(e, t.length - r), t, r, n)
        }

        function T(t, e, r, n) {
          return Z(function(t) {
            const e = [];
            for (let r = 0; r < t.length; ++r) e.push(255 & t.charCodeAt(r));
            return e
          }(e), t, r, n)
        }

        function E(t, e, r, n) {
          return Z(V(e), t, r, n)
        }

        function P(t, e, r, n) {
          return Z(function(t, e) {
            let r, n, i;
            const o = [];
            for (let s = 0; s < t.length && (e -= 2) >= 0; ++s) r = t.charCodeAt(s), n = r >> 8, i = r % 256, o.push(i), o.push(n);
            return o
          }(e, t.length - r), t, r, n)
        }

        function k(t, e, r) {
          return 0 === e && r === t.length ? n.fromByteArray(t) : n.fromByteArray(t.slice(e, r))
        }

        function x(t, e, r) {
          r = Math.min(t.length, r);
          const n = [];
          let i = e;
          for (; r > i;) {
            const e = t[i];
            let o = null,
              s = e > 239 ? 4 : e > 223 ? 3 : e > 191 ? 2 : 1;
            if (r >= i + s) {
              let r, n, a, u;
              switch (s) {
                case 1:
                  128 > e && (o = e);
                  break;
                case 2:
                  r = t[i + 1], 128 == (192 & r) && (u = (31 & e) << 6 | 63 & r, u > 127 && (o = u));
                  break;
                case 3:
                  r = t[i + 1], n = t[i + 2], 128 == (192 & r) && 128 == (192 & n) && (u = (15 & e) << 12 | (63 & r) << 6 | 63 & n, u > 2047 && (55296 > u || u > 57343) && (o = u));
                  break;
                case 4:
                  r = t[i + 1], n = t[i + 2], a = t[i + 3], 128 == (192 & r) && 128 == (192 & n) && 128 == (192 & a) && (u = (15 & e) << 18 | (63 & r) << 12 | (63 & n) << 6 | 63 & a, u > 65535 && 1114112 > u && (o = u))
              }
            }
            null === o ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | 1023 & o), n.push(o), i += s
          }
          return function(t) {
            const e = t.length;
            if (I >= e) return String.fromCharCode.apply(String, t);
            let r = "",
              n = 0;
            for (; e > n;) r += String.fromCharCode.apply(String, t.slice(n, n += I));
            return r
          }(n)
        }
        e.kMaxLength = s, u.TYPED_ARRAY_SUPPORT = function() {
          try {
            const t = new Uint8Array(1),
              e = {
                foo: function() {
                  return 42
                }
              };
            return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(t, e), 42 === t.foo()
          } catch {
            return !1
          }
        }(), !u.TYPED_ARRAY_SUPPORT && "u" > typeof console && "function" == typeof console.error && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u.prototype, "parent", {
          enumerable: !0,
          get: function() {
            if (u.isBuffer(this)) return this.buffer
          }
        }), Object.defineProperty(u.prototype, "offset", {
          enumerable: !0,
          get: function() {
            if (u.isBuffer(this)) return this.byteOffset
          }
        }), u.poolSize = 8192, u.from = function(t, e, r) {
          return c(t, e, r)
        }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array), u.alloc = function(t, e, r) {
          return function(t, e, r) {
            return f(t), t > 0 && void 0 !== e ? "string" == typeof r ? a(t).fill(e, r) : a(t).fill(e) : a(t)
          }(t, e, r)
        }, u.allocUnsafe = function(t) {
          return l(t)
        }, u.allocUnsafeSlow = function(t) {
          return l(t)
        }, u.isBuffer = function(t) {
          return null != t && !0 === t.br && t !== u.prototype
        }, u.compare = function(t, e) {
          if (q(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)), q(e, Uint8Array) && (e = u.from(e, e.offset, e.byteLength)), !u.isBuffer(t) || !u.isBuffer(e)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (t === e) return 0;
          let r = t.length,
            n = e.length;
          for (let i = 0, o = Math.min(r, n); o > i; ++i)
            if (t[i] !== e[i]) {
              r = t[i], n = e[i];
              break
            } return n > r ? -1 : r > n ? 1 : 0
        }, u.isEncoding = function(t) {
          switch ((t + "").toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return !0;
            default:
              return !1
          }
        }, u.concat = function(t, e) {
          if (!Array.isArray(t)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t.length) return u.alloc(0);
          let r;
          if (void 0 === e)
            for (e = 0, r = 0; r < t.length; ++r) e += t[r].length;
          const n = u.allocUnsafe(e);
          let i = 0;
          for (r = 0; r < t.length; ++r) {
            let e = t[r];
            if (q(e, Uint8Array)) i + e.length > n.length ? (u.isBuffer(e) || (e = u.from(e)), e.copy(n, i)) : Uint8Array.prototype.set.call(n, e, i);
            else {
              if (!u.isBuffer(e)) throw new TypeError('"list" argument must be an Array of Buffers');
              e.copy(n, i)
            }
            i += e.length
          }
          return n
        }, u.byteLength = b, u.prototype.br = !0, u.prototype.swap16 = function() {
          const t = this.length;
          if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let e = 0; t > e; e += 2) y(this, e, e + 1);
          return this
        }, u.prototype.swap32 = function() {
          const t = this.length;
          if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let e = 0; t > e; e += 4) y(this, e, e + 3), y(this, e + 1, e + 2);
          return this
        }, u.prototype.swap64 = function() {
          const t = this.length;
          if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let e = 0; t > e; e += 8) y(this, e, e + 7), y(this, e + 1, e + 6), y(this, e + 2, e + 5), y(this, e + 3, e + 4);
          return this
        }, u.prototype.toString = function() {
          const t = this.length;
          return 0 === t ? "" : 0 === arguments.length ? x(this, 0, t) : m.apply(this, arguments)
        }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(t) {
          if (!u.isBuffer(t)) throw new TypeError("Argument must be a Buffer");
          return this === t || 0 === u.compare(this, t)
        }, u.prototype.inspect = function() {
          let t = "";
          const r = e.INSPECT_MAX_BYTES;
          return t = this.toString("hex", 0, r).replace(/(.{2})/g, "$1 ").trim(), this.length > r && (t += " ... "), "<Buffer " + t + ">"
        }, o && (u.prototype[o] = u.prototype.inspect), u.prototype.compare = function(t, e, r, n, i) {
          if (q(t, Uint8Array) && (t = u.from(t, t.offset, t.byteLength)), !u.isBuffer(t)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t);
          if (void 0 === e && (e = 0), void 0 === r && (r = t ? t.length : 0), void 0 === n && (n = 0), void 0 === i && (i = this.length), 0 > e || r > t.length || 0 > n || i > this.length) throw new RangeError("out of range index");
          if (n >= i && e >= r) return 0;
          if (n >= i) return -1;
          if (e >= r) return 1;
          if (this === t) return 0;
          let o = (i >>>= 0) - (n >>>= 0),
            s = (r >>>= 0) - (e >>>= 0);
          const a = Math.min(o, s),
            c = this.slice(n, i),
            f = t.slice(e, r);
          for (let t = 0; a > t; ++t)
            if (c[t] !== f[t]) {
              o = c[t], s = f[t];
              break
            } return s > o ? -1 : o > s ? 1 : 0
        }, u.prototype.includes = function(t, e, r) {
          return -1 !== this.indexOf(t, e, r)
        }, u.prototype.indexOf = function(t, e, r) {
          return g(this, t, e, r, !0)
        }, u.prototype.lastIndexOf = function(t, e, r) {
          return g(this, t, e, r, !1)
        }, u.prototype.write = function(t, e, r, n) {
          if (void 0 === e) n = "utf8", r = this.length, e = 0;
          else if (void 0 === r && "string" == typeof e) n = e, r = this.length, e = 0;
          else {
            if (!isFinite(e)) throw Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e >>>= 0, isFinite(r) ? (r >>>= 0, void 0 === n && (n = "utf8")) : (n = r, r = void 0)
          }
          const i = this.length - e;
          if ((void 0 === r || r > i) && (r = i), t.length > 0 && (0 > r || 0 > e) || e > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          n || (n = "utf8");
          let o = !1;
          for (;;) switch (n) {
            case "hex":
              return w(this, t, e, r);
            case "utf8":
            case "utf-8":
              return A(this, t, e, r);
            case "ascii":
            case "latin1":
            case "binary":
              return T(this, t, e, r);
            case "base64":
              return E(this, t, e, r);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return P(this, t, e, r);
            default:
              if (o) throw new TypeError("Unknown encoding: " + n);
              n = ("" + n).toLowerCase(), o = !0
          }
        }, u.prototype.toJSON = function() {
          return {
            type: "Buffer",
            data: [].slice.call(this.mr || this, 0)
          }
        };
        const I = 4096;

        function S(t, e, r) {
          let n = "";
          r = Math.min(t.length, r);
          for (let i = e; r > i; ++i) n += String.fromCharCode(127 & t[i]);
          return n
        }

        function O(t, e, r) {
          let n = "";
          r = Math.min(t.length, r);
          for (let i = e; r > i; ++i) n += String.fromCharCode(t[i]);
          return n
        }

        function B(t, e, r) {
          const n = t.length;
          (!e || 0 > e) && (e = 0), (!r || 0 > r || r > n) && (r = n);
          let i = "";
          for (let n = e; r > n; ++n) i += Y[t[n]];
          return i
        }

        function W(t, e, r) {
          const n = t.slice(e, r);
          let i = "";
          for (let t = 0; t < n.length - 1; t += 2) i += String.fromCharCode(n[t] + 256 * n[t + 1]);
          return i
        }

        function M(t, e, r) {
          if (t % 1 != 0 || 0 > t) throw new RangeError("offset is not uint");
          if (t + e > r) throw new RangeError("Trying to access beyond buffer length")
        }

        function C(t, e, r, n, i, o) {
          if (!u.isBuffer(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (e > i || o > e) throw new RangeError('"value" argument is out of bounds');
          if (r + n > t.length) throw new RangeError("Index out of range")
        }

        function R(t, e, r, n, i) {
          $(e, n, i, t, r, 7);
          let o = +(e & BigInt(4294967295));
          t[r++] = o, o >>= 8, t[r++] = o, o >>= 8, t[r++] = o, o >>= 8, t[r++] = o;
          let s = +(e >> BigInt(32) & BigInt(4294967295));
          return t[r++] = s, s >>= 8, t[r++] = s, s >>= 8, t[r++] = s, s >>= 8, t[r++] = s, r
        }

        function N(t, e, r, n, i) {
          $(e, n, i, t, r, 7);
          let o = +(e & BigInt(4294967295));
          t[r + 7] = o, o >>= 8, t[r + 6] = o, o >>= 8, t[r + 5] = o, o >>= 8, t[r + 4] = o;
          let s = +(e >> BigInt(32) & BigInt(4294967295));
          return t[r + 3] = s, s >>= 8, t[r + 2] = s, s >>= 8, t[r + 1] = s, s >>= 8, t[r] = s, r + 8
        }

        function j(t, e, r, n, i, o) {
          if (r + n > t.length) throw new RangeError("Index out of range");
          if (0 > r) throw new RangeError("Index out of range")
        }

        function _(t, e, r, n, o) {
          return e = +e, r >>>= 0, o || j(t, 0, r, 4), i.write(t, e, r, n, 23, 4), r + 4
        }

        function D(t, e, r, n, o) {
          return e = +e, r >>>= 0, o || j(t, 0, r, 8), i.write(t, e, r, n, 52, 8), r + 8
        }
        u.prototype.slice = function(t, e) {
          const r = this.length;
          0 > (t = ~~t) ? 0 > (t += r) && (t = 0) : t > r && (t = r), 0 > (e = void 0 === e ? r : ~~e) ? 0 > (e += r) && (e = 0) : e > r && (e = r), t > e && (e = t);
          const n = this.subarray(t, e);
          return Object.setPrototypeOf(n, u.prototype), n
        }, u.prototype.readUintLE = u.prototype.readUIntLE = function(t, e, r) {
          t >>>= 0, e >>>= 0, r || M(t, e, this.length);
          let n = this[t],
            i = 1,
            o = 0;
          for (; ++o < e && (i *= 256);) n += this[t + o] * i;
          return n
        }, u.prototype.readUintBE = u.prototype.readUIntBE = function(t, e, r) {
          t >>>= 0, e >>>= 0, r || M(t, e, this.length);
          let n = this[t + --e],
            i = 1;
          for (; e > 0 && (i *= 256);) n += this[t + --e] * i;
          return n
        }, u.prototype.readUint8 = u.prototype.readUInt8 = function(t, e) {
          return t >>>= 0, e || M(t, 1, this.length), this[t]
        }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(t, e) {
          return t >>>= 0, e || M(t, 2, this.length), this[t] | this[t + 1] << 8
        }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(t, e) {
          return t >>>= 0, e || M(t, 2, this.length), this[t] << 8 | this[t + 1]
        }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3]
        }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3])
        }, u.prototype.readBigUInt64LE = Q(function(t) {
          z(t >>>= 0, "offset");
          const e = this[t],
            r = this[t + 7];
          (void 0 === e || void 0 === r) && H(t, this.length - 8);
          const n = e + 256 * this[++t] + 65536 * this[++t] + this[++t] * 2 ** 24,
            i = this[++t] + 256 * this[++t] + 65536 * this[++t] + r * 2 ** 24;
          return BigInt(n) + (BigInt(i) << BigInt(32))
        }), u.prototype.readBigUInt64BE = Q(function(t) {
          z(t >>>= 0, "offset");
          const e = this[t],
            r = this[t + 7];
          (void 0 === e || void 0 === r) && H(t, this.length - 8);
          const n = e * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + this[++t],
            i = this[++t] * 2 ** 24 + 65536 * this[++t] + 256 * this[++t] + r;
          return (BigInt(n) << BigInt(32)) + BigInt(i)
        }), u.prototype.readIntLE = function(t, e, r) {
          t >>>= 0, e >>>= 0, r || M(t, e, this.length);
          let n = this[t],
            i = 1,
            o = 0;
          for (; ++o < e && (i *= 256);) n += this[t + o] * i;
          return i *= 128, n >= i && (n -= Math.pow(2, 8 * e)), n
        }, u.prototype.readIntBE = function(t, e, r) {
          t >>>= 0, e >>>= 0, r || M(t, e, this.length);
          let n = e,
            i = 1,
            o = this[t + --n];
          for (; n > 0 && (i *= 256);) o += this[t + --n] * i;
          return i *= 128, o >= i && (o -= Math.pow(2, 8 * e)), o
        }, u.prototype.readInt8 = function(t, e) {
          return t >>>= 0, e || M(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t]
        }, u.prototype.readInt16LE = function(t, e) {
          t >>>= 0, e || M(t, 2, this.length);
          const r = this[t] | this[t + 1] << 8;
          return 32768 & r ? 4294901760 | r : r
        }, u.prototype.readInt16BE = function(t, e) {
          t >>>= 0, e || M(t, 2, this.length);
          const r = this[t + 1] | this[t] << 8;
          return 32768 & r ? 4294901760 | r : r
        }, u.prototype.readInt32LE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24
        }, u.prototype.readInt32BE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]
        }, u.prototype.readBigInt64LE = Q(function(t) {
          z(t >>>= 0, "offset");
          const e = this[t],
            r = this[t + 7];
          (void 0 === e || void 0 === r) && H(t, this.length - 8);
          const n = this[t + 4] + 256 * this[t + 5] + 65536 * this[t + 6] + (r << 24);
          return (BigInt(n) << BigInt(32)) + BigInt(e + 256 * this[++t] + 65536 * this[++t] + 16777216 * this[++t])
        }), u.prototype.readBigInt64BE = Q(function(t) {
          z(t >>>= 0, "offset");
          const e = this[t],
            r = this[t + 7];
          (void 0 === e || void 0 === r) && H(t, this.length - 8);
          const n = (e << 24) + 65536 * this[++t] + 256 * this[++t] + this[++t];
          return (BigInt(n) << BigInt(32)) + BigInt(16777216 * this[++t] + 65536 * this[++t] + 256 * this[++t] + r)
        }), u.prototype.readFloatLE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), i.read(this, t, !0, 23, 4)
        }, u.prototype.readFloatBE = function(t, e) {
          return t >>>= 0, e || M(t, 4, this.length), i.read(this, t, !1, 23, 4)
        }, u.prototype.readDoubleLE = function(t, e) {
          return t >>>= 0, e || M(t, 8, this.length), i.read(this, t, !0, 52, 8)
        }, u.prototype.readDoubleBE = function(t, e) {
          return t >>>= 0, e || M(t, 8, this.length), i.read(this, t, !1, 52, 8)
        }, u.prototype.writeUintLE = u.prototype.writeUIntLE = function(t, e, r, n) {
          t = +t, e >>>= 0, r >>>= 0, n || C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
          let i = 1,
            o = 0;
          for (this[e] = 255 & t; ++o < r && (i *= 256);) this[e + o] = t / i & 255;
          return e + r
        }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(t, e, r, n) {
          t = +t, e >>>= 0, r >>>= 0, n || C(this, t, e, r, Math.pow(2, 8 * r) - 1, 0);
          let i = r - 1,
            o = 1;
          for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);) this[e + i] = t / o & 255;
          return e + r
        }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 1, 255, 0), this[e] = 255 & t, e + 1
        }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 2, 65535, 0), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2
        }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 2, 65535, 0), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2
        }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 4, 4294967295, 0), this[e + 3] = t >>> 24, this[e + 2] = t >>> 16, this[e + 1] = t >>> 8, this[e] = 255 & t, e + 4
        }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 4, 4294967295, 0), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4
        }, u.prototype.writeBigUInt64LE = Q(function(t, e = 0) {
          return R(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }), u.prototype.writeBigUInt64BE = Q(function(t, e = 0) {
          return N(this, t, e, BigInt(0), BigInt("0xffffffffffffffff"))
        }), u.prototype.writeIntLE = function(t, e, r, n) {
          if (t = +t, e >>>= 0, !n) {
            const n = Math.pow(2, 8 * r - 1);
            C(this, t, e, r, n - 1, -n)
          }
          let i = 0,
            o = 1,
            s = 0;
          for (this[e] = 255 & t; ++i < r && (o *= 256);) 0 > t && 0 === s && 0 !== this[e + i - 1] && (s = 1), this[e + i] = (t / o | 0) - s & 255;
          return e + r
        }, u.prototype.writeIntBE = function(t, e, r, n) {
          if (t = +t, e >>>= 0, !n) {
            const n = Math.pow(2, 8 * r - 1);
            C(this, t, e, r, n - 1, -n)
          }
          let i = r - 1,
            o = 1,
            s = 0;
          for (this[e + i] = 255 & t; --i >= 0 && (o *= 256);) 0 > t && 0 === s && 0 !== this[e + i + 1] && (s = 1), this[e + i] = (t / o | 0) - s & 255;
          return e + r
        }, u.prototype.writeInt8 = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 1, 127, -128), 0 > t && (t = 255 + t + 1), this[e] = 255 & t, e + 1
        }, u.prototype.writeInt16LE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 2, 32767, -32768), this[e] = 255 & t, this[e + 1] = t >>> 8, e + 2
        }, u.prototype.writeInt16BE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 2, 32767, -32768), this[e] = t >>> 8, this[e + 1] = 255 & t, e + 2
        }, u.prototype.writeInt32LE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 4, 2147483647, -2147483648), this[e] = 255 & t, this[e + 1] = t >>> 8, this[e + 2] = t >>> 16, this[e + 3] = t >>> 24, e + 4
        }, u.prototype.writeInt32BE = function(t, e, r) {
          return t = +t, e >>>= 0, r || C(this, t, e, 4, 2147483647, -2147483648), 0 > t && (t = 4294967295 + t + 1), this[e] = t >>> 24, this[e + 1] = t >>> 16, this[e + 2] = t >>> 8, this[e + 3] = 255 & t, e + 4
        }, u.prototype.writeBigInt64LE = Q(function(t, e = 0) {
          return R(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }), u.prototype.writeBigInt64BE = Q(function(t, e = 0) {
          return N(this, t, e, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }), u.prototype.writeFloatLE = function(t, e, r) {
          return _(this, t, e, !0, r)
        }, u.prototype.writeFloatBE = function(t, e, r) {
          return _(this, t, e, !1, r)
        }, u.prototype.writeDoubleLE = function(t, e, r) {
          return D(this, t, e, !0, r)
        }, u.prototype.writeDoubleBE = function(t, e, r) {
          return D(this, t, e, !1, r)
        }, u.prototype.copy = function(t, e, r, n) {
          if (!u.isBuffer(t)) throw new TypeError("argument should be a Buffer");
          if (r || (r = 0), !n && 0 !== n && (n = this.length), e >= t.length && (e = t.length), e || (e = 0), n > 0 && r > n && (n = r), n === r || 0 === t.length || 0 === this.length) return 0;
          if (0 > e) throw new RangeError("targetStart out of bounds");
          if (0 > r || r >= this.length) throw new RangeError("Index out of range");
          if (0 > n) throw new RangeError("sourceEnd out of bounds");
          n > this.length && (n = this.length), t.length - e < n - r && (n = t.length - e + r);
          const i = n - r;
          return this === t && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e, r, n) : Uint8Array.prototype.set.call(t, this.subarray(r, n), e), i
        }, u.prototype.fill = function(t, e, r, n) {
          if ("string" == typeof t) {
            if ("string" == typeof e ? (n = e, e = 0, r = this.length) : "string" == typeof r && (n = r, r = this.length), void 0 !== n && "string" != typeof n) throw new TypeError("encoding must be a string");
            if ("string" == typeof n && !u.isEncoding(n)) throw new TypeError("Unknown encoding: " + n);
            if (1 === t.length) {
              const e = t.charCodeAt(0);
              ("utf8" === n && 128 > e || "latin1" === n) && (t = e)
            }
          } else "number" == typeof t ? t &= 255 : "boolean" == typeof t && (t = +t);
          if (0 > e || this.length < e || this.length < r) throw new RangeError("Out of range index");
          if (e >= r) return this;
          let i;
          if (e >>>= 0, r = void 0 === r ? this.length : r >>> 0, t || (t = 0), "number" == typeof t)
            for (i = e; r > i; ++i) this[i] = t;
          else {
            const o = u.isBuffer(t) ? t : u.from(t, n),
              s = o.length;
            if (0 === s) throw new TypeError('The value "' + t + '" is invalid for argument "value"');
            for (i = 0; r - e > i; ++i) this[i + e] = o[i % s]
          }
          return this
        };
        const U = {};

        function L(t, e, r) {
          U[t] = class extends r {
            constructor() {
              super(), Object.defineProperty(this, "message", {
                value: e.apply(this, arguments),
                writable: !0,
                configurable: !0
              }), this.name = `${this.name} [${t}]`, this.stack, delete this.name
            }
            get code() {
              return t
            }
            set code(t) {
              Object.defineProperty(this, "code", {
                configurable: !0,
                enumerable: !0,
                value: t,
                writable: !0
              })
            }
            toString() {
              return `${this.name} [${t}]: ${this.message}`
            }
          }
        }

        function F(t) {
          let e = "",
            r = t.length;
          const n = "-" === t[0] ? 1 : 0;
          for (; r >= n + 4; r -= 3) e = `_${t.slice(r-3,r)}${e}`;
          return `${t.slice(0,r)}${e}`
        }

        function $(t, e, r, n, i, o) {
          if (t > r || e > t) {
            const n = "bigint" == typeof e ? "n" : "";
            let i;
            throw i = o > 3 ? 0 === e || e === BigInt(0) ? `>= 0${n} and < 2${n} ** ${8*(o+1)}${n}` : `>= -(2${n} ** ${8*(o+1)-1}${n}) and < 2 ** ${8*(o+1)-1}${n}` : `>= ${e}${n} and <= ${r}${n}`, new U.ERR_OUT_OF_RANGE("value", i, t)
          }! function(t, e, r) {
            z(e, "offset"), (void 0 === t[e] || void 0 === t[e + r]) && H(e, t.length - (r + 1))
          }(n, i, o)
        }

        function z(t, e) {
          if ("number" != typeof t) throw new U.ERR_INVALID_ARG_TYPE(e, "number", t)
        }

        function H(t, e, r) {
          throw Math.floor(t) !== t ? (z(t, r), new U.ERR_OUT_OF_RANGE(r || "offset", "an integer", t)) : 0 > e ? new U.ERR_BUFFER_OUT_OF_BOUNDS : new U.ERR_OUT_OF_RANGE(r || "offset", `>= ${r?1:0} and <= ${e}`, t)
        }
        L("ERR_BUFFER_OUT_OF_BOUNDS", function(t) {
          return t ? t + " is outside of buffer bounds" : "Attempt to access memory outside buffer bounds"
        }, RangeError), L("ERR_INVALID_ARG_TYPE", function(t, e) {
          return `The "${t}" argument must be of type number. Received type ${typeof e}`
        }, TypeError), L("ERR_OUT_OF_RANGE", function(t, e, r) {
          let n = `The value of "${t}" is out of range.`,
            i = r;
          return Number.isInteger(r) && Math.abs(r) > 4294967296 ? i = F(r + "") : "bigint" == typeof r && (i = r + "", (r > BigInt(2) ** BigInt(32) || r < -(BigInt(2) ** BigInt(32))) && (i = F(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n
        }, RangeError);
        const G = /[^+/0-9A-Za-z-_]/g;

        function K(t, e) {
          let r;
          e = e || 1 / 0;
          const n = t.length;
          let i = null;
          const o = [];
          for (let s = 0; n > s; ++s) {
            if (r = t.charCodeAt(s), r > 55295 && 57344 > r) {
              if (!i) {
                if (r > 56319) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue
                }
                if (s + 1 === n) {
                  (e -= 3) > -1 && o.push(239, 191, 189);
                  continue
                }
                i = r;
                continue
              }
              if (56320 > r) {
                (e -= 3) > -1 && o.push(239, 191, 189), i = r;
                continue
              }
              r = 65536 + (i - 55296 << 10 | r - 56320)
            } else i && (e -= 3) > -1 && o.push(239, 191, 189);
            if (i = null, 128 > r) {
              if (0 > (e -= 1)) break;
              o.push(r)
            } else if (2048 > r) {
              if (0 > (e -= 2)) break;
              o.push(r >> 6 | 192, 63 & r | 128)
            } else if (65536 > r) {
              if (0 > (e -= 3)) break;
              o.push(r >> 12 | 224, r >> 6 & 63 | 128, 63 & r | 128)
            } else {
              if (r >= 1114112) throw Error("Invalid code point");
              if (0 > (e -= 4)) break;
              o.push(r >> 18 | 240, r >> 12 & 63 | 128, r >> 6 & 63 | 128, 63 & r | 128)
            }
          }
          return o
        }

        function V(t) {
          return n.toByteArray(function(t) {
            if (2 > (t = (t = t.split("=")[0]).trim().replace(G, "")).length) return "";
            for (; t.length % 4 != 0;) t += "=";
            return t
          }(t))
        }

        function Z(t, e, r, n) {
          let i;
          for (i = 0; n > i && i + r < e.length && i < t.length; ++i) e[i + r] = t[i];
          return i
        }

        function q(t, e) {
          return t instanceof e || null != t && null != t.constructor && null != t.constructor.name && t.constructor.name === e.name
        }

        function J(t) {
          return t != t
        }
        const Y = function() {
          const t = "0123456789abcdef",
            e = Array(256);
          for (let r = 0; 16 > r; ++r) {
            const n = 16 * r;
            for (let i = 0; 16 > i; ++i) e[n + i] = t[r] + t[i]
          }
          return e
        }();

        function Q(t) {
          return typeof BigInt > "u" ? X : t
        }

        function X() {
          throw Error("BigInt not supported")
        }
      },
      48648: t => {
        "use strict";
        t.exports = "u" > typeof Reflect && Reflect.getPrototypeOf || null
      },
      49026: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")(),
          s = r(38108);
        i.object.extend(proto, s), i.exportSymbol("TronWebProto.AccountBalanceRequest", null, o), i.exportSymbol("TronWebProto.AccountBalanceResponse", null, o), i.exportSymbol("TronWebProto.AccountIdentifier", null, o), i.exportSymbol("TronWebProto.AccountTrace", null, o), i.exportSymbol("TronWebProto.BlockBalanceTrace", null, o), i.exportSymbol("TronWebProto.BlockBalanceTrace.BlockIdentifier", null, o), i.exportSymbol("TronWebProto.CancelAllUnfreezeV2Contract", null, o), i.exportSymbol("TronWebProto.DelegateResourceContract", null, o), i.exportSymbol("TronWebProto.FreezeBalanceContract", null, o), i.exportSymbol("TronWebProto.FreezeBalanceV2Contract", null, o), i.exportSymbol("TronWebProto.TransactionBalanceTrace", null, o), i.exportSymbol("TronWebProto.TransactionBalanceTrace.Operation", null, o), i.exportSymbol("TronWebProto.TransferContract", null, o), i.exportSymbol("TronWebProto.UnDelegateResourceContract", null, o), i.exportSymbol("TronWebProto.UnfreezeBalanceContract", null, o), i.exportSymbol("TronWebProto.UnfreezeBalanceV2Contract", null, o), i.exportSymbol("TronWebProto.WithdrawBalanceContract", null, o), i.exportSymbol("TronWebProto.WithdrawExpireUnfreezeContract", null, o), TronWebProto.FreezeBalanceContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.FreezeBalanceContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceContract.displayName = "TronWebProto.FreezeBalanceContract"), TronWebProto.UnfreezeBalanceContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UnfreezeBalanceContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceContract.displayName = "TronWebProto.UnfreezeBalanceContract"), TronWebProto.WithdrawBalanceContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.WithdrawBalanceContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.WithdrawBalanceContract.displayName = "TronWebProto.WithdrawBalanceContract"), TronWebProto.TransferContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.TransferContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.TransferContract.displayName = "TronWebProto.TransferContract"), TronWebProto.TransactionBalanceTrace = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.TransactionBalanceTrace.repeatedFields_, null)
        }, i.inherits(TronWebProto.TransactionBalanceTrace, n.Message), i.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.displayName = "TronWebProto.TransactionBalanceTrace"), TronWebProto.TransactionBalanceTrace.Operation = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.TransactionBalanceTrace.Operation, n.Message), i.DEBUG && !COMPILED && (TronWebProto.TransactionBalanceTrace.Operation.displayName = "TronWebProto.TransactionBalanceTrace.Operation"), TronWebProto.BlockBalanceTrace = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.BlockBalanceTrace.repeatedFields_, null)
        }, i.inherits(TronWebProto.BlockBalanceTrace, n.Message), i.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.displayName = "TronWebProto.BlockBalanceTrace"), TronWebProto.BlockBalanceTrace.BlockIdentifier = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.BlockBalanceTrace.BlockIdentifier, n.Message), i.DEBUG && !COMPILED && (TronWebProto.BlockBalanceTrace.BlockIdentifier.displayName = "TronWebProto.BlockBalanceTrace.BlockIdentifier"), TronWebProto.AccountTrace = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountTrace, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountTrace.displayName = "TronWebProto.AccountTrace"), TronWebProto.AccountIdentifier = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountIdentifier, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountIdentifier.displayName = "TronWebProto.AccountIdentifier"), TronWebProto.AccountBalanceRequest = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountBalanceRequest, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountBalanceRequest.displayName = "TronWebProto.AccountBalanceRequest"), TronWebProto.AccountBalanceResponse = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountBalanceResponse, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountBalanceResponse.displayName = "TronWebProto.AccountBalanceResponse"), TronWebProto.FreezeBalanceV2Contract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.FreezeBalanceV2Contract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.FreezeBalanceV2Contract.displayName = "TronWebProto.FreezeBalanceV2Contract"), TronWebProto.UnfreezeBalanceV2Contract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UnfreezeBalanceV2Contract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UnfreezeBalanceV2Contract.displayName = "TronWebProto.UnfreezeBalanceV2Contract"), TronWebProto.WithdrawExpireUnfreezeContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.WithdrawExpireUnfreezeContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.WithdrawExpireUnfreezeContract.displayName = "TronWebProto.WithdrawExpireUnfreezeContract"), TronWebProto.DelegateResourceContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.DelegateResourceContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.DelegateResourceContract.displayName = "TronWebProto.DelegateResourceContract"), TronWebProto.UnDelegateResourceContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UnDelegateResourceContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UnDelegateResourceContract.displayName = "TronWebProto.UnDelegateResourceContract"), TronWebProto.CancelAllUnfreezeV2Contract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.CancelAllUnfreezeV2Contract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.CancelAllUnfreezeV2Contract.displayName = "TronWebProto.CancelAllUnfreezeV2Contract"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceContract.prototype.toObject = function(t) {
          return TronWebProto.FreezeBalanceContract.toObject(t, this)
        }, TronWebProto.FreezeBalanceContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            frozenBalance: n.Message.getFieldWithDefault(e, 2, 0),
            frozenDuration: n.Message.getFieldWithDefault(e, 3, 0),
            resource: n.Message.getFieldWithDefault(e, 10, 0),
            receiverAddress: e.getReceiverAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.FreezeBalanceContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.FreezeBalanceContract;
          return TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.FreezeBalanceContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setFrozenBalance(r);
              break;
            case 3:
              r = e.readInt64(), t.setFrozenDuration(r);
              break;
            case 10:
              r = e.readEnum(), t.setResource(r);
              break;
            case 15:
              r = e.readBytes(), t.setReceiverAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.FreezeBalanceContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.FreezeBalanceContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.FreezeBalanceContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getFrozenBalance()) && e.writeInt64(2, r), 0 !== (r = t.getFrozenDuration()) && e.writeInt64(3, r), 0 !== (r = t.getResource()) && e.writeEnum(10, r), (r = t.getReceiverAddress_asU8()).length > 0 && e.writeBytes(15, r)
        }, TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.FreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.FreezeBalanceContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.FreezeBalanceContract.prototype.getFrozenBalance = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.FreezeBalanceContract.prototype.setFrozenBalance = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.FreezeBalanceContract.prototype.getFrozenDuration = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.FreezeBalanceContract.prototype.setFrozenDuration = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.FreezeBalanceContract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 10, 0)
        }, TronWebProto.FreezeBalanceContract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 10, t)
        }, TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress = function() {
          return n.Message.getFieldWithDefault(this, 15, "")
        }, TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getReceiverAddress())
        }, TronWebProto.FreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getReceiverAddress())
        }, TronWebProto.FreezeBalanceContract.prototype.setReceiverAddress = function(t) {
          return n.Message.setProto3BytesField(this, 15, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceContract.prototype.toObject = function(t) {
          return TronWebProto.UnfreezeBalanceContract.toObject(t, this)
        }, TronWebProto.UnfreezeBalanceContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            resource: n.Message.getFieldWithDefault(e, 10, 0),
            receiverAddress: e.getReceiverAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UnfreezeBalanceContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UnfreezeBalanceContract;
          return TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UnfreezeBalanceContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 10:
              r = e.readEnum(), t.setResource(r);
              break;
            case 15:
              r = e.readBytes(), t.setReceiverAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UnfreezeBalanceContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UnfreezeBalanceContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getResource()) && e.writeEnum(10, r), (r = t.getReceiverAddress_asU8()).length > 0 && e.writeBytes(15, r)
        }, TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UnfreezeBalanceContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UnfreezeBalanceContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UnfreezeBalanceContract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 10, 0)
        }, TronWebProto.UnfreezeBalanceContract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 10, t)
        }, TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress = function() {
          return n.Message.getFieldWithDefault(this, 15, "")
        }, TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getReceiverAddress())
        }, TronWebProto.UnfreezeBalanceContract.prototype.getReceiverAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getReceiverAddress())
        }, TronWebProto.UnfreezeBalanceContract.prototype.setReceiverAddress = function(t) {
          return n.Message.setProto3BytesField(this, 15, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawBalanceContract.prototype.toObject = function(t) {
          return TronWebProto.WithdrawBalanceContract.toObject(t, this)
        }, TronWebProto.WithdrawBalanceContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.WithdrawBalanceContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.WithdrawBalanceContract;
          return TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.WithdrawBalanceContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = e.readBytes();
              t.setOwnerAddress(r)
            } else e.skipField();
          return t
        }, TronWebProto.WithdrawBalanceContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.WithdrawBalanceContract.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r)
        }, TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.WithdrawBalanceContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.WithdrawBalanceContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferContract.prototype.toObject = function(t) {
          return TronWebProto.TransferContract.toObject(t, this)
        }, TronWebProto.TransferContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            toAddress: e.getToAddress_asB64(),
            amount: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.TransferContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.TransferContract;
          return TronWebProto.TransferContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.TransferContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setToAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setAmount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.TransferContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.TransferContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.TransferContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getToAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getAmount()) && e.writeInt64(3, r)
        }, TronWebProto.TransferContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.TransferContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.TransferContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.TransferContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.TransferContract.prototype.getToAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.TransferContract.prototype.getToAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getToAddress())
        }, TronWebProto.TransferContract.prototype.getToAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getToAddress())
        }, TronWebProto.TransferContract.prototype.setToAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.TransferContract.prototype.getAmount = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.TransferContract.prototype.setAmount = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.TransactionBalanceTrace.repeatedFields_ = [2], n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.prototype.toObject = function(t) {
          return TronWebProto.TransactionBalanceTrace.toObject(t, this)
        }, TronWebProto.TransactionBalanceTrace.toObject = function(t, e) {
          var r = {
            transactionIdentifier: e.getTransactionIdentifier_asB64(),
            operationList: n.Message.toObjectList(e.getOperationList(), TronWebProto.TransactionBalanceTrace.Operation.toObject, t),
            type: n.Message.getFieldWithDefault(e, 3, ""),
            status: n.Message.getFieldWithDefault(e, 4, "")
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.TransactionBalanceTrace.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.TransactionBalanceTrace;
          return TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader(r, e)
        }, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setTransactionIdentifier(r);
              break;
            case 2:
              r = new TronWebProto.TransactionBalanceTrace.Operation, e.readMessage(r, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader), t.addOperation(r);
              break;
            case 3:
              r = e.readString(), t.setType(r);
              break;
            case 4:
              r = e.readString(), t.setStatus(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.TransactionBalanceTrace.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getTransactionIdentifier_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getOperationList()).length > 0 && e.writeRepeatedMessage(2, r, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter), (r = t.getType()).length > 0 && e.writeString(3, r), (r = t.getStatus()).length > 0 && e.writeString(4, r)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransactionBalanceTrace.Operation.prototype.toObject = function(t) {
          return TronWebProto.TransactionBalanceTrace.Operation.toObject(t, this)
        }, TronWebProto.TransactionBalanceTrace.Operation.toObject = function(t, e) {
          var r = {
            operationIdentifier: n.Message.getFieldWithDefault(e, 1, 0),
            address: e.getAddress_asB64(),
            amount: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.TransactionBalanceTrace.Operation.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.TransactionBalanceTrace.Operation;
          return TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader(r, e)
        }, TronWebProto.TransactionBalanceTrace.Operation.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setOperationIdentifier(r);
              break;
            case 2:
              r = e.readBytes(), t.setAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setAmount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.TransactionBalanceTrace.Operation.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getOperationIdentifier()) && e.writeInt64(1, r), (r = t.getAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getAmount()) && e.writeInt64(3, r)
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.getOperationIdentifier = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.setOperationIdentifier = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.getAmount = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.TransactionBalanceTrace.Operation.prototype.setAmount = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asB64 = function() {
          return n.Message.bytesAsB64(this.getTransactionIdentifier())
        }, TronWebProto.TransactionBalanceTrace.prototype.getTransactionIdentifier_asU8 = function() {
          return n.Message.bytesAsU8(this.getTransactionIdentifier())
        }, TronWebProto.TransactionBalanceTrace.prototype.setTransactionIdentifier = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.TransactionBalanceTrace.prototype.getOperationList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace.Operation, 2)
        }, TronWebProto.TransactionBalanceTrace.prototype.setOperationList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 2, t)
        }, TronWebProto.TransactionBalanceTrace.prototype.addOperation = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 2, t, TronWebProto.TransactionBalanceTrace.Operation, e)
        }, TronWebProto.TransactionBalanceTrace.prototype.clearOperationList = function() {
          return this.setOperationList([])
        }, TronWebProto.TransactionBalanceTrace.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.TransactionBalanceTrace.prototype.setType = function(t) {
          return n.Message.setProto3StringField(this, 3, t)
        }, TronWebProto.TransactionBalanceTrace.prototype.getStatus = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.TransactionBalanceTrace.prototype.setStatus = function(t) {
          return n.Message.setProto3StringField(this, 4, t)
        }, TronWebProto.BlockBalanceTrace.repeatedFields_ = [3], n.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.prototype.toObject = function(t) {
          return TronWebProto.BlockBalanceTrace.toObject(t, this)
        }, TronWebProto.BlockBalanceTrace.toObject = function(t, e) {
          var r, i = {
            blockIdentifier: (r = e.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(t, r),
            timestamp: n.Message.getFieldWithDefault(e, 2, 0),
            transactionBalanceTraceList: n.Message.toObjectList(e.getTransactionBalanceTraceList(), TronWebProto.TransactionBalanceTrace.toObject, t)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.BlockBalanceTrace.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.BlockBalanceTrace;
          return TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader(r, e)
        }, TronWebProto.BlockBalanceTrace.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
              e.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader), t.setBlockIdentifier(r);
              break;
            case 2:
              r = e.readInt64(), t.setTimestamp(r);
              break;
            case 3:
              r = new TronWebProto.TransactionBalanceTrace, e.readMessage(r, TronWebProto.TransactionBalanceTrace.deserializeBinaryFromReader), t.addTransactionBalanceTrace(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.BlockBalanceTrace.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.BlockBalanceTrace.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.BlockBalanceTrace.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          null != (r = t.getBlockIdentifier()) && e.writeMessage(1, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter), 0 !== (r = t.getTimestamp()) && e.writeInt64(2, r), (r = t.getTransactionBalanceTraceList()).length > 0 && e.writeRepeatedMessage(3, r, TronWebProto.TransactionBalanceTrace.serializeBinaryToWriter)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.toObject = function(t) {
          return TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(t, this)
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject = function(t, e) {
          var r = {
            hash: e.getHash_asB64(),
            number: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.BlockBalanceTrace.BlockIdentifier;
          return TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader(r, e)
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setHash(r);
              break;
            case 2:
              r = e.readInt64(), t.setNumber(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getHash_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getNumber()) && e.writeInt64(2, r)
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asB64 = function() {
          return n.Message.bytesAsB64(this.getHash())
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getHash_asU8 = function() {
          return n.Message.bytesAsU8(this.getHash())
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setHash = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.getNumber = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.BlockBalanceTrace.BlockIdentifier.prototype.setNumber = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.BlockBalanceTrace.prototype.getBlockIdentifier = function() {
          return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 1)
        }, TronWebProto.BlockBalanceTrace.prototype.setBlockIdentifier = function(t) {
          return n.Message.setWrapperField(this, 1, t)
        }, TronWebProto.BlockBalanceTrace.prototype.clearBlockIdentifier = function() {
          return this.setBlockIdentifier(void 0)
        }, TronWebProto.BlockBalanceTrace.prototype.hasBlockIdentifier = function() {
          return null != n.Message.getField(this, 1)
        }, TronWebProto.BlockBalanceTrace.prototype.getTimestamp = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.BlockBalanceTrace.prototype.setTimestamp = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.BlockBalanceTrace.prototype.getTransactionBalanceTraceList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.TransactionBalanceTrace, 3)
        }, TronWebProto.BlockBalanceTrace.prototype.setTransactionBalanceTraceList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 3, t)
        }, TronWebProto.BlockBalanceTrace.prototype.addTransactionBalanceTrace = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 3, t, TronWebProto.TransactionBalanceTrace, e)
        }, TronWebProto.BlockBalanceTrace.prototype.clearTransactionBalanceTraceList = function() {
          return this.setTransactionBalanceTraceList([])
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountTrace.prototype.toObject = function(t) {
          return TronWebProto.AccountTrace.toObject(t, this)
        }, TronWebProto.AccountTrace.toObject = function(t, e) {
          var r = {
            balance: n.Message.getFieldWithDefault(e, 1, 0),
            placeholder: n.Message.getFieldWithDefault(e, 99, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AccountTrace.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountTrace;
          return TronWebProto.AccountTrace.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountTrace.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setBalance(r);
              break;
            case 99:
              r = e.readInt64(), t.setPlaceholder(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountTrace.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountTrace.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountTrace.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getBalance()) && e.writeInt64(1, r), 0 !== (r = t.getPlaceholder()) && e.writeInt64(99, r)
        }, TronWebProto.AccountTrace.prototype.getBalance = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.AccountTrace.prototype.setBalance = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.AccountTrace.prototype.getPlaceholder = function() {
          return n.Message.getFieldWithDefault(this, 99, 0)
        }, TronWebProto.AccountTrace.prototype.setPlaceholder = function(t) {
          return n.Message.setProto3IntField(this, 99, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountIdentifier.prototype.toObject = function(t) {
          return TronWebProto.AccountIdentifier.toObject(t, this)
        }, TronWebProto.AccountIdentifier.toObject = function(t, e) {
          var r = {
            address: e.getAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AccountIdentifier.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountIdentifier;
          return TronWebProto.AccountIdentifier.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountIdentifier.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = e.readBytes();
              t.setAddress(r)
            } else e.skipField();
          return t
        }, TronWebProto.AccountIdentifier.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountIdentifier.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountIdentifier.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getAddress_asU8()).length > 0 && e.writeBytes(1, r)
        }, TronWebProto.AccountIdentifier.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AccountIdentifier.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.AccountIdentifier.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.AccountIdentifier.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceRequest.prototype.toObject = function(t) {
          return TronWebProto.AccountBalanceRequest.toObject(t, this)
        }, TronWebProto.AccountBalanceRequest.toObject = function(t, e) {
          var r, n = {
            accountIdentifier: (r = e.getAccountIdentifier()) && TronWebProto.AccountIdentifier.toObject(t, r),
            blockIdentifier: (r = e.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(t, r)
          };
          return t && (n.$jspbMessageInstance = e), n
        }), TronWebProto.AccountBalanceRequest.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountBalanceRequest;
          return TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountBalanceRequest.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = new TronWebProto.AccountIdentifier;
              e.readMessage(r, TronWebProto.AccountIdentifier.deserializeBinaryFromReader), t.setAccountIdentifier(r);
              break;
            case 2:
              r = new TronWebProto.BlockBalanceTrace.BlockIdentifier, e.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader), t.setBlockIdentifier(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountBalanceRequest.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountBalanceRequest.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountBalanceRequest.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          null != (r = t.getAccountIdentifier()) && e.writeMessage(1, r, TronWebProto.AccountIdentifier.serializeBinaryToWriter), null != (r = t.getBlockIdentifier()) && e.writeMessage(2, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
        }, TronWebProto.AccountBalanceRequest.prototype.getAccountIdentifier = function() {
          return n.Message.getWrapperField(this, TronWebProto.AccountIdentifier, 1)
        }, TronWebProto.AccountBalanceRequest.prototype.setAccountIdentifier = function(t) {
          return n.Message.setWrapperField(this, 1, t)
        }, TronWebProto.AccountBalanceRequest.prototype.clearAccountIdentifier = function() {
          return this.setAccountIdentifier(void 0)
        }, TronWebProto.AccountBalanceRequest.prototype.hasAccountIdentifier = function() {
          return null != n.Message.getField(this, 1)
        }, TronWebProto.AccountBalanceRequest.prototype.getBlockIdentifier = function() {
          return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
        }, TronWebProto.AccountBalanceRequest.prototype.setBlockIdentifier = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.AccountBalanceRequest.prototype.clearBlockIdentifier = function() {
          return this.setBlockIdentifier(void 0)
        }, TronWebProto.AccountBalanceRequest.prototype.hasBlockIdentifier = function() {
          return null != n.Message.getField(this, 2)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountBalanceResponse.prototype.toObject = function(t) {
          return TronWebProto.AccountBalanceResponse.toObject(t, this)
        }, TronWebProto.AccountBalanceResponse.toObject = function(t, e) {
          var r, i = {
            balance: n.Message.getFieldWithDefault(e, 1, 0),
            blockIdentifier: (r = e.getBlockIdentifier()) && TronWebProto.BlockBalanceTrace.BlockIdentifier.toObject(t, r)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.AccountBalanceResponse.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountBalanceResponse;
          return TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountBalanceResponse.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setBalance(r);
              break;
            case 2:
              r = new TronWebProto.BlockBalanceTrace.BlockIdentifier, e.readMessage(r, TronWebProto.BlockBalanceTrace.BlockIdentifier.deserializeBinaryFromReader), t.setBlockIdentifier(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountBalanceResponse.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountBalanceResponse.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountBalanceResponse.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getBalance()) && e.writeInt64(1, r), null != (r = t.getBlockIdentifier()) && e.writeMessage(2, r, TronWebProto.BlockBalanceTrace.BlockIdentifier.serializeBinaryToWriter)
        }, TronWebProto.AccountBalanceResponse.prototype.getBalance = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.AccountBalanceResponse.prototype.setBalance = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.AccountBalanceResponse.prototype.getBlockIdentifier = function() {
          return n.Message.getWrapperField(this, TronWebProto.BlockBalanceTrace.BlockIdentifier, 2)
        }, TronWebProto.AccountBalanceResponse.prototype.setBlockIdentifier = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.AccountBalanceResponse.prototype.clearBlockIdentifier = function() {
          return this.setBlockIdentifier(void 0)
        }, TronWebProto.AccountBalanceResponse.prototype.hasBlockIdentifier = function() {
          return null != n.Message.getField(this, 2)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.FreezeBalanceV2Contract.prototype.toObject = function(t) {
          return TronWebProto.FreezeBalanceV2Contract.toObject(t, this)
        }, TronWebProto.FreezeBalanceV2Contract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            frozenBalance: n.Message.getFieldWithDefault(e, 2, 0),
            resource: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.FreezeBalanceV2Contract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.FreezeBalanceV2Contract;
          return TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.FreezeBalanceV2Contract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setFrozenBalance(r);
              break;
            case 3:
              r = e.readEnum(), t.setResource(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.FreezeBalanceV2Contract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.FreezeBalanceV2Contract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getFrozenBalance()) && e.writeInt64(2, r), 0 !== (r = t.getResource()) && e.writeEnum(3, r)
        }, TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.FreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.FreezeBalanceV2Contract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.FreezeBalanceV2Contract.prototype.getFrozenBalance = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.FreezeBalanceV2Contract.prototype.setFrozenBalance = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.FreezeBalanceV2Contract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.FreezeBalanceV2Contract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeBalanceV2Contract.prototype.toObject = function(t) {
          return TronWebProto.UnfreezeBalanceV2Contract.toObject(t, this)
        }, TronWebProto.UnfreezeBalanceV2Contract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            unfreezeBalance: n.Message.getFieldWithDefault(e, 2, 0),
            resource: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UnfreezeBalanceV2Contract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UnfreezeBalanceV2Contract;
          return TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UnfreezeBalanceV2Contract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setUnfreezeBalance(r);
              break;
            case 3:
              r = e.readEnum(), t.setResource(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UnfreezeBalanceV2Contract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getUnfreezeBalance()) && e.writeInt64(2, r), 0 !== (r = t.getResource()) && e.writeEnum(3, r)
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.getUnfreezeBalance = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.setUnfreezeBalance = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.UnfreezeBalanceV2Contract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.WithdrawExpireUnfreezeContract.prototype.toObject = function(t) {
          return TronWebProto.WithdrawExpireUnfreezeContract.toObject(t, this)
        }, TronWebProto.WithdrawExpireUnfreezeContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.WithdrawExpireUnfreezeContract;
          return TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.WithdrawExpireUnfreezeContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = e.readBytes();
              t.setOwnerAddress(r)
            } else e.skipField();
          return t
        }, TronWebProto.WithdrawExpireUnfreezeContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.WithdrawExpireUnfreezeContract.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r)
        }, TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.WithdrawExpireUnfreezeContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.WithdrawExpireUnfreezeContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegateResourceContract.prototype.toObject = function(t) {
          return TronWebProto.DelegateResourceContract.toObject(t, this)
        }, TronWebProto.DelegateResourceContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            resource: n.Message.getFieldWithDefault(e, 2, 0),
            balance: n.Message.getFieldWithDefault(e, 3, 0),
            receiverAddress: e.getReceiverAddress_asB64(),
            lock: n.Message.getBooleanFieldWithDefault(e, 5, !1),
            lockPeriod: n.Message.getFieldWithDefault(e, 6, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.DelegateResourceContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.DelegateResourceContract;
          return TronWebProto.DelegateResourceContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.DelegateResourceContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readEnum(), t.setResource(r);
              break;
            case 3:
              r = e.readInt64(), t.setBalance(r);
              break;
            case 4:
              r = e.readBytes(), t.setReceiverAddress(r);
              break;
            case 5:
              r = e.readBool(), t.setLock(r);
              break;
            case 6:
              r = e.readInt64(), t.setLockPeriod(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.DelegateResourceContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.DelegateResourceContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.DelegateResourceContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getResource()) && e.writeEnum(2, r), 0 !== (r = t.getBalance()) && e.writeInt64(3, r), (r = t.getReceiverAddress_asU8()).length > 0 && e.writeBytes(4, r), (r = t.getLock()) && e.writeBool(5, r), 0 !== (r = t.getLockPeriod()) && e.writeInt64(6, r)
        }, TronWebProto.DelegateResourceContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.DelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.DelegateResourceContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.DelegateResourceContract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.DelegateResourceContract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 2, t)
        }, TronWebProto.DelegateResourceContract.prototype.getBalance = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.DelegateResourceContract.prototype.setBalance = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.DelegateResourceContract.prototype.getReceiverAddress = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getReceiverAddress())
        }, TronWebProto.DelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getReceiverAddress())
        }, TronWebProto.DelegateResourceContract.prototype.setReceiverAddress = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.DelegateResourceContract.prototype.getLock = function() {
          return n.Message.getBooleanFieldWithDefault(this, 5, !1)
        }, TronWebProto.DelegateResourceContract.prototype.setLock = function(t) {
          return n.Message.setProto3BooleanField(this, 5, t)
        }, TronWebProto.DelegateResourceContract.prototype.getLockPeriod = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.DelegateResourceContract.prototype.setLockPeriod = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnDelegateResourceContract.prototype.toObject = function(t) {
          return TronWebProto.UnDelegateResourceContract.toObject(t, this)
        }, TronWebProto.UnDelegateResourceContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            resource: n.Message.getFieldWithDefault(e, 2, 0),
            balance: n.Message.getFieldWithDefault(e, 3, 0),
            receiverAddress: e.getReceiverAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UnDelegateResourceContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UnDelegateResourceContract;
          return TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UnDelegateResourceContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readEnum(), t.setResource(r);
              break;
            case 3:
              r = e.readInt64(), t.setBalance(r);
              break;
            case 4:
              r = e.readBytes(), t.setReceiverAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UnDelegateResourceContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UnDelegateResourceContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getResource()) && e.writeEnum(2, r), 0 !== (r = t.getBalance()) && e.writeInt64(3, r), (r = t.getReceiverAddress_asU8()).length > 0 && e.writeBytes(4, r)
        }, TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UnDelegateResourceContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UnDelegateResourceContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UnDelegateResourceContract.prototype.getResource = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.UnDelegateResourceContract.prototype.setResource = function(t) {
          return n.Message.setProto3EnumField(this, 2, t)
        }, TronWebProto.UnDelegateResourceContract.prototype.getBalance = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.UnDelegateResourceContract.prototype.setBalance = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getReceiverAddress())
        }, TronWebProto.UnDelegateResourceContract.prototype.getReceiverAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getReceiverAddress())
        }, TronWebProto.UnDelegateResourceContract.prototype.setReceiverAddress = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.CancelAllUnfreezeV2Contract.prototype.toObject = function(t) {
          return TronWebProto.CancelAllUnfreezeV2Contract.toObject(t, this)
        }, TronWebProto.CancelAllUnfreezeV2Contract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.CancelAllUnfreezeV2Contract;
          return TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.CancelAllUnfreezeV2Contract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = e.readBytes();
              t.setOwnerAddress(r)
            } else e.skipField();
          return t
        }, TronWebProto.CancelAllUnfreezeV2Contract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.CancelAllUnfreezeV2Contract.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r)
        }, TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.CancelAllUnfreezeV2Contract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.CancelAllUnfreezeV2Contract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, i.object.extend(e, TronWebProto)
      },
      49032: (t, e, r) => {
        "use strict";
        var n = r(47244),
          i = r(48184),
          o = r(25767),
          s = r(35680);

        function a(t) {
          return t.call.bind(t)
        }
        var u = "u" > typeof BigInt,
          c = "u" > typeof Symbol,
          f = a({}.toString),
          l = a((0).valueOf),
          h = a("".valueOf),
          d = a(Boolean.prototype.valueOf);
        if (u) var p = a(BigInt.prototype.valueOf);
        if (c) var b = a(Symbol.prototype.valueOf);

        function m(t, e) {
          if ("object" != typeof t) return !1;
          try {
            return e(t), !0
          } catch {
            return !1
          }
        }

        function y(t) {
          return "[object Map]" === f(t)
        }

        function g(t) {
          return "[object Set]" === f(t)
        }

        function v(t) {
          return "[object WeakMap]" === f(t)
        }

        function w(t) {
          return "[object WeakSet]" === f(t)
        }

        function A(t) {
          return "[object ArrayBuffer]" === f(t)
        }

        function T(t) {
          return "u" >= typeof ArrayBuffer && (A.working ? A(t) : t instanceof ArrayBuffer)
        }

        function E(t) {
          return "[object DataView]" === f(t)
        }

        function P(t) {
          return "u" >= typeof DataView && (E.working ? E(t) : t instanceof DataView)
        }
        e.isArgumentsObject = n, e.isGeneratorFunction = i, e.isTypedArray = s, e.isPromise = function(t) {
          return "u" > typeof Promise && t instanceof Promise || null !== t && "object" == typeof t && "function" == typeof t.then && "function" == typeof t.catch
        }, e.isArrayBufferView = function(t) {
          return "u" > typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : s(t) || P(t)
        }, e.isUint8Array = function(t) {
          return "Uint8Array" === o(t)
        }, e.isUint8ClampedArray = function(t) {
          return "Uint8ClampedArray" === o(t)
        }, e.isUint16Array = function(t) {
          return "Uint16Array" === o(t)
        }, e.isUint32Array = function(t) {
          return "Uint32Array" === o(t)
        }, e.isInt8Array = function(t) {
          return "Int8Array" === o(t)
        }, e.isInt16Array = function(t) {
          return "Int16Array" === o(t)
        }, e.isInt32Array = function(t) {
          return "Int32Array" === o(t)
        }, e.isFloat32Array = function(t) {
          return "Float32Array" === o(t)
        }, e.isFloat64Array = function(t) {
          return "Float64Array" === o(t)
        }, e.isBigInt64Array = function(t) {
          return "BigInt64Array" === o(t)
        }, e.isBigUint64Array = function(t) {
          return "BigUint64Array" === o(t)
        }, y.working = "u" > typeof Map && y(new Map), e.isMap = function(t) {
          return "u" >= typeof Map && (y.working ? y(t) : t instanceof Map)
        }, g.working = "u" > typeof Set && g(new Set), e.isSet = function(t) {
          return "u" >= typeof Set && (g.working ? g(t) : t instanceof Set)
        }, v.working = "u" > typeof WeakMap && v(new WeakMap), e.isWeakMap = function(t) {
          return "u" >= typeof WeakMap && (v.working ? v(t) : t instanceof WeakMap)
        }, w.working = "u" > typeof WeakSet && w(new WeakSet), e.isWeakSet = function(t) {
          return w(t)
        }, A.working = "u" > typeof ArrayBuffer && A(new ArrayBuffer), e.isArrayBuffer = T, E.working = "u" > typeof ArrayBuffer && "u" > typeof DataView && E(new DataView(new ArrayBuffer(1), 0, 1)), e.isDataView = P;
        var k = "u" > typeof SharedArrayBuffer ? SharedArrayBuffer : void 0;

        function x(t) {
          return "[object SharedArrayBuffer]" === f(t)
        }

        function I(t) {
          return "u" >= typeof k && (typeof x.working > "u" && (x.working = x(new k)), x.working ? x(t) : t instanceof k)
        }

        function S(t) {
          return m(t, l)
        }

        function O(t) {
          return m(t, h)
        }

        function B(t) {
          return m(t, d)
        }

        function W(t) {
          return u && m(t, p)
        }

        function M(t) {
          return c && m(t, b)
        }
        e.isSharedArrayBuffer = I, e.isAsyncFunction = function(t) {
          return "[object AsyncFunction]" === f(t)
        }, e.isMapIterator = function(t) {
          return "[object Map Iterator]" === f(t)
        }, e.isSetIterator = function(t) {
          return "[object Set Iterator]" === f(t)
        }, e.isGeneratorObject = function(t) {
          return "[object Generator]" === f(t)
        }, e.isWebAssemblyCompiledModule = function(t) {
          return "[object WebAssembly.Module]" === f(t)
        }, e.isNumberObject = S, e.isStringObject = O, e.isBooleanObject = B, e.isBigIntObject = W, e.isSymbolObject = M, e.isBoxedPrimitive = function(t) {
          return S(t) || O(t) || B(t) || W(t) || M(t)
        }, e.isAnyArrayBuffer = function(t) {
          return "u" > typeof Uint8Array && (T(t) || I(t))
        }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(t) {
          Object.defineProperty(e, t, {
            enumerable: !1,
            value: function() {
              throw Error(t + " is not supported in userland")
            }
          })
        })
      },
      49092: (t, e, r) => {
        "use strict";
        var n = r(41333);
        t.exports = function() {
          return n() && !!Symbol.toStringTag
        }
      },
      49334: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ParserError = e.getErrorStack = e.getErrorMessage = void 0;
        const n = r(65534);
        e.getErrorMessage = t => "string" == typeof t ? t : t instanceof Error || (0, n.isObject)(t) && (0, n.hasProperty)(t, "message") && "string" == typeof t.message ? t.message : "Unknown error.", e.getErrorStack = t => {
          if (t instanceof Error) return t.stack
        }, e.ParserError = class extends Error {
          constructor(t, r) {
            super(t), this.name = "ParserError";
            const n = (0, e.getErrorStack)(r);
            n && (this.stack = n)
          }
        }
      },
      49534: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        }, e.halfWidth = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /[\u0020-\u007E\uFF61-\uFF9F\uFFA0-\uFFDC\uFFE8-\uFFEE0-9a-zA-Z]/;
        e.halfWidth = o
      },
      49556: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.writeString = e.stringToCell = e.readString = void 0;
        const i = r(65871);

        function o(t) {
          if (t.remainingBits % 8 != 0) throw Error("Invalid string length: " + t.remainingBits);
          if (0 !== t.remainingRefs && 1 !== t.remainingRefs) throw Error("invalid number of refs: " + t.remainingRefs);
          let e;
          return e = 0 === t.remainingBits ? n.alloc(0) : t.loadBuffer(t.remainingBits / 8), 1 === t.remainingRefs && (e = n.concat([e, o(t.loadRef().beginParse())])), e
        }

        function s(t, e) {
          if (t.length > 0) {
            let r = Math.floor(e.availableBits / 8);
            if (t.length > r) {
              let n = t.subarray(0, r),
                o = t.subarray(r);
              e = e.storeBuffer(n);
              let a = (0, i.beginCell)();
              s(o, a), e = e.storeRef(a.endCell())
            } else e = e.storeBuffer(t)
          }
        }
        e.readString = function(t) {
          return o(t).toString()
        }, e.stringToCell = function(t) {
          let e = (0, i.beginCell)();
          return s(n.from(t), e), e.endCell()
        }, e.writeString = function(t, e) {
          s(n.from(t), e)
        }
      },
      49589: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeSplitMergeInfo = e.loadSplitMergeInfo = void 0, e.loadSplitMergeInfo = function(t) {
          return {
            currentShardPrefixLength: t.loadUint(6),
            accountSplitDepth: t.loadUint(6),
            thisAddress: t.loadUintBig(256),
            siblingAddress: t.loadUintBig(256)
          }
        }, e.storeSplitMergeInfo = function(t) {
          return e => {
            e.storeUint(t.currentShardPrefixLength, 6), e.storeUint(t.accountSplitDepth, 6), e.storeUint(t.thisAddress, 256), e.storeUint(t.siblingAddress, 256)
          }
        }
      },
      49604: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.fn = e.getFunction = void 0;
        const n = r(35620),
          i = r(65534),
          o = r(49334),
          s = r(64122),
          a = (0, n.coerce)((0, n.object)({
            address: i.StrictHexStruct,
            selector: i.StrictHexStruct
          }), (0, n.union)([i.StrictHexStruct, (0, n.instance)(Uint8Array)]), t => {
            const e = (0, i.createBytes)(t);
            return (0, i.assert)(24 === e.length, new o.ParserError(`Invalid Solidity function. Expected function to be 24 bytes long, but received ${e.length} bytes.`)), {
              address: (0, i.bytesToHex)(e.subarray(0, 20)),
              selector: (0, i.bytesToHex)(e.subarray(20, 24))
            }
          });
        e.getFunction = t => {
          const e = (0, n.create)(t, a);
          return (0, i.concatBytes)([(0, i.hexToBytes)(e.address), (0, i.hexToBytes)(e.selector)])
        }, e.fn = {
          isDynamic: !1,
          isType: t => "function" === t,
          getByteLength: () => 32,
          encode({
            buffer: t,
            value: r,
            packed: n,
            tight: i
          }) {
            const o = (0, e.getFunction)(r);
            return s.fixedBytes.encode({
              type: "bytes24",
              buffer: t,
              value: o,
              packed: n,
              tight: i
            })
          },
          decode: ({
            value: t
          }) => ({
            address: (0, i.bytesToHex)(t.slice(0, 20)),
            selector: (0, i.bytesToHex)(t.slice(20, 24))
          })
        }
      },
      49919: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")(),
          s = r(99135);
        i.object.extend(proto, s), i.exportSymbol("TronWebProto.AccountCreateContract", null, o), i.exportSymbol("TronWebProto.AccountPermissionUpdateContract", null, o), i.exportSymbol("TronWebProto.AccountUpdateContract", null, o), i.exportSymbol("TronWebProto.SetAccountIdContract", null, o), TronWebProto.AccountCreateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountCreateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountCreateContract.displayName = "TronWebProto.AccountCreateContract"), TronWebProto.AccountUpdateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountUpdateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountUpdateContract.displayName = "TronWebProto.AccountUpdateContract"), TronWebProto.SetAccountIdContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.SetAccountIdContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SetAccountIdContract.displayName = "TronWebProto.SetAccountIdContract"), TronWebProto.AccountPermissionUpdateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.AccountPermissionUpdateContract.repeatedFields_, null)
        }, i.inherits(TronWebProto.AccountPermissionUpdateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountPermissionUpdateContract.displayName = "TronWebProto.AccountPermissionUpdateContract"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountCreateContract.prototype.toObject = function(t) {
          return TronWebProto.AccountCreateContract.toObject(t, this)
        }, TronWebProto.AccountCreateContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            accountAddress: e.getAccountAddress_asB64(),
            type: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AccountCreateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountCreateContract;
          return TronWebProto.AccountCreateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountCreateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setAccountAddress(r);
              break;
            case 3:
              r = e.readEnum(), t.setType(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountCreateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountCreateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountCreateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getAccountAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getType()) && e.writeEnum(3, r)
        }, TronWebProto.AccountCreateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.AccountCreateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.AccountCreateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.AccountCreateContract.prototype.getAccountAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.AccountCreateContract.prototype.getAccountAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAccountAddress())
        }, TronWebProto.AccountCreateContract.prototype.getAccountAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAccountAddress())
        }, TronWebProto.AccountCreateContract.prototype.setAccountAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.AccountCreateContract.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.AccountCreateContract.prototype.setType = function(t) {
          return n.Message.setProto3EnumField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountUpdateContract.prototype.toObject = function(t) {
          return TronWebProto.AccountUpdateContract.toObject(t, this)
        }, TronWebProto.AccountUpdateContract.toObject = function(t, e) {
          var r = {
            accountName: e.getAccountName_asB64(),
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AccountUpdateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountUpdateContract;
          return TronWebProto.AccountUpdateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountUpdateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAccountName(r);
              break;
            case 2:
              r = e.readBytes(), t.setOwnerAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountUpdateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountUpdateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountUpdateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAccountName_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.AccountUpdateContract.prototype.getAccountName = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AccountUpdateContract.prototype.getAccountName_asB64 = function() {
          return n.Message.bytesAsB64(this.getAccountName())
        }, TronWebProto.AccountUpdateContract.prototype.getAccountName_asU8 = function() {
          return n.Message.bytesAsU8(this.getAccountName())
        }, TronWebProto.AccountUpdateContract.prototype.setAccountName = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.AccountUpdateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.AccountUpdateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.AccountUpdateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.SetAccountIdContract.prototype.toObject = function(t) {
          return TronWebProto.SetAccountIdContract.toObject(t, this)
        }, TronWebProto.SetAccountIdContract.toObject = function(t, e) {
          var r = {
            accountId: e.getAccountId_asB64(),
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.SetAccountIdContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SetAccountIdContract;
          return TronWebProto.SetAccountIdContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SetAccountIdContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAccountId(r);
              break;
            case 2:
              r = e.readBytes(), t.setOwnerAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SetAccountIdContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SetAccountIdContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SetAccountIdContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAccountId_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.SetAccountIdContract.prototype.getAccountId = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.SetAccountIdContract.prototype.getAccountId_asB64 = function() {
          return n.Message.bytesAsB64(this.getAccountId())
        }, TronWebProto.SetAccountIdContract.prototype.getAccountId_asU8 = function() {
          return n.Message.bytesAsU8(this.getAccountId())
        }, TronWebProto.SetAccountIdContract.prototype.setAccountId = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.SetAccountIdContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.SetAccountIdContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.SetAccountIdContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.AccountPermissionUpdateContract.repeatedFields_ = [4], n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountPermissionUpdateContract.prototype.toObject = function(t) {
          return TronWebProto.AccountPermissionUpdateContract.toObject(t, this)
        }, TronWebProto.AccountPermissionUpdateContract.toObject = function(t, e) {
          var r, i = {
            ownerAddress: e.getOwnerAddress_asB64(),
            owner: (r = e.getOwner()) && s.Permission.toObject(t, r),
            witness: (r = e.getWitness()) && s.Permission.toObject(t, r),
            activesList: n.Message.toObjectList(e.getActivesList(), s.Permission.toObject, t)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.AccountPermissionUpdateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountPermissionUpdateContract;
          return TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountPermissionUpdateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = new s.Permission, e.readMessage(r, s.Permission.deserializeBinaryFromReader), t.setOwner(r);
              break;
            case 3:
              r = new s.Permission, e.readMessage(r, s.Permission.deserializeBinaryFromReader), t.setWitness(r);
              break;
            case 4:
              r = new s.Permission, e.readMessage(r, s.Permission.deserializeBinaryFromReader), t.addActives(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountPermissionUpdateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountPermissionUpdateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), null != (r = t.getOwner()) && e.writeMessage(2, r, s.Permission.serializeBinaryToWriter), null != (r = t.getWitness()) && e.writeMessage(3, r, s.Permission.serializeBinaryToWriter), (r = t.getActivesList()).length > 0 && e.writeRepeatedMessage(4, r, s.Permission.serializeBinaryToWriter)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.AccountPermissionUpdateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getOwner = function() {
          return n.Message.getWrapperField(this, s.Permission, 2)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.setOwner = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.clearOwner = function() {
          return this.setOwner(void 0)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.hasOwner = function() {
          return null != n.Message.getField(this, 2)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getWitness = function() {
          return n.Message.getWrapperField(this, s.Permission, 3)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.setWitness = function(t) {
          return n.Message.setWrapperField(this, 3, t)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.clearWitness = function() {
          return this.setWitness(void 0)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.hasWitness = function() {
          return null != n.Message.getField(this, 3)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.getActivesList = function() {
          return n.Message.getRepeatedWrapperField(this, s.Permission, 4)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.setActivesList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 4, t)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.addActives = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 4, t, TronWebProto.Permission, e)
        }, TronWebProto.AccountPermissionUpdateContract.prototype.clearActivesList = function() {
          return this.setActivesList([])
        }, i.object.extend(e, TronWebProto)
      },
      49924: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.BitBuilder = void 0;
        const i = r(3512),
          o = r(71629),
          s = r(62386);
        e.BitBuilder = class {
          constructor(t = 1023) {
            this.yr = n.alloc(Math.ceil(t / 8)), this.gr = 0
          }
          get length() {
            return this.gr
          }
          writeBit(t) {
            let e = this.gr;
            if (e > 8 * this.yr.length) throw Error("BitBuilder overflow");
            ("boolean" == typeof t && !0 === t || "number" == typeof t && t > 0) && (this.yr[e / 8 | 0] |= 1 << 7 - e % 8), this.gr++
          }
          writeBits(t) {
            for (let e = 0; e < t.length; e++) this.writeBit(t.at(e))
          }
          writeBuffer(t) {
            if (this.gr % 8 == 0) {
              if (this.gr + 8 * t.length > 8 * this.yr.length) throw Error("BitBuilder overflow");
              t.copy(this.yr, this.gr / 8), this.gr += 8 * t.length
            } else
              for (let e = 0; e < t.length; e++) this.writeUint(t[e], 8)
          }
          writeUint(t, e) {
            if (0 > e || !Number.isSafeInteger(e)) throw Error("invalid bit length. Got " + e);
            const r = BigInt(t);
            if (0 === e) {
              if (0n !== r) throw Error(`value is not zero for ${e} bits. Got ${t}`);
              return
            }
            const n = 1n << BigInt(e);
            if (0 > r || r >= n) throw Error(`bitLength is too small for a value ${t}. Got ${e}`);
            if (this.gr + e > 8 * this.yr.length) throw Error("BitBuilder overflow");
            const i = 8 - this.gr % 8;
            if (i > 0) {
              const t = Math.floor(this.gr / 8);
              if (i > e) {
                const n = +r;
                this.yr[t] |= n << i - e, this.gr += e
              } else {
                const n = +(r >> BigInt(e - i));
                this.yr[t] |= n, this.gr += i
              }
            }
            for (e -= i; e > 0;) 8 > e ? (this.yr[this.gr / 8] = +(r << BigInt(8 - e) & 0xffn), this.gr += e, e = 0) : (this.yr[this.gr / 8] = +(r >> BigInt(e - 8) & 0xffn), this.gr += 8, e -= 8)
          }
          writeInt(t, e) {
            let r = BigInt(t);
            if (0 > e || !Number.isSafeInteger(e)) throw Error("invalid bit length. Got " + e);
            if (0 === e) {
              if (0n !== r) throw Error(`value is not zero for ${e} bits. Got ${t}`);
              return
            }
            if (1 === e) {
              if (-1n !== r && 0n !== r) throw Error(`value is not zero or -1 for ${e} bits. Got ${t}`);
              return void this.writeBit(-1n === t)
            }
            let n = 1n << BigInt(e) - 1n;
            if (-n > r || r >= n) throw Error(`value is out of range for ${e} bits. Got ${t}`);
            0 > r ? (this.writeBit(!0), r = n + r) : this.writeBit(!1), this.writeUint(r, e - 1)
          }
          writeVarUint(t, e) {
            let r = BigInt(t);
            if (0 > e || !Number.isSafeInteger(e)) throw Error("invalid bit length. Got " + e);
            if (0 > r) throw Error("value is negative. Got " + t);
            if (0n === r) return void this.writeUint(0, e);
            const n = Math.ceil(r.toString(2).length / 8),
              i = 8 * n;
            this.writeUint(n, e), this.writeUint(r, i)
          }
          writeVarInt(t, e) {
            let r = BigInt(t);
            if (0 > e || !Number.isSafeInteger(e)) throw Error("invalid bit length. Got " + e);
            if (0n === r) return void this.writeUint(0, e);
            const n = Math.ceil(((r > 0 ? r : -r).toString(2).length + 1) / 8),
              i = 8 * n;
            this.writeUint(n, e), this.writeInt(r, i)
          }
          writeCoins(t) {
            this.writeVarUint(t, 4)
          }
          writeAddress(t) {
            if (null != t) {
              if (i.Address.isAddress(t)) return this.writeUint(2, 2), this.writeUint(0, 1), this.writeInt(t.workChain, 8), void this.writeBuffer(t.hash);
              if (o.ExternalAddress.isAddress(t)) return this.writeUint(1, 2), this.writeUint(t.bits, 9), void this.writeUint(t.value, t.bits);
              throw Error("Invalid address. Got " + t)
            }
            this.writeUint(0, 2)
          }
          build() {
            return new s.BitString(this.yr, 0, this.gr)
          }
          buffer() {
            if (this.gr % 8 != 0) throw Error("BitBuilder buffer is not byte aligned");
            return this.yr.subarray(0, this.gr / 8)
          }
        }
      },
      50230: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.address = e.getAddress = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(76291);
        e.getAddress = t => {
          const e = (0, n.createBytes)(t);
          return (0, n.assert)(20 >= e.length, new i.ParserError(`Invalid address value. Expected address to be 20 bytes long, but received ${e.length} bytes.`)), (0, o.padStart)(e, 20)
        }, e.address = {
          isDynamic: !1,
          isType: t => "address" === t,
          getByteLength: () => 32,
          encode({
            buffer: t,
            value: r,
            packed: i
          }) {
            const s = (0, e.getAddress)(r);
            if (i) return (0, n.concatBytes)([t, s]);
            const a = (0, o.padStart)(s);
            return (0, n.concatBytes)([t, a])
          },
          decode: ({
            value: t
          }) => (0, n.add0x)((0, n.bytesToHex)(t.slice(12, 32)))
        }
      },
      50401: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.refine = e.size = e.pattern = e.nonempty = e.min = e.max = e.empty = void 0;
        const n = r(99067),
          i = r(70639);

        function o(t) {
          return t instanceof Map || t instanceof Set ? t.size : t.length
        }

        function s(t, e, r) {
          return new n.Struct({
            ...t,
            * refiner(n, o) {
              yield* t.refiner(n, o);
              const s = r(n, o),
                a = (0, i.toFailures)(s, o, t, n);
              for (const t of a) yield {
                ...t,
                refinement: e
              }
            }
          })
        }
        e.empty = function(t) {
          return s(t, "empty", e => {
            const r = o(e);
            return 0 === r || `Expected an empty ${t.type} but received one with a size of \`${r}\``
          })
        }, e.max = function(t, e, r = {}) {
          const {
            exclusive: n
          } = r;
          return s(t, "max", r => n ? e > r : e >= r || `Expected a ${t.type} less than ${n?"":"or equal to "}${e} but received \`${r}\``)
        }, e.min = function(t, e, r = {}) {
          const {
            exclusive: n
          } = r;
          return s(t, "min", r => n ? r > e : r >= e || `Expected a ${t.type} greater than ${n?"":"or equal to "}${e} but received \`${r}\``)
        }, e.nonempty = function(t) {
          return s(t, "nonempty", e => o(e) > 0 || `Expected a nonempty ${t.type} but received an empty one`)
        }, e.pattern = function(t, e) {
          return s(t, "pattern", r => e.test(r) || `Expected a ${t.type} matching \`/${e.source}/\` but received "${r}"`)
        }, e.size = function(t, e, r = e) {
          const n = "Expected a " + t.type,
            i = e === r ? `of \`${e}\`` : `between \`${e}\` and \`${r}\``;
          return s(t, "size", t => {
            if ("number" == typeof t || t instanceof Date) return t >= e && r >= t || `${n} ${i} but received \`${t}\``;
            if (t instanceof Map || t instanceof Set) {
              const {
                size: o
              } = t;
              return o >= e && r >= o || `${n} with a size ${i} but received one with a size of \`${o}\``
            }
            const {
              length: o
            } = t;
            return o >= e && r >= o || `${n} with a length ${i} but received one with a length of \`${o}\``
          })
        }, e.refine = s
      },
      50421: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.readUnaryLength = void 0, e.readUnaryLength = function(t) {
          let e = 0;
          for (; t.loadBit();) e++;
          return e
        }
      },
      50496: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.createHex = e.createBytes = e.createBigInt = e.createNumber = void 0;
        const n = r(35620),
          i = r(74772),
          o = r(67295),
          s = r(17773),
          a = (0, n.union)([(0, n.number)(), (0, n.bigint)(), (0, n.string)(), s.StrictHexStruct]),
          u = (0, n.coerce)((0, n.number)(), a, Number),
          c = (0, n.coerce)((0, n.bigint)(), a, BigInt),
          f = ((0, n.union)([s.StrictHexStruct, (0, n.instance)(Uint8Array)]), (0, n.coerce)((0, n.instance)(Uint8Array), (0, n.union)([s.StrictHexStruct]), o.hexToBytes)),
          l = (0, n.coerce)(s.StrictHexStruct, (0, n.instance)(Uint8Array), o.bytesToHex);
        e.createNumber = function(t) {
          try {
            const e = (0, n.create)(t, u);
            return (0, i.assert)(Number.isFinite(e), `Expected a number-like value, got "${t}".`), e
          } catch (e) {
            throw e instanceof n.StructError ? Error(`Expected a number-like value, got "${t}".`) : e
          }
        }, e.createBigInt = function(t) {
          try {
            return (0, n.create)(t, c)
          } catch (t) {
            throw t instanceof n.StructError ? Error(`Expected a number-like value, got "${t.value+""}".`) : t
          }
        }, e.createBytes = function(t) {
          if ("string" == typeof t && "0x" === t.toLowerCase()) return new Uint8Array;
          try {
            return (0, n.create)(t, f)
          } catch (t) {
            throw t instanceof n.StructError ? Error(`Expected a bytes-like value, got "${t.value+""}".`) : t
          }
        }, e.createHex = function(t) {
          if (t instanceof Uint8Array && 0 === t.length || "string" == typeof t && "0x" === t.toLowerCase()) return "0x";
          try {
            return (0, n.create)(t, l)
          } catch (t) {
            throw t instanceof n.StructError ? Error(`Expected a bytes-like value, got "${t.value+""}".`) : t
          }
        }
      },
      50560: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e, r) => new n(t, r).compare(new n(e, r))
      },
      50855: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), parseInt(t, e || 10)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      50993: function(t, e, r) {
        "use strict";
        var n, i, o, s, a = r(48287).Buffer,
          u = this && this.vr || function(t, e, r, n, i) {
            if ("m" === n) throw new TypeError("Private method is not writable");
            if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === n ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
          },
          c = this && this.wr || function(t, e, r, n) {
            if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === r ? n : "a" === r ? n.call(t) : n ? n.value : e.get(t)
          },
          f = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.TonClient4 = void 0;
        const l = f(r(86425)),
          h = r(1307),
          d = r(68546),
          p = r(7552);

        function b(t, e, r, n) {
          return {
            async getState() {
              let n = e;
              null === n && (n = (await t.getLastBlock()).last.seqno);
              let i, o = await t.getAccount(n, r),
                s = o.account.last ? {
                  lt: BigInt(o.account.last.lt),
                  hash: a.from(o.account.last.hash, "base64")
                } : null;
              if ("active" === o.account.state.type) i = {
                type: "active",
                code: o.account.state.code ? a.from(o.account.state.code, "base64") : null,
                data: o.account.state.data ? a.from(o.account.state.data, "base64") : null
              };
              else if ("uninit" === o.account.state.type) i = {
                type: "uninit"
              };
              else {
                if ("frozen" !== o.account.state.type) throw Error("Unsupported state");
                i = {
                  type: "frozen",
                  stateHash: a.from(o.account.state.stateHash, "base64")
                }
              }
              return {
                balance: BigInt(o.account.balance.coins),
                last: s,
                state: i
              }
            },
            async get(n, i) {
              if ("string" != typeof n) throw Error("Method name must be a string for TonClient4 provider");
              let o = e;
              null === o && (o = (await t.getLastBlock()).last.seqno);
              let s = await t.runMethod(o, r, n, i);
              if (0 !== s.exitCode && 1 !== s.exitCode) throw Error("Exit code: " + s.exitCode);
              return {
                stack: new h.TupleReader(s.result)
              }
            },
            async external(e) {
              let i = await t.getLastBlock(),
                o = null;
              n && "active" !== (await t.getAccountLite(i.last.seqno, r)).account.state.type && (o = n);
              const s = (0, h.external)({
                to: r,
                init: o,
                body: e
              });
              let a = (0, h.beginCell)().store((0, h.storeMessage)(s)).endCell().toBoc();
              await t.sendMessage(a)
            },
            async internal(e, i) {
              let o = await t.getLastBlock(),
                s = null;
              n && "active" !== (await t.getAccountLite(o.last.seqno, r)).account.state.type && (s = n);
              let a, u = !0;
              null !== i.bounce && void 0 !== i.bounce && (u = i.bounce), a = "string" == typeof i.value ? (0, h.toNano)(i.value) : i.value;
              let c = null;
              "string" == typeof i.body ? c = (0, h.comment)(i.body) : i.body && (c = i.body), await e.send({
                to: r,
                value: a,
                bounce: u,
                sendMode: i.sendMode,
                init: s,
                body: c
              })
            },
            open: r => (0, h.openContract)(r, r => b(t, e, r.address, r.init ?? null)),
            async getTransactions(e, r, n, i) {
              const o = "number" == typeof i;
              if (o && 0 >= i) return [];
              let s = [];
              do {
                const i = await t.getAccountTransactions(e, r, n),
                  o = i[0].tx,
                  [a, u] = [o.lt, o.hash()];
                if (s.length > 0 && a === r && u.equals(n) && i.shift(), 0 === i.length) break;
                const c = i[i.length - 1].tx,
                  [f, l] = [c.lt, c.hash()];
                if (f === r && l.equals(n)) break;
                s.push(...i.map(t => t.tx)), r = f, n = l
              } while (o && s.length < i);
              return o && (s = s.slice(0, i)), s
            }
          }
        }
        e.TonClient4 = class {
          constructor(t) {
            n.set(this, void 0), i.set(this, void 0), o.set(this, void 0), s.set(this, void 0), u(this, s, l.default.create(), "f"), u(this, n, t.endpoint, "f"), u(this, i, t.timeout || 5e3, "f"), u(this, o, t.httpAdapter, "f"), t.requestInterceptor && c(this, s, "f").interceptors.request.use(t.requestInterceptor)
          }
          async getLastBlock() {
            let t = await c(this, s, "f").get(c(this, n, "f") + "/block/latest", {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              e = m.safeParse(t.data);
            if (!e.success) throw Error("Mailformed response: " + e.error.format().Te.join(", "));
            return e.data
          }
          async getBlock(t) {
            let e = await c(this, s, "f").get(c(this, n, "f") + "/block/" + t, {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              r = y.safeParse(e.data);
            if (!r.success) throw Error("Mailformed response");
            if (!r.data.exist) throw Error("Block is out of scope");
            return r.data.block
          }
          async getBlockByUtime(t) {
            let e = await c(this, s, "f").get(c(this, n, "f") + "/block/utime/" + t, {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              r = y.safeParse(e.data);
            if (!r.success) throw Error("Mailformed response");
            if (!r.data.exist) throw Error("Block is out of scope");
            return r.data.block
          }
          async getAccount(t, e) {
            let r = await c(this, s, "f").get(c(this, n, "f") + "/block/" + t + "/" + e.toString({
                urlSafe: !0
              }), {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              a = v.safeParse(r.data);
            if (!a.success) throw Error("Mailformed response");
            return a.data
          }
          async getAccountLite(t, e) {
            let r = await c(this, s, "f").get(c(this, n, "f") + "/block/" + t + "/" + e.toString({
                urlSafe: !0
              }) + "/lite", {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              a = w.safeParse(r.data);
            if (!a.success) throw Error("Mailformed response");
            return a.data
          }
          async isContractDeployed(t, e) {
            return "active" === (await this.getAccountLite(t, e)).account.state.type
          }
          async isAccountChanged(t, e, r) {
            let a = await c(this, s, "f").get(c(this, n, "f") + "/block/" + t + "/" + e.toString({
                urlSafe: !0
              }) + "/changed/" + r.toString(10), {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              u = A.safeParse(a.data);
            if (!u.success) throw Error("Mailformed response");
            return u.data
          }
          async getAccountTransactions(t, e, r) {
            let u = await c(this, s, "f").get(c(this, n, "f") + "/account/" + t.toString({
                urlSafe: !0
              }) + "/tx/" + e.toString(10) + "/" + (0, d.toUrlSafe)(r.toString("base64")), {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              f = x.safeParse(u.data);
            if (!f.success) throw Error("Mailformed response");
            let l = f.data,
              p = [],
              b = h.Cell.fromBoc(a.from(l.boc, "base64"));
            for (let t = 0; t < l.blocks.length; t++) p.push({
              block: l.blocks[t],
              tx: (0, h.loadTransaction)(b[t].beginParse())
            });
            return p
          }
          async getAccountTransactionsParsed(t, e, r, a = 20) {
            let u = await c(this, s, "f").get(c(this, n, "f") + "/account/" + t.toString({
                urlSafe: !0
              }) + "/tx/parsed/" + e.toString(10) + "/" + (0, d.toUrlSafe)(r.toString("base64")), {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f"),
                params: {
                  count: a
                }
              }),
              f = D.safeParse(u.data);
            if (!f.success) throw Error("Mailformed response");
            return f.data
          }
          async getConfig(t, e) {
            let r = "";
            e && e.length > 0 && (r = "/" + [...e].sort().join(","));
            let a = await c(this, s, "f").get(c(this, n, "f") + "/block/" + t + "/config" + r, {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              u = E.safeParse(a.data);
            if (!u.success) throw Error("Mailformed response");
            return u.data
          }
          async runMethod(t, e, r, u) {
            let f = u && u.length > 0 ? "/" + (0, d.toUrlSafe)((0, h.serializeTuple)(u).toBoc({
                idx: !1,
                crc32: !1
              }).toString("base64")) : "",
              l = c(this, n, "f") + "/block/" + t + "/" + e.toString({
                urlSafe: !0
              }) + "/run/" + encodeURIComponent(r) + f,
              p = await c(this, s, "f").get(l, {
                adapter: c(this, o, "f"),
                timeout: c(this, i, "f")
              }),
              b = T.safeParse(p.data);
            if (!b.success) throw Error("Mailformed response");
            let m = b.data.resultRaw ? (0, h.parseTuple)(h.Cell.fromBoc(a.from(b.data.resultRaw, "base64"))[0]) : [];
            return {
              exitCode: b.data.exitCode,
              result: m,
              resultRaw: b.data.resultRaw,
              block: b.data.block,
              shardBlock: b.data.shardBlock,
              reader: new h.TupleReader(m)
            }
          }
          async sendMessage(t) {
            let e = await c(this, s, "f").post(c(this, n, "f") + "/send", {
              boc: t.toString("base64")
            }, {
              adapter: c(this, o, "f"),
              timeout: c(this, i, "f")
            });
            if (!P.safeParse(e.data).success) throw Error("Mailformed response");
            return {
              status: e.data.status
            }
          }
          open(t) {
            return (0, h.openContract)(t, t => b(this, null, t.address, t.init))
          }
          openAt(t, e) {
            return (0, h.openContract)(e, e => b(this, t, e.address, e.init))
          }
          provider(t, e) {
            return b(this, null, t, e ?? null)
          }
          providerAt(t, e, r) {
            return b(this, t, e, r ?? null)
          }
        }, n = new WeakMap, i = new WeakMap, o = new WeakMap, s = new WeakMap;
        const m = p.z.object({
            last: p.z.object({
              seqno: p.z.number(),
              shard: p.z.string(),
              workchain: p.z.number(),
              fileHash: p.z.string(),
              rootHash: p.z.string()
            }),
            init: p.z.object({
              fileHash: p.z.string(),
              rootHash: p.z.string()
            }),
            stateRootHash: p.z.string(),
            now: p.z.number()
          }),
          y = p.z.union([p.z.object({
            exist: p.z.literal(!1)
          }), p.z.object({
            exist: p.z.literal(!0),
            block: p.z.object({
              shards: p.z.array(p.z.object({
                workchain: p.z.number(),
                seqno: p.z.number(),
                shard: p.z.string(),
                rootHash: p.z.string(),
                fileHash: p.z.string(),
                transactions: p.z.array(p.z.object({
                  account: p.z.string(),
                  hash: p.z.string(),
                  lt: p.z.string()
                }))
              }))
            })
          })]),
          g = p.z.object({
            lastPaid: p.z.number(),
            duePayment: p.z.union([p.z.null(), p.z.string()]),
            used: p.z.object({
              bits: p.z.number(),
              cells: p.z.number(),
              publicCells: p.z.number()
            })
          }),
          v = p.z.object({
            account: p.z.object({
              state: p.z.union([p.z.object({
                type: p.z.literal("uninit")
              }), p.z.object({
                type: p.z.literal("active"),
                code: p.z.union([p.z.string(), p.z.null()]),
                data: p.z.union([p.z.string(), p.z.null()])
              }), p.z.object({
                type: p.z.literal("frozen"),
                stateHash: p.z.string()
              })]),
              balance: p.z.object({
                coins: p.z.string()
              }),
              last: p.z.union([p.z.null(), p.z.object({
                lt: p.z.string(),
                hash: p.z.string()
              })]),
              storageStat: p.z.union([p.z.null(), g])
            }),
            block: p.z.object({
              workchain: p.z.number(),
              seqno: p.z.number(),
              shard: p.z.string(),
              rootHash: p.z.string(),
              fileHash: p.z.string()
            })
          }),
          w = p.z.object({
            account: p.z.object({
              state: p.z.union([p.z.object({
                type: p.z.literal("uninit")
              }), p.z.object({
                type: p.z.literal("active"),
                codeHash: p.z.string(),
                dataHash: p.z.string()
              }), p.z.object({
                type: p.z.literal("frozen"),
                stateHash: p.z.string()
              })]),
              balance: p.z.object({
                coins: p.z.string()
              }),
              last: p.z.union([p.z.null(), p.z.object({
                lt: p.z.string(),
                hash: p.z.string()
              })]),
              storageStat: p.z.union([p.z.null(), g])
            })
          }),
          A = p.z.object({
            changed: p.z.boolean(),
            block: p.z.object({
              workchain: p.z.number(),
              seqno: p.z.number(),
              shard: p.z.string(),
              rootHash: p.z.string(),
              fileHash: p.z.string()
            })
          }),
          T = p.z.object({
            exitCode: p.z.number(),
            resultRaw: p.z.union([p.z.string(), p.z.null()]),
            block: p.z.object({
              workchain: p.z.number(),
              seqno: p.z.number(),
              shard: p.z.string(),
              rootHash: p.z.string(),
              fileHash: p.z.string()
            }),
            shardBlock: p.z.object({
              workchain: p.z.number(),
              seqno: p.z.number(),
              shard: p.z.string(),
              rootHash: p.z.string(),
              fileHash: p.z.string()
            })
          }),
          E = p.z.object({
            config: p.z.object({
              cell: p.z.string(),
              address: p.z.string(),
              globalBalance: p.z.object({
                coins: p.z.string()
              })
            })
          }),
          P = p.z.object({
            status: p.z.number()
          }),
          k = p.z.array(p.z.object({
            workchain: p.z.number(),
            seqno: p.z.number(),
            shard: p.z.string(),
            rootHash: p.z.string(),
            fileHash: p.z.string()
          })),
          x = p.z.object({
            blocks: k,
            boc: p.z.string()
          }),
          I = p.z.object({
            bits: p.z.number(),
            data: p.z.string()
          }),
          S = p.z.union([p.z.object({
            type: p.z.literal("internal"),
            value: p.z.string(),
            dest: p.z.string(),
            src: p.z.string(),
            bounced: p.z.boolean(),
            bounce: p.z.boolean(),
            ihrDisabled: p.z.boolean(),
            createdAt: p.z.number(),
            createdLt: p.z.string(),
            fwdFee: p.z.string(),
            ihrFee: p.z.string()
          }), p.z.object({
            type: p.z.literal("external-in"),
            dest: p.z.string(),
            src: p.z.union([I, p.z.null()]),
            importFee: p.z.string()
          }), p.z.object({
            type: p.z.literal("external-out"),
            dest: p.z.union([I, p.z.null()])
          })]),
          O = p.z.object({
            splitDepth: p.z.union([p.z.number(), p.z.null()]),
            code: p.z.union([p.z.string(), p.z.null()]),
            data: p.z.union([p.z.string(), p.z.null()]),
            special: p.z.union([p.z.object({
              tick: p.z.boolean(),
              tock: p.z.boolean()
            }), p.z.null()])
          }),
          B = p.z.object({
            body: p.z.string(),
            info: S,
            init: p.z.union([O, p.z.null()])
          }),
          W = p.z.union([p.z.literal("uninitialized"), p.z.literal("frozen"), p.z.literal("active"), p.z.literal("non-existing")]),
          M = p.z.union([p.z.object({
            type: p.z.literal("comment"),
            comment: p.z.string()
          }), p.z.object({
            type: p.z.literal("payload"),
            cell: p.z.string()
          })]),
          C = p.z.union([p.z.object({
            kind: p.z.literal("ton"),
            amount: p.z.string()
          }), p.z.object({
            kind: p.z.literal("token"),
            amount: p.z.string()
          })]),
          R = p.z.union([p.z.literal("jetton::excesses"), p.z.literal("jetton::transfer"), p.z.literal("jetton::transfer_notification"), p.z.literal("deposit"), p.z.literal("deposit::ok"), p.z.literal("withdraw"), p.z.literal("withdraw::all"), p.z.literal("withdraw::delayed"), p.z.literal("withdraw::ok"), p.z.literal("airdrop")]),
          N = p.z.object({
            type: R,
            options: p.z.optional(p.z.record(p.z.string()))
          }),
          j = p.z.object({
            address: p.z.string(),
            comment: p.z.optional(p.z.string()),
            items: p.z.array(C),
            op: p.z.optional(N)
          }),
          _ = p.z.object({
            address: p.z.string(),
            lt: p.z.string(),
            hash: p.z.string(),
            prevTransaction: p.z.object({
              lt: p.z.string(),
              hash: p.z.string()
            }),
            time: p.z.number(),
            outMessagesCount: p.z.number(),
            oldStatus: W,
            newStatus: W,
            fees: p.z.string(),
            update: p.z.object({
              oldHash: p.z.string(),
              newHash: p.z.string()
            }),
            inMessage: p.z.union([B, p.z.null()]),
            outMessages: p.z.array(B),
            parsed: p.z.object({
              seqno: p.z.union([p.z.number(), p.z.null()]),
              body: p.z.union([M, p.z.null()]),
              status: p.z.union([p.z.literal("success"), p.z.literal("failed"), p.z.literal("pending")]),
              dest: p.z.union([p.z.string(), p.z.null()]),
              kind: p.z.union([p.z.literal("out"), p.z.literal("in")]),
              amount: p.z.string(),
              resolvedAddress: p.z.string(),
              bounced: p.z.boolean(),
              mentioned: p.z.array(p.z.string())
            }),
            operation: j
          }),
          D = p.z.object({
            blocks: k,
            transactions: p.z.array(_)
          })
      },
      50995: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = RegExp("^(?:[-+])?(?:[0-9]+)?(?:\\".concat((e = e || {}).locale ? o.decimal[e.locale] : ".", "[0-9]*)?(?:[eE][\\+\\-]?(?:[0-9]+))?$"));
          if ("" === t || "." === t || "," === t || "-" === t || "+" === t) return !1;
          var n = parseFloat(t.replace(",", "."));
          return r.test(t) && (!e.hasOwnProperty("min") || n >= e.min) && (!e.hasOwnProperty("max") || n <= e.max) && (!e.hasOwnProperty("lt") || n < e.lt) && (!e.hasOwnProperty("gt") || n > e.gt)
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(13237),
          s = Object.keys(o.decimal);
        e.locales = s
      },
      51682: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getSecureRandomNumber = e.getSecureRandomWords = e.getSecureRandomBytes = void 0;
        const n = r(32370);
        async function i(t) {
          return (0, n.getSecureRandomBytes)(t)
        }
        e.getSecureRandomBytes = i, e.getSecureRandomWords = async function t(e) {
          return t(e)
        }, e.getSecureRandomNumber = async function(t, e) {
          let r = e - t;
          var n = Math.ceil(Math.log2(r));
          if (n > 53) throw Error("Range is too large");
          for (var o = Math.ceil(n / 8), s = Math.pow(2, n) - 1;;) {
            let e = await i(n),
              u = 8 * (o - 1),
              c = 0;
            for (var a = 0; o > a; a++) c += e[a] * Math.pow(2, u), u -= 8;
            if (c &= s, r > c) return t + c
          }
        }
      },
      51832: (t, e, r) => {
        const n = r(30144);
        t.exports = (t, e) => {
          const r = n(t, null, !0),
            i = n(e, null, !0),
            o = r.compare(i);
          if (0 === o) return null;
          const s = o > 0,
            a = s ? r : i,
            u = s ? i : r,
            c = !!a.prerelease.length;
          if (u.prerelease.length && !c) {
            if (!u.patch && !u.minor) return "major";
            if (0 === u.compareMain(a)) return u.minor && !u.patch ? "minor" : "patch"
          }
          const f = c ? "pre" : "";
          return r.major !== i.major ? f + "major" : r.minor !== i.minor ? f + "minor" : r.patch !== i.patch ? f + "patch" : "prerelease"
        }
      },
      52231: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.resolveExotic = void 0;
        const n = r(53528),
          i = r(34654),
          o = r(29368),
          s = r(31459),
          a = r(91408),
          u = r(79499),
          c = r(20555);
        e.resolveExotic = function(t, e) {
          let r = new n.BitReader(t).preloadUint(8);
          if (1 === r) return function(t, e) {
            let r = (0, u.exoticPruned)(t, e),
              n = [],
              o = [],
              s = new c.LevelMask(r.mask);
            for (let t = 0; t < r.pruned.length; t++) n.push(r.pruned[t].depth), o.push(r.pruned[t].hash);
            return {
              type: i.CellType.PrunedBranch,
              depths: n,
              hashes: o,
              mask: s
            }
          }(t, e);
          if (2 === r) return function(t, e) {
            (0, o.exoticLibrary)(t, e);
            let r = new c.LevelMask;
            return {
              type: i.CellType.Library,
              depths: [],
              hashes: [],
              mask: r
            }
          }(t, e);
          if (3 === r) return function(t, e) {
            (0, s.exoticMerkleProof)(t, e);
            let r = new c.LevelMask(e[0].level() >> 1);
            return {
              type: i.CellType.MerkleProof,
              depths: [],
              hashes: [],
              mask: r
            }
          }(t, e);
          if (4 === r) return function(t, e) {
            (0, a.exoticMerkleUpdate)(t, e);
            let r = new c.LevelMask((e[0].level() | e[1].level()) >> 1);
            return {
              type: i.CellType.MerkleUpdate,
              depths: [],
              hashes: [],
              mask: r
            }
          }(t, e);
          throw Error("Invalid exotic cell type: " + r)
        }
      },
      52273: (t, e) => {
        "use strict";

        function r(t) {
          return "setIsPublicKeyEnabled" === t.type || "addExtension" === t.type || "removeExtension" === t.type
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isOutActionExtended = r, e.isOutActionBasic = function(t) {
          return !r(t)
        }
      },
      52279: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.newSecurePassphrase = void 0;
        const n = r(75269);
        e.newSecurePassphrase = async function(t = 6) {
          return (await (0, n.newSecureWords)(t)).join("-")
        }
      },
      52566: (t, e) => {
        ! function(t) {
          t.version = "1.2.2";
          var e = function() {
              for (var t = 0, e = Array(256), r = 0; 256 != r; ++r) t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = 1 & (t = r) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1) ? -306674912 ^ t >>> 1 : t >>> 1, e[r] = t;
              return "u" > typeof Int32Array ? new Int32Array(e) : e
            }(),
            r = function(t) {
              var e = 0,
                r = 0,
                n = 0,
                i = "u" > typeof Int32Array ? new Int32Array(4096) : Array(4096);
              for (n = 0; 256 != n; ++n) i[n] = t[n];
              for (n = 0; 256 != n; ++n)
                for (r = t[n], e = 256 + n; 4096 > e; e += 256) r = i[e] = r >>> 8 ^ t[255 & r];
              var o = [];
              for (n = 1; 16 != n; ++n) o[n - 1] = "u" > typeof Int32Array ? i.subarray(256 * n, 256 * n + 256) : i.slice(256 * n, 256 * n + 256);
              return o
            }(e),
            n = r[0],
            i = r[1],
            o = r[2],
            s = r[3],
            a = r[4],
            u = r[5],
            c = r[6],
            f = r[7],
            l = r[8],
            h = r[9],
            d = r[10],
            p = r[11],
            b = r[12],
            m = r[13],
            y = r[14];
          t.table = e, t.bstr = function(t, r) {
            for (var n = -1 ^ r, i = 0, o = t.length; o > i;) n = n >>> 8 ^ e[255 & (n ^ t.charCodeAt(i++))];
            return ~n
          }, t.buf = function(t, r) {
            for (var g = -1 ^ r, v = t.length - 15, w = 0; v > w;) g = y[t[w++] ^ 255 & g] ^ m[t[w++] ^ g >> 8 & 255] ^ b[t[w++] ^ g >> 16 & 255] ^ p[t[w++] ^ g >>> 24] ^ d[t[w++]] ^ h[t[w++]] ^ l[t[w++]] ^ f[t[w++]] ^ c[t[w++]] ^ u[t[w++]] ^ a[t[w++]] ^ s[t[w++]] ^ o[t[w++]] ^ i[t[w++]] ^ n[t[w++]] ^ e[t[w++]];
            for (v += 15; v > w;) g = g >>> 8 ^ e[255 & (g ^ t[w++])];
            return ~g
          }, t.str = function(t, r) {
            for (var n = -1 ^ r, i = 0, o = t.length, s = 0, a = 0; o > i;) 128 > (s = t.charCodeAt(i++)) ? n = n >>> 8 ^ e[255 & (n ^ s)] : 2048 > s ? n = (n = n >>> 8 ^ e[255 & (n ^ (192 | s >> 6 & 31))]) >>> 8 ^ e[255 & (n ^ (128 | 63 & s))] : s >= 55296 && 57344 > s ? (s = 64 + (1023 & s), a = 1023 & t.charCodeAt(i++), n = (n = (n = (n = n >>> 8 ^ e[255 & (n ^ (240 | s >> 8 & 7))]) >>> 8 ^ e[255 & (n ^ (128 | s >> 2 & 63))]) >>> 8 ^ e[255 & (n ^ (128 | a >> 6 & 15 | (3 & s) << 4))]) >>> 8 ^ e[255 & (n ^ (128 | 63 & a))]) : n = (n = (n = n >>> 8 ^ e[255 & (n ^ (224 | s >> 12 & 15))]) >>> 8 ^ e[255 & (n ^ (128 | s >> 6 & 63))]) >>> 8 ^ e[255 & (n ^ (128 | 63 & s))];
            return ~n
          }
        }(typeof DO_NOT_EXPORT_CRC > "u" ? e : {})
      },
      52652: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.GWEI_TO_WEI = void 0, e.GWEI_TO_WEI = BigInt(1e9)
      },
      52938: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wonderCalculator = void 0;
        const n = r(62386),
          i = r(34654),
          o = r(20555),
          s = r(79499),
          a = r(31459),
          u = r(9896),
          c = r(75269),
          f = r(91408),
          l = r(29368);
        e.wonderCalculator = function(t, e, r) {
          let h, d = null;
          if (t === i.CellType.Ordinary) {
            let t = 0;
            for (let e of r) t |= e.mask.value;
            h = new o.LevelMask(t)
          } else if (t === i.CellType.PrunedBranch) d = (0, s.exoticPruned)(e, r), h = new o.LevelMask(d.mask);
          else if (t === i.CellType.MerkleProof)(0, a.exoticMerkleProof)(e, r), h = new o.LevelMask(r[0].mask.value >> 1);
          else if (t === i.CellType.MerkleUpdate)(0, f.exoticMerkleUpdate)(e, r), h = new o.LevelMask((r[0].mask.value | r[1].mask.value) >> 1);
          else {
            if (t !== i.CellType.Library) throw Error("Unsupported exotic type");
            (0, l.exoticLibrary)(e, r), h = new o.LevelMask
          }
          let p = [],
            b = [],
            m = t === i.CellType.PrunedBranch ? 1 : h.hashCount,
            y = h.hashCount - m;
          for (let o = 0, s = 0; o <= h.level; o++) {
            if (!h.isSignificant(o)) continue;
            if (y > s) {
              s++;
              continue
            }
            let a;
            if (s === y) {
              if (0 !== o && t !== i.CellType.PrunedBranch) throw Error("Invalid");
              a = e
            } else {
              if (0 === o || t === i.CellType.PrunedBranch) throw Error("Invalid: " + o + ", " + t);
              a = new n.BitString(b[s - y - 1], 0, 256)
            }
            let f = 0;
            for (let e of r) {
              let r;
              r = t == i.CellType.MerkleProof || t == i.CellType.MerkleUpdate ? e.depth(o + 1) : e.depth(o), f = Math.max(f, r)
            }
            r.length > 0 && f++;
            let l = (0, u.getRepr)(e, a, r, o, h.apply(o).value, t),
              d = (0, c.sha256_sync)(l),
              m = s - y;
            p[m] = f, b[m] = d, s++
          }
          let g = [],
            v = [];
          if (d)
            for (let t = 0; 4 > t; t++) {
              const {
                hashIndex: e
              } = h.apply(t), {
                hashIndex: r
              } = h;
              e !== r ? (g.push(d.pruned[e].hash), v.push(d.pruned[e].depth)) : (g.push(b[0]), v.push(p[0]))
            } else
              for (let t = 0; 4 > t; t++) g.push(b[h.apply(t).hashIndex]), v.push(p[h.apply(t).hashIndex]);
          return {
            mask: h,
            hashes: g,
            depths: v
          }
        }
      },
      53269: t => {
        "use strict";
        t.exports = function(t, e, r, n) {
          for (var i = 65535 & t, o = t >>> 16 & 65535, s = 0; 0 !== r;) {
            r -= s = r > 2e3 ? 2e3 : r;
            do {
              o = o + (i = i + e[n++] | 0) | 0
            } while (--s);
            i %= 65521, o %= 65521
          }
          return i | o << 16
        }
      },
      53318: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV5Beta = void 0;
        const i = r(1307),
          o = r(20574),
          s = r(66408);
        class a {
          static create(t) {
            const e = {
              networkGlobalId: t.walletId?.networkGlobalId ?? -239,
              workchain: t?.walletId?.workchain ?? 0,
              subwalletNumber: t?.walletId?.subwalletNumber ?? 0,
              walletVersion: t?.walletId?.walletVersion ?? "v5"
            };
            return new a(e, t.publicKey)
          }
          constructor(t, e) {
            this.walletId = t, this.publicKey = e, this.walletId = t;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEAIwAIQgLkzzsvTG1qYeoPK1RH0mZ4WyavNjfbLe7mvNGqgm80Eg3NjhE=", "base64"))[0],
              o = (0, i.beginCell)().storeInt(0, 33).store((0, s.storeWalletIdV5Beta)(this.walletId)).storeBuffer(this.publicKey, 32).storeBit(0).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(this.walletId.workchain, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async getExtensions(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("get_extensions", [])).stack.readCellOpt() : null
          }
          async getExtensionsArray(t) {
            const e = await this.getExtensions(t);
            if (!e) return [];
            const r = i.Dictionary.loadDirect(i.Dictionary.Keys.BigUint(256), i.Dictionary.Values.BigInt(8), e);
            return r.keys().map(t => {
              const e = r.get(t),
                n = t ^ e + 1n;
              return i.Address.parseRaw(`${e}:${n.toString(16).padStart(64,"0")}`)
            })
          }
          async getIsSecretKeyAuthEnabled(t) {
            return 0 !== (await t.get("get_is_signature_auth_allowed", [])).stack.readNumber()
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            const r = await this.createTransfer(e);
            await this.send(t, r)
          }
          async sendAddExtension(t, e) {
            const r = await this.createAddExtension(e);
            await this.send(t, r)
          }
          async sendRemoveExtension(t, e) {
            const r = await this.createRemoveExtension(e);
            await this.send(t, r)
          }
          async sendActionsBatch(t, e) {
            const r = await this.createRequest(e);
            await this.send(t, r)
          }
          createActions(t) {
            return t.messages.map(e => ({
              type: "sendMsg",
              mode: t.sendMode,
              outMsg: e
            }))
          }
          createTransfer(t) {
            return this.createRequest({
              ...t,
              actions: this.createActions({
                messages: t.messages,
                sendMode: t.sendMode
              })
            })
          }
          createAddExtension(t) {
            return this.createRequest({
              ...t,
              actions: [{
                type: "addExtension",
                address: t.extensionAddress
              }]
            })
          }
          createRemoveExtension(t) {
            return this.createRequest({
              ...t,
              actions: [{
                type: "removeExtension",
                address: t.extensionAddress
              }]
            })
          }
          createRequest(t) {
            return "extension" === t.authType ? (0, o.createWalletTransferV5Beta)(t) : (0, o.createWalletTransferV5Beta)({
              ...t,
              walletId: (0, s.storeWalletIdV5Beta)(this.walletId)
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode ?? i.SendMode.PAY_GAS_SEPARATELY + i.SendMode.IGNORE_ERRORS,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV5Beta = a, a.OpCodes = {
          auth_extension: 1702392942,
          auth_signed_external: 1936287598,
          auth_signed_internal: 1936289396
        }
      },
      53528: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.BitReader = void 0;
        const i = r(3512),
          o = r(71629);
        class s {
          constructor(t, e = 0) {
            this.Ar = [], this.Tr = t, this.Er = e
          }
          get offset() {
            return this.Er
          }
          get remaining() {
            return this.Tr.length - this.Er
          }
          skip(t) {
            if (0 > t || this.Er + t > this.Tr.length) throw Error(`Index ${this.Er+t} is out of bounds`);
            this.Er += t
          }
          reset() {
            this.Ar.length > 0 ? this.Er = this.Ar.pop() : this.Er = 0
          }
          save() {
            this.Ar.push(this.Er)
          }
          loadBit() {
            let t = this.Tr.at(this.Er);
            return this.Er++, t
          }
          preloadBit() {
            return this.Tr.at(this.Er)
          }
          loadBits(t) {
            let e = this.Tr.substring(this.Er, t);
            return this.Er += t, e
          }
          preloadBits(t) {
            return this.Tr.substring(this.Er, t)
          }
          loadBuffer(t) {
            let e = this.Pr(t, this.Er);
            return this.Er += 8 * t, e
          }
          preloadBuffer(t) {
            return this.Pr(t, this.Er)
          }
          loadUint(t) {
            return this.kr(this.loadUintBig(t), "loadUintBig")
          }
          loadUintBig(t) {
            let e = this.preloadUintBig(t);
            return this.Er += t, e
          }
          preloadUint(t) {
            return this.kr(this.Ir(t, this.Er), "preloadUintBig")
          }
          preloadUintBig(t) {
            return this.Ir(t, this.Er)
          }
          loadInt(t) {
            let e = this.Sr(t, this.Er);
            return this.Er += t, this.kr(e, "loadUintBig")
          }
          loadIntBig(t) {
            let e = this.Sr(t, this.Er);
            return this.Er += t, e
          }
          preloadInt(t) {
            return this.kr(this.Sr(t, this.Er), "preloadIntBig")
          }
          preloadIntBig(t) {
            return this.Sr(t, this.Er)
          }
          loadVarUint(t) {
            let e = +this.loadUint(t);
            return this.kr(this.loadUintBig(8 * e), "loadVarUintBig")
          }
          loadVarUintBig(t) {
            let e = +this.loadUint(t);
            return this.loadUintBig(8 * e)
          }
          preloadVarUint(t) {
            let e = +this.Ir(t, this.Er);
            return this.kr(this.Ir(8 * e, this.Er + t), "preloadVarUintBig")
          }
          preloadVarUintBig(t) {
            let e = +this.Ir(t, this.Er);
            return this.Ir(8 * e, this.Er + t)
          }
          loadVarInt(t) {
            let e = +this.loadUint(t);
            return this.kr(this.loadIntBig(8 * e), "loadVarIntBig")
          }
          loadVarIntBig(t) {
            let e = +this.loadUint(t);
            return this.loadIntBig(8 * e)
          }
          preloadVarInt(t) {
            let e = +this.Ir(t, this.Er);
            return this.kr(this.Sr(8 * e, this.Er + t), "preloadVarIntBig")
          }
          preloadVarIntBig(t) {
            let e = +this.Ir(t, this.Er);
            return this.Sr(8 * e, this.Er + t)
          }
          loadCoins() {
            return this.loadVarUintBig(4)
          }
          preloadCoins() {
            return this.preloadVarUintBig(4)
          }
          loadAddress() {
            let t = +this.Ir(2, this.Er);
            if (2 === t) return this.Or();
            throw Error("Invalid address: " + t)
          }
          loadMaybeAddress() {
            let t = +this.Ir(2, this.Er);
            if (0 === t) return this.Er += 2, null;
            if (2 === t) return this.Or();
            throw Error("Invalid address")
          }
          loadExternalAddress() {
            if (1 === +this.Ir(2, this.Er)) return this.Br();
            throw Error("Invalid address")
          }
          loadMaybeExternalAddress() {
            let t = +this.Ir(2, this.Er);
            if (0 === t) return this.Er += 2, null;
            if (1 === t) return this.Br();
            throw Error("Invalid address")
          }
          loadAddressAny() {
            let t = +this.Ir(2, this.Er);
            if (0 === t) return this.Er += 2, null;
            if (2 === t) return this.Or();
            if (1 === t) return this.Br();
            throw Error(3 === t ? "Unsupported" : "Unreachable")
          }
          loadPaddedBits(t) {
            if (t % 8 != 0) throw Error("Invalid number of bits");
            let e = t;
            for (;;) {
              if (this.Tr.at(this.Er + e - 1)) {
                e--;
                break
              }
              e--
            }
            let r = this.Tr.substring(this.Er, e);
            return this.Er += t, r
          }
          clone() {
            return new s(this.Tr, this.Er)
          }
          Sr(t, e) {
            if (0 == t) return 0n;
            let r = this.Tr.at(e),
              n = 0n;
            for (let r = 0; t - 1 > r; r++) this.Tr.at(e + 1 + r) && (n += 1n << BigInt(t - r - 1 - 1));
            return r && (n -= 1n << BigInt(t - 1)), n
          }
          Ir(t, e) {
            if (0 == t) return 0n;
            let r = 0n;
            for (let n = 0; t > n; n++) this.Tr.at(e + n) && (r += 1n << BigInt(t - n - 1));
            return r
          }
          Pr(t, e) {
            let r = this.Tr.subbuffer(e, 8 * t);
            if (r) return r;
            let i = n.alloc(t);
            for (let r = 0; t > r; r++) i[r] = +this.Ir(8, e + 8 * r);
            return i
          }
          Or() {
            if (2 !== +this.Ir(2, this.Er)) throw Error("Invalid address");
            let t, e;
            0n !== this.Ir(1, this.Er + 2) && (e = +this.Ir(5, this.Er + 3), t = this.Ir(e, this.Er + 8), this.Er += 5 + e);
            let r = +this.Sr(8, this.Er + 3),
              n = this.Pr(32, this.Er + 11);
            if (void 0 !== e && void 0 !== t) {
              let r = +t,
                i = 0,
                o = 0,
                s = e;
              for (; s > 0;) {
                let t = Math.min(8 - o, s),
                  e = (1 << t) - 1 << 8 - o - t,
                  a = (r >> s - t & (1 << t) - 1) << 8 - o - t;
                n[i] = n[i] & ~e | a, s -= t, o += t, 8 === o && (i++, o = 0)
              }
            }
            return this.Er += 267, new i.Address(r, n)
          }
          Br() {
            if (1 !== +this.Ir(2, this.Er)) throw Error("Invalid address");
            let t = +this.Ir(9, this.Er + 2),
              e = this.Ir(t, this.Er + 11);
            return this.Er += 11 + t, new o.ExternalAddress(e, t)
          }
          kr(t, e) {
            if (BigInt(Number.MAX_SAFE_INTEGER) < t || t < BigInt(Number.MIN_SAFE_INTEGER)) throw new TypeError(`${t} is out of safe integer range. Use ${e} instead`);
            return +t
          }
        }
        e.BitReader = s
      },
      53721: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.base32Decode = e.base32Encode = void 0;
        const i = "abcdefghijklmnopqrstuvwxyz234567";

        function o(t, e) {
          const r = t.indexOf(e);
          if (-1 === r) throw Error("Invalid character found: " + e);
          return r
        }
        e.base32Encode = function(t) {
          const e = t.byteLength;
          let r = 0,
            n = 0,
            o = "";
          for (let s = 0; e > s; s++)
            for (n = n << 8 | t[s], r += 8; r >= 5;) o += i[n >>> r - 5 & 31], r -= 5;
          return r > 0 && (o += i[n << 5 - r & 31]), o
        }, e.base32Decode = function(t) {
          let e;
          e = t.toLowerCase();
          const {
            length: r
          } = e;
          let s = 0,
            a = 0,
            u = 0;
          const c = n.alloc(5 * r / 8 | 0);
          for (let t = 0; r > t; t++) a = a << 5 | o(i, e[t]), s += 5, s >= 8 && (c[u++] = a >>> s - 8 & 255, s -= 8);
          return c
        }
      },
      53832: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.has(t.toUpperCase())
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = new Set(["AFG", "ALA", "ALB", "DZA", "ASM", "AND", "AGO", "AIA", "ATA", "ATG", "ARG", "ARM", "ABW", "AUS", "AUT", "AZE", "BHS", "BHR", "BGD", "BRB", "BLR", "BEL", "BLZ", "BEN", "BMU", "BTN", "BOL", "BES", "BIH", "BWA", "BVT", "BRA", "IOT", "BRN", "BGR", "BFA", "BDI", "KHM", "CMR", "CAN", "CPV", "CYM", "CAF", "TCD", "CHL", "CHN", "CXR", "CCK", "COL", "COM", "COG", "COD", "COK", "CRI", "CIV", "HRV", "CUB", "CUW", "CYP", "CZE", "DNK", "DJI", "DMA", "DOM", "ECU", "EGY", "SLV", "GNQ", "ERI", "EST", "ETH", "FLK", "FRO", "FJI", "FIN", "FRA", "GUF", "PYF", "ATF", "GAB", "GMB", "GEO", "DEU", "GHA", "GIB", "GRC", "GRL", "GRD", "GLP", "GUM", "GTM", "GGY", "GIN", "GNB", "GUY", "HTI", "HMD", "VAT", "HND", "HKG", "HUN", "ISL", "IND", "IDN", "IRN", "IRQ", "IRL", "IMN", "ISR", "ITA", "JAM", "JPN", "JEY", "JOR", "KAZ", "KEN", "KIR", "PRK", "KOR", "KWT", "KGZ", "LAO", "LVA", "LBN", "LSO", "LBR", "LBY", "LIE", "LTU", "LUX", "MAC", "MKD", "MDG", "MWI", "MYS", "MDV", "MLI", "MLT", "MHL", "MTQ", "MRT", "MUS", "MYT", "MEX", "FSM", "MDA", "MCO", "MNG", "MNE", "MSR", "MAR", "MOZ", "MMR", "NAM", "NRU", "NPL", "NLD", "NCL", "NZL", "NIC", "NER", "NGA", "NIU", "NFK", "MNP", "NOR", "OMN", "PAK", "PLW", "PSE", "PAN", "PNG", "PRY", "PER", "PHL", "PCN", "POL", "PRT", "PRI", "QAT", "REU", "ROU", "RUS", "RWA", "BLM", "SHN", "KNA", "LCA", "MAF", "SPM", "VCT", "WSM", "SMR", "STP", "SAU", "SEN", "SRB", "SYC", "SLE", "SGP", "SXM", "SVK", "SVN", "SLB", "SOM", "ZAF", "SGS", "SSD", "ESP", "LKA", "SDN", "SUR", "SJM", "SWZ", "SWE", "CHE", "SYR", "TWN", "TJK", "TZA", "THA", "TLS", "TGO", "TKL", "TON", "TTO", "TUN", "TUR", "TKM", "TCA", "TUV", "UGA", "UKR", "ARE", "GBR", "USA", "UMI", "URY", "UZB", "VUT", "VEN", "VNM", "VGB", "VIR", "WLF", "ESH", "YEM", "ZMB", "ZWE"]);
        t.exports = e.default, t.exports.default = e.default
      },
      53857: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionComputePhase = e.loadTransactionComputePhase = void 0;
        const n = r(65871),
          i = r(93471);
        e.loadTransactionComputePhase = function(t) {
          if (!t.loadBit()) return {
            type: "skipped",
            reason: (0, i.loadComputeSkipReason)(t)
          };
          let e = t.loadBit(),
            r = t.loadBit(),
            n = t.loadBit(),
            o = t.loadCoins();
          const s = t.loadRef().beginParse();
          return {
            type: "vm",
            success: e,
            messageStateUsed: r,
            accountActivated: n,
            gasFees: o,
            gasUsed: s.loadVarUintBig(3),
            gasLimit: s.loadVarUintBig(3),
            gasCredit: s.loadBit() ? s.loadVarUintBig(2) : void 0,
            mode: s.loadUint(8),
            exitCode: s.loadInt(32),
            exitArg: s.loadBit() ? s.loadInt(32) : void 0,
            vmSteps: s.loadUint(32),
            vmInitStateHash: s.loadUintBig(256),
            vmFinalStateHash: s.loadUintBig(256)
          }
        }, e.storeTransactionComputePhase = function(t) {
          return e => {
            if ("skipped" === t.type) return e.storeBit(0), void e.store((0, i.storeComputeSkipReason)(t.reason));
            e.storeBit(1), e.storeBit(t.success), e.storeBit(t.messageStateUsed), e.storeBit(t.accountActivated), e.storeCoins(t.gasFees), e.storeRef((0, n.beginCell)().storeVarUint(t.gasUsed, 3).storeVarUint(t.gasLimit, 3).store(e => void 0 !== t.gasCredit && null !== t.gasCredit ? e.storeBit(1).storeVarUint(t.gasCredit, 2) : e.storeBit(0)).storeUint(t.mode, 8).storeInt(t.exitCode, 32).store(e => void 0 !== t.exitArg && null !== t.exitArg ? e.storeBit(1).storeInt(t.exitArg, 32) : e.storeBit(0)).storeUint(t.vmSteps, 32).storeUint(t.vmInitStateHash, 256).storeUint(t.vmFinalStateHash, 256).endCell())
          }
        }
      },
      53908: (t, e, r) => {
        const n = r(57272),
          {
            MAX_LENGTH: i,
            MAX_SAFE_INTEGER: o
          } = r(16874),
          {
            safeRe: s,
            safeSrc: a,
            t: u
          } = r(99718),
          c = r(98587),
          {
            compareIdentifiers: f
          } = r(61123);
        class l {
          constructor(t, e) {
            if (e = c(e), t instanceof l) {
              if (t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease) return t;
              t = t.version
            } else if ("string" != typeof t) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
            if (t.length > i) throw new TypeError(`version is longer than ${i} characters`);
            n("SemVer", t, e), this.options = e, this.loose = !!e.loose, this.includePrerelease = !!e.includePrerelease;
            const r = t.trim().match(e.loose ? s[u.LOOSE] : s[u.FULL]);
            if (!r) throw new TypeError("Invalid Version: " + t);
            if (this.raw = t, this.major = +r[1], this.minor = +r[2], this.patch = +r[3], this.major > o || 0 > this.major) throw new TypeError("Invalid major version");
            if (this.minor > o || 0 > this.minor) throw new TypeError("Invalid minor version");
            if (this.patch > o || 0 > this.patch) throw new TypeError("Invalid patch version");
            r[4] ? this.prerelease = r[4].split(".").map(t => {
              if (/^[0-9]+$/.test(t)) {
                const e = +t;
                if (e >= 0 && o > e) return e
              }
              return t
            }) : this.prerelease = [], this.build = r[5] ? r[5].split(".") : [], this.format()
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += "-" + this.prerelease.join(".")), this.version
          }
          toString() {
            return this.version
          }
          compare(t) {
            if (n("SemVer.compare", this.version, this.options, t), !(t instanceof l)) {
              if ("string" == typeof t && t === this.version) return 0;
              t = new l(t, this.options)
            }
            return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t)
          }
          compareMain(t) {
            return t instanceof l || (t = new l(t, this.options)), f(this.major, t.major) || f(this.minor, t.minor) || f(this.patch, t.patch)
          }
          comparePre(t) {
            if (t instanceof l || (t = new l(t, this.options)), this.prerelease.length && !t.prerelease.length) return -1;
            if (!this.prerelease.length && t.prerelease.length) return 1;
            if (!this.prerelease.length && !t.prerelease.length) return 0;
            let e = 0;
            do {
              const r = this.prerelease[e],
                i = t.prerelease[e];
              if (n("prerelease compare", e, r, i), void 0 === r && void 0 === i) return 0;
              if (void 0 === i) return 1;
              if (void 0 === r) return -1;
              if (r !== i) return f(r, i)
            } while (++e)
          }
          compareBuild(t) {
            t instanceof l || (t = new l(t, this.options));
            let e = 0;
            do {
              const r = this.build[e],
                i = t.build[e];
              if (n("build compare", e, r, i), void 0 === r && void 0 === i) return 0;
              if (void 0 === i) return 1;
              if (void 0 === r) return -1;
              if (r !== i) return f(r, i)
            } while (++e)
          }
          inc(t, e, r) {
            if (t.startsWith("pre")) {
              if (!e && !1 === r) throw Error("invalid increment argument: identifier is empty");
              if (e) {
                const t = RegExp(`^${this.options.loose?a[u.PRERELEASELOOSE]:a[u.PRERELEASE]}$`),
                  r = ("-" + e).match(t);
                if (!r || r[1] !== e) throw Error("invalid identifier: " + e)
              }
            }
            switch (t) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e, r);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e, r);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", e, r), this.inc("pre", e, r);
                break;
              case "prerelease":
                0 === this.prerelease.length && this.inc("patch", e, r), this.inc("pre", e, r);
                break;
              case "release":
                if (0 === this.prerelease.length) throw Error(`version ${this.raw} is not a prerelease`);
                this.prerelease.length = 0;
                break;
              case "major":
                (0 !== this.minor || 0 !== this.patch || 0 === this.prerelease.length) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                (0 !== this.patch || 0 === this.prerelease.length) && this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const t = +r ? 1 : 0;
                if (0 === this.prerelease.length) this.prerelease = [t];
                else {
                  let n = this.prerelease.length;
                  for (; --n >= 0;) "number" == typeof this.prerelease[n] && (this.prerelease[n]++, n = -2);
                  if (-1 === n) {
                    if (e === this.prerelease.join(".") && !1 === r) throw Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(t)
                  }
                }
                if (e) {
                  let n = [e, t];
                  !1 === r && (n = [e]), 0 === f(this.prerelease[0], e) ? isNaN(this.prerelease[1]) && (this.prerelease = n) : this.prerelease = n
                }
                break
              }
              default:
                throw Error("invalid increment argument: " + t)
            }
            return this.raw = this.format(), this.build.length && (this.raw += "+" + this.build.join(".")), this
          }
        }
        t.exports = l
      },
      54050: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.HashMD = e.Maj = e.Chi = void 0;
        const n = r(28021),
          i = r(17412);
        e.Chi = (t, e, r) => t & e ^ ~t & r, e.Maj = (t, e, r) => t & e ^ t & r ^ e & r;
        class o extends i.Hash {
          constructor(t, e, r, n) {
            super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = (0, i.createView)(this.buffer)
          }
          update(t) {
            (0, n.exists)(this);
            const {
              view: e,
              buffer: r,
              blockLen: o
            } = this, s = (t = (0, i.toBytes)(t)).length;
            for (let n = 0; s > n;) {
              const a = Math.min(o - this.pos, s - n);
              if (a === o) {
                const e = (0, i.createView)(t);
                for (; s - n >= o; n += o) this.process(e, n);
                continue
              }
              r.set(t.subarray(n, n + a), this.pos), this.pos += a, n += a, this.pos === o && (this.process(e, 0), this.pos = 0)
            }
            return this.length += t.length, this.roundClean(), this
          }
          digestInto(t) {
            (0, n.exists)(this), (0, n.output)(t, this), this.finished = !0;
            const {
              buffer: e,
              view: r,
              blockLen: o,
              isLE: s
            } = this;
            let {
              pos: a
            } = this;
            e[a++] = 128, this.buffer.subarray(a).fill(0), this.padOffset > o - a && (this.process(r, 0), a = 0);
            for (let t = a; o > t; t++) e[t] = 0;
            (function(t, e, r, n) {
              if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, r, n);
              const i = BigInt(32),
                o = BigInt(4294967295),
                s = +(r >> i & o),
                a = +(r & o),
                u = n ? 4 : 0,
                c = n ? 0 : 4;
              t.setUint32(e + u, s, n), t.setUint32(e + c, a, n)
            })(r, o - 8, BigInt(8 * this.length), s), this.process(r, 0);
            const u = (0, i.createView)(t),
              c = this.outputLen;
            if (c % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
            const f = c / 4,
              l = this.get();
            if (f > l.length) throw Error("_sha2: outputLen bigger than state");
            for (let t = 0; f > t; t++) u.setUint32(4 * t, l[t], s)
          }
          digest() {
            const {
              buffer: t,
              outputLen: e
            } = this;
            this.digestInto(t);
            const r = t.slice(0, e);
            return this.destroy(), r
          }
          jt(t) {
            t || (t = new this.constructor), t.set(...this.get());
            const {
              blockLen: e,
              buffer: r,
              length: n,
              finished: i,
              destroyed: o,
              pos: s
            } = this;
            return t.length = n, t.pos = s, t.finished = i, t.destroyed = o, n % e && t.buffer.set(r), t
          }
        }
        e.HashMD = o
      },
      54089: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => n(t, e, r) >= 0
      },
      54674: t => {
        "use strict";
        t.exports = {
          2: "need dictionary",
          1: "stream end",
          0: "",
          "-1": "file error",
          "-2": "stream error",
          "-3": "data error",
          "-4": "insufficient memory",
          "-5": "buffer error",
          "-6": "incompatible version"
        }
      },
      55121: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ComputeError = void 0;
        class r extends Error {
          constructor(t, e, n) {
            super(t), this.exitCode = e, this.debugLogs = n && n.debugLogs ? n.debugLogs : null, this.logs = n && n.logs ? n.logs : null, Object.setPrototypeOf(this, r.prototype)
          }
        }
        e.ComputeError = r
      },
      55157: t => {
        t.exports = function() {
          throw Error("Readable.from is not available in the browser")
        }
      },
      55259: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, i.default)(t);
          var e = t.slice(4, 6).toUpperCase();
          return !(!o.CountryCodes.has(e) && "XK" !== e) && s.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(88447),
          s = /^[A-Za-z]{6}[A-Za-z0-9]{2}([A-Za-z0-9]{3})?$/;
        t.exports = e.default, t.exports.default = e.default
      },
      55366: (t, e, r) => {
        "use strict";

        function n(t) {
          return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, o.default)(t), (0, o.default)(e), e in u) return u[e](t);
          throw Error("Invalid country code: '".concat(e, "'"))
        }, e.vatMatchers = void 0;
        var i, o = (i = r(83399)) && i._ ? i : {
            default: i
          },
          s = function(t) {
            if (t && t._) return t;
            if (null === t || "object" !== n(t) && "function" != typeof t) return {
              default: t
            };
            var e = a();
            if (e && e.has(t)) return e.get(t);
            var r = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in t)
              if ({}.hasOwnProperty.call(t, o)) {
                var s = i ? Object.getOwnPropertyDescriptor(t, o) : null;
                s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = t[o]
              } return r.default = t, e && e.set(t, r), r
          }(r(44834));

        function a() {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap;
          return a = function() {
            return t
          }, t
        }
        var u = {
          AT: function(t) {
            return /^(AT)?U\d{8}$/.test(t)
          },
          BE: function(t) {
            return /^(BE)?\d{10}$/.test(t)
          },
          BG: function(t) {
            return /^(BG)?\d{9,10}$/.test(t)
          },
          HR: function(t) {
            return /^(HR)?\d{11}$/.test(t)
          },
          CY: function(t) {
            return /^(CY)?\w{9}$/.test(t)
          },
          CZ: function(t) {
            return /^(CZ)?\d{8,10}$/.test(t)
          },
          DK: function(t) {
            return /^(DK)?\d{8}$/.test(t)
          },
          EE: function(t) {
            return /^(EE)?\d{9}$/.test(t)
          },
          FI: function(t) {
            return /^(FI)?\d{8}$/.test(t)
          },
          FR: function(t) {
            return /^(FR)?\w{2}\d{9}$/.test(t)
          },
          DE: function(t) {
            return /^(DE)?\d{9}$/.test(t)
          },
          EL: function(t) {
            return /^(EL)?\d{9}$/.test(t)
          },
          HU: function(t) {
            return /^(HU)?\d{8}$/.test(t)
          },
          IE: function(t) {
            return /^(IE)?\d{7}\w{1}(W)?$/.test(t)
          },
          IT: function(t) {
            return /^(IT)?\d{11}$/.test(t)
          },
          LV: function(t) {
            return /^(LV)?\d{11}$/.test(t)
          },
          LT: function(t) {
            return /^(LT)?\d{9,12}$/.test(t)
          },
          LU: function(t) {
            return /^(LU)?\d{8}$/.test(t)
          },
          MT: function(t) {
            return /^(MT)?\d{8}$/.test(t)
          },
          NL: function(t) {
            return /^(NL)?\d{9}B\d{2}$/.test(t)
          },
          PL: function(t) {
            return /^(PL)?(\d{10}|(\d{3}-\d{3}-\d{2}-\d{2})|(\d{3}-\d{2}-\d{2}-\d{3}))$/.test(t)
          },
          PT: function(t) {
            var e = t.match(/^(PT)?(\d{9})$/);
            if (!e) return !1;
            var r = e[2],
              n = 11 - s.reverseMultiplyAndSum(r.split("").slice(0, 8).map(function(t) {
                return parseInt(t, 10)
              }), 9) % 11;
            return n > 9 ? 0 === parseInt(r[8], 10) : n === parseInt(r[8], 10)
          },
          RO: function(t) {
            return /^(RO)?\d{2,10}$/.test(t)
          },
          SK: function(t) {
            return /^(SK)?\d{10}$/.test(t)
          },
          SI: function(t) {
            return /^(SI)?\d{8}$/.test(t)
          },
          ES: function(t) {
            return /^(ES)?\w\d{7}[A-Z]$/.test(t)
          },
          SE: function(t) {
            return /^(SE)?\d{12}$/.test(t)
          },
          AL: function(t) {
            return /^(AL)?\w{9}[A-Z]$/.test(t)
          },
          MK: function(t) {
            return /^(MK)?\d{13}$/.test(t)
          },
          AU: function(t) {
            return /^(AU)?\d{11}$/.test(t)
          },
          BY: function(t) {
            return /^( )?\d{9}$/.test(t)
          },
          CA: function(t) {
            return /^(CA)?\d{9}$/.test(t)
          },
          IS: function(t) {
            return /^(IS)?\d{5,6}$/.test(t)
          },
          IN: function(t) {
            return /^(IN)?\d{15}$/.test(t)
          },
          ID: function(t) {
            return /^(ID)?(\d{15}|(\d{2}.\d{3}.\d{3}.\d{1}-\d{3}.\d{3}))$/.test(t)
          },
          IL: function(t) {
            return /^(IL)?\d{9}$/.test(t)
          },
          KZ: function(t) {
            return /^(KZ)?\d{9}$/.test(t)
          },
          NZ: function(t) {
            return /^(NZ)?\d{9}$/.test(t)
          },
          NG: function(t) {
            return /^(NG)?(\d{12}|(\d{8}-\d{4}))$/.test(t)
          },
          NO: function(t) {
            return /^(NO)?\d{9}MVA$/.test(t)
          },
          PH: function(t) {
            return /^(PH)?(\d{12}|\d{3} \d{3} \d{3} \d{3})$/.test(t)
          },
          RU: function(t) {
            return /^(RU)?(\d{10}|\d{12})$/.test(t)
          },
          SM: function(t) {
            return /^(SM)?\d{5}$/.test(t)
          },
          SA: function(t) {
            return /^(SA)?\d{15}$/.test(t)
          },
          RS: function(t) {
            return /^(RS)?\d{9}$/.test(t)
          },
          CH: function(t) {
            var e, r, n;
            return /^(CHE[- ]?)?(\d{9}|(\d{3}\.\d{3}\.\d{3})|(\d{3} \d{3} \d{3})) ?(TVA|MWST|IVA)?$/.test(t) && (r = (e = t.match(/\d/g).map(function(t) {
              return +t
            })).pop(), n = [5, 4, 3, 2, 7, 6, 5, 4], r === (11 - e.reduce(function(t, e, r) {
              return t + e * n[r]
            }, 0) % 11) % 11)
          },
          TR: function(t) {
            return /^(TR)?\d{10}$/.test(t)
          },
          UA: function(t) {
            return /^(UA)?\d{12}$/.test(t)
          },
          GB: function(t) {
            return /^GB((\d{3} \d{4} ([0-8][0-9]|9[0-6]))|(\d{9} \d{3})|(((GD[0-4])|(HA[5-9]))[0-9]{2}))$/.test(t)
          },
          UZ: function(t) {
            return /^(UZ)?\d{9}$/.test(t)
          },
          AR: function(t) {
            return /^(AR)?\d{11}$/.test(t)
          },
          BO: function(t) {
            return /^(BO)?\d{7}$/.test(t)
          },
          BR: function(t) {
            return /^(BR)?((\d{2}.\d{3}.\d{3}\/\d{4}-\d{2})|(\d{3}.\d{3}.\d{3}-\d{2}))$/.test(t)
          },
          CL: function(t) {
            return /^(CL)?\d{8}-\d{1}$/.test(t)
          },
          CO: function(t) {
            return /^(CO)?\d{10}$/.test(t)
          },
          CR: function(t) {
            return /^(CR)?\d{9,12}$/.test(t)
          },
          EC: function(t) {
            return /^(EC)?\d{13}$/.test(t)
          },
          SV: function(t) {
            return /^(SV)?\d{4}-\d{6}-\d{3}-\d{1}$/.test(t)
          },
          GT: function(t) {
            return /^(GT)?\d{7}-\d{1}$/.test(t)
          },
          HN: function(t) {
            return /^(HN)?$/.test(t)
          },
          MX: function(t) {
            return /^(MX)?\w{3,4}\d{6}\w{3}$/.test(t)
          },
          NI: function(t) {
            return /^(NI)?\d{3}-\d{6}-\d{4}\w{1}$/.test(t)
          },
          PA: function(t) {
            return /^(PA)?$/.test(t)
          },
          PY: function(t) {
            return /^(PY)?\d{6,8}-\d{1}$/.test(t)
          },
          PE: function(t) {
            return /^(PE)?\d{11}$/.test(t)
          },
          DO: function(t) {
            return /^(DO)?(\d{11}|(\d{3}-\d{7}-\d{1})|[1,4,5]{1}\d{8}|([1,4,5]{1})-\d{2}-\d{5}-\d{1})$/.test(t)
          },
          UY: function(t) {
            return /^(UY)?\d{12}$/.test(t)
          },
          VE: function(t) {
            return /^(VE)?[J,G,V,E]{1}-(\d{9}|(\d{8}-\d{1}))$/.test(t)
          }
        };
        e.vatMatchers = u
      },
      55373: (t, e, r) => {
        "use strict";
        var n = r(98636),
          i = r(62642),
          o = r(74765);
        t.exports = {
          formats: o,
          parse: i,
          stringify: n
        }
      },
      55411: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.JettonWallet = void 0;
        class r {
          static create(t) {
            return new r(t)
          }
          constructor(t) {
            this.address = t
          }
          async getBalance(t) {
            return "active" !== (await t.getState()).state.type ? 0n : (await t.get("get_wallet_data", [])).stack.readBigNumber()
          }
        }
        e.JettonWallet = r
      },
      55537: (t, e, r) => {
        var n = r(48287).Buffer,
          i = r(65606),
          o = r(6688),
          s = r(56698),
          a = r(6917),
          u = r(28399),
          c = a.IncomingMessage,
          f = a.readyStates,
          l = t.exports = function(t) {
            var e = this;
            u.Writable.call(e), e.Wr = t, e.Mr = [], e.Cr = {}, t.auth && e.setHeader("Authorization", "Basic " + n.from(t.auth).toString("base64")), Object.keys(t.headers).forEach(function(r) {
              e.setHeader(r, t.headers[r])
            });
            var r, i = !0;
            if ("disable-fetch" === t.mode || "requestTimeout" in t && !o.abortController) i = !1, r = !0;
            else if ("prefer-streaming" === t.mode) r = !1;
            else if ("allow-wrong-content-type" === t.mode) r = !o.overrideMimeType;
            else {
              if (t.mode && "default" !== t.mode && "prefer-fast" !== t.mode) throw Error("Invalid value for opts.mode");
              r = !0
            }
            e.vt = function(t, e) {
              return o.fetch && e ? "fetch" : o.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : o.msstream ? "ms-stream" : o.arraybuffer && t ? "arraybuffer" : "text"
            }(r, i), e.Rr = null, e.Nr = null, e.jr = null, e.on("finish", function() {
              e._r()
            })
          };
        s(l, u.Writable), l.prototype.setHeader = function(t, e) {
          var r = t.toLowerCase(); - 1 === h.indexOf(r) && (this.Cr[r] = {
            name: t,
            value: e
          })
        }, l.prototype.getHeader = function(t) {
          var e = this.Cr[t.toLowerCase()];
          return e ? e.value : null
        }, l.prototype.removeHeader = function(t) {
          delete this.Cr[t.toLowerCase()]
        }, l.prototype._r = function() {
          var t = this;
          if (!t.wt) {
            var e = t.Wr;
            "timeout" in e && 0 !== e.timeout && t.setTimeout(e.timeout);
            var n = t.Cr,
              s = null;
            "GET" !== e.method && "HEAD" !== e.method && (s = new Blob(t.Mr, {
              type: (n["content-type"] || {}).value || ""
            }));
            var a = [];
            if (Object.keys(n).forEach(function(t) {
                var e = n[t].name,
                  r = n[t].value;
                Array.isArray(r) ? r.forEach(function(t) {
                  a.push([e, t])
                }) : a.push([e, r])
              }), "fetch" === t.vt) {
              var u = null;
              if (o.abortController) {
                var c = new AbortController;
                u = c.signal, t.Dr = c, "requestTimeout" in e && 0 !== e.requestTimeout && (t.Rr = r.g.setTimeout(function() {
                  t.emit("requestTimeout"), t.Dr && t.Dr.abort()
                }, e.requestTimeout))
              }
              r.g.fetch(t.Wr.url, {
                method: t.Wr.method,
                headers: a,
                body: s || void 0,
                mode: "cors",
                credentials: e.withCredentials ? "include" : "same-origin",
                signal: u
              }).then(function(e) {
                t.At = e, t.Ur(!1), t.Lr()
              }, function(e) {
                t.Ur(!0), t.wt || t.emit("error", e)
              })
            } else {
              var l = t.Et = new r.g.XMLHttpRequest;
              try {
                l.open(t.Wr.method, t.Wr.url, !0)
              } catch (e) {
                return void i.nextTick(function() {
                  t.emit("error", e)
                })
              }
              "responseType" in l && (l.responseType = t.vt), "withCredentials" in l && (l.withCredentials = !!e.withCredentials), "text" === t.vt && "overrideMimeType" in l && l.overrideMimeType("text/plain; charset=x-user-defined"), "requestTimeout" in e && (l.timeout = e.requestTimeout, l.ontimeout = function() {
                t.emit("requestTimeout")
              }), a.forEach(function(t) {
                l.setRequestHeader(t[0], t[1])
              }), t.Fr = null, l.onreadystatechange = function() {
                switch (l.readyState) {
                  case f.LOADING:
                  case f.DONE:
                    t.It()
                }
              }, "moz-chunked-arraybuffer" === t.vt && (l.onprogress = function() {
                t.It()
              }), l.onerror = function() {
                t.wt || (t.Ur(!0), t.emit("error", Error("XHR error")))
              };
              try {
                l.send(s)
              } catch (e) {
                return void i.nextTick(function() {
                  t.emit("error", e)
                })
              }
            }
          }
        }, l.prototype.It = function() {
          var t = this;
          t.Ur(!1),
            function(t) {
              try {
                var e = t.status;
                return null !== e && 0 !== e
              } catch {
                return !1
              }
            }(t.Et) && !t.wt && (t.Fr || t.Lr(), t.Fr.It(t.Ur.bind(t)))
        }, l.prototype.Lr = function() {
          var t = this;
          t.wt || (t.Fr = new c(t.Et, t.At, t.vt, t.Ur.bind(t)), t.Fr.on("error", function(e) {
            t.emit("error", e)
          }), t.emit("response", t.Fr))
        }, l.prototype.it = function(t, e, r) {
          this.Mr.push(t), r()
        }, l.prototype.Ur = function(t) {
          var e = this;
          r.g.clearTimeout(e.jr), e.jr = null, t ? (r.g.clearTimeout(e.Rr), e.Rr = null) : e.Nr && (e.jr = r.g.setTimeout(function() {
            e.emit("timeout")
          }, e.Nr))
        }, l.prototype.abort = l.prototype.destroy = function(t) {
          var e = this;
          e.wt = !0, e.Ur(!0), e.Fr && (e.Fr.wt = !0), e.Et ? e.Et.abort() : e.Dr && e.Dr.abort(), t && e.emit("error", t)
        }, l.prototype.end = function(t, e, r) {
          "function" == typeof t && (r = t, t = void 0), u.Writable.prototype.end.call(this, t, e, r)
        }, l.prototype.setTimeout = function(t, e) {
          var r = this;
          e && r.once("timeout", e), r.Nr = t, r.Ur(!1)
        }, l.prototype.flushHeaders = function() {}, l.prototype.setNoDelay = function() {}, l.prototype.setSocketKeepAlive = function() {};
        var h = ["accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via"]
      },
      55730: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          var r = t.join("");
          return RegExp(r, e)
        }, t.exports = e.default, t.exports.default = e.default
      },
      56224: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha512 = e.sha512_fallback = e.sha512_sync = void 0;
        const o = i(r(68343)),
          s = r(32370);

        function a(t) {
          let e;
          e = "string" == typeof t ? n.from(t, "utf-8").toString("hex") : t.toString("hex");
          let r = new o.default("SHA-512", "HEX");
          r.update(e);
          let i = r.getHash("HEX");
          return n.from(i, "hex")
        }
        e.sha512_sync = a, e.sha512_fallback = async function(t) {
          return a(t)
        }, e.sha512 = async function(t) {
          return (0, s.sha512)(t)
        }
      },
      56622: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.newSecureWords = void 0;
        const n = r(51682),
          i = r(20706);
        e.newSecureWords = async function(t = 6) {
          let e = [];
          for (let r = 0; t > r; r++) e.push(i.wordlist[await (0, n.getSecureRandomNumber)(0, i.wordlist.length)]);
          return e
        }
      },
      56698: t => {
        t.exports = "function" == typeof Object.create ? function(t, e) {
          e && (t.super_ = e, t.prototype = Object.create(e.prototype, {
            constructor: {
              value: t,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }))
        } : function(t, e) {
          if (e) {
            t.super_ = e;
            var r = function() {};
            r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
          }
        }
      },
      56906: function(t, e, r) {
        "use strict";
        var n, i = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Slice = void 0;
        const o = i(r(29107)),
          s = r(97590),
          a = r(65871),
          u = r(49556);
        class c {
          constructor(t, e) {
            this[n] = () => this.toString(), this.$r = t.clone(), this.zr = [...e], this.Hr = 0
          }
          get remainingBits() {
            return this.$r.remaining
          }
          get offsetBits() {
            return this.$r.offset
          }
          get remainingRefs() {
            return this.zr.length - this.Hr
          }
          get offsetRefs() {
            return this.Hr
          }
          skip(t) {
            return this.$r.skip(t), this
          }
          loadBit() {
            return this.$r.loadBit()
          }
          preloadBit() {
            return this.$r.preloadBit()
          }
          loadBoolean() {
            return this.loadBit()
          }
          loadMaybeBoolean() {
            return this.loadBit() ? this.loadBoolean() : null
          }
          loadBits(t) {
            return this.$r.loadBits(t)
          }
          preloadBits(t) {
            return this.$r.preloadBits(t)
          }
          loadUint(t) {
            return this.$r.loadUint(t)
          }
          loadUintBig(t) {
            return this.$r.loadUintBig(t)
          }
          preloadUint(t) {
            return this.$r.preloadUint(t)
          }
          preloadUintBig(t) {
            return this.$r.preloadUintBig(t)
          }
          loadMaybeUint(t) {
            return this.loadBit() ? this.loadUint(t) : null
          }
          loadMaybeUintBig(t) {
            return this.loadBit() ? this.loadUintBig(t) : null
          }
          loadInt(t) {
            return this.$r.loadInt(t)
          }
          loadIntBig(t) {
            return this.$r.loadIntBig(t)
          }
          preloadInt(t) {
            return this.$r.preloadInt(t)
          }
          preloadIntBig(t) {
            return this.$r.preloadIntBig(t)
          }
          loadMaybeInt(t) {
            return this.loadBit() ? this.loadInt(t) : null
          }
          loadMaybeIntBig(t) {
            return this.loadBit() ? this.loadIntBig(t) : null
          }
          loadVarUint(t) {
            return this.$r.loadVarUint(t)
          }
          loadVarUintBig(t) {
            return this.$r.loadVarUintBig(t)
          }
          preloadVarUint(t) {
            return this.$r.preloadVarUint(t)
          }
          preloadVarUintBig(t) {
            return this.$r.preloadVarUintBig(t)
          }
          loadVarInt(t) {
            return this.$r.loadVarInt(t)
          }
          loadVarIntBig(t) {
            return this.$r.loadVarIntBig(t)
          }
          preloadVarInt(t) {
            return this.$r.preloadVarInt(t)
          }
          preloadVarIntBig(t) {
            return this.$r.preloadVarIntBig(t)
          }
          loadCoins() {
            return this.$r.loadCoins()
          }
          preloadCoins() {
            return this.$r.preloadCoins()
          }
          loadMaybeCoins() {
            return this.$r.loadBit() ? this.$r.loadCoins() : null
          }
          loadAddress() {
            return this.$r.loadAddress()
          }
          loadMaybeAddress() {
            return this.$r.loadMaybeAddress()
          }
          loadExternalAddress() {
            return this.$r.loadExternalAddress()
          }
          loadMaybeExternalAddress() {
            return this.$r.loadMaybeExternalAddress()
          }
          loadAddressAny() {
            return this.$r.loadAddressAny()
          }
          loadRef() {
            if (this.Hr >= this.zr.length) throw Error("No more references");
            return this.zr[this.Hr++]
          }
          preloadRef() {
            if (this.Hr >= this.zr.length) throw Error("No more references");
            return this.zr[this.Hr]
          }
          loadMaybeRef() {
            return this.loadBit() ? this.loadRef() : null
          }
          preloadMaybeRef() {
            return this.preloadBit() ? this.preloadRef() : null
          }
          loadBuffer(t) {
            return this.$r.loadBuffer(t)
          }
          preloadBuffer(t) {
            return this.$r.preloadBuffer(t)
          }
          loadStringTail() {
            return (0, u.readString)(this)
          }
          loadMaybeStringTail() {
            return this.loadBit() ? (0, u.readString)(this) : null
          }
          loadStringRefTail() {
            return (0, u.readString)(this.loadRef().beginParse())
          }
          loadMaybeStringRefTail() {
            const t = this.loadMaybeRef();
            return t ? (0, u.readString)(t.beginParse()) : null
          }
          loadDict(t, e) {
            return s.Dictionary.load(t, e, this)
          }
          loadDictDirect(t, e) {
            return s.Dictionary.loadDirect(t, e, this)
          }
          endParse() {
            if (this.remainingBits > 0 || this.remainingRefs > 0) throw Error("Slice is not empty")
          }
          asCell() {
            return (0, a.beginCell)().storeSlice(this).endCell()
          }
          asBuilder() {
            return (0, a.beginCell)().storeSlice(this)
          }
          clone(t = !1) {
            if (t) {
              let t = this.$r.clone();
              return t.reset(), new c(t, this.zr)
            } {
              let t = new c(this.$r, this.zr);
              return t.Hr = this.Hr, t
            }
          }
          toString() {
            return this.asCell().toString()
          }
        }
        e.Slice = c, n = o.default
      },
      56953: (t, e, r) => {
        const n = r(30144);
        t.exports = (t, e) => {
          const r = n(t, e);
          return r ? r.version : null
        }
      },
      57017: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.configParseMasterAddress = i, e.parseValidatorSet = a, e.parseBridge = u, e.configParseMasterAddressRequired = c, e.configParse5 = f, e.configParse13 = function(t) {
          if (!t) throw Error("Invalid config");
          if (26 === t.loadUint(8)) return {
            deposit: t.loadCoins(),
            bitPrice: t.loadCoins(),
            cellPrice: t.loadCoins()
          };
          throw Error("Invalid config")
        }, e.configParse15 = l, e.configParse16 = h, e.configParse17 = d, e.configParse18 = b, e.configParse8 = m, e.configParse40 = y, e.configParseWorkchainDescriptor = function(t) {
          if (166 !== t.loadUint(8)) throw Error("Invalid config");
          const e = t.loadUint(32),
            r = t.loadUint(8),
            n = t.loadUint(8),
            i = t.loadUint(8),
            o = t.loadBit(),
            s = t.loadBit(),
            a = t.loadBit(),
            u = t.loadUint(13),
            c = t.loadBuffer(32),
            f = t.loadBuffer(32),
            l = t.loadUint(32);
          if (t.loadBit()) throw Error("Invalid config");
          return {
            enabledSince: e,
            actialMinSplit: r,
            min_split: n,
            max_split: i,
            basic: o,
            active: s,
            accept_msgs: a,
            flags: u,
            zerostateRootHash: c,
            zerostateFileHash: f,
            version: l,
            format: {
              vmVersion: t.loadUint(32),
              vmMode: t.loadUintBig(64)
            }
          }
        }, e.configParse12 = v, e.configParseValidatorSet = w, e.configParseBridge = A, e.configParseGasLimitsPrices = T, e.configParseMsgPrices = E, e.configParse28 = P, e.configParse29 = k, e.parseProposalSetup = x, e.parseVotingSetup = I, e.loadConfigParamById = function(t, e) {
          return S(t).get(e)
        }, e.loadConfigParamsAsSlice = function(t) {
          const e = S(t),
            r = new Map;
          for (const [t, n] of e) r.set(t, n.beginParse());
          return r
        }, e.parseFullConfig = function(t) {
          return {
            configAddress: c(t.get(0)),
            electorAddress: c(t.get(1)),
            minterAddress: i(t.get(2)),
            feeCollectorAddress: i(t.get(3)),
            dnsRootAddress: i(t.get(4)),
            burningConfig: f(t.get(5)),
            globalVersion: m(t.get(8)),
            workchains: v(t.get(12)),
            voting: I(t.get(11)),
            validators: {
              ...l(t.get(15)),
              ...h(t.get(16)),
              ...d(t.get(17))
            },
            storagePrices: b(t.get(18)),
            gasPrices: {
              masterchain: T(t.get(20)),
              workchain: T(t.get(21))
            },
            msgPrices: {
              masterchain: E(t.get(24)),
              workchain: E(t.get(25))
            },
            validatorSets: {
              prevValidators: w(t.get(32)),
              prevTempValidators: w(t.get(33)),
              currentValidators: w(t.get(34)),
              currentTempValidators: w(t.get(35)),
              nextValidators: w(t.get(36)),
              nextTempValidators: w(t.get(37))
            },
            validatorsPunish: y(t.get(40)),
            bridges: {
              ethereum: A(t.get(71)),
              binance: A(t.get(72)),
              polygon: A(t.get(73))
            },
            catchain: P(t.get(28)),
            consensus: k(t.get(29))
          }
        };
        const n = r(1307);

        function i(t) {
          return t ? new n.Address(-1, t.loadBuffer(32)) : null
        }

        function o(t) {
          if (2390828938 !== t.loadUint(32)) throw Error("Invalid config");
          return t.loadBuffer(32)
        }
        const s = {
          serialize(t, e) {
            throw Error("not implemented")
          },
          parse(t) {
            const e = t.loadUint(8);
            if (83 === e) return {
              publicKey: o(t),
              weight: t.loadUintBig(64),
              adnlAddress: null
            };
            if (115 === e) return {
              publicKey: o(t),
              weight: t.loadUintBig(64),
              adnlAddress: t.loadBuffer(32)
            };
            throw Error("Invalid config")
          }
        };

        function a(t) {
          const e = t.loadUint(8);
          return 17 === e ? {
            timeSince: t.loadUint(32),
            timeUntil: t.loadUint(32),
            total: t.loadUint(16),
            main: t.loadUint(16),
            totalWeight: null,
            list: t.loadDictDirect(n.Dictionary.Keys.Uint(16), s)
          } : 18 === e ? {
            timeSince: t.loadUint(32),
            timeUntil: t.loadUint(32),
            total: t.loadUint(16),
            main: t.loadUint(16),
            totalWeight: t.loadUintBig(64),
            list: t.loadDict(n.Dictionary.Keys.Uint(16), s)
          } : void 0
        }

        function u(t) {
          const e = new n.Address(-1, t.loadBuffer(32)),
            r = new n.Address(-1, t.loadBuffer(32)),
            i = t.loadDict(n.Dictionary.Keys.Buffer(32), n.Dictionary.Values.Buffer(32)),
            o = new Map;
          for (const [t, e] of i) o.set(new n.Address(-1, t).toString(), e);
          return {
            bridgeAddress: e,
            oracleMultisigAddress: r,
            oracles: o,
            externalChainAddress: t.loadBuffer(32)
          }
        }

        function c(t) {
          if (!t) throw Error("Invalid config");
          return i(t)
        }

        function f(t) {
          if (!t) throw Error("Invalid config");
          if (1 === t.loadUint(8)) return {
            blackholeAddr: t.loadBit() ? new n.Address(-1, t.loadBuffer(32)) : null,
            feeBurnNominator: t.loadUint(32),
            feeBurnDenominator: t.loadUint(32)
          };
          throw Error("Invalid config")
        }

        function l(t) {
          if (!t) throw Error("Invalid config");
          return {
            validatorsElectedFor: t.loadUint(32),
            electorsStartBefore: t.loadUint(32),
            electorsEndBefore: t.loadUint(32),
            stakeHeldFor: t.loadUint(32)
          }
        }

        function h(t) {
          if (!t) throw Error("Invalid config");
          return {
            maxValidators: t.loadUint(16),
            maxMainValidators: t.loadUint(16),
            minValidators: t.loadUint(16)
          }
        }

        function d(t) {
          if (!t) throw Error("Invalid config");
          return {
            minStake: t.loadCoins(),
            maxStake: t.loadCoins(),
            minTotalStake: t.loadCoins(),
            maxStakeFactor: t.loadUint(32)
          }
        }
        const p = {
          serialize(t, e) {
            throw Error("not implemented")
          },
          parse(t) {
            if (204 !== t.loadUint(8)) throw Error("Invalid config");
            return {
              utime_since: t.loadUint(32),
              bit_price_ps: t.loadUintBig(64),
              cell_price_ps: t.loadUintBig(64),
              mc_bit_price_ps: t.loadUintBig(64),
              mc_cell_price_ps: t.loadUintBig(64)
            }
          }
        };

        function b(t) {
          if (!t) throw Error("Invalid config");
          return t.loadDictDirect(n.Dictionary.Keys.Buffer(4), p).values()
        }

        function m(t) {
          return t ? {
            version: t.loadUint(32),
            capabilities: t.loadUintBig(64)
          } : {
            version: 0,
            capabilities: 0n
          }
        }

        function y(t) {
          if (!t) return null;
          if (1 !== t.loadUint(8)) throw Error("Invalid config");
          return {
            defaultFlatFine: t.loadCoins(),
            defaultProportionaFine: t.loadCoins(),
            severityFlatMult: t.loadUint(16),
            severityProportionalMult: t.loadUint(16),
            unfunishableInterval: t.loadUint(16),
            longInterval: t.loadUint(16),
            longFlatMult: t.loadUint(16),
            longProportionalMult: t.loadUint(16),
            mediumInterval: t.loadUint(16),
            mediumFlatMult: t.loadUint(16),
            mediumProportionalMult: t.loadUint(16)
          }
        }
        const g = {
          serialize(t, e) {
            throw Error("not implemented")
          },
          parse(t) {
            if (166 !== t.loadUint(8)) throw Error("Invalid config");
            const e = t.loadUint(32),
              r = t.loadUint(8),
              n = t.loadUint(8),
              i = t.loadUint(8),
              o = t.loadBit(),
              s = t.loadBit(),
              a = t.loadBit(),
              u = t.loadUint(13),
              c = t.loadBuffer(32),
              f = t.loadBuffer(32),
              l = t.loadUint(32);
            if (t.loadBit()) throw Error("Invalid config");
            return {
              enabledSince: e,
              actialMinSplit: r,
              min_split: n,
              max_split: i,
              basic: o,
              active: s,
              accept_msgs: a,
              flags: u,
              zerostateRootHash: c,
              zerostateFileHash: f,
              version: l,
              format: {
                vmVersion: t.loadUint(32),
                vmMode: t.loadUintBig(64)
              }
            }
          }
        };

        function v(t) {
          if (!t) throw Error("Invalid config");
          const e = t.loadDict(n.Dictionary.Keys.Uint(32), g);
          if (e) return e;
          throw Error("No workchains exist")
        }

        function w(t) {
          return t ? a(t) : null
        }

        function A(t) {
          return t ? u(t) : null
        }

        function T(t) {
          if (!t) throw Error("Invalid config");
          if (209 === t.loadUint(8)) {
            const e = t.loadUintBig(64),
              r = t.loadUintBig(64),
              n = function(t) {
                const e = t.loadUint(8);
                if (222 === e) return {
                  gasPrice: t.loadUintBig(64),
                  gasLimit: t.loadUintBig(64),
                  specialGasLimit: t.loadUintBig(64),
                  gasCredit: t.loadUintBig(64),
                  blockGasLimit: t.loadUintBig(64),
                  freezeDueLimit: t.loadUintBig(64),
                  deleteDueLimit: t.loadUintBig(64)
                };
                if (221 === e) return {
                  gasPrice: t.loadUintBig(64),
                  gasLimit: t.loadUintBig(64),
                  gasCredit: t.loadUintBig(64),
                  blockGasLimit: t.loadUintBig(64),
                  freezeDueLimit: t.loadUintBig(64),
                  deleteDueLimit: t.loadUintBig(64)
                };
                throw Error("Invalid config")
              }(t);
            return {
              flatLimit: e,
              flatGasPrice: r,
              other: n
            }
          }
          throw Error("Invalid config")
        }

        function E(t) {
          if (!t) throw Error("Invalid config");
          if (234 !== t.loadUint(8)) throw Error("Invalid msg prices param");
          return {
            lumpPrice: t.loadUintBig(64),
            bitPrice: t.loadUintBig(64),
            cellPrice: t.loadUintBig(64),
            ihrPriceFactor: t.loadUint(32),
            firstFrac: t.loadUint(16),
            nextFrac: t.loadUint(16)
          }
        }

        function P(t) {
          if (!t) throw Error("Invalid config");
          const e = t.loadUint(8);
          if (193 === e) return {
            masterCatchainLifetime: t.loadUint(32),
            shardCatchainLifetime: t.loadUint(32),
            shardValidatorsLifetime: t.loadUint(32),
            shardValidatorsCount: t.loadUint(32)
          };
          if (194 === e) return {
            flags: t.loadUint(7),
            suffleMasterValidators: t.loadBit(),
            masterCatchainLifetime: t.loadUint(32),
            shardCatchainLifetime: t.loadUint(32),
            shardValidatorsLifetime: t.loadUint(32),
            shardValidatorsCount: t.loadUint(32)
          };
          throw Error("Invalid config")
        }

        function k(t) {
          if (!t) throw Error("Invalid config");
          const e = t.loadUint(8);
          if (214 === e) return {
            roundCandidates: t.loadUint(32),
            nextCandidateDelay: t.loadUint(32),
            consensusTimeout: t.loadUint(32),
            fastAttempts: t.loadUint(32),
            attemptDuration: t.loadUint(32),
            catchainMaxDeps: t.loadUint(32),
            maxBlockBytes: t.loadUint(32),
            maxColaltedBytes: t.loadUint(32)
          };
          if (215 === e) return {
            flags: t.loadUint(7),
            newCatchainIds: t.loadBit(),
            roundCandidates: t.loadUint(8),
            nextCandidateDelay: t.loadUint(32),
            consensusTimeout: t.loadUint(32),
            fastAttempts: t.loadUint(32),
            attemptDuration: t.loadUint(32),
            catchainMaxDeps: t.loadUint(32),
            maxBlockBytes: t.loadUint(32),
            maxColaltedBytes: t.loadUint(32)
          };
          if (216 === e) return {
            flags: t.loadUint(7),
            newCatchainIds: t.loadBit(),
            roundCandidates: t.loadUint(8),
            nextCandidateDelay: t.loadUint(32),
            consensusTimeout: t.loadUint(32),
            fastAttempts: t.loadUint(32),
            attemptDuration: t.loadUint(32),
            catchainMaxDeps: t.loadUint(32),
            maxBlockBytes: t.loadUint(32),
            maxColaltedBytes: t.loadUint(32),
            protoVersion: t.loadUint(16)
          };
          if (217 === e) return {
            flags: t.loadUint(7),
            newCatchainIds: t.loadBit(),
            roundCandidates: t.loadUint(8),
            nextCandidateDelay: t.loadUint(32),
            consensusTimeout: t.loadUint(32),
            fastAttempts: t.loadUint(32),
            attemptDuration: t.loadUint(32),
            catchainMaxDeps: t.loadUint(32),
            maxBlockBytes: t.loadUint(32),
            maxColaltedBytes: t.loadUint(32),
            protoVersion: t.loadUint(16),
            catchainMaxBlocksCoeff: t.loadUint(32)
          };
          throw Error("Invalid config")
        }

        function x(t) {
          if (54 !== t.loadUint(8)) throw Error("Invalid config");
          return {
            minTotalRounds: t.loadUint(8),
            maxTotalRounds: t.loadUint(8),
            minWins: t.loadUint(8),
            maxLoses: t.loadUint(8),
            minStoreSec: t.loadUint(32),
            maxStoreSec: t.loadUint(32),
            bitPrice: t.loadUint(32),
            cellPrice: t.loadUint(32)
          }
        }

        function I(t) {
          if (!t) throw Error("Invalid config");
          if (145 !== t.loadUint(8)) throw Error("Invalid config");
          return {
            normalParams: x(t.loadRef().beginParse()),
            criticalParams: x(t.loadRef().beginParse())
          }
        }

        function S(t) {
          return n.Cell.fromBase64(t).beginParse().loadDictDirect(n.Dictionary.Keys.Int(32), n.Dictionary.Values.Cell())
        }
      },
      57086: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, i.default)(t);
          var e = t.replace(/\s+/g, " ").replace(/\s?(hsla?\(|\)|,)\s?/gi, "$1");
          return -1 !== e.indexOf(",") ? o.test(e) : s.test(e)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(,(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}(,((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?))?\)$/i,
          s = /^hsla?\(((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?))(deg|grad|rad|turn)?(\s(\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%){2}\s?(\/\s((\+|\-)?([0-9]+(\.[0-9]+)?(e(\+|\-)?[0-9]+)?|\.[0-9]+(e(\+|\-)?[0-9]+)?)%?)\s?)?\)$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      57272: (t, e, r) => {
        const n = "object" == typeof r(65606) && "MISSING_ENV_VAR".NODE_DEBUG && /\bsemver\b/i.test("MISSING_ENV_VAR".NODE_DEBUG) ? (...t) => console.error("SEMVER", ...t) : () => {};
        t.exports = n
      },
      57414: (t, e, r) => {
        const n = r(30144);
        t.exports = (t, e) => {
          const r = n(t.trim().replace(/^[=v]+/, ""), e);
          return r ? r.version : null
        }
      },
      57510: t => {
        t.exports = function() {
          for (var t = {}, r = 0; arguments.length > r; r++) {
            var n = arguments[r];
            for (var i in n) e.call(n, i) && (t[i] = n[i])
          }
          return t
        };
        var e = {}.hasOwnProperty
      },
      57658: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, n.default)(t), (e = (0, i.default)(e, s)).allow_trailing_dot && "." === t[t.length - 1] && (t = t.substring(0, t.length - 1)), !0 === e.allow_wildcard && 0 === t.indexOf("*.") && (t = t.substring(2));
          var r = t.split("."),
            o = r[r.length - 1];
          return !(e.require_tld && (2 > r.length || !e.allow_numeric_tld && !/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(o) || /\s/.test(o)) || !e.allow_numeric_tld && /^\d+$/.test(o)) && r.every(function(t) {
            return !(t.length > 63 && !e.ignore_max_length || !/^[a-z_\u00a1-\uffff0-9-]+$/i.test(t) || /[\uff01-\uff5e]/.test(t) || /^-|-$/.test(t) || !e.allow_underscores && /_/.test(t))
          })
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = {
          require_tld: !0,
          allow_underscores: !1,
          allow_trailing_dot: !1,
          allow_numeric_tld: !1,
          allow_wildcard: !1,
          ignore_max_length: !1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      57758: (t, e, r) => {
        "use strict";
        var n, i = r(86048).F,
          o = i.ERR_MISSING_ARGS,
          s = i.ERR_STREAM_DESTROYED;

        function a(t) {
          if (t) throw t
        }

        function u(t) {
          t()
        }

        function c(t, e) {
          return t.pipe(e)
        }
        t.exports = function() {
          for (var t = arguments.length, e = Array(t), i = 0; t > i; i++) e[i] = arguments[i];
          var f = function(t) {
            return t.length && "function" == typeof t[t.length - 1] ? t.pop() : a
          }(e);
          if (Array.isArray(e[0]) && (e = e[0]), 2 > e.length) throw new o("streams");
          var l, h = e.map(function(t, i) {
            var o = i < e.length - 1;
            return function(t, e, i, o) {
              o = function(t) {
                var e = !1;
                return function() {
                  e || (e = !0, t.apply(void 0, arguments))
                }
              }(o);
              var a = !1;
              t.on("close", function() {
                a = !0
              }), void 0 === n && (n = r(86238)), n(t, {
                readable: e,
                writable: i
              }, function(t) {
                if (t) return o(t);
                a = !0, o()
              });
              var u = !1;
              return function(e) {
                if (!a && !u) {
                  if (u = !0, function(t) {
                      return t.setHeader && "function" == typeof t.abort
                    }(t)) return t.abort();
                  if ("function" == typeof t.destroy) return t.destroy();
                  o(e || new s("pipe"))
                }
              }
            }(t, o, i > 0, function(t) {
              l || (l = t), t && h.forEach(u), !o && (h.forEach(u), f(l))
            })
          });
          return e.reduce(c)
        }
      },
      57761: (t, e, r) => {
        "use strict";

        function n(t) {
          return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = void 0;
        var i = Jt(r(13752)),
          o = Jt(r(33752)),
          s = Jt(r(50855)),
          a = Jt(r(43214)),
          u = Jt(r(40700)),
          c = Jt(r(59220)),
          f = Jt(r(72576)),
          l = Jt(r(69517)),
          h = Jt(r(77844)),
          d = Jt(r(3196)),
          p = Jt(r(35372)),
          b = Jt(r(17115)),
          m = Jt(r(57658)),
          y = Jt(r(99013)),
          g = Jt(r(58796)),
          v = Jt(r(1697)),
          w = Jt(r(7071)),
          A = qt(r(66529)),
          T = qt(r(98986)),
          E = Jt(r(21666)),
          P = Jt(r(93442)),
          k = Jt(r(33906)),
          x = Jt(r(37612)),
          I = Jt(r(75577)),
          S = Jt(r(8461)),
          O = Jt(r(74294)),
          B = Jt(r(29666)),
          W = Jt(r(49534)),
          M = Jt(r(31449)),
          C = Jt(r(72830)),
          R = Jt(r(99841)),
          N = Jt(r(43459)),
          j = Jt(r(76084)),
          _ = qt(r(50995)),
          D = Jt(r(45926)),
          U = Jt(r(82002)),
          L = Jt(r(99546)),
          F = Jt(r(13735)),
          $ = Jt(r(24641)),
          z = Jt(r(45467)),
          H = Jt(r(57086)),
          G = Jt(r(31954)),
          K = qt(r(23641)),
          V = Jt(r(55259)),
          Z = Jt(r(59745)),
          q = Jt(r(33973)),
          J = Jt(r(29172)),
          Y = Jt(r(75751)),
          Q = Jt(r(2056)),
          X = Jt(r(29285)),
          tt = Jt(r(46255)),
          et = Jt(r(65186)),
          rt = Jt(r(31252)),
          nt = Jt(r(61195)),
          it = Jt(r(66658)),
          ot = Jt(r(19266)),
          st = Jt(r(73609)),
          at = Jt(r(61062)),
          ut = Jt(r(62645)),
          ct = Jt(r(27717)),
          ft = Jt(r(92678)),
          lt = Jt(r(59717)),
          ht = Jt(r(60604)),
          dt = Jt(r(77741)),
          pt = qt(r(95251)),
          bt = Jt(r(60082)),
          mt = Jt(r(6782)),
          yt = Jt(r(25748)),
          gt = r(45777),
          vt = Jt(r(48033)),
          wt = Jt(r(66169)),
          At = Jt(r(61578)),
          Tt = Jt(r(88447)),
          Et = Jt(r(53832)),
          Pt = Jt(r(88342)),
          kt = Jt(r(7673)),
          xt = Jt(r(26617)),
          It = Jt(r(98274)),
          St = Jt(r(73583)),
          Ot = Jt(r(27349)),
          Bt = Jt(r(32337)),
          Wt = Jt(r(64633)),
          Mt = Jt(r(5830)),
          Ct = qt(r(93939)),
          Rt = Jt(r(62309)),
          Nt = Jt(r(12483)),
          jt = Jt(r(30317)),
          _t = Jt(r(69790)),
          Dt = Jt(r(87677)),
          Ut = Jt(r(561)),
          Lt = Jt(r(61996)),
          Ft = Jt(r(410)),
          $t = Jt(r(90629)),
          zt = Jt(r(81128)),
          Ht = Jt(r(69234)),
          Gt = Jt(r(10676)),
          Kt = Jt(r(17179)),
          Vt = Jt(r(55366));

        function Zt() {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap;
          return Zt = function() {
            return t
          }, t
        }

        function qt(t) {
          if (t && t._) return t;
          if (null === t || "object" !== n(t) && "function" != typeof t) return {
            default: t
          };
          var e = Zt();
          if (e && e.has(t)) return e.get(t);
          var r = {},
            i = Object.defineProperty && Object.getOwnPropertyDescriptor;
          for (var o in t)
            if ({}.hasOwnProperty.call(t, o)) {
              var s = i ? Object.getOwnPropertyDescriptor(t, o) : null;
              s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = t[o]
            } return r.default = t, e && e.set(t, r), r
        }

        function Jt(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var Yt = {
          version: "13.11.0",
          toDate: i.default,
          toFloat: o.default,
          toInt: s.default,
          toBoolean: a.default,
          equals: u.default,
          contains: c.default,
          matches: f.default,
          isEmail: l.default,
          isURL: h.default,
          isMACAddress: d.default,
          isIP: p.default,
          isIPRange: b.default,
          isFQDN: m.default,
          isBoolean: v.default,
          isIBAN: K.default,
          isBIC: V.default,
          isAlpha: A.default,
          isAlphaLocales: A.locales,
          isAlphanumeric: T.default,
          isAlphanumericLocales: T.locales,
          isNumeric: E.default,
          isPassportNumber: P.default,
          isPort: k.default,
          isLowercase: x.default,
          isUppercase: I.default,
          isAscii: O.default,
          isFullWidth: B.default,
          isHalfWidth: W.default,
          isVariableWidth: M.default,
          isMultibyte: C.default,
          isSemVer: R.default,
          isSurrogatePair: N.default,
          isInt: j.default,
          isIMEI: S.default,
          isFloat: _.default,
          isFloatLocales: _.locales,
          isDecimal: D.default,
          isHexadecimal: U.default,
          isOctal: L.default,
          isDivisibleBy: F.default,
          isHexColor: $.default,
          isRgbColor: z.default,
          isHSL: H.default,
          isISRC: G.default,
          isMD5: Z.default,
          isHash: q.default,
          isJWT: J.default,
          isJSON: Y.default,
          isEmpty: Q.default,
          isLength: X.default,
          isLocale: w.default,
          isByteLength: tt.default,
          isUUID: et.default,
          isMongoId: rt.default,
          isAfter: nt.default,
          isBefore: it.default,
          isIn: ot.default,
          isLuhnNumber: st.default,
          isCreditCard: at.default,
          isIdentityCard: ut.default,
          isEAN: ct.default,
          isISIN: ft.default,
          isISBN: lt.default,
          isISSN: ht.default,
          isMobilePhone: pt.default,
          isMobilePhoneLocales: pt.locales,
          isPostalCode: Ct.default,
          isPostalCodeLocales: Ct.locales,
          isEthereumAddress: bt.default,
          isCurrency: mt.default,
          isBtcAddress: yt.default,
          isISO6346: gt.isISO6346,
          isFreightContainerID: gt.isFreightContainerID,
          isISO6391: vt.default,
          isISO8601: wt.default,
          isRFC3339: At.default,
          isISO31661Alpha2: Tt.default,
          isISO31661Alpha3: Et.default,
          isISO4217: Pt.default,
          isBase32: kt.default,
          isBase58: xt.default,
          isBase64: It.default,
          isDataURI: St.default,
          isMagnetURI: Ot.default,
          isMailtoURI: Bt.default,
          isMimeType: Wt.default,
          isLatLong: Mt.default,
          ltrim: Rt.default,
          rtrim: Nt.default,
          trim: jt.default,
          escape: _t.default,
          unescape: Dt.default,
          stripLow: Ut.default,
          whitelist: Lt.default,
          blacklist: Ft.default,
          isWhitelisted: $t.default,
          normalizeEmail: zt.default,
          toString: toString,
          isSlug: Ht.default,
          isStrongPassword: Kt.default,
          isTaxID: dt.default,
          isDate: y.default,
          isTime: g.default,
          isLicensePlate: Gt.default,
          isVAT: Vt.default,
          ibanLocales: K.locales
        };
        e.default = Yt, t.exports = e.default, t.exports.default = e.default
      },
      58068: t => {
        "use strict";
        t.exports = SyntaxError
      },
      58353: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransactionsStoragePhase = e.loadTransactionStoragePhase = void 0;
        const n = r(62312);
        e.loadTransactionStoragePhase = function(t) {
          const e = t.loadCoins();
          let r;
          return t.loadBit() && (r = t.loadCoins()), {
            storageFeesCollected: e,
            storageFeesDue: r,
            statusChange: (0, n.loadAccountStatusChange)(t)
          }
        }, e.storeTransactionsStoragePhase = function(t) {
          return e => {
            e.storeCoins(t.storageFeesCollected), null === t.storageFeesDue || void 0 === t.storageFeesDue ? e.storeBit(!1) : (e.storeBit(!0), e.storeCoins(t.storageFeesDue)), e.store((0, n.storeAccountStatusChange)(t.statusChange))
          }
        }
      },
      58411: (t, e, r) => {
        "use strict";
        var n, i = r(9805),
          o = r(23665),
          s = r(53269),
          a = r(14823),
          u = r(54674),
          c = -2,
          f = 258,
          l = 262,
          h = 103,
          d = 113,
          p = 666;

        function b(t, e) {
          return t.msg = u[e], e
        }

        function m(t) {
          return (t << 1) - (t > 4 ? 9 : 0)
        }

        function y(t) {
          for (var e = t.length; --e >= 0;) t[e] = 0
        }

        function g(t) {
          var e = t.state,
            r = e.pending;
          r > t.avail_out && (r = t.avail_out), 0 !== r && (i.arraySet(t.output, e.pending_buf, e.pending_out, r, t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0))
        }

        function v(t, e) {
          o.Yt(t, 0 > t.block_start ? -1 : t.block_start, t.strstart - t.block_start, e), t.block_start = t.strstart, g(t.strm)
        }

        function w(t, e) {
          t.pending_buf[t.pending++] = e
        }

        function A(t, e) {
          t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e
        }

        function T(t, e, r, n) {
          var o = t.avail_in;
          return o > n && (o = n), 0 === o ? 0 : (t.avail_in -= o, i.arraySet(e, t.input, t.next_in, o, r), 1 === t.state.wrap ? t.adler = s(t.adler, e, o, r) : 2 === t.state.wrap && (t.adler = a(t.adler, e, o, r)), t.next_in += o, t.total_in += o, o)
        }

        function E(t, e) {
          var r, n, i = t.max_chain_length,
            o = t.strstart,
            s = t.prev_length,
            a = t.nice_match,
            u = t.strstart > t.w_size - l ? t.strstart - (t.w_size - l) : 0,
            c = t.window,
            h = t.w_mask,
            d = t.prev,
            p = t.strstart + f,
            b = c[o + s - 1],
            m = c[o + s];
          t.prev_length >= t.good_match && (i >>= 2), a > t.lookahead && (a = t.lookahead);
          do {
            if (c[(r = e) + s] === m && c[r + s - 1] === b && c[r] === c[o] && c[++r] === c[o + 1]) {
              o += 2, r++;
              do {} while (c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && c[++o] === c[++r] && p > o);
              if (n = f - (p - o), o = p - f, n > s) {
                if (t.match_start = e, s = n, n >= a) break;
                b = c[o + s - 1], m = c[o + s]
              }
            }
          } while ((e = d[e & h]) > u && 0 !== --i);
          return s > t.lookahead ? t.lookahead : s
        }

        function P(t) {
          var e, r, n, o, s, a = t.w_size;
          do {
            if (o = t.window_size - t.lookahead - t.strstart, t.strstart >= a + (a - l)) {
              i.arraySet(t.window, t.window, a, a, 0), t.match_start -= a, t.strstart -= a, t.block_start -= a, e = r = t.hash_size;
              do {
                n = t.head[--e], t.head[e] = a > n ? 0 : n - a
              } while (--r);
              e = r = a;
              do {
                n = t.prev[--e], t.prev[e] = a > n ? 0 : n - a
              } while (--r);
              o += a
            }
            if (0 === t.strm.avail_in) break;
            if (r = T(t.strm, t.window, t.strstart + t.lookahead, o), t.lookahead += r, t.lookahead + t.insert >= 3)
              for (s = t.strstart - t.insert, t.ins_h = t.window[s], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[s + 3 - 1]) & t.hash_mask, t.prev[s & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = s, s++, t.insert--, t.lookahead + t.insert >= 3););
          } while (t.lookahead < l && 0 !== t.strm.avail_in)
        }

        function k(t, e) {
          for (var r, n;;) {
            if (t.lookahead < l) {
              if (P(t), t.lookahead < l && 0 === e) return 1;
              if (0 === t.lookahead) break
            }
            if (r = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - l && (t.match_length = E(t, r)), 3 > t.match_length) n = o.Qt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++;
            else if (n = o.Qt(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length > t.max_lazy_match || 3 > t.lookahead) t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask;
            else {
              t.match_length--;
              do {
                t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart
              } while (0 !== --t.match_length);
              t.strstart++
            }
            if (n && (v(t, !1), 0 === t.strm.avail_out)) return 1
          }
          return t.insert = 2 > t.strstart ? t.strstart : 2, 4 === e ? (v(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (v(t, !1), 0 === t.strm.avail_out) ? 1 : 2
        }

        function x(t, e) {
          for (var r, n, i;;) {
            if (t.lookahead < l) {
              if (P(t), t.lookahead < l && 0 === e) return 1;
              if (0 === t.lookahead) break
            }
            if (r = 0, t.lookahead >= 3 && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - l && (t.match_length = E(t, r), 5 >= t.match_length && (1 === t.strategy || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), 3 > t.prev_length || t.match_length > t.prev_length)
              if (t.match_available) {
                if ((n = o.Qt(t, 0, t.window[t.strstart - 1])) && v(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1
              } else t.match_available = 1, t.strstart++, t.lookahead--;
            else {
              i = t.strstart + t.lookahead - 3, n = o.Qt(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2;
              do {
                ++t.strstart <= i && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 3 - 1]) & t.hash_mask, r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart)
              } while (0 !== --t.prev_length);
              if (t.match_available = 0, t.match_length = 2, t.strstart++, n && (v(t, !1), 0 === t.strm.avail_out)) return 1
            }
          }
          return t.match_available && (n = o.Qt(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = 2 > t.strstart ? t.strstart : 2, 4 === e ? (v(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (v(t, !1), 0 === t.strm.avail_out) ? 1 : 2
        }

        function I(t, e, r, n, i) {
          this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = n, this.func = i
        }

        function S() {
          this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(1146), this.dyn_dtree = new i.Buf16(122), this.bl_tree = new i.Buf16(78), y(this.dyn_ltree), y(this.dyn_dtree), y(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(16), this.heap = new i.Buf16(573), y(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(573), y(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
        }

        function O(t) {
          var e;
          return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = 2, (e = t.state).pending = 0, e.pending_out = 0, 0 > e.wrap && (e.wrap = -e.wrap), e.status = e.wrap ? 42 : d, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = 0, o.qt(e), 0) : b(t, c)
        }

        function B(t) {
          var e = O(t);
          return 0 === e && function(t) {
            t.window_size = 2 * t.w_size, y(t.head), t.max_lazy_match = n[t.level].max_lazy, t.good_match = n[t.level].good_length, t.nice_match = n[t.level].nice_length, t.max_chain_length = n[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = 2, t.match_available = 0, t.ins_h = 0
          }(t.state), e
        }

        function W(t, e, r, n, o, s) {
          if (!t) return c;
          var a = 1;
          if (-1 === e && (e = 6), 0 > n ? (a = 0, n = -n) : n > 15 && (a = 2, n -= 16), 1 > o || o > 9 || 8 !== r || 8 > n || n > 15 || 0 > e || e > 9 || 0 > s || s > 4) return b(t, c);
          8 === n && (n = 9);
          var u = new S;
          return t.state = u, u.strm = t, u.wrap = a, u.gzhead = null, u.w_bits = n, u.w_size = 1 << u.w_bits, u.w_mask = u.w_size - 1, u.hash_bits = o + 7, u.hash_size = 1 << u.hash_bits, u.hash_mask = u.hash_size - 1, u.hash_shift = ~~((u.hash_bits + 3 - 1) / 3), u.window = new i.Buf8(2 * u.w_size), u.head = new i.Buf16(u.hash_size), u.prev = new i.Buf16(u.w_size), u.lit_bufsize = 1 << o + 6, u.pending_buf_size = 4 * u.lit_bufsize, u.pending_buf = new i.Buf8(u.pending_buf_size), u.d_buf = 1 * u.lit_bufsize, u.l_buf = 3 * u.lit_bufsize, u.level = e, u.strategy = s, u.method = r, B(t)
        }
        n = [new I(0, 0, 0, 0, function(t, e) {
          var r = 65535;
          for (r > t.pending_buf_size - 5 && (r = t.pending_buf_size - 5);;) {
            if (1 >= t.lookahead) {
              if (P(t), 0 === t.lookahead && 0 === e) return 1;
              if (0 === t.lookahead) break
            }
            t.strstart += t.lookahead, t.lookahead = 0;
            var n = t.block_start + r;
            if ((0 === t.strstart || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, v(t, !1), 0 === t.strm.avail_out) || t.strstart - t.block_start >= t.w_size - l && (v(t, !1), 0 === t.strm.avail_out)) return 1
          }
          return t.insert = 0, 4 === e ? (v(t, !0), 0 === t.strm.avail_out ? 3 : 4) : (t.strstart > t.block_start && (v(t, !1), t.strm.avail_out), 1)
        }), new I(4, 4, 8, 4, k), new I(4, 5, 16, 8, k), new I(4, 6, 32, 32, k), new I(4, 4, 16, 16, x), new I(8, 16, 32, 32, x), new I(8, 16, 128, 128, x), new I(8, 32, 128, 256, x), new I(32, 128, 258, 1024, x), new I(32, 258, 258, 4096, x)], e.deflateInit = function(t, e) {
          return W(t, e, 8, 15, 8, 0)
        }, e.deflateInit2 = W, e.deflateReset = B, e.deflateResetKeep = O, e.deflateSetHeader = function(t, e) {
          return t && t.state && 2 === t.state.wrap ? (t.state.gzhead = e, 0) : c
        }, e.deflate = function(t, e) {
          var r, i, s, u;
          if (!t || !t.state || e > 5 || 0 > e) return t ? b(t, c) : c;
          if (i = t.state, !t.output || !t.input && 0 !== t.avail_in || i.status === p && 4 !== e) return b(t, 0 === t.avail_out ? -5 : c);
          if (i.strm = t, r = i.last_flush, i.last_flush = e, 42 === i.status)
            if (2 === i.wrap) t.adler = 0, w(i, 31), w(i, 139), w(i, 8), i.gzhead ? (w(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), w(i, 255 & i.gzhead.time), w(i, i.gzhead.time >> 8 & 255), w(i, i.gzhead.time >> 16 & 255), w(i, i.gzhead.time >> 24 & 255), w(i, 9 === i.level ? 2 : i.strategy >= 2 || 2 > i.level ? 4 : 0), w(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (w(i, 255 & i.gzhead.extra.length), w(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (t.adler = a(t.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (w(i, 0), w(i, 0), w(i, 0), w(i, 0), w(i, 0), w(i, 9 === i.level ? 2 : i.strategy >= 2 || 2 > i.level ? 4 : 0), w(i, 3), i.status = d);
            else {
              var l = 8 + (i.w_bits - 8 << 4) << 8;
              l |= (i.strategy >= 2 || 2 > i.level ? 0 : 6 > i.level ? 1 : 6 === i.level ? 2 : 3) << 6, 0 !== i.strstart && (l |= 32), l += 31 - l % 31, i.status = d, A(i, l), 0 !== i.strstart && (A(i, t.adler >>> 16), A(i, 65535 & t.adler)), t.adler = 1
            } if (69 === i.status)
            if (i.gzhead.extra) {
              for (s = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), g(t), s = i.pending, i.pending !== i.pending_buf_size));) w(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++;
              i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73)
            } else i.status = 73;
          if (73 === i.status)
            if (i.gzhead.name) {
              s = i.pending;
              do {
                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), g(t), s = i.pending, i.pending === i.pending_buf_size)) {
                  u = 1;
                  break
                }
                u = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0, w(i, u)
              } while (0 !== u);
              i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), 0 === u && (i.gzindex = 0, i.status = 91)
            } else i.status = 91;
          if (91 === i.status)
            if (i.gzhead.comment) {
              s = i.pending;
              do {
                if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), g(t), s = i.pending, i.pending === i.pending_buf_size)) {
                  u = 1;
                  break
                }
                u = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0, w(i, u)
              } while (0 !== u);
              i.gzhead.hcrc && i.pending > s && (t.adler = a(t.adler, i.pending_buf, i.pending - s, s)), 0 === u && (i.status = h)
            } else i.status = h;
          if (i.status === h && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && g(t), i.pending + 2 <= i.pending_buf_size && (w(i, 255 & t.adler), w(i, t.adler >> 8 & 255), t.adler = 0, i.status = d)) : i.status = d), 0 !== i.pending) {
            if (g(t), 0 === t.avail_out) return i.last_flush = -1, 0
          } else if (0 === t.avail_in && m(e) <= m(r) && 4 !== e) return b(t, -5);
          if (i.status === p && 0 !== t.avail_in) return b(t, -5);
          if (0 !== t.avail_in || 0 !== i.lookahead || 0 !== e && i.status !== p) {
            var T = 2 === i.strategy ? function(t, e) {
              for (var r;;) {
                if (0 === t.lookahead && (P(t), 0 === t.lookahead)) {
                  if (0 === e) return 1;
                  break
                }
                if (t.match_length = 0, r = o.Qt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (v(t, !1), 0 === t.strm.avail_out)) return 1
              }
              return t.insert = 0, 4 === e ? (v(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (v(t, !1), 0 === t.strm.avail_out) ? 1 : 2
            }(i, e) : 3 === i.strategy ? function(t, e) {
              for (var r, n, i, s, a = t.window;;) {
                if (t.lookahead <= f) {
                  if (P(t), t.lookahead <= f && 0 === e) return 1;
                  if (0 === t.lookahead) break
                }
                if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (n = a[i = t.strstart - 1]) === a[++i] && n === a[++i] && n === a[++i]) {
                  s = t.strstart + f;
                  do {} while (n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && n === a[++i] && s > i);
                  t.match_length = f - (s - i), t.match_length > t.lookahead && (t.match_length = t.lookahead)
                }
                if (3 > t.match_length ? (r = o.Qt(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++) : (r = o.Qt(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0), r && (v(t, !1), 0 === t.strm.avail_out)) return 1
              }
              return t.insert = 0, 4 === e ? (v(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.last_lit && (v(t, !1), 0 === t.strm.avail_out) ? 1 : 2
            }(i, e) : n[i.level].func(i, e);
            if ((3 === T || 4 === T) && (i.status = p), 1 === T || 3 === T) return 0 === t.avail_out && (i.last_flush = -1), 0;
            if (2 === T && (1 === e ? o.Xt(i) : 5 !== e && (o.Jt(i, 0, 0, !1), 3 === e && (y(i.head), 0 === i.lookahead && (i.strstart = 0, i.block_start = 0, i.insert = 0))), g(t), 0 === t.avail_out)) return i.last_flush = -1, 0
          }
          return 4 !== e ? 0 : i.wrap > 0 ? (2 === i.wrap ? (w(i, 255 & t.adler), w(i, t.adler >> 8 & 255), w(i, t.adler >> 16 & 255), w(i, t.adler >> 24 & 255), w(i, 255 & t.total_in), w(i, t.total_in >> 8 & 255), w(i, t.total_in >> 16 & 255), w(i, t.total_in >> 24 & 255)) : (A(i, t.adler >>> 16), A(i, 65535 & t.adler)), g(t), i.wrap > 0 && (i.wrap = -i.wrap), 0 !== i.pending ? 0 : 1) : 1
        }, e.deflateEnd = function(t) {
          var e;
          return t && t.state ? 42 !== (e = t.state.status) && 69 !== e && 73 !== e && 91 !== e && e !== h && e !== d && e !== p ? b(t, c) : (t.state = null, e === d ? b(t, -3) : 0) : c
        }, e.deflateSetDictionary = function(t, e) {
          var r, n, o, a, u, f, l, h, d = e.length;
          if (!t || !t.state || 2 === (a = (r = t.state).wrap) || 1 === a && 42 !== r.status || r.lookahead) return c;
          for (1 === a && (t.adler = s(t.adler, e, d, 0)), r.wrap = 0, d >= r.w_size && (0 === a && (y(r.head), r.strstart = 0, r.block_start = 0, r.insert = 0), h = new i.Buf8(r.w_size), i.arraySet(h, e, d - r.w_size, r.w_size, 0), e = h, d = r.w_size), u = t.avail_in, f = t.next_in, l = t.input, t.avail_in = d, t.next_in = 0, t.input = e, P(r); r.lookahead >= 3;) {
            n = r.strstart, o = r.lookahead - 2;
            do {
              r.ins_h = (r.ins_h << r.hash_shift ^ r.window[n + 3 - 1]) & r.hash_mask, r.prev[n & r.w_mask] = r.head[r.ins_h], r.head[r.ins_h] = n, n++
            } while (--o);
            r.strstart = n, r.lookahead = 2, P(r)
          }
          return r.strstart += r.lookahead, r.block_start = r.strstart, r.insert = r.lookahead, r.lookahead = 0, r.match_length = r.prev_length = 2, r.match_available = 0, t.next_in = f, t.input = l, t.avail_in = u, r.wrap = a, 0
        }, e.deflateInfo = "pako deflate (from Nodeca project)"
      },
      58796: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return e = (0, i.default)(e, o), "string" == typeof t && s[e.hourFormat][e.mode].test(t)
        };
        var n, i = (n = r(71229)) && n._ ? n : {
            default: n
          },
          o = {
            hourFormat: "hour24",
            mode: "default"
          },
          s = {
            hour24: {
              default: /^([01]?[0-9]|2[0-3]):([0-5][0-9])$/,
              withSeconds: /^([01]?[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/
            },
            hour12: {
              default: /^(0?[1-9]|1[0-2]):([0-5][0-9]) (A|P)M$/,
              withSeconds: /^(0?[1-9]|1[0-2]):([0-5][0-9]):([0-5][0-9]) (A|P)M$/
            }
          };
        t.exports = e.default, t.exports.default = e.default
      },
      58859: (t, e, r) => {
        var n = "function" == typeof Map && Map.prototype,
          i = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null,
          o = n && i && "function" == typeof i.get ? i.get : null,
          s = n && Map.prototype.forEach,
          a = "function" == typeof Set && Set.prototype,
          u = Object.getOwnPropertyDescriptor && a ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null,
          c = a && u && "function" == typeof u.get ? u.get : null,
          f = a && Set.prototype.forEach,
          l = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null,
          h = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null,
          d = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null,
          p = Boolean.prototype.valueOf,
          b = {}.toString,
          m = function() {}.toString,
          y = "".match,
          g = "".slice,
          v = "".replace,
          w = "".toUpperCase,
          A = "".toLowerCase,
          T = /t/.test,
          E = [].concat,
          P = [].join,
          k = [].slice,
          x = Math.floor,
          I = "function" == typeof BigInt ? BigInt.prototype.valueOf : null,
          S = Object.getOwnPropertySymbols,
          O = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null,
          B = "function" == typeof Symbol && "object" == typeof Symbol.iterator,
          W = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 1) ? Symbol.toStringTag : null,
          M = {}.propertyIsEnumerable,
          C = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(t) {
            return t.__proto__
          } : null);

        function R(t, e) {
          if (t === 1 / 0 || t === -1 / 0 || t != t || t && t > -1e3 && 1e3 > t || T.call(/e/, e)) return e;
          var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
          if ("number" == typeof t) {
            var n = 0 > t ? -x(-t) : x(t);
            if (n !== t) {
              var i = n + "",
                o = g.call(e, i.length + 1);
              return v.call(i, r, "$&_") + "." + v.call(v.call(o, /([0-9]{3})/g, "$&_"), /_$/, "")
            }
          }
          return v.call(e, r, "$&_")
        }
        var N = r(42634),
          j = N.custom,
          _ = G(j) ? j : null,
          D = {
            __proto__: null,
            double: '"',
            single: "'"
          },
          U = {
            __proto__: null,
            double: /(["\\])/g,
            single: /(['\\])/g
          };

        function L(t, e, r) {
          var n = r.quoteStyle || e,
            i = D[n];
          return i + t + i
        }

        function F(t) {
          return v.call(t + "", /"/g, "&quot;")
        }

        function $(t) {
          return !W || !("object" == typeof t && (W in t || "u" > typeof t[W]))
        }

        function z(t) {
          return "[object Array]" === Z(t) && $(t)
        }

        function H(t) {
          return "[object RegExp]" === Z(t) && $(t)
        }

        function G(t) {
          if (B) return t && "object" == typeof t && t instanceof Symbol;
          if ("symbol" == typeof t) return !0;
          if (!t || "object" != typeof t || !O) return !1;
          try {
            return O.call(t), !0
          } catch {}
          return !1
        }
        t.exports = function t(e, n, i, a) {
          var u = n || {};
          if (V(u, "quoteStyle") && !V(D, u.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
          if (V(u, "maxStringLength") && ("number" == typeof u.maxStringLength ? 0 > u.maxStringLength && u.maxStringLength !== 1 / 0 : null !== u.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
          var b = !V(u, "customInspect") || u.customInspect;
          if ("boolean" != typeof b && "symbol" !== b) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
          if (V(u, "indent") && null !== u.indent && "\t" !== u.indent && (parseInt(u.indent, 10) !== u.indent || 0 >= u.indent)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
          if (V(u, "numericSeparator") && "boolean" != typeof u.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
          var w = u.numericSeparator;
          if (typeof e > "u") return "undefined";
          if (null === e) return "null";
          if ("boolean" == typeof e) return e ? "true" : "false";
          if ("string" == typeof e) return J(e, u);
          if ("number" == typeof e) {
            if (0 === e) return 1 / 0 / e > 0 ? "0" : "-0";
            var T = e + "";
            return w ? R(e, T) : T
          }
          if ("bigint" == typeof e) {
            var x = e + "n";
            return w ? R(e, x) : x
          }
          var S = typeof u.depth > "u" ? 5 : u.depth;
          if (typeof i > "u" && (i = 0), i >= S && S > 0 && "object" == typeof e) return z(e) ? "[Array]" : "[Object]";
          var j = function(t, e) {
            var r;
            if ("\t" === t.indent) r = "\t";
            else {
              if ("number" != typeof t.indent || 0 >= t.indent) return null;
              r = P.call(Array(t.indent + 1), " ")
            }
            return {
              base: r,
              prev: P.call(Array(e + 1), r)
            }
          }(u, i);
          if (typeof a > "u") a = [];
          else if (q(a, e) >= 0) return "[Circular]";

          function U(e, r, n) {
            if (r && (a = k.call(a)).push(r), n) {
              var o = {
                depth: u.depth
              };
              return V(u, "quoteStyle") && (o.quoteStyle = u.quoteStyle), t(e, o, i + 1, a)
            }
            return t(e, u, i + 1, a)
          }
          if ("function" == typeof e && !H(e)) {
            var K = function(t) {
                if (t.name) return t.name;
                var e = y.call(m.call(t), /^function\s*([\w$]+)/);
                return e ? e[1] : null
              }(e),
              Y = rt(e, U);
            return "[Function" + (K ? ": " + K : " (anonymous)") + "]" + (Y.length > 0 ? " { " + P.call(Y, ", ") + " }" : "")
          }
          if (G(e)) {
            var nt = B ? v.call(e + "", /^(Symbol\(.*\))_[^)]*$/, "$1") : O.call(e);
            return "object" != typeof e || B ? nt : Q(nt)
          }
          if (function(t) {
              return !(!t || "object" != typeof t) && ("u" > typeof HTMLElement && t instanceof HTMLElement || "string" == typeof t.nodeName && "function" == typeof t.getAttribute)
            }(e)) {
            for (var it = "<" + A.call(e.nodeName + ""), ot = e.attributes || [], st = 0; st < ot.length; st++) it += " " + ot[st].name + "=" + L(F(ot[st].value), "double", u);
            return it += ">", e.childNodes && e.childNodes.length && (it += "..."), it + "</" + A.call(e.nodeName + "") + ">"
          }
          if (z(e)) {
            if (0 === e.length) return "[]";
            var at = rt(e, U);
            return j && ! function(t) {
              for (var e = 0; e < t.length; e++)
                if (q(t[e], "\n") >= 0) return !1;
              return !0
            }(at) ? "[" + et(at, j) + "]" : "[ " + P.call(at, ", ") + " ]"
          }
          if (function(t) {
              return "[object Error]" === Z(t) && $(t)
            }(e)) {
            var ut = rt(e, U);
            return "cause" in Error.prototype || !("cause" in e) || M.call(e, "cause") ? 0 === ut.length ? "[" + e + "]" : "{ [" + e + "] " + P.call(ut, ", ") + " }" : "{ [" + e + "] " + P.call(E.call("[cause]: " + U(e.cause), ut), ", ") + " }"
          }
          if ("object" == typeof e && b) {
            if (_ && "function" == typeof e[_] && N) return N(e, {
              depth: S - i
            });
            if ("symbol" !== b && "function" == typeof e.inspect) return e.inspect()
          }
          if (function(t) {
              if (!o || !t || "object" != typeof t) return !1;
              try {
                o.call(t);
                try {
                  c.call(t)
                } catch {
                  return !0
                }
                return t instanceof Map
              } catch {}
              return !1
            }(e)) {
            var ct = [];
            return s && s.call(e, function(t, r) {
              ct.push(U(r, e, !0) + " => " + U(t, e))
            }), tt("Map", o.call(e), ct, j)
          }
          if (function(t) {
              if (!c || !t || "object" != typeof t) return !1;
              try {
                c.call(t);
                try {
                  o.call(t)
                } catch {
                  return !0
                }
                return t instanceof Set
              } catch {}
              return !1
            }(e)) {
            var ft = [];
            return f && f.call(e, function(t) {
              ft.push(U(t, e))
            }), tt("Set", c.call(e), ft, j)
          }
          if (function(t) {
              if (!l || !t || "object" != typeof t) return !1;
              try {
                l.call(t, l);
                try {
                  h.call(t, h)
                } catch {
                  return !0
                }
                return t instanceof WeakMap
              } catch {}
              return !1
            }(e)) return X("WeakMap");
          if (function(t) {
              if (!h || !t || "object" != typeof t) return !1;
              try {
                h.call(t, h);
                try {
                  l.call(t, l)
                } catch {
                  return !0
                }
                return t instanceof WeakSet
              } catch {}
              return !1
            }(e)) return X("WeakSet");
          if (function(t) {
              if (!d || !t || "object" != typeof t) return !1;
              try {
                return d.call(t), !0
              } catch {}
              return !1
            }(e)) return X("WeakRef");
          if (function(t) {
              return "[object Number]" === Z(t) && $(t)
            }(e)) return Q(U(+e));
          if (function(t) {
              if (!t || "object" != typeof t || !I) return !1;
              try {
                return I.call(t), !0
              } catch {}
              return !1
            }(e)) return Q(U(I.call(e)));
          if (function(t) {
              return "[object Boolean]" === Z(t) && $(t)
            }(e)) return Q(p.call(e));
          if (function(t) {
              return "[object String]" === Z(t) && $(t)
            }(e)) return Q(U(e + ""));
          if ("u" > typeof window && e === window) return "{ [object Window] }";
          if ("u" > typeof globalThis && e === globalThis || "u" > typeof r.g && e === r.g) return "{ [object globalThis] }";
          if (! function(t) {
              return "[object Date]" === Z(t) && $(t)
            }(e) && !H(e)) {
            var lt = rt(e, U),
              ht = C ? C(e) === Object.prototype : e instanceof Object || e.constructor === Object,
              dt = e instanceof Object ? "" : "null prototype",
              pt = !ht && W && Object(e) === e && W in e ? g.call(Z(e), 8, -1) : dt ? "Object" : "",
              bt = (ht || "function" != typeof e.constructor ? "" : e.constructor.name ? e.constructor.name + " " : "") + (pt || dt ? "[" + P.call(E.call([], pt || [], dt || []), ": ") + "] " : "");
            return 0 === lt.length ? bt + "{}" : j ? bt + "{" + et(lt, j) + "}" : bt + "{ " + P.call(lt, ", ") + " }"
          }
          return e + ""
        };
        var K = {}.hasOwnProperty || function(t) {
          return t in this
        };

        function V(t, e) {
          return K.call(t, e)
        }

        function Z(t) {
          return b.call(t)
        }

        function q(t, e) {
          if (t.indexOf) return t.indexOf(e);
          for (var r = 0, n = t.length; n > r; r++)
            if (t[r] === e) return r;
          return -1
        }

        function J(t, e) {
          if (t.length > e.maxStringLength) {
            var r = t.length - e.maxStringLength,
              n = "... " + r + " more character" + (r > 1 ? "s" : "");
            return J(g.call(t, 0, e.maxStringLength), e) + n
          }
          var i = U[e.quoteStyle || "single"];
          return i.lastIndex = 0, L(v.call(v.call(t, i, "\\$1"), /[\x00-\x1f]/g, Y), "single", e)
        }

        function Y(t) {
          var e = t.charCodeAt(0),
            r = {
              8: "b",
              9: "t",
              10: "n",
              12: "f",
              13: "r"
            } [e];
          return r ? "\\" + r : "\\x" + (16 > e ? "0" : "") + w.call(e.toString(16))
        }

        function Q(t) {
          return "Object(" + t + ")"
        }

        function X(t) {
          return t + " { ? }"
        }

        function tt(t, e, r, n) {
          return t + " (" + e + ") {" + (n ? et(r, n) : P.call(r, ", ")) + "}"
        }

        function et(t, e) {
          if (0 === t.length) return "";
          var r = "\n" + e.prev + e.base;
          return r + P.call(t, "," + r) + "\n" + e.prev
        }

        function rt(t, e) {
          var r = z(t),
            n = [];
          if (r) {
            n.length = t.length;
            for (var i = 0; i < t.length; i++) n[i] = V(t, i) ? e(t[i], t) : ""
          }
          var o, s = "function" == typeof S ? S(t) : [];
          if (B) {
            o = {};
            for (var a = 0; a < s.length; a++) o["$" + s[a]] = s[a]
          }
          for (var u in t) V(t, u) && (r && +u + "" === u && u < t.length || B && o["$" + u] instanceof Symbol || (T.call(/[^\w$]/, u) ? n.push(e(u, t) + ": " + e(t[u], t)) : n.push(u + ": " + e(t[u], t))));
          if ("function" == typeof S)
            for (var c = 0; c < s.length; c++) M.call(t, s[c]) && n.push("[" + e(s[c]) + "]: " + e(t[s[c]], t));
          return n
        }
      },
      58968: t => {
        "use strict";
        t.exports = Math.floor
      },
      59206: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wNAF = function(t, e) {
          const r = (t, e) => {
              const r = e.negate();
              return t ? r : e
            },
            n = t => ({
              windows: Math.ceil(e / t) + 1,
              windowSize: 2 ** (t - 1)
            });
          return {
            constTimeNegate: r,
            unsafeLadder(e, r) {
              let n = t.ZERO,
                i = e;
              for (; r > o;) r & s && (n = n.add(i)), i = i.double(), r >>= s;
              return n
            },
            precomputeWindow(t, e) {
              const {
                windows: r,
                windowSize: i
              } = n(e), o = [];
              let s = t,
                a = s;
              for (let t = 0; r > t; t++) {
                a = s, o.push(a);
                for (let t = 1; i > t; t++) a = a.add(s), o.push(a);
                s = a.double()
              }
              return o
            },
            wNAF(e, i, o) {
              const {
                windows: a,
                windowSize: u
              } = n(e);
              let c = t.ZERO,
                f = t.BASE;
              const l = BigInt(2 ** e - 1),
                h = 2 ** e,
                d = BigInt(e);
              for (let t = 0; a > t; t++) {
                const e = t * u;
                let n = +(o & l);
                o >>= d, n > u && (n -= h, o += s);
                const a = e,
                  p = e + Math.abs(n) - 1,
                  b = t % 2 != 0,
                  m = 0 > n;
                0 === n ? f = f.add(r(b, i[a])) : c = c.add(r(m, i[p]))
              }
              return {
                p: c,
                f: f
              }
            },
            wNAFCached(t, e, r, n) {
              const i = t.Gt || 1;
              let o = e.get(t);
              return o || (o = this.precomputeWindow(t, i), 1 !== i && e.set(t, n(o))), this.wNAF(i, o, r)
            }
          }
        }, e.validateBasic = function(t) {
          return (0, n.validateField)(t.Fp), (0, i.validateObject)(t, {
            n: "bigint",
            h: "bigint",
            Gx: "field",
            Gy: "field"
          }, {
            nBitLength: "isSafeInteger",
            nByteLength: "isSafeInteger"
          }), Object.freeze({
            ...(0, n.nLength)(t.n, t.nBitLength),
            ...t,
            p: t.Fp.ORDER
          })
        };
        const n = r(89015),
          i = r(19372),
          o = BigInt(0),
          s = BigInt(1)
      },
      59220: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e, r) {
          return (0, n.default)(t), (r = (0, o.default)(r, a)).ignoreCase ? t.toLowerCase().split((0, i.default)(e).toLowerCase()).length > r.minOccurrences : t.split((0, i.default)(e)).length > r.minOccurrences
        };
        var n = s(r(83399)),
          i = s(r(45772)),
          o = s(r(71229));

        function s(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var a = {
          ignoreCase: !1,
          minOccurrences: 1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      59256: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.pbkdf2_sha512 = void 0;
        const n = r(32370);
        e.pbkdf2_sha512 = function(t, e, r, i) {
          return (0, n.pbkdf2_sha512)(t, e, r, i)
        }
      },
      59302: (t, e, r) => {
        "use strict";
        var n, i = r(65606),
          o = function() {
            function t(t, e) {
              if ("function" != typeof t) throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: " + t + ".");
              this.Gr = t, this.Kr = function(t) {
                if (t && !1 === t.batch) return 1;
                var e = t && t.maxBatchSize;
                if (void 0 === e) return 1 / 0;
                if ("number" != typeof e || 1 > e) throw new TypeError("maxBatchSize must be a positive number: " + e);
                return e
              }(e), this.Vr = function(t) {
                var e = t && t.batchScheduleFn;
                if (void 0 === e) return s;
                if ("function" != typeof e) throw new TypeError("batchScheduleFn must be a function: " + e);
                return e
              }(e), this.Zr = function(t) {
                var e = t && t.cacheKeyFn;
                if (void 0 === e) return function(t) {
                  return t
                };
                if ("function" != typeof e) throw new TypeError("cacheKeyFn must be a function: " + e);
                return e
              }(e), this.qr = function(t) {
                if (t && !1 === t.cache) return null;
                var e = t && t.cacheMap;
                if (void 0 === e) return new Map;
                if (null !== e) {
                  var r = ["get", "set", "delete", "clear"].filter(function(t) {
                    return e && "function" != typeof e[t]
                  });
                  if (0 !== r.length) throw new TypeError("Custom cacheMap missing methods: " + r.join(", "))
                }
                return e
              }(e), this.Jr = null, this.name = function(t) {
                return t && t.name ? t.name : null
              }(e)
            }
            var e = t.prototype;
            return e.load = function(t) {
              if (null == t) throw new TypeError("The loader.load() function must be called with a value, but got: " + t + ".");
              var e, r = function(t) {
                  var e = t.Jr;
                  if (null !== e && !e.hasDispatched && e.keys.length < t.Kr) return e;
                  var r = {
                    hasDispatched: !1,
                    keys: [],
                    callbacks: []
                  };
                  return t.Jr = r, t.Vr(function() {
                    ! function(t, e) {
                      if (e.hasDispatched = !0, 0 !== e.keys.length) {
                        var r;
                        try {
                          r = t.Gr(e.keys)
                        } catch (r) {
                          return a(t, e, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: " + r + "."))
                        }
                        if (!r || "function" != typeof r.then) return a(t, e, new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: " + r + "."));
                        r.then(function(t) {
                          if (!c(t)) throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: " + t + ".");
                          if (t.length !== e.keys.length) throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.\n\nKeys:\n" + e.keys + "\n\nValues:\n" + t);
                          u(e);
                          for (var r = 0; r < e.callbacks.length; r++) {
                            var n = t[r];
                            n instanceof Error ? e.callbacks[r].reject(n) : e.callbacks[r].resolve(n)
                          }
                        }).catch(function(r) {
                          a(t, e, r)
                        })
                      } else u(e)
                    }(t, r)
                  }), r
                }(this),
                n = this.qr;
              if (n) {
                e = this.Zr(t);
                var i = n.get(e);
                if (i) {
                  var o = r.cacheHits || (r.cacheHits = []);
                  return new Promise(function(t) {
                    o.push(function() {
                      t(i)
                    })
                  })
                }
              }
              r.keys.push(t);
              var s = new Promise(function(t, e) {
                r.callbacks.push({
                  resolve: t,
                  reject: e
                })
              });
              return n && n.set(e, s), s
            }, e.loadMany = function(t) {
              if (!c(t)) throw new TypeError("The loader.loadMany() function must be called with Array<key> but got: " + t + ".");
              for (var e = [], r = 0; r < t.length; r++) e.push(this.load(t[r]).catch(function(t) {
                return t
              }));
              return Promise.all(e)
            }, e.clear = function(t) {
              var e = this.qr;
              if (e) {
                var r = this.Zr(t);
                e.delete(r)
              }
              return this
            }, e.clearAll = function() {
              var t = this.qr;
              return t && t.clear(), this
            }, e.prime = function(t, e) {
              var r = this.qr;
              if (r) {
                var n, i = this.Zr(t);
                void 0 === r.get(i) && (e instanceof Error ? (n = Promise.reject(e)).catch(function() {}) : n = Promise.resolve(e), r.set(i, n))
              }
              return this
            }, t
          }(),
          s = "object" == typeof i && "function" == typeof i.nextTick ? function(t) {
            n || (n = Promise.resolve()), n.then(function() {
              i.nextTick(t)
            })
          } : "function" == typeof setImmediate ? function(t) {
            setImmediate(t)
          } : function(t) {
            setTimeout(t)
          };

        function a(t, e, r) {
          u(e);
          for (var n = 0; n < e.keys.length; n++) t.clear(e.keys[n]), e.callbacks[n].reject(r)
        }

        function u(t) {
          if (t.cacheHits)
            for (var e = 0; e < t.cacheHits.length; e++) t.cacheHits[e]()
        }

        function c(t) {
          return "object" == typeof t && null !== t && "number" == typeof t.length && (0 === t.length || t.length > 0 && {}.hasOwnProperty.call(t, t.length - 1))
        }
        t.exports = o
      },
      59498: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;

        function i(t) {
          if ("string" != typeof t) throw Error("[isHexPrefixed] input must be type 'string', received type " + typeof t);
          return "0" === t[0] && "x" === t[1]
        }

        function o(t) {
          let e = t;
          if ("string" != typeof e) throw Error("[padToEven] value must be type 'string', received " + typeof e);
          return e.length % 2 && (e = "0" + e), e
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isHexString = e.getKeys = e.fromAscii = e.fromUtf8 = e.toAscii = e.arrayContainsArray = e.getBinarySize = e.padToEven = e.stripHexPrefix = e.isHexPrefixed = void 0, e.isHexPrefixed = i, e.stripHexPrefix = t => {
          if ("string" != typeof t) throw Error("[stripHexPrefix] input must be type 'string', received " + typeof t);
          return i(t) ? t.slice(2) : t
        }, e.padToEven = o, e.getBinarySize = function(t) {
          if ("string" != typeof t) throw Error("[getBinarySize] method requires input type 'string', received " + typeof t);
          return n.byteLength(t, "utf8")
        }, e.arrayContainsArray = function(t, e, r) {
          if (!0 !== Array.isArray(t)) throw Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof t}'`);
          if (!0 !== Array.isArray(e)) throw Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof e}'`);
          return e[!0 === r ? "some" : "every"](e => t.indexOf(e) >= 0)
        }, e.toAscii = function(t) {
          let e = "",
            r = 0;
          const n = t.length;
          for ("0x" === t.substring(0, 2) && (r = 2); n > r; r += 2) {
            const n = parseInt(t.substr(r, 2), 16);
            e += String.fromCharCode(n)
          }
          return e
        }, e.fromUtf8 = function(t) {
          return "0x" + o(n.from(t, "utf8").toString("hex")).replace(/^0+|0+$/g, "")
        }, e.fromAscii = function(t) {
          let e = "";
          for (let r = 0; r < t.length; r++) {
            const n = t.charCodeAt(r).toString(16);
            e += 2 > n.length ? "0" + n : n
          }
          return "0x" + e
        }, e.getKeys = function(t, e, r) {
          if (!Array.isArray(t)) throw Error("[getKeys] method expects input 'params' to be an array, got " + typeof t);
          if ("string" != typeof e) throw Error("[getKeys] method expects input 'key' to be type 'string', got " + typeof t);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            let o = t[i][e];
            if (!0 !== r || o) {
              if ("string" != typeof o) throw Error("invalid abi - expected type 'string', received " + typeof o)
            } else o = "";
            n.push(o)
          }
          return n
        }, e.isHexString = function(t, e) {
          return !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/) || "u" > typeof e && e > 0 && t.length !== 2 + 2 * e)
        }
      },
      59717: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function t(e, r) {
          (0, i.default)(e);
          var n = (r?.version || r) + "";
          if (!(null != r && r.version || r)) return t(e, {
            version: 10
          }) || t(e, {
            version: 13
          });
          var u = e.replace(/[\s-]+/g, ""),
            c = 0;
          if ("10" === n) {
            if (!o.test(u)) return !1;
            for (var f = 0; n - 1 > f; f++) c += (f + 1) * u.charAt(f);
            if ("X" === u.charAt(9) ? c += 100 : c += 10 * u.charAt(9), c % 11 == 0) return !0
          } else if ("13" === n) {
            if (!s.test(u)) return !1;
            for (var l = 0; 12 > l; l++) c += a[l % 2] * u.charAt(l);
            if (u.charAt(12) - (10 - c % 10) % 10 == 0) return !0
          }
          return !1
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(?:[0-9]{9}X|[0-9]{10})$/,
          s = /^(?:[0-9]{13})$/,
          a = [1, 3];
        t.exports = e.default, t.exports.default = e.default
      },
      59745: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[a-f0-9]{32}$/;
        t.exports = e.default, t.exports.default = e.default
      },
      60027: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ChecksumStruct = void 0;
        const n = r(35620),
          i = r(94107);
        e.ChecksumStruct = (0, n.size)((0, i.base64)((0, n.string)(), {
          paddingRequired: !0
        }), 44, 44)
      },
      60082: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(0x)[0-9a-f]{40}$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      60445: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeCommonMessageInfo = e.loadCommonMessageInfo = void 0;
        const n = r(10574);
        e.loadCommonMessageInfo = function(t) {
          return t.loadBit() ? t.loadBit() ? {
            type: "external-out",
            src: t.loadAddress(),
            dest: t.loadMaybeExternalAddress(),
            createdLt: t.loadUintBig(64),
            createdAt: t.loadUint(32)
          } : {
            type: "external-in",
            src: t.loadMaybeExternalAddress(),
            dest: t.loadAddress(),
            importFee: t.loadCoins()
          } : {
            type: "internal",
            ihrDisabled: t.loadBit(),
            bounce: t.loadBit(),
            bounced: t.loadBit(),
            src: t.loadAddress(),
            dest: t.loadAddress(),
            value: (0, n.loadCurrencyCollection)(t),
            ihrFee: t.loadCoins(),
            forwardFee: t.loadCoins(),
            createdLt: t.loadUintBig(64),
            createdAt: t.loadUint(32)
          }
        }, e.storeCommonMessageInfo = function(t) {
          return e => {
            if ("internal" === t.type) e.storeBit(0), e.storeBit(t.ihrDisabled), e.storeBit(t.bounce), e.storeBit(t.bounced), e.storeAddress(t.src), e.storeAddress(t.dest), e.store((0, n.storeCurrencyCollection)(t.value)), e.storeCoins(t.ihrFee), e.storeCoins(t.forwardFee), e.storeUint(t.createdLt, 64), e.storeUint(t.createdAt, 32);
            else if ("external-in" === t.type) e.storeBit(1), e.storeBit(0), e.storeAddress(t.src), e.storeAddress(t.dest), e.storeCoins(t.importFee);
            else {
              if ("external-out" !== t.type) throw Error("Unknown CommonMessageInfo type");
              e.storeBit(1), e.storeBit(1), e.storeAddress(t.src), e.storeAddress(t.dest), e.storeUint(t.createdLt, 64), e.storeUint(t.createdAt, 32)
            }
          }
        }
      },
      60604: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (0, i.default)(t);
          var r = o;
          if (r = e.require_hyphen ? r.replace("?", "") : r, !(r = e.case_sensitive ? RegExp(r) : RegExp(r, "i")).test(t)) return !1;
          for (var n = t.replace("-", "").toUpperCase(), s = 0, a = 0; a < n.length; a++) {
            var u = n[a];
            s += ("X" === u ? 10 : +u) * (8 - a)
          }
          return s % 11 == 0
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = "^\\d{4}-?\\d{3}[\\dX]$";
        t.exports = e.default, t.exports.default = e.default
      },
      61062: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (0, n.default)(t);
          var r = e.provider,
            o = t.replace(/[- ]+/g, "");
          if (r && r.toLowerCase() in s) {
            if (!s[r.toLowerCase()].test(o)) return !1
          } else {
            if (r && !(r.toLowerCase() in s)) throw Error("".concat(r, " is not a valid credit card provider."));
            if (!a.some(function(t) {
                return t.test(o)
              })) return !1
          }
          return (0, i.default)(t)
        };
        var n = o(r(83399)),
          i = o(r(73609));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = {
            amex: /^3[47][0-9]{13}$/,
            dinersclub: /^3(?:0[0-5]|[68][0-9])[0-9]{11}$/,
            discover: /^6(?:011|5[0-9][0-9])[0-9]{12,15}$/,
            jcb: /^(?:2131|1800|35\d{3})\d{11}$/,
            mastercard: /^5[1-5][0-9]{2}|(222[1-9]|22[3-9][0-9]|2[3-6][0-9]{2}|27[01][0-9]|2720)[0-9]{12}$/,
            unionpay: /^(6[27][0-9]{14}|^(81[0-9]{14,17}))$/,
            visa: /^(?:4[0-9]{12})(?:[0-9]{3,6})?$/
          },
          a = function() {
            var t = [];
            for (var e in s) s.hasOwnProperty(e) && t.push(s[e]);
            return t
          }();
        t.exports = e.default, t.exports.default = e.default
      },
      61123: t => {
        const e = /^[0-9]+$/,
          r = (t, r) => {
            const n = e.test(t),
              i = e.test(r);
            return n && i && (t = +t, r = +r), t === r ? 0 : n && !i ? -1 : i && !n ? 1 : r > t ? -1 : 1
          };
        t.exports = {
          compareIdentifiers: r,
          rcompareIdentifiers: (t, e) => r(e, t)
        }
      },
      61195: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          var r = e?.comparisonDate || e || Date().toString(),
            n = (0, i.default)(r),
            o = (0, i.default)(t);
          return !!(o && n && o > n)
        };
        var n, i = (n = r(13752)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      61270: function(t, e, r) {
        var n;
        t = r.nmd(t),
          function() {
            e && e.nodeType, t && t.nodeType;
            var i = "object" == typeof r.g && r.g;
            i.global === i || i.window === i || i.self;
            var o = 2147483647,
              s = 36,
              a = /^xn--/,
              u = /[^\x20-\x7E]/,
              c = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
              },
              f = Math.floor,
              l = String.fromCharCode;

            function h(t) {
              throw new RangeError(c[t])
            }

            function d(t, e) {
              for (var r = t.length, n = []; r--;) n[r] = e(t[r]);
              return n
            }

            function p(t, e) {
              var r = t.split("@"),
                n = "";
              return r.length > 1 && (n = r[0] + "@", t = r[1]), n + d((t = t.replace(/[\x2E\u3002\uFF0E\uFF61]/g, ".")).split("."), e).join(".")
            }

            function b(t) {
              for (var e, r, n = [], i = 0, o = t.length; o > i;) 55296 > (e = t.charCodeAt(i++)) || e > 56319 || i >= o ? n.push(e) : 56320 == (64512 & (r = t.charCodeAt(i++))) ? n.push(((1023 & e) << 10) + (1023 & r) + 65536) : (n.push(e), i--);
              return n
            }

            function m(t) {
              return d(t, function(t) {
                var e = "";
                return t > 65535 && (e += l((t -= 65536) >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e + l(t)
              }).join("")
            }

            function y(t) {
              return 10 > t - 48 ? t - 22 : 26 > t - 65 ? t - 65 : 26 > t - 97 ? t - 97 : s
            }

            function g(t, e) {
              return t + 22 + 75 * (26 > t) - ((0 != e) << 5)
            }

            function v(t, e, r) {
              var n = 0;
              for (t = r ? f(t / 700) : t >> 1, t += f(t / e); t > 455; n += s) t = f(t / 35);
              return f(n + 36 * t / (t + 38))
            }

            function w(t) {
              var e, r, n, i, a, u, c, l, d, p, b = [],
                g = t.length,
                w = 0,
                A = 128,
                T = 72;
              for (0 > (r = t.lastIndexOf("-")) && (r = 0), n = 0; r > n; ++n) t.charCodeAt(n) >= 128 && h("not-basic"), b.push(t.charCodeAt(n));
              for (i = r > 0 ? r + 1 : 0; g > i;) {
                for (a = w, u = 1, c = s; i >= g && h("invalid-input"), ((l = y(t.charCodeAt(i++))) >= s || l > f((o - w) / u)) && h("overflow"), w += l * u, (d = c > T ? T + 26 > c ? c - T : 26 : 1) <= l; c += s) u > f(o / (p = s - d)) && h("overflow"), u *= p;
                T = v(w - a, e = b.length + 1, 0 == a), f(w / e) > o - A && h("overflow"), A += f(w / e), w %= e, b.splice(w++, 0, A)
              }
              return m(b)
            }

            function A(t) {
              var e, r, n, i, a, u, c, d, p, m, y, w, A, T, E, P = [];
              for (w = (t = b(t)).length, e = 128, r = 0, a = 72, u = 0; w > u; ++u) 128 > (y = t[u]) && P.push(l(y));
              for (n = i = P.length, i && P.push("-"); w > n;) {
                for (c = o, u = 0; w > u; ++u)(y = t[u]) >= e && c > y && (c = y);
                for (c - e > f((o - r) / (A = n + 1)) && h("overflow"), r += (c - e) * A, e = c, u = 0; w > u; ++u)
                  if (e > (y = t[u]) && ++r > o && h("overflow"), y == e) {
                    for (d = r, p = s;
                      (m = p > a ? a + 26 > p ? p - a : 26 : 1) <= d; p += s) E = d - m, T = s - m, P.push(l(g(m + E % T, 0))), d = f(E / T);
                    P.push(l(g(d, 0))), a = v(r, A, n == i), r = 0, ++n
                  }++ r, ++e
              }
              return P.join("")
            }
            void 0 !== (n = {
              version: "1.4.1",
              ucs2: {
                decode: b,
                encode: m
              },
              decode: w,
              encode: A,
              toASCII: function(t) {
                return p(t, function(t) {
                  return u.test(t) ? "xn--" + A(t) : t
                })
              },
              toUnicode: function(t) {
                return p(t, function(t) {
                  return a.test(t) ? w(t.slice(4).toLowerCase()) : t
                })
              }
            }) && (t.exports = n)
          }()
      },
      61461: function(t, e) {
        "use strict";
        var r, n, i = this && this.wr || function(t, e, r, n) {
            if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter");
            if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
            return "m" === r ? n : "a" === r ? n.call(t) : n ? n.value : e.get(t)
          },
          o = this && this.vr || function(t, e, r, n, i) {
            if ("m" === n) throw new TypeError("Private method is not writable");
            if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter");
            if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
            return "a" === n ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.FrozenSet = e.FrozenMap = void 0;
        class s {
          get size() {
            return i(this, r, "f").size
          } [(r = new WeakMap, Symbol.iterator)]() {
            return i(this, r, "f")[Symbol.iterator]()
          }
          constructor(t) {
            r.set(this, void 0), o(this, r, new Map(t), "f"), Object.freeze(this)
          }
          entries() {
            return i(this, r, "f").entries()
          }
          forEach(t, e) {
            return i(this, r, "f").forEach((r, n, i) => t.call(e, r, n, this))
          }
          get(t) {
            return i(this, r, "f").get(t)
          }
          has(t) {
            return i(this, r, "f").has(t)
          }
          keys() {
            return i(this, r, "f").keys()
          }
          values() {
            return i(this, r, "f").values()
          }
          toString() {
            return `FrozenMap(${this.size}) {${this.size>0?` ${[...this.entries()].map(([t,e])=>`${t+""} => ${e+""}`).join(", ")} `:""}}`
          }
        }
        e.FrozenMap = s;
        class a {
          get size() {
            return i(this, n, "f").size
          } [(n = new WeakMap, Symbol.iterator)]() {
            return i(this, n, "f")[Symbol.iterator]()
          }
          constructor(t) {
            n.set(this, void 0), o(this, n, new Set(t), "f"), Object.freeze(this)
          }
          entries() {
            return i(this, n, "f").entries()
          }
          forEach(t, e) {
            return i(this, n, "f").forEach((r, n, i) => t.call(e, r, n, this))
          }
          has(t) {
            return i(this, n, "f").has(t)
          }
          keys() {
            return i(this, n, "f").keys()
          }
          values() {
            return i(this, n, "f").values()
          }
          toString() {
            return `FrozenSet(${this.size}) {${this.size>0?` ${[...this.values()].map(t=>t+"").join(", ")} `:""}}`
          }
        }
        e.FrozenSet = a, Object.freeze(s), Object.freeze(s.prototype), Object.freeze(a), Object.freeze(a.prototype)
      },
      61578: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), h.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /([01][0-9]|2[0-3])/,
          s = /[0-5][0-9]/,
          a = RegExp("[-+]".concat(o.source, ":").concat(s.source)),
          u = RegExp("([zZ]|".concat(a.source, ")")),
          c = RegExp("".concat(o.source, ":").concat(s.source, ":").concat(/([0-5][0-9]|60)/.source).concat(/(\.[0-9]+)?/.source)),
          f = RegExp("".concat(/[0-9]{4}/.source, "-").concat(/(0[1-9]|1[0-2])/.source, "-").concat(/([12]\d|0[1-9]|3[01])/.source)),
          l = RegExp("".concat(c.source).concat(u.source)),
          h = RegExp("^".concat(f.source, "[ tT]").concat(l.source, "$"));
        t.exports = e.default, t.exports.default = e.default
      },
      61996: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          return (0, i.default)(t), t.replace(RegExp("[^".concat(e, "]+"), "g"), "")
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      62031: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.hmac = e.HMAC = void 0;
        const n = r(28021),
          i = r(17412);
        class o extends i.Hash {
          constructor(t, e) {
            super(), this.finished = !1, this.destroyed = !1, (0, n.hash)(t);
            const r = (0, i.toBytes)(e);
            if (this.iHash = t.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
            this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
            const o = this.blockLen,
              s = new Uint8Array(o);
            s.set(r.length > o ? t.create().update(r).digest() : r);
            for (let t = 0; t < s.length; t++) s[t] ^= 54;
            this.iHash.update(s), this.oHash = t.create();
            for (let t = 0; t < s.length; t++) s[t] ^= 106;
            this.oHash.update(s), s.fill(0)
          }
          update(t) {
            return (0, n.exists)(this), this.iHash.update(t), this
          }
          digestInto(t) {
            (0, n.exists)(this), (0, n.bytes)(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
          }
          digest() {
            const t = new Uint8Array(this.oHash.outputLen);
            return this.digestInto(t), t
          }
          jt(t) {
            t || (t = Object.create(Object.getPrototypeOf(this), {}));
            const {
              oHash: e,
              iHash: r,
              finished: n,
              destroyed: i,
              blockLen: o,
              outputLen: s
            } = this;
            return t.finished = n, t.destroyed = i, t.blockLen = o, t.outputLen = s, t.oHash = e.jt(t.oHash), t.iHash = r.jt(t.iHash), t
          }
          destroy() {
            this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
          }
        }
        e.HMAC = o, e.hmac = (t, e, r) => new o(t, e).update(r).digest(), e.hmac.create = (t, e) => new o(t, e)
      },
      62142: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeAccount = e.loadAccount = void 0;
        const n = r(86161),
          i = r(69456);
        e.loadAccount = function(t) {
          return {
            addr: t.loadAddress(),
            storageStats: (0, i.loadStorageInfo)(t),
            storage: (0, n.loadAccountStorage)(t)
          }
        }, e.storeAccount = function(t) {
          return e => {
            e.storeAddress(t.addr), e.store((0, i.storeStorageInfo)(t.storageStats)), e.store((0, n.storeAccountStorage)(t.storage))
          }
        }
      },
      62309: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = e ? RegExp("^[".concat(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "]+"), "g") : /^\s+/g;
          return t.replace(r, "")
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      62312: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeAccountStatusChange = e.loadAccountStatusChange = void 0, e.loadAccountStatusChange = function(t) {
          return t.loadBit() ? t.loadBit() ? "deleted" : "frozen" : "unchanged"
        }, e.storeAccountStatusChange = function(t) {
          return e => {
            if ("unchanged" == t) e.storeBit(0);
            else if ("frozen" === t) e.storeBit(1), e.storeBit(0);
            else {
              if ("deleted" !== t) throw Error("Invalid account status change");
              e.storeBit(1), e.storeBit(1)
            }
          }
        }
      },
      62386: function(t, e, r) {
        "use strict";
        var n, i = r(48287).Buffer,
          o = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.BitString = void 0;
        const s = r(34382),
          a = o(r(29107));
        class u {
          static isBitString(t) {
            return t instanceof u
          }
          constructor(t, e, r) {
            if (this[n] = () => this.toString(), 0 > r) throw Error(`Length ${r} is out of bounds`);
            this.gr = r, this.Yr = t, this.Er = e
          }
          get length() {
            return this.gr
          }
          at(t) {
            if (t >= this.gr) throw Error(`Index ${t} > ${this.gr} is out of bounds`);
            if (0 > t) throw Error(`Index ${t} < 0 is out of bounds`);
            let e = this.Er + t >> 3,
              r = 7 - (this.Er + t) % 8;
            return !!(this.Yr[e] & 1 << r)
          }
          substring(t, e) {
            if (t > this.gr) throw Error(`Offset(${t}) > ${this.gr} is out of bounds`);
            if (0 > t) throw Error(`Offset(${t}) < 0 is out of bounds`);
            if (0 === e) return u.EMPTY;
            if (t + e > this.gr) throw Error(`Offset ${t} + Length ${e} > ${this.gr} is out of bounds`);
            return new u(this.Yr, this.Er + t, e)
          }
          subbuffer(t, e) {
            if (t > this.gr) throw Error(`Offset ${t} is out of bounds`);
            if (0 > t) throw Error(`Offset ${t} is out of bounds`);
            if (t + e > this.gr) throw Error(`Offset + Lenght = ${t+e} is out of bounds`);
            if (e % 8 != 0 || (this.Er + t) % 8 != 0) return null;
            let r = this.Er + t >> 3,
              n = r + (e >> 3);
            return this.Yr.subarray(r, n)
          }
          equals(t) {
            if (this.gr !== t.gr) return !1;
            for (let e = 0; e < this.gr; e++)
              if (this.at(e) !== t.at(e)) return !1;
            return !0
          }
          toString() {
            const t = (0, s.bitsToPaddedBuffer)(this);
            if (this.gr % 4 == 0) {
              const e = t.subarray(0, Math.ceil(this.gr / 8)).toString("hex").toUpperCase();
              return this.gr % 8 == 0 ? e : e.substring(0, e.length - 1)
            } {
              const e = t.toString("hex").toUpperCase();
              return this.gr % 8 > 4 ? e + "_" : e.substring(0, e.length - 1) + "_"
            }
          }
        }
        e.BitString = u, n = a.default, u.EMPTY = new u(i.alloc(0), 0, 0)
      },
      62441: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.pbkdf2_sha512 = void 0, e.pbkdf2_sha512 = async function(t, e, r, i) {
          const o = "string" == typeof t ? n.from(t, "utf-8") : t,
            s = "string" == typeof e ? n.from(e, "utf-8") : e,
            a = await window.crypto.subtle.importKey("raw", o, {
              name: "PBKDF2"
            }, !1, ["deriveBits"]),
            u = await window.crypto.subtle.deriveBits({
              name: "PBKDF2",
              hash: "SHA-512",
              salt: s,
              iterations: r
            }, a, 8 * i);
          return n.from(u)
        }
      },
      62642: (t, e, r) => {
        "use strict";
        var n = r(37720),
          i = {}.hasOwnProperty,
          o = Array.isArray,
          s = {
            allowDots: !1,
            allowEmptyArrays: !1,
            allowPrototypes: !1,
            allowSparse: !1,
            arrayLimit: 20,
            charset: "utf-8",
            charsetSentinel: !1,
            comma: !1,
            decodeDotInKeys: !1,
            decoder: n.decode,
            delimiter: "&",
            depth: 5,
            duplicates: "combine",
            ignoreQueryPrefix: !1,
            interpretNumericEntities: !1,
            parameterLimit: 1e3,
            parseArrays: !0,
            plainObjects: !1,
            strictDepth: !1,
            strictNullHandling: !1,
            throwOnLimitExceeded: !1
          },
          a = function(t) {
            return t.replace(/&#(\d+);/g, function(t, e) {
              return String.fromCharCode(parseInt(e, 10))
            })
          },
          u = function(t, e, r) {
            if (t && "string" == typeof t && e.comma && t.indexOf(",") > -1) return t.split(",");
            if (e.throwOnLimitExceeded && r >= e.arrayLimit) throw new RangeError("Array limit exceeded. Only " + e.arrayLimit + " element" + (1 === e.arrayLimit ? "" : "s") + " allowed in an array.");
            return t
          },
          c = function(t, e, r, o) {
            if (t) {
              var s = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t,
                a = /(\[[^[\]]*])/g,
                c = r.depth > 0 && /(\[[^[\]]*])/.exec(s),
                f = c ? s.slice(0, c.index) : s,
                l = [];
              if (f) {
                if (!r.plainObjects && i.call(Object.prototype, f) && !r.allowPrototypes) return;
                l.push(f)
              }
              for (var h = 0; r.depth > 0 && null !== (c = a.exec(s)) && h < r.depth;) {
                if (h += 1, !r.plainObjects && i.call(Object.prototype, c[1].slice(1, -1)) && !r.allowPrototypes) return;
                l.push(c[1])
              }
              if (c) {
                if (!0 === r.strictDepth) throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
                l.push("[" + s.slice(c.index) + "]")
              }
              return function(t, e, r, i) {
                var o = 0;
                if (t.length > 0 && "[]" === t[t.length - 1]) {
                  var s = t.slice(0, -1).join("");
                  o = Array.isArray(e) && e[s] ? e[s].length : 0
                }
                for (var a = i ? e : u(e, r, o), c = t.length - 1; c >= 0; --c) {
                  var f, l = t[c];
                  if ("[]" === l && r.parseArrays) f = r.allowEmptyArrays && ("" === a || r.strictNullHandling && null === a) ? [] : n.combine([], a);
                  else {
                    f = r.plainObjects ? {
                      __proto__: null
                    } : {};
                    var h = "[" === l.charAt(0) && "]" === l.charAt(l.length - 1) ? l.slice(1, -1) : l,
                      d = r.decodeDotInKeys ? h.replace(/%2E/g, ".") : h,
                      p = parseInt(d, 10);
                    r.parseArrays || "" !== d ? isNaN(p) || l === d || p + "" !== d || 0 > p || !r.parseArrays || p > r.arrayLimit ? "__proto__" !== d && (f[d] = a) : (f = [])[p] = a : f = {
                      0: a
                    }
                  }
                  a = f
                }
                return a
              }(l, e, r, o)
            }
          };
        t.exports = function(t, e) {
          var r = function(t) {
            if (!t) return s;
            if ("u" > typeof t.allowEmptyArrays && "boolean" != typeof t.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
            if ("u" > typeof t.decodeDotInKeys && "boolean" != typeof t.decodeDotInKeys) throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
            if (null !== t.decoder && "u" > typeof t.decoder && "function" != typeof t.decoder) throw new TypeError("Decoder has to be a function.");
            if ("u" > typeof t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
            if ("u" > typeof t.throwOnLimitExceeded && "boolean" != typeof t.throwOnLimitExceeded) throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
            var e = typeof t.charset > "u" ? s.charset : t.charset,
              r = typeof t.duplicates > "u" ? s.duplicates : t.duplicates;
            if ("combine" !== r && "first" !== r && "last" !== r) throw new TypeError("The duplicates option must be either combine, first, or last");
            return {
              allowDots: typeof t.allowDots > "u" ? !0 === t.decodeDotInKeys || s.allowDots : !!t.allowDots,
              allowEmptyArrays: "boolean" == typeof t.allowEmptyArrays ? !!t.allowEmptyArrays : s.allowEmptyArrays,
              allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : s.allowPrototypes,
              allowSparse: "boolean" == typeof t.allowSparse ? t.allowSparse : s.allowSparse,
              arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : s.arrayLimit,
              charset: e,
              charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : s.charsetSentinel,
              comma: "boolean" == typeof t.comma ? t.comma : s.comma,
              decodeDotInKeys: "boolean" == typeof t.decodeDotInKeys ? t.decodeDotInKeys : s.decodeDotInKeys,
              decoder: "function" == typeof t.decoder ? t.decoder : s.decoder,
              delimiter: "string" == typeof t.delimiter || n.isRegExp(t.delimiter) ? t.delimiter : s.delimiter,
              depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : s.depth,
              duplicates: r,
              ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
              interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : s.interpretNumericEntities,
              parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : s.parameterLimit,
              parseArrays: !1 !== t.parseArrays,
              plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : s.plainObjects,
              strictDepth: "boolean" == typeof t.strictDepth ? !!t.strictDepth : s.strictDepth,
              strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : s.strictNullHandling,
              throwOnLimitExceeded: "boolean" == typeof t.throwOnLimitExceeded && t.throwOnLimitExceeded
            }
          }(e);
          if ("" === t || null === t || typeof t > "u") return r.plainObjects ? {
            __proto__: null
          } : {};
          for (var f = "string" == typeof t ? function(t, e) {
              var r = {
                  __proto__: null
                },
                c = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
              c = c.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
              var f = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit,
                l = c.split(e.delimiter, e.throwOnLimitExceeded ? f + 1 : f);
              if (e.throwOnLimitExceeded && l.length > f) throw new RangeError("Parameter limit exceeded. Only " + f + " parameter" + (1 === f ? "" : "s") + " allowed.");
              var h, d = -1,
                p = e.charset;
              if (e.charsetSentinel)
                for (h = 0; h < l.length; ++h) 0 === l[h].indexOf("utf8=") && ("utf8=%E2%9C%93" === l[h] ? p = "utf-8" : "utf8=%26%2310003%3B" === l[h] && (p = "iso-8859-1"), d = h, h = l.length);
              for (h = 0; h < l.length; ++h)
                if (h !== d) {
                  var b, m, y = l[h],
                    g = y.indexOf("]="),
                    v = -1 === g ? y.indexOf("=") : g + 1; - 1 === v ? (b = e.decoder(y, s.decoder, p, "key"), m = e.strictNullHandling ? null : "") : (b = e.decoder(y.slice(0, v), s.decoder, p, "key"), m = n.maybeMap(u(y.slice(v + 1), e, o(r[b]) ? r[b].length : 0), function(t) {
                    return e.decoder(t, s.decoder, p, "value")
                  })), m && e.interpretNumericEntities && "iso-8859-1" === p && (m = a(m + "")), y.indexOf("[]=") > -1 && (m = o(m) ? [m] : m);
                  var w = i.call(r, b);
                  w && "combine" === e.duplicates ? r[b] = n.combine(r[b], m) : (!w || "last" === e.duplicates) && (r[b] = m)
                } return r
            }(t, r) : t, l = r.plainObjects ? {
              __proto__: null
            } : {}, h = Object.keys(f), d = 0; d < h.length; ++d) {
            var p = h[d],
              b = c(p, f[p], r, "string" == typeof t);
            l = n.merge(l, b, r)
          }
          return !0 === r.allowSparse ? l : n.compact(l)
        }
      },
      62645: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, n.default)(t), e in s) return s[e](t);
          if ("any" === e) {
            for (var r in s)
              if (s.hasOwnProperty(r) && (0, s[r])(t)) return !0;
            return !1
          }
          throw Error("Invalid locale '".concat(e, "'"))
        };
        var n = o(r(83399)),
          i = o(r(76084));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = {
          PL: function(t) {
            (0, n.default)(t);
            var e = {
              1: 1,
              2: 3,
              3: 7,
              4: 9,
              5: 1,
              6: 3,
              7: 7,
              8: 9,
              9: 1,
              10: 3,
              11: 0
            };
            if (null != t && 11 === t.length && (0, i.default)(t, {
                allow_leading_zeroes: !0
              })) {
              var r = t.split("").slice(0, -1).reduce(function(t, r, n) {
                  return t + +r * e[n + 1]
                }, 0) % 10,
                o = +t.charAt(t.length - 1);
              if (0 === r && 0 === o || o === 10 - r) return !0
            }
            return !1
          },
          ES: function(t) {
            (0, n.default)(t);
            var e = {
                X: 0,
                Y: 1,
                Z: 2
              },
              r = t.trim().toUpperCase();
            if (!/^[0-9X-Z][0-9]{7}[TRWAGMYFPDXBNJZSQVHLCKE]$/.test(r)) return !1;
            var i = r.slice(0, -1).replace(/[X,Y,Z]/g, function(t) {
              return e[t]
            });
            return r.endsWith(["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][i % 23])
          },
          FI: function(t) {
            return (0, n.default)(t), !(11 !== t.length || !t.match(/^\d{6}[\-A\+]\d{3}[0-9ABCDEFHJKLMNPRSTUVWXY]{1}$/)) && "0123456789ABCDEFHJKLMNPRSTUVWXY" [(1e3 * parseInt(t.slice(0, 6), 10) + parseInt(t.slice(7, 10), 10)) % 31] === t.slice(10, 11)
          },
          IN: function(t) {
            var e = [
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 2, 3, 4, 0, 6, 7, 8, 9, 5],
                [2, 3, 4, 0, 1, 7, 8, 9, 5, 6],
                [3, 4, 0, 1, 2, 8, 9, 5, 6, 7],
                [4, 0, 1, 2, 3, 9, 5, 6, 7, 8],
                [5, 9, 8, 7, 6, 0, 4, 3, 2, 1],
                [6, 5, 9, 8, 7, 1, 0, 4, 3, 2],
                [7, 6, 5, 9, 8, 2, 1, 0, 4, 3],
                [8, 7, 6, 5, 9, 3, 2, 1, 0, 4],
                [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
              ],
              r = [
                [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                [1, 5, 7, 6, 2, 8, 3, 0, 9, 4],
                [5, 8, 0, 3, 7, 9, 6, 1, 4, 2],
                [8, 9, 1, 6, 0, 4, 3, 5, 2, 7],
                [9, 4, 5, 3, 1, 2, 6, 8, 7, 0],
                [4, 2, 8, 6, 5, 7, 3, 9, 0, 1],
                [2, 7, 9, 3, 8, 0, 6, 4, 1, 5],
                [7, 0, 4, 6, 9, 1, 3, 2, 5, 8]
              ],
              n = t.trim();
            if (!/^[1-9]\d{3}\s?\d{4}\s?\d{4}$/.test(n)) return !1;
            var i = 0;
            return n.replace(/\s/g, "").split("").map(Number).reverse().forEach(function(t, n) {
              i = e[i][r[n % 8][t]]
            }), 0 === i
          },
          IR: function(t) {
            if (!t.match(/^\d{10}$/) || (t = "0000".concat(t).slice(t.length - 6), 0 === parseInt(t.slice(3, 9), 10))) return !1;
            for (var e = parseInt(t.slice(9, 10), 10), r = 0, n = 0; 9 > n; n++) r += parseInt(t.slice(n, n + 1), 10) * (10 - n);
            return 2 > (r %= 11) && e === r || r >= 2 && e === 11 - r
          },
          IT: function(t) {
            return 9 === t.length && "CA00000AA" !== t && t.search(/C[A-Z][0-9]{5}[A-Z]{2}/i) > -1
          },
          NO: function(t) {
            var e = t.trim();
            if (isNaN(+e) || 11 !== e.length || "00000000000" === e) return !1;
            var r = e.split("").map(Number),
              n = (11 - (3 * r[0] + 7 * r[1] + 6 * r[2] + 1 * r[3] + 8 * r[4] + 9 * r[5] + 4 * r[6] + 5 * r[7] + 2 * r[8]) % 11) % 11,
              i = (11 - (5 * r[0] + 4 * r[1] + 3 * r[2] + 2 * r[3] + 7 * r[4] + 6 * r[5] + 5 * r[6] + 4 * r[7] + 3 * r[8] + 2 * n) % 11) % 11;
            return !(n !== r[9] || i !== r[10])
          },
          TH: function(t) {
            if (!t.match(/^[1-8]\d{12}$/)) return !1;
            for (var e = 0, r = 0; 12 > r; r++) e += parseInt(t[r], 10) * (13 - r);
            return t[12] === "" + (11 - e % 11) % 10
          },
          LK: function(t) {
            return !(10 !== t.length || !/^[1-9]\d{8}[vx]$/i.test(t)) || !(12 !== t.length || !/^[1-9]\d{11}$/i.test(t))
          },
          "he-IL": function(t) {
            var e = t.trim();
            if (!/^\d{9}$/.test(e)) return !1;
            for (var r, n = e, i = 0, o = 0; o < n.length; o++) i += (r = +n[o] * (o % 2 + 1)) > 9 ? r - 9 : r;
            return i % 10 == 0
          },
          "ar-LY": function(t) {
            var e = t.trim();
            return !!/^(1|2)\d{11}$/.test(e)
          },
          "ar-TN": function(t) {
            var e = t.trim();
            return !!/^\d{8}$/.test(e)
          },
          "zh-CN": function(t) {
            var e, r = ["11", "12", "13", "14", "15", "21", "22", "23", "31", "32", "33", "34", "35", "36", "37", "41", "42", "43", "44", "45", "46", "50", "51", "52", "53", "54", "61", "62", "63", "64", "65", "71", "81", "82", "91"],
              n = ["7", "9", "10", "5", "8", "4", "2", "1", "6", "3", "7", "9", "10", "5", "8", "4", "2"],
              i = ["1", "0", "X", "9", "8", "7", "6", "5", "4", "3", "2"],
              o = function(t) {
                return r.includes(t)
              },
              s = function(t) {
                var e = parseInt(t.substring(0, 4), 10),
                  r = parseInt(t.substring(4, 6), 10),
                  n = parseInt(t.substring(6), 10),
                  i = new Date(e, r - 1, n);
                return new Date >= i && i.getFullYear() === e && i.getMonth() === r - 1 && i.getDate() === n
              };
            return !!/^\d{15}|(\d{17}(\d|x|X))$/.test(e = t) && (15 === e.length ? function(t) {
              var e = /^[1-9]\d{7}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}$/.test(t);
              if (!e) return !1;
              var r = t.substring(0, 2);
              if (!(e = o(r))) return !1;
              var n = "19".concat(t.substring(6, 12));
              return !!(e = s(n))
            }(e) : function(t) {
              var e = /^[1-9]\d{5}[1-9]\d{3}((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9])|(3[0-1]))\d{3}(\d|x|X)$/.test(t);
              if (!e) return !1;
              var r = t.substring(0, 2);
              if (!(e = o(r))) return !1;
              var a = t.substring(6, 14);
              return !!(e = s(a)) && function(t) {
                return function(t) {
                  for (var e = t.substring(0, 17), r = 0, o = 0; 17 > o; o++) r += parseInt(e.charAt(o), 10) * parseInt(n[o], 10);
                  return i[r % 11]
                }(t) === t.charAt(17).toUpperCase()
              }(t)
            }(e))
          },
          "zh-HK": function(t) {
            var e = /^[0-9]$/;
            if (t = (t = t.trim()).toUpperCase(), !/^[A-Z]{1,2}[0-9]{6}((\([0-9A]\))|(\[[0-9A]\])|([0-9A]))$/.test(t)) return !1;
            8 === (t = t.replace(/\[|\]|\(|\)/g, "")).length && (t = "3".concat(t));
            for (var r = 0, n = 0; 7 >= n; n++) r += (e.test(t[n]) ? t[n] : (t[n].charCodeAt(0) - 55) % 11) * (9 - n);
            return (0 == (r %= 11) ? "0" : 1 === r ? "A" : 11 - r + "") === t[t.length - 1]
          },
          "zh-TW": function(t) {
            var e = {
                A: 10,
                B: 11,
                C: 12,
                D: 13,
                E: 14,
                F: 15,
                G: 16,
                H: 17,
                I: 34,
                J: 18,
                K: 19,
                L: 20,
                M: 21,
                N: 22,
                O: 35,
                P: 23,
                Q: 24,
                R: 25,
                S: 26,
                T: 27,
                U: 28,
                V: 29,
                W: 32,
                X: 30,
                Y: 31,
                Z: 33
              },
              r = t.trim().toUpperCase();
            return !!/^[A-Z][0-9]{9}$/.test(r) && Array.from(r).reduce(function(t, r, n) {
              if (0 === n) {
                var i = e[r];
                return i % 10 * 9 + Math.floor(i / 10)
              }
              return 9 === n ? (10 - t % 10 - +r) % 10 == 0 : t + +r * (9 - n)
            }, 0)
          }
        };
        t.exports = e.default, t.exports.default = e.default
      },
      62672: (t, e) => {
        "use strict";

        function r(t) {
          return {
            public: t.loadBit(),
            root: t.loadRef()
          }
        }

        function n(t) {
          return e => {
            e.storeBit(t.public), e.storeRef(t.root)
          }
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.SimpleLibraryValue = e.storeSimpleLibrary = e.loadSimpleLibrary = void 0, e.loadSimpleLibrary = r, e.storeSimpleLibrary = n, e.SimpleLibraryValue = {
          serialize(t, e) {
            n(t)(e)
          },
          parse: t => r(t)
        }
      },
      63101: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.loadOutList = e.storeOutList = e.loadOutAction = e.storeOutAction = void 0;
        const n = r(84143),
          i = r(65871),
          o = r(10574),
          s = r(63137);

        function a(t) {
          switch (t.type) {
            case "sendMsg":
              return function(t) {
                return e => {
                  e.storeUint(u, 32).storeUint(t.mode, 8).storeRef((0, i.beginCell)().store((0, n.storeMessageRelaxed)(t.outMsg)).endCell())
                }
              }(t);
            case "setCode":
              return function(t) {
                return e => {
                  e.storeUint(c, 32).storeRef(t.newCode)
                }
              }(t);
            case "reserve":
              return function(t) {
                return e => {
                  e.storeUint(f, 32).storeUint(t.mode, 8).store((0, o.storeCurrencyCollection)(t.currency))
                }
              }(t);
            case "changeLibrary":
              return function(t) {
                return e => {
                  e.storeUint(l, 32).storeUint(t.mode, 7).store((0, s.storeLibRef)(t.libRef))
                }
              }(t);
            default:
              throw Error("Unknown action type " + t.type)
          }
        }
        e.storeOutAction = a;
        const u = 247711853,
          c = 2907562126,
          f = 921090057,
          l = 653925844;

        function h(t) {
          const e = t.loadUint(32);
          if (e === u) return {
            type: "sendMsg",
            mode: t.loadUint(8),
            outMsg: (0, n.loadMessageRelaxed)(t.loadRef().beginParse())
          };
          if (e === c) return {
            type: "setCode",
            newCode: t.loadRef()
          };
          if (e === f) return {
            type: "reserve",
            mode: t.loadUint(8),
            currency: (0, o.loadCurrencyCollection)(t)
          };
          if (e === l) return {
            type: "changeLibrary",
            mode: t.loadUint(7),
            libRef: (0, s.loadLibRef)(t)
          };
          throw Error("Unknown out action tag 0x" + e.toString(16))
        }
        e.loadOutAction = h, e.storeOutList = function(t) {
          const e = t.reduce((t, e) => (0, i.beginCell)().storeRef(t).store(a(e)).endCell(), (0, i.beginCell)().endCell());
          return t => {
            t.storeSlice(e.beginParse())
          }
        }, e.loadOutList = function(t) {
          const e = [];
          for (; t.remainingRefs;) {
            const r = t.loadRef();
            e.push(h(t)), t = r.beginParse()
          }
          return e.reverse()
        }
      },
      63137: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeLibRef = e.loadLibRef = void 0, e.loadLibRef = function(t) {
          return 0 === t.loadUint(1) ? {
            type: "hash",
            libHash: t.loadBuffer(32)
          } : {
            type: "ref",
            library: t.loadRef()
          }
        }, e.storeLibRef = function(t) {
          return e => {
            "hash" === t.type ? (e.storeUint(0, 1), e.storeBuffer(t.libHash)) : (e.storeUint(1, 1), e.storeRef(t.library))
          }
        }
      },
      63203: (t, e) => {
        "use strict";

        function r(t) {
          return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
        }

        function n(...t) {
          const e = t => t,
            r = (t, e) => r => t(e(r));
          return {
            encode: t.map(t => t.encode).reduceRight(r, e),
            decode: t.map(t => t.decode).reduce(r, e)
          }
        }

        function i(t) {
          return {
            encode: e => {
              if (!Array.isArray(e) || e.length && "number" != typeof e[0]) throw Error("alphabet.encode input should be an array of numbers");
              return e.map(e => {
                if (0 > e || e >= t.length) throw Error(`Digit index outside alphabet: ${e} (alphabet: ${t.length})`);
                return t[e]
              })
            },
            decode: e => {
              if (!Array.isArray(e) || e.length && "string" != typeof e[0]) throw Error("alphabet.decode input should be array of strings");
              return e.map(e => {
                if ("string" != typeof e) throw Error("alphabet.decode: not string element=" + e);
                const r = t.indexOf(e);
                if (-1 === r) throw Error(`Unknown letter: "${e}". Allowed: ${t}`);
                return r
              })
            }
          }
        }

        function o(t = "") {
          if ("string" != typeof t) throw Error("join separator should be string");
          return {
            encode: e => {
              if (!Array.isArray(e) || e.length && "string" != typeof e[0]) throw Error("join.encode input should be array of strings");
              for (let t of e)
                if ("string" != typeof t) throw Error("join.encode: non-string input=" + t);
              return e.join(t)
            },
            decode: e => {
              if ("string" != typeof e) throw Error("join.decode input should be string");
              return e.split(t)
            }
          }
        }

        function s(t, e = "=") {
          if ("string" != typeof e) throw Error("padding chr should be string");
          return {
            encode(r) {
              if (!Array.isArray(r) || r.length && "string" != typeof r[0]) throw Error("padding.encode input should be array of strings");
              for (let t of r)
                if ("string" != typeof t) throw Error("padding.encode: non-string input=" + t);
              for (; r.length * t % 8;) r.push(e);
              return r
            },
            decode(r) {
              if (!Array.isArray(r) || r.length && "string" != typeof r[0]) throw Error("padding.encode input should be array of strings");
              for (let t of r)
                if ("string" != typeof t) throw Error("padding.decode: non-string input=" + t);
              let n = r.length;
              if (n * t % 8) throw Error("Invalid padding: string should have whole number of bytes");
              for (; n > 0 && r[n - 1] === e; n--)
                if (!((n - 1) * t % 8)) throw Error("Invalid padding: string has too much padding");
              return r.slice(0, n)
            }
          }
        }

        function a(t) {
          if ("function" != typeof t) throw Error("normalize fn should be function");
          return {
            encode: t => t,
            decode: e => t(e)
          }
        }

        function u(t, e, r) {
          if (2 > e) throw Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);
          if (2 > r) throw Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);
          if (!Array.isArray(t)) throw Error("convertRadix: data should be array");
          if (!t.length) return [];
          let n = 0;
          const i = [],
            o = Array.from(t);
          for (o.forEach(t => {
              if (0 > t || t >= e) throw Error("Wrong integer: " + t)
            });;) {
            let t = 0,
              s = !0;
            for (let i = n; i < o.length; i++) {
              const a = o[i],
                u = e * t + a;
              if (!Number.isSafeInteger(u) || e * t / e !== t || u - a !== e * t) throw Error("convertRadix: carry overflow");
              t = u % r;
              const c = Math.floor(u / r);
              if (o[i] = c, !Number.isSafeInteger(c) || c * r + t !== u) throw Error("convertRadix: carry overflow");
              s && (c ? s = !1 : n = i)
            }
            if (i.push(t), s) break
          }
          for (let e = 0; e < t.length - 1 && 0 === t[e]; e++) i.push(0);
          return i.reverse()
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.bytes = e.stringToBytes = e.str = e.bytesToString = e.hex = e.utf8 = e.bech32m = e.bech32 = e.base58check = e.createBase58check = e.base58xmr = e.base58xrp = e.base58flickr = e.base58 = e.base64urlnopad = e.base64url = e.base64nopad = e.base64 = e.base32crockford = e.base32hexnopad = e.base32hex = e.base32nopad = e.base32 = e.base16 = e.utils = void 0, e.assertNumber = function(t) {
          if (!Number.isSafeInteger(t)) throw Error("Wrong integer: " + t)
        };
        const c = (t, e) => e ? c(e, t % e) : t,
          f = (t, e) => t + (e - c(t, e));

        function l(t, e, r, n) {
          if (!Array.isArray(t)) throw Error("convertRadix2: data should be array");
          if (0 >= e || e > 32) throw Error("convertRadix2: wrong from=" + e);
          if (0 >= r || r > 32) throw Error("convertRadix2: wrong to=" + r);
          if (f(e, r) > 32) throw Error(`convertRadix2: carry overflow from=${e} to=${r} carryBits=${f(e,r)}`);
          let i = 0,
            o = 0;
          const s = 2 ** r - 1,
            a = [];
          for (const n of t) {
            if (n >= 2 ** e) throw Error(`convertRadix2: invalid data word=${n} from=${e}`);
            if (i = i << e | n, o + e > 32) throw Error(`convertRadix2: carry overflow pos=${o} from=${e}`);
            for (o += e; o >= r; o -= r) a.push((i >> o - r & s) >>> 0);
            i &= 2 ** o - 1
          }
          if (i = i << r - o & s, !n && o >= e) throw Error("Excess padding");
          if (!n && i) throw Error("Non-zero padding: " + i);
          return n && o > 0 && a.push(i >>> 0), a
        }

        function h(t) {
          return {
            encode: e => {
              if (!r(e)) throw Error("radix.encode input should be Uint8Array");
              return u(Array.from(e), 256, t)
            },
            decode: e => {
              if (!Array.isArray(e) || e.length && "number" != typeof e[0]) throw Error("radix.decode input should be array of numbers");
              return Uint8Array.from(u(e, t, 256))
            }
          }
        }

        function d(t, e = !1) {
          if (0 >= t || t > 32) throw Error("radix2: bits should be in (0..32]");
          if (f(8, t) > 32 || f(t, 8) > 32) throw Error("radix2: carry overflow");
          return {
            encode: n => {
              if (!r(n)) throw Error("radix2.encode input should be Uint8Array");
              return l(Array.from(n), 8, t, !e)
            },
            decode: r => {
              if (!Array.isArray(r) || r.length && "number" != typeof r[0]) throw Error("radix2.decode input should be array of numbers");
              return Uint8Array.from(l(r, t, 8, e))
            }
          }
        }

        function p(t) {
          if ("function" != typeof t) throw Error("unsafeWrapper fn should be function");
          return function(...e) {
            try {
              return t.apply(null, e)
            } catch {}
          }
        }

        function b(t, e) {
          if ("function" != typeof e) throw Error("checksum fn should be function");
          return {
            encode(n) {
              if (!r(n)) throw Error("checksum.encode: input should be Uint8Array");
              const i = e(n).slice(0, t),
                o = new Uint8Array(n.length + t);
              return o.set(n), o.set(i, n.length), o
            },
            decode(n) {
              if (!r(n)) throw Error("checksum.decode: input should be Uint8Array");
              const i = n.slice(0, -t),
                o = e(i).slice(0, t),
                s = n.slice(-t);
              for (let e = 0; t > e; e++)
                if (o[e] !== s[e]) throw Error("Invalid checksum");
              return i
            }
          }
        }
        e.utils = {
          alphabet: i,
          chain: n,
          checksum: b,
          convertRadix: u,
          convertRadix2: l,
          radix: h,
          radix2: d,
          join: o,
          padding: s
        }, e.base16 = n(d(4), i("0123456789ABCDEF"), o("")), e.base32 = n(d(5), i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), s(5), o("")), e.base32nopad = n(d(5), i("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), o("")), e.base32hex = n(d(5), i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), s(5), o("")), e.base32hexnopad = n(d(5), i("0123456789ABCDEFGHIJKLMNOPQRSTUV"), o("")), e.base32crockford = n(d(5), i("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), o(""), a(t => t.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), e.base64 = n(d(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), s(6), o("")), e.base64nopad = n(d(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), o("")), e.base64url = n(d(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), s(6), o("")), e.base64urlnopad = n(d(6), i("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), o(""));
        const m = t => n(h(58), i(t), o(""));
        e.base58 = m("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), e.base58flickr = m("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), e.base58xrp = m("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
        const y = [0, 2, 3, 5, 6, 7, 9, 10, 11];
        e.base58xmr = {
          encode(t) {
            let r = "";
            for (let n = 0; n < t.length; n += 8) {
              const i = t.subarray(n, n + 8);
              r += e.base58.encode(i).padStart(y[i.length], "1")
            }
            return r
          },
          decode(t) {
            let r = [];
            for (let n = 0; n < t.length; n += 11) {
              const i = t.slice(n, n + 11),
                o = y.indexOf(i.length),
                s = e.base58.decode(i);
              for (let t = 0; t < s.length - o; t++)
                if (0 !== s[t]) throw Error("base58xmr: wrong padding");
              r = r.concat(Array.from(s.slice(s.length - o)))
            }
            return Uint8Array.from(r)
          }
        }, e.createBase58check = t => n(b(4, e => t(t(e))), e.base58), e.base58check = e.createBase58check;
        const g = n(i("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), o("")),
          v = [996825010, 642813549, 513874426, 1027748829, 705979059];

        function w(t) {
          const e = t >> 25;
          let r = (33554431 & t) << 5;
          for (let t = 0; 5 > t; t++) 1 == (e >> t & 1) && (r ^= v[t]);
          return r
        }

        function A(t, e, r = 1) {
          const n = t.length;
          let i = 1;
          for (let e = 0; n > e; e++) {
            const r = t.charCodeAt(e);
            if (33 > r || r > 126) throw Error(`Invalid prefix (${t})`);
            i = w(i) ^ r >> 5
          }
          i = w(i);
          for (let e = 0; n > e; e++) i = w(i) ^ 31 & t.charCodeAt(e);
          for (let t of e) i = w(i) ^ t;
          for (let t = 0; 6 > t; t++) i = w(i);
          return i ^= r, g.encode(l([i % 1073741824], 30, 5, !1))
        }

        function T(t) {
          const e = "bech32" === t ? 1 : 734539939,
            r = d(5),
            n = r.decode,
            i = r.encode,
            o = p(n);

          function s(t, r, n = 90) {
            if ("string" != typeof t) throw Error("bech32.encode prefix should be string, not " + typeof t);
            if (r instanceof Uint8Array && (r = Array.from(r)), !Array.isArray(r) || r.length && "number" != typeof r[0]) throw Error("bech32.encode words should be array of numbers, not " + typeof r);
            if (0 === t.length) throw new TypeError("Invalid prefix length " + t.length);
            const i = t.length + 7 + r.length;
            if (!1 !== n && i > n) throw new TypeError(`Length ${i} exceeds limit ${n}`);
            const o = t.toLowerCase(),
              s = A(o, r, e);
            return `${o}1${g.encode(r)}${s}`
          }

          function a(t, r = 90) {
            if ("string" != typeof t) throw Error("bech32.decode input should be string, not " + typeof t);
            if (8 > t.length || !1 !== r && t.length > r) throw new TypeError(`Wrong string length: ${t.length} (${t}). Expected (8..${r})`);
            const n = t.toLowerCase();
            if (t !== n && t !== t.toUpperCase()) throw Error("String must be lowercase or uppercase");
            const i = n.lastIndexOf("1");
            if (0 === i || -1 === i) throw Error('Letter "1" must be present between prefix and data only');
            const o = n.slice(0, i),
              s = n.slice(i + 1);
            if (6 > s.length) throw Error("Data must be at least 6 characters long");
            const a = g.decode(s).slice(0, -6),
              u = A(o, a, e);
            if (!s.endsWith(u)) throw Error(`Invalid checksum in ${t}: expected "${u}"`);
            return {
              prefix: o,
              words: a
            }
          }
          return {
            encode: s,
            decode: a,
            encodeFromBytes: function(t, e) {
              return s(t, i(e))
            },
            decodeToBytes: function(t) {
              const {
                prefix: e,
                words: r
              } = a(t, !1);
              return {
                prefix: e,
                words: r,
                bytes: n(r)
              }
            },
            decodeUnsafe: p(a),
            fromWords: n,
            fromWordsUnsafe: o,
            toWords: i
          }
        }
        e.bech32 = T("bech32"), e.bech32m = T("bech32m"), e.utf8 = {
          encode: t => (new TextDecoder).decode(t),
          decode: t => (new TextEncoder).encode(t)
        }, e.hex = n(d(4), i("0123456789abcdef"), o(""), a(t => {
          if ("string" != typeof t || t.length % 2) throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);
          return t.toLowerCase()
        }));
        const E = {
            utf8: e.utf8,
            hex: e.hex,
            base16: e.base16,
            base32: e.base32,
            base64: e.base64,
            base64url: e.base64url,
            base58: e.base58,
            base58xmr: e.base58xmr
          },
          P = "Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr";
        e.bytesToString = (t, e) => {
          if ("string" != typeof t || !E.hasOwnProperty(t)) throw new TypeError(P);
          if (!r(e)) throw new TypeError("bytesToString() expects Uint8Array");
          return E[t].encode(e)
        }, e.str = e.bytesToString, e.stringToBytes = (t, e) => {
          if (!E.hasOwnProperty(t)) throw new TypeError(P);
          if ("string" != typeof e) throw new TypeError("stringToBytes() expects string");
          return E[t].decode(e)
        }, e.bytes = e.stringToBytes
      },
      63600: (t, e, r) => {
        "use strict";
        t.exports = i;
        var n = r(74610);

        function i(t) {
          if (!(this instanceof i)) return new i(t);
          n.call(this, t)
        }
        r(56698)(i, n), i.prototype.Qr = function(t, e, r) {
          r(null, t)
        }
      },
      64039: (t, e, r) => {
        "use strict";
        var n = "u" > typeof Symbol && Symbol,
          i = r(41333);
        t.exports = function() {
          return "function" == typeof n && "function" == typeof Symbol && "symbol" == typeof n("foo") && "symbol" == typeof Symbol("bar") && i()
        }
      },
      64122: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.fixedBytes = e.getByteLength = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(76291),
          s = /^bytes([0-9]{1,2})$/u;
        e.getByteLength = t => {
          const e = t.match(s)?.[1];
          (0, n.assert)(e, `Invalid byte length. Expected a number between 1 and 32, but received "${t}".`);
          const r = +e;
          return (0, n.assert)(r > 0 && 32 >= r, new i.ParserError(`Invalid byte length. Expected a number between 1 and 32, but received "${t}".`)), r
        }, e.fixedBytes = {
          isDynamic: !1,
          isType: t => s.test(t),
          getByteLength: () => 32,
          encode({
            type: t,
            buffer: r,
            value: s,
            packed: a
          }) {
            const u = (0, e.getByteLength)(t),
              c = (0, n.createBytes)(s);
            return (0, n.assert)(c.length <= u, new i.ParserError(`Expected a value of length ${u}, but received a value of length ${c.length}.`)), a ? (0, n.concatBytes)([r, (0, o.padEnd)(c, u)]) : (0, n.concatBytes)([r, (0, o.padEnd)(c)])
          },
          decode({
            type: t,
            value: r
          }) {
            const n = (0, e.getByteLength)(t);
            return r.slice(0, n)
          }
        }
      },
      64204: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.MultisigOrder = void 0;
        const n = r(75269),
          i = r(1307);
        class o {
          constructor(t) {
            this.signatures = {}, this.payload = t
          }
          static fromCell(t) {
            let e = t.beginParse(),
              r = e.loadMaybeRef()?.beginParse();
            const n = e.asCell();
            let i = new o(n);
            if (r) {
              for (; r.remainingBits > 0;) {
                const t = r.loadBuffer(64),
                  e = r.loadUint(8);
                i.signatures[e] = t, r.remainingRefs > 0 ? r = r.loadRef().asSlice() : r.skip(1)
              }
              r.endParse()
            }
            return i
          }
          static fromPayload(t) {
            return new o(t)
          }
          addSignature(t, e, r) {
            const i = this.payload.hash();
            if (!(0, n.signVerify)(i, e, r.owners.get(t).slice(0, -1))) throw Error("invalid signature");
            this.signatures[t] = e
          }
          sign(t, e) {
            const r = this.payload.hash();
            return this.signatures[t] = (0, n.sign)(r, e), r
          }
          unionSignatures(t) {
            this.signatures = Object.assign({}, this.signatures, t.signatures)
          }
          clearSignatures() {
            this.signatures = {}
          }
          toCell(t) {
            let e = (0, i.beginCell)().storeBit(0);
            for (const t in this.signatures) {
              const r = this.signatures[t];
              e = (0, i.beginCell)().storeBit(1).storeRef((0, i.beginCell)().storeBuffer(r).storeUint(parseInt(t), 8).storeBuilder(e).endCell())
            }
            return (0, i.beginCell)().storeUint(t, 8).storeBuilder(e).storeBuilder(this.payload.asBuilder()).endCell()
          }
        }
        e.MultisigOrder = o
      },
      64633: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t) || s.test(t) || a.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(application|audio|font|image|message|model|multipart|text|video)\/[a-zA-Z0-9\.\-\+_]{1,100}$/i,
          s = /^text\/[a-zA-Z0-9\.\-\+]{1,100};\s?charset=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?$/i,
          a = /^multipart\/[a-zA-Z0-9\.\-\+]{1,100}(;\s?(boundary|charset)=("[a-zA-Z0-9\.\-\+\s]{0,70}"|[a-zA-Z0-9\.\-\+]{0,70})(\s?\([a-zA-Z0-9\.\-\+\s]{1,20}\))?){0,2}$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      64792: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.InMemoryCache = void 0, e.InMemoryCache = class {
          constructor() {
            this.cache = new Map, this.set = async (t, e, r) => {
              null !== r ? this.cache.set(t + "$$" + e, r) : this.cache.delete(t + "$$" + e)
            }, this.get = async (t, e) => {
              let r = this.cache.get(t + "$$" + e);
              return void 0 !== r ? r : null
            }
          }
        }
      },
      65149: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getMethodId = void 0;
        const i = new Int16Array([0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920]);
        e.getMethodId = function(t) {
          return 65535 & function(t) {
            t instanceof n || (t = n.from(t));
            let e = 0;
            for (let r = 0; r < t.length; r++) {
              const n = t[r];
              e = 65535 & (i[255 & (e >> 8 ^ n)] ^ e << 8)
            }
            return e
          }(t) | 65536
        }
      },
      65165: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      65186: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = o[[void 0, null].includes(e) ? "all" : e];
          return !!r && r.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            1: /^[0-9A-F]{8}-[0-9A-F]{4}-1[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            2: /^[0-9A-F]{8}-[0-9A-F]{4}-2[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
            4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
            all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i
          };
        t.exports = e.default, t.exports.default = e.default
      },
      65229: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.serializeBoc = e.deserializeBoc = e.parseBoc = void 0;
        const n = r(53528),
          i = r(62386),
          o = r(66902),
          s = r(41080),
          a = r(16767),
          u = r(49924),
          c = r(9896),
          f = r(34382),
          l = r(29429);

        function h(t) {
          return function(t) {
            let e = 0;
            for (let r = 0; 3 > r; r++) e += 1 & t, t >>= 1;
            return e + 1
          }(7 & t)
        }

        function d(t, e) {
          const r = t.loadUint(8),
            n = r % 8,
            o = !!(8 & r),
            s = t.loadUint(8),
            a = Math.ceil(s / 2),
            u = !!(s % 2),
            c = r >> 5,
            f = !!(16 & r),
            l = f ? 32 * h(c) : 0,
            d = f ? 2 * h(c) : 0;
          t.skip(8 * l), t.skip(8 * d);
          let p = i.BitString.EMPTY;
          a > 0 && (p = u ? t.loadPaddedBits(8 * a) : t.loadBits(8 * a));
          let b = [];
          for (let r = 0; n > r; r++) b.push(t.loadUint(8 * e));
          return {
            bits: p,
            refs: b,
            exotic: o
          }
        }

        function p(t, e) {
          return 2 + Math.ceil(t.bits.length / 8) + t.refs.length * e
        }

        function b(t) {
          let e = new n.BitReader(new i.BitString(t, 0, 8 * t.length)),
            r = e.loadUint(32);
          if (1761568243 === r) {
            let t = e.loadUint(8),
              r = e.loadUint(8),
              n = e.loadUint(8 * t),
              i = e.loadUint(8 * t),
              o = e.loadUint(8 * t),
              s = e.loadUint(8 * r);
            return {
              size: t,
              offBytes: r,
              cells: n,
              roots: i,
              absent: o,
              totalCellSize: s,
              index: e.loadBuffer(n * r),
              cellData: e.loadBuffer(s),
              root: [0]
            }
          }
          if (2898503464 === r) {
            let r = e.loadUint(8),
              n = e.loadUint(8),
              i = e.loadUint(8 * r),
              o = e.loadUint(8 * r),
              s = e.loadUint(8 * r),
              a = e.loadUint(8 * n),
              u = e.loadBuffer(i * n),
              c = e.loadBuffer(a),
              f = e.loadBuffer(4);
            if (!(0, l.crc32c)(t.subarray(0, t.length - 4)).equals(f)) throw Error("Invalid CRC32C");
            return {
              size: r,
              offBytes: n,
              cells: i,
              roots: o,
              absent: s,
              totalCellSize: a,
              index: u,
              cellData: c,
              root: [0]
            }
          }
          if (3052313714 === r) {
            let r = e.loadUint(1),
              n = e.loadUint(1),
              i = (e.loadUint(1), e.loadUint(2), e.loadUint(3)),
              o = e.loadUint(8),
              s = e.loadUint(8 * i),
              a = e.loadUint(8 * i),
              u = e.loadUint(8 * i),
              c = e.loadUint(8 * o),
              f = [];
            for (let t = 0; a > t; t++) f.push(e.loadUint(8 * i));
            let h = null;
            r && (h = e.loadBuffer(s * o));
            let d = e.loadBuffer(c);
            if (n) {
              let r = e.loadBuffer(4);
              if (!(0, l.crc32c)(t.subarray(0, t.length - 4)).equals(r)) throw Error("Invalid CRC32C")
            }
            return {
              size: i,
              offBytes: o,
              cells: s,
              roots: a,
              absent: u,
              totalCellSize: c,
              index: h,
              cellData: d,
              root: f
            }
          }
          throw Error("Invalid magic")
        }

        function m(t, e, r, n) {
          let i = (0, c.getRefsDescriptor)(t.refs, t.mask.value, t.type),
            o = (0, c.getBitsDescriptor)(t.bits);
          n.writeUint(i, 8), n.writeUint(o, 8), n.writeBuffer((0, f.bitsToPaddedBuffer)(t.bits));
          for (let t of e) n.writeUint(t, 8 * r)
        }
        e.parseBoc = b, e.deserializeBoc = function(t) {
          let e = b(t),
            r = new n.BitReader(new i.BitString(e.cellData, 0, 8 * e.cellData.length)),
            s = [];
          for (let t = 0; t < e.cells; t++) {
            let t = d(r, e.size);
            s.push({
              ...t,
              result: null
            })
          }
          for (let t = s.length - 1; t >= 0; t--) {
            if (s[t].result) throw Error("Impossible");
            let e = [];
            for (let r of s[t].refs) {
              if (!s[r].result) throw Error("Invalid BOC file");
              e.push(s[r].result)
            }
            s[t].result = new o.Cell({
              bits: s[t].bits,
              refs: e,
              exotic: s[t].exotic
            })
          }
          let a = [];
          for (let t = 0; t < e.root.length; t++) a.push(s[e.root[t]].result);
          return a
        }, e.serializeBoc = function(t, e) {
          let r = (0, s.topologicalSort)(t),
            n = r.length,
            i = e.idx,
            o = e.crc32,
            c = Math.max(Math.ceil((0, a.bitsForNumber)(n, "uint") / 8), 1),
            f = 0,
            h = [];
          for (let t of r) f += p(t.cell, c), h.push(f);
          let d = Math.max(Math.ceil((0, a.bitsForNumber)(f, "uint") / 8), 1),
            b = 8 * (6 + 3 * c + d + 1 * c + (i ? n * d : 0) + f + (o ? 4 : 0)),
            y = new u.BitBuilder(b);
          if (y.writeUint(3052313714, 32), y.writeBit(i), y.writeBit(o), y.writeBit(!1), y.writeUint(0, 2), y.writeUint(c, 3), y.writeUint(d, 8), y.writeUint(n, 8 * c), y.writeUint(1, 8 * c), y.writeUint(0, 8 * c), y.writeUint(f, 8 * d), y.writeUint(0, 8 * c), i)
            for (let t = 0; n > t; t++) y.writeUint(h[t], 8 * d);
          for (let t = 0; n > t; t++) m(r[t].cell, r[t].refs, c, y);
          if (o) {
            let t = (0, l.crc32c)(y.buffer());
            y.writeBuffer(t)
          }
          let g = y.buffer();
          if (g.length !== b / 8) throw Error("Internal error");
          return g
        }
      },
      65291: (t, e, r) => {
        "use strict";
        var n = r(86048).F.ERR_INVALID_OPT_VALUE;
        t.exports = {
          getHighWaterMark: function(t, e, r, i) {
            var o = function(t, e, r) {
              return null != t.highWaterMark ? t.highWaterMark : e ? t[r] : null
            }(e, i, r);
            if (null != o) {
              if (!isFinite(o) || Math.floor(o) !== o || 0 > o) throw new n(i ? r : "highWaterMark", o);
              return Math.floor(o)
            }
            return t.objectMode ? 16 : 16384
          }
        }
      },
      65339: function(t, e, r) {
        var n = "function" == typeof Object.defineProperties ? Object.defineProperty : function(t, e, r) {
            t != Array.prototype && t != Object.prototype && (t[e] = r.value)
          },
          i = "u" > typeof window && window === this ? this : "u" > typeof r.g && null != r.g ? r.g : this;

        function o() {
          o = function() {}, i.Symbol || (i.Symbol = u)
        }

        function s(t, e) {
          this.a = t, n(this, "description", {
            configurable: !0,
            writable: !0,
            value: e
          })
        }
        s.prototype.toString = function() {
          return this.a
        };
        var a, u = (a = 0, function t(e) {
          if (this instanceof t) throw new TypeError("Symbol is not a constructor");
          return new s("jscomp_symbol_" + (e || "") + "_" + a++, e)
        });

        function c() {
          o();
          var t = i.Symbol.iterator;
          t || (t = i.Symbol.iterator = i.Symbol("Symbol.iterator")), "function" != typeof Array.prototype[t] && n(Array.prototype, t, {
            configurable: !0,
            writable: !0,
            value: function() {
              return function(t) {
                return c(), (t = {
                  next: t
                })[i.Symbol.iterator] = function() {
                  return this
                }, t
              }(function(t) {
                var e = 0;
                return function() {
                  return e < t.length ? {
                    done: !1,
                    value: t[e++]
                  } : {
                    done: !0
                  }
                }
              }(this))
            }
          }), c = function() {}
        }! function(t, e) {
          if (e) {
            var r = i;
            t = t.split(".");
            for (var o = 0; o < t.length - 1; o++) {
              var s = t[o];
              s in r || (r[s] = {}), r = r[s]
            }(e = e(o = r[t = t[t.length - 1]])) != o && null != e && n(r, t, {
              configurable: !0,
              writable: !0,
              value: e
            })
          }
        }("Array.prototype.entries", function(t) {
          return t || function() {
            return function(t, e) {
              c(), t instanceof String && (t += "");
              var r = 0,
                n = {
                  next: function() {
                    if (r < t.length) {
                      var i = r++;
                      return {
                        value: e(i, t[i]),
                        done: !1
                      }
                    }
                    return n.next = function() {
                      return {
                        done: !0,
                        value: void 0
                      }
                    }, n.next()
                  }
                };
              return n[Symbol.iterator] = function() {
                return n
              }, n
            }(this, function(t, e) {
              return [t, e]
            })
          }
        });
        var f = this || self;

        function l(t, e, r) {
          t = t.split("."), r = r || f, t[0] in r || typeof r.execScript > "u" || r.execScript("var " + t[0]);
          for (var n; t.length && (n = t.shift());) t.length || void 0 === e ? r = r[n] && r[n] !== Object.prototype[n] ? r[n] : r[n] = {} : r[n] = e
        }

        function h(t) {
          var e = typeof t;
          if ("object" == e) {
            if (!t) return "null";
            if (t instanceof Array) return "array";
            if (t instanceof Object) return e;
            var r = {}.toString.call(t);
            if ("[object Window]" == r) return "object";
            if ("[object Array]" == r || "number" == typeof t.length && "u" > typeof t.splice && "u" > typeof t.propertyIsEnumerable && !t.propertyIsEnumerable("splice")) return "array";
            if ("[object Function]" == r || "u" > typeof t.call && "u" > typeof t.propertyIsEnumerable && !t.propertyIsEnumerable("call")) return "function"
          } else if ("function" == e && typeof t.call > "u") return "object";
          return e
        }

        function d(t) {
          var e = typeof t;
          return "object" == e && null != t || "function" == e
        }
        var p = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
          b = [].forEach ? function(t, e) {
            [].forEach.call(t, e, void 0)
          } : function(t, e) {
            for (var r = t.length, n = "string" == typeof t ? t.split("") : t, i = 0; r > i; i++) i in n && e.call(void 0, n[i], i, t)
          },
          m = [].map ? function(t, e) {
            return [].map.call(t, e, void 0)
          } : function(t, e) {
            for (var r = t.length, n = Array(r), i = "string" == typeof t ? t.split("") : t, o = 0; r > o; o++) o in i && (n[o] = e.call(void 0, i[o], o, t));
            return n
          };

        function y(t, e, r) {
          return arguments.length > 2 ? [].slice.call(t, e, r) : [].slice.call(t, e)
        }

        function g(t, e, r, n) {
          var i = "Assertion failed";
          if (r) {
            i += ": " + r;
            var o = n
          } else t && (i += ": " + t, o = e);
          throw Error(i, o || [])
        }

        function v(t, e, r) {
          for (var n = [], i = 2; arguments.length > i; ++i) n[i - 2] = arguments[i];
          return t || g("", null, e, n), t
        }

        function w(t, e) {
          for (var r = [], n = 1; arguments.length > n; ++n) r[n - 1] = arguments[n];
          throw Error("Failure" + (t ? ": " + t : ""), r)
        }

        function A(t, e, r, n) {
          for (var i = [], o = 3; arguments.length > o; ++o) i[o - 3] = arguments[o];
          t instanceof e || g("Expected instanceof %s but got %s.", [T(e), T(t)], r, i)
        }

        function T(t) {
          return t instanceof Function ? t.displayName || t.name || "unknown type name" : t instanceof Object ? t.constructor.displayName || t.constructor.name || {}.toString.call(t) : null === t ? "null" : typeof t
        }

        function E(t, e) {
          if (this.c = t, this.b = e, this.a = {}, this.arrClean = !0, this.c.length > 0) {
            for (t = 0; t < this.c.length; t++) {
              var r = (e = this.c[t])[0];
              this.a[r.toString()] = new I(r, e[1])
            }
            this.arrClean = !0
          }
        }

        function P(t) {
          this.a = 0, this.b = t
        }

        function k(t, e) {
          return t.b ? (e.a || (e.a = new t.b(e.value)), e.a) : e.value
        }

        function x(t) {
          t = t.a;
          var e, r = [];
          for (e in t)({}).hasOwnProperty.call(t, e) && r.push(e);
          return r
        }

        function I(t, e) {
          this.key = t, this.value = e, this.a = void 0
        }

        function S(t) {
          if (8192 >= t.length) return String.fromCharCode.apply(null, t);
          for (var e = "", r = 0; r < t.length; r += 8192) e += String.fromCharCode.apply(null, y(t, r, r + 8192));
          return e
        }
        l("jspb.Map", E, void 0), E.prototype.g = function() {
          if (this.arrClean) {
            if (this.b) {
              var t, e = this.a;
              for (t in e)
                if ({}.hasOwnProperty.call(e, t)) {
                  var r = e[t].a;
                  r && r.g()
                }
            }
          } else {
            for (this.c.length = 0, (e = x(this)).sort(), t = 0; t < e.length; t++) {
              var n = this.a[e[t]];
              (r = n.a) && r.g(), this.c.push([n.key, n.value])
            }
            this.arrClean = !0
          }
          return this.c
        }, E.prototype.toArray = E.prototype.g, E.prototype.Mc = function(t, e) {
          for (var r = this.g(), n = [], i = 0; i < r.length; i++) {
            var o = this.a[r[i][0].toString()];
            k(this, o);
            var s = o.a;
            s ? (v(e), n.push([o.key, e(t, s)])) : n.push([o.key, o.value])
          }
          return n
        }, E.prototype.toObject = E.prototype.Mc, E.fromObject = function(t, e, r) {
          e = new E([], e);
          for (var n = 0; n < t.length; n++) {
            var i = t[n][0],
              o = r(t[n][1]);
            e.set(i, o)
          }
          return e
        }, P.prototype.next = function() {
          return this.a < this.b.length ? {
            done: !1,
            value: this.b[this.a++]
          } : {
            done: !0,
            value: void 0
          }
        }, "u" > typeof Symbol && (P.prototype[Symbol.iterator] = function() {
          return this
        }), E.prototype.Jb = function() {
          return x(this).length
        }, E.prototype.getLength = E.prototype.Jb, E.prototype.clear = function() {
          this.a = {}, this.arrClean = !1
        }, E.prototype.clear = E.prototype.clear, E.prototype.Cb = function(t) {
          t = t.toString();
          var e = this.a.hasOwnProperty(t);
          return delete this.a[t], this.arrClean = !1, e
        }, E.prototype.del = E.prototype.Cb, E.prototype.Eb = function() {
          var t = [],
            e = x(this);
          e.sort();
          for (var r = 0; r < e.length; r++) {
            var n = this.a[e[r]];
            t.push([n.key, n.value])
          }
          return t
        }, E.prototype.getEntryList = E.prototype.Eb, E.prototype.entries = function() {
          var t = [],
            e = x(this);
          e.sort();
          for (var r = 0; r < e.length; r++) {
            var n = this.a[e[r]];
            t.push([n.key, k(this, n)])
          }
          return new P(t)
        }, E.prototype.entries = E.prototype.entries, E.prototype.keys = function() {
          var t = [],
            e = x(this);
          e.sort();
          for (var r = 0; r < e.length; r++) t.push(this.a[e[r]].key);
          return new P(t)
        }, E.prototype.keys = E.prototype.keys, E.prototype.values = function() {
          var t = [],
            e = x(this);
          e.sort();
          for (var r = 0; r < e.length; r++) t.push(k(this, this.a[e[r]]));
          return new P(t)
        }, E.prototype.values = E.prototype.values, E.prototype.forEach = function(t, e) {
          var r = x(this);
          r.sort();
          for (var n = 0; n < r.length; n++) {
            var i = this.a[r[n]];
            t.call(e, k(this, i), i.key, this)
          }
        }, E.prototype.forEach = E.prototype.forEach, E.prototype.set = function(t, e) {
          var r = new I(t);
          return this.b ? (r.a = e, r.value = e.g()) : r.value = e, this.a[t.toString()] = r, this.arrClean = !1, this
        }, E.prototype.set = E.prototype.set, E.prototype.get = function(t) {
          if (t = this.a[t.toString()]) return k(this, t)
        }, E.prototype.get = E.prototype.get, E.prototype.has = function(t) {
          return t.toString() in this.a
        }, E.prototype.has = E.prototype.has, E.prototype.Jc = function(t, e, r, n, i) {
          var o = x(this);
          o.sort();
          for (var s = 0; s < o.length; s++) {
            var a = this.a[o[s]];
            e.Va(t), r.call(e, 1, a.key), this.b ? n.call(e, 2, k(this, a), i) : n.call(e, 2, a.value), e.Ya()
          }
        }, E.prototype.serializeBinary = E.prototype.Jc, E.deserializeBinary = function(t, e, r, n, i, o, s) {
          for (; e.oa() && !e.bb();) {
            var a = e.c;
            1 == a ? o = r.call(e) : 2 == a && (t.b ? (v(i), s || (s = new t.b), n.call(e, s, i)) : s = n.call(e))
          }
          v(null != o), v(null != s), t.set(o, s)
        };
        var O = {
            "\0": "\\0",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
            "\v": "\\x0B",
            '"': '\\"',
            "\\": "\\\\",
            "<": "\\u003C"
          },
          B = {
            "'": "\\'"
          },
          W = {},
          M = null;

        function C(t, e) {
          void 0 === e && (e = 0), N(), e = W[e];
          for (var r = [], n = 0; n < t.length; n += 3) {
            var i = t[n],
              o = n + 1 < t.length,
              s = o ? t[n + 1] : 0,
              a = n + 2 < t.length,
              u = a ? t[n + 2] : 0,
              c = i >> 2;
            i = (3 & i) << 4 | s >> 4, s = (15 & s) << 2 | u >> 6, u &= 63, a || (u = 64, o || (s = 64)), r.push(e[c], e[i], e[s] || "", e[u] || "")
          }
          return r.join("")
        }

        function R(t) {
          var e = t.length,
            r = 3 * e / 4;
          r % 3 ? r = Math.floor(r) : -1 != "=.".indexOf(t[e - 1]) && (r = -1 != "=.".indexOf(t[e - 2]) ? r - 2 : r - 1);
          var n = new Uint8Array(r),
            i = 0;
          return function(t, e) {
            function r(e) {
              for (; n < t.length;) {
                var r = t.charAt(n++),
                  i = M[r];
                if (null != i) return i;
                if (!/^[\s\xa0]*$/.test(r)) throw Error("Unknown base64 encoding at char: " + r)
              }
              return e
            }
            N();
            for (var n = 0;;) {
              var i = r(-1),
                o = r(0),
                s = r(64),
                a = r(64);
              if (64 === a && -1 === i) break;
              e(i << 2 | o >> 4), 64 != s && (e(o << 4 & 240 | s >> 2), 64 != a && e(s << 6 & 192 | a))
            }
          }(t, function(t) {
            n[i++] = t
          }), n.subarray(0, i)
        }

        function N() {
          if (!M) {
            M = {};
            for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e = ["+/=", "+/", "-_=", "-_.", "-_"], r = 0; 5 > r; r++) {
              var n = t.concat(e[r].split(""));
              W[r] = n;
              for (var i = 0; i < n.length; i++) {
                var o = n[i];
                void 0 === M[o] && (M[o] = i)
              }
            }
          }
        }
        l("jspb.ConstBinaryMessage", function() {}, void 0), l("jspb.BinaryMessage", function() {}, void 0), l("jspb.BinaryConstants.FieldType", {
          yb: -1,
          ee: 1,
          FLOAT: 2,
          ke: 3,
          te: 4,
          je: 5,
          xb: 6,
          wb: 7,
          BOOL: 8,
          re: 9,
          ie: 10,
          le: 11,
          ce: 12,
          se: 13,
          ge: 14,
          me: 15,
          ne: 16,
          oe: 17,
          pe: 18,
          he: 30,
          ve: 31
        }, void 0), l("jspb.BinaryConstants.WireType", {
          yb: -1,
          ue: 0,
          xb: 1,
          de: 2,
          qe: 3,
          fe: 4,
          wb: 5
        }, void 0), l("jspb.BinaryConstants.FieldTypeToWireType", function(t) {
          switch (t) {
            case 5:
            case 3:
            case 13:
            case 4:
            case 17:
            case 18:
            case 8:
            case 14:
            case 31:
              return 0;
            case 1:
            case 6:
            case 16:
            case 30:
              return 1;
            case 9:
            case 11:
            case 12:
              return 2;
            case 2:
            case 7:
            case 15:
              return 5;
            default:
              return -1
          }
        }, void 0), l("jspb.BinaryConstants.INVALID_FIELD_NUMBER", -1, void 0), l("jspb.BinaryConstants.FLOAT32_EPS", 1401298464324817e-60, void 0), l("jspb.BinaryConstants.FLOAT32_MIN", 11754943508222875e-54, void 0), l("jspb.BinaryConstants.FLOAT32_MAX", 34028234663852886e22, void 0), l("jspb.BinaryConstants.FLOAT64_EPS", 5e-324, void 0), l("jspb.BinaryConstants.FLOAT64_MIN", 22250738585072014e-324, void 0), l("jspb.BinaryConstants.FLOAT64_MAX", 17976931348623157e292, void 0), l("jspb.BinaryConstants.TWO_TO_20", 1048576, void 0), l("jspb.BinaryConstants.TWO_TO_23", 8388608, void 0), l("jspb.BinaryConstants.TWO_TO_31", 2147483648, void 0), l("jspb.BinaryConstants.TWO_TO_32", 4294967296, void 0), l("jspb.BinaryConstants.TWO_TO_52", 4503599627370496, void 0), l("jspb.BinaryConstants.TWO_TO_63", 0x8000000000000000, void 0), l("jspb.BinaryConstants.TWO_TO_64", 0x10000000000000000, void 0), l("jspb.BinaryConstants.ZERO_HASH", "\0\0\0\0\0\0\0\0", void 0);
        var j = 0,
          _ = 0;

        function D(t) {
          var e = t >>> 0;
          j = e, _ = t = Math.floor((t - e) / 4294967296) >>> 0
        }

        function U(t) {
          var e = 0 > t,
            r = (t = Math.abs(t)) >>> 0;
          t = Math.floor((t - r) / 4294967296), t >>>= 0, e && (t = ~t >>> 0, (r = (~r >>> 0) + 1) > 4294967295 && (r = 0, ++t > 4294967295 && (t = 0))), j = r, _ = t
        }

        function L(t) {
          var e = 0 > t;
          D(t = 2 * Math.abs(t)), t = j;
          var r = _;
          e && (0 == t ? 0 == r ? r = t = 4294967295 : (r--, t = 4294967295) : t--), j = t, _ = r
        }

        function F(t) {
          var e = 0 > t ? 1 : 0;
          if (0 === (t = e ? -t : t)) 1 / t > 0 ? j = _ = 0 : (_ = 0, j = 2147483648);
          else if (isNaN(t)) _ = 0, j = 2147483647;
          else if (t > 34028234663852886e22) _ = 0, j = (e << 31 | 2139095040) >>> 0;
          else if (11754943508222875e-54 > t) _ = 0, j = (e << 31 | (t = Math.round(t / Math.pow(2, -149)))) >>> 0;
          else {
            var r = Math.floor(Math.log(t) / Math.LN2);
            (t = Math.round(8388608 * (t *= Math.pow(2, -r)))) >= 16777216 && ++r, _ = 0, j = (e << 31 | r + 127 << 23 | 8388607 & t) >>> 0
          }
        }

        function $(t) {
          var e = 0 > t ? 1 : 0;
          if (0 === (t = e ? -t : t)) _ = 1 / t > 0 ? 0 : 2147483648, j = 0;
          else if (isNaN(t)) _ = 2147483647, j = 4294967295;
          else if (t > 17976931348623157e292) _ = (e << 31 | 2146435072) >>> 0, j = 0;
          else if (22250738585072014e-324 > t) _ = (e << 31 | (t /= 5e-324) / 4294967296) >>> 0, j = t >>> 0;
          else {
            var r = t,
              n = 0;
            if (2 > r)
              for (; 1 > r && n > -1022;) r *= 2, n--;
            else
              for (; r >= 2 && 1023 > n;) n++, r /= 2;
            _ = (e << 31 | n + 1023 << 20 | 1048576 * (t *= Math.pow(2, -n)) & 1048575) >>> 0, j = 4503599627370496 * t >>> 0
          }
        }

        function z(t) {
          var e = t.charCodeAt(4),
            r = t.charCodeAt(5),
            n = t.charCodeAt(6),
            i = t.charCodeAt(7);
          j = t.charCodeAt(0) + (t.charCodeAt(1) << 8) + (t.charCodeAt(2) << 16) + (t.charCodeAt(3) << 24) >>> 0, _ = e + (r << 8) + (n << 16) + (i << 24) >>> 0
        }

        function H(t, e) {
          return 4294967296 * e + (t >>> 0)
        }

        function G(t, e) {
          var r = 2147483648 & e;
          return r && (e = ~e >>> 0, 0 == (t = 1 + ~t >>> 0) && (e = e + 1 >>> 0)), t = H(t, e), r ? -t : t
        }

        function K(t, e, r) {
          var n = e >> 31;
          return r(t << 1 ^ n, (e << 1 | t >>> 31) ^ n)
        }

        function V(t, e) {
          return Z(t, e, G)
        }

        function Z(t, e, r) {
          var n = -(1 & t);
          return r((t >>> 1 | e << 31) ^ n, e >>> 1 ^ n)
        }

        function q(t) {
          var e = 2 * (t >> 31) + 1,
            r = t >>> 23 & 255;
          return t &= 8388607, 255 == r ? t ? NaN : 1 / 0 * e : 0 == r ? e * Math.pow(2, -149) * t : e * Math.pow(2, r - 150) * (t + 8388608)
        }

        function J(t, e) {
          var r = 2 * (e >> 31) + 1,
            n = e >>> 20 & 2047;
          return t = 4294967296 * (1048575 & e) + t, 2047 == n ? t ? NaN : 1 / 0 * r : 0 == n ? 5e-324 * r * t : r * Math.pow(2, n - 1075) * (t + 4503599627370496)
        }

        function Y(t, e) {
          return String.fromCharCode(t >>> 0 & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255, e >>> 0 & 255, e >>> 8 & 255, e >>> 16 & 255, e >>> 24 & 255)
        }

        function Q(t, e) {
          function r(t, e) {
            return t = t ? t + "" : "", e ? "0000000".slice(t.length) + t : t
          }
          if (2097151 >= e) return "" + H(t, e);
          var n = (t >>> 24 | e << 8) >>> 0 & 16777215;
          return t = (16777215 & t) + 6777216 * n + 6710656 * (e = e >> 16 & 65535), n += 8147497 * e, e *= 2, t >= 1e7 && (n += Math.floor(t / 1e7), t %= 1e7), n >= 1e7 && (e += Math.floor(n / 1e7), n %= 1e7), r(e, 0) + r(n, e) + r(t, 1)
        }

        function X(t, e) {
          var r = 2147483648 & e;
          return r && (e = ~e + (0 == (t = 1 + ~t >>> 0) ? 1 : 0) >>> 0), t = Q(t, e), r ? "-" + t : t
        }

        function tt(t, e) {
          z(t), t = j;
          var r = _;
          return e ? X(t, r) : Q(t, r)
        }

        function et(t) {
          function e(t, e) {
            for (var r = 0; 8 > r && (1 !== t || e > 0); r++) e = t * n[r] + e, n[r] = 255 & e, e >>>= 8
          }
          v(t.length > 0);
          var r = !1;
          "-" === t[0] && (r = !0, t = t.slice(1));
          for (var n = [0, 0, 0, 0, 0, 0, 0, 0], i = 0; i < t.length; i++) e(10, t.charCodeAt(i) - 48);
          return r && (function() {
            for (var t = 0; 8 > t; t++) n[t] = 255 & ~n[t]
          }(), e(1, 1)), S(n)
        }

        function rt(t) {
          return String.fromCharCode(10 > t ? 48 + t : 87 + t)
        }

        function nt(t) {
          return 97 > t ? t - 48 : t - 97 + 10
        }

        function it(t, e, r, n, i) {
          var o = 0;
          if (128 > n)
            for (; r > e && t[e++] == n;) o++, e += i;
          else
            for (; r > e;) {
              for (var s = n; s > 128;) {
                if (t[e++] != (127 & s | 128)) return o;
                s >>= 7
              }
              if (t[e++] != s) break;
              o++, e += i
            }
          return o
        }

        function ot(t) {
          return t.constructor === Uint8Array ? t : t.constructor === ArrayBuffer || t.constructor === Array ? new Uint8Array(t) : t.constructor === String ? R(t) : t instanceof Uint8Array ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : (w("Type not convertible to Uint8Array."), new Uint8Array(0))
        }

        function st(t, e, r) {
          this.b = null, this.a = this.c = this.h = 0, this.v = !1, t && this.H(t, e, r)
        }
        l("jspb.utils.getSplit64Low", function() {
          return j
        }, void 0), l("jspb.utils.getSplit64High", function() {
          return _
        }, void 0), l("jspb.utils.splitUint64", D, void 0), l("jspb.utils.splitInt64", U, void 0), l("jspb.utils.splitZigzag64", L, void 0), l("jspb.utils.splitFloat32", F, void 0), l("jspb.utils.splitFloat64", $, void 0), l("jspb.utils.splitHash64", z, void 0), l("jspb.utils.joinUint64", H, void 0), l("jspb.utils.joinInt64", G, void 0), l("jspb.utils.toZigzag64", K, void 0), l("jspb.utils.joinZigzag64", V, void 0), l("jspb.utils.fromZigzag64", Z, void 0), l("jspb.utils.joinFloat32", q, void 0), l("jspb.utils.joinFloat64", J, void 0), l("jspb.utils.joinHash64", Y, void 0), l("jspb.utils.DIGITS", "0123456789abcdef".split(""), void 0), l("jspb.utils.joinUnsignedDecimalString", Q, void 0), l("jspb.utils.joinSignedDecimalString", X, void 0), l("jspb.utils.hash64ToDecimalString", tt, void 0), l("jspb.utils.hash64ArrayToDecimalStrings", function(t, e) {
          for (var r = Array(t.length), n = 0; n < t.length; n++) r[n] = tt(t[n], e);
          return r
        }, void 0), l("jspb.utils.decimalStringToHash64", et, void 0), l("jspb.utils.splitDecimalString", function(t) {
          z(et(t))
        }, void 0), l("jspb.utils.hash64ToHexString", function(t) {
          var e = Array(18);
          e[0] = "0", e[1] = "x";
          for (var r = 0; 8 > r; r++) {
            var n = t.charCodeAt(7 - r);
            e[2 * r + 2] = rt(n >> 4), e[2 * r + 3] = rt(15 & n)
          }
          return e.join("")
        }, void 0), l("jspb.utils.hexStringToHash64", function(t) {
          v(18 == (t = t.toLowerCase()).length), v("0" == t[0]), v("x" == t[1]);
          for (var e = "", r = 0; 8 > r; r++) e = String.fromCharCode(16 * nt(t.charCodeAt(2 * r + 2)) + nt(t.charCodeAt(2 * r + 3))) + e;
          return e
        }, void 0), l("jspb.utils.hash64ToNumber", function(t, e) {
          z(t), t = j;
          var r = _;
          return e ? G(t, r) : H(t, r)
        }, void 0), l("jspb.utils.numberToHash64", function(t) {
          return U(t), Y(j, _)
        }, void 0), l("jspb.utils.countVarints", function(t, e, r) {
          for (var n = 0, i = e; r > i; i++) n += t[i] >> 7;
          return r - e - n
        }, void 0), l("jspb.utils.countVarintFields", function(t, e, r, n) {
          var i = 0;
          if (128 > (n *= 8))
            for (; r > e && t[e++] == n;)
              for (i++;;) {
                var o = t[e++];
                if (!(128 & o)) break
              } else
                for (; r > e;) {
                  for (o = n; o > 128;) {
                    if (t[e] != (127 & o | 128)) return i;
                    e++, o >>= 7
                  }
                  if (t[e++] != o) break;
                  for (i++; 128 & (o = t[e++]););
                }
          return i
        }, void 0), l("jspb.utils.countFixed32Fields", function(t, e, r, n) {
          return it(t, e, r, 8 * n + 5, 4)
        }, void 0), l("jspb.utils.countFixed64Fields", function(t, e, r, n) {
          return it(t, e, r, 8 * n + 1, 8)
        }, void 0), l("jspb.utils.countDelimitedFields", function(t, e, r, n) {
          var i = 0;
          for (n = 8 * n + 2; r > e;) {
            for (var o = n; o > 128;) {
              if (t[e++] != (127 & o | 128)) return i;
              o >>= 7
            }
            if (t[e++] != o) break;
            i++;
            for (var s = 0, a = 1; s += (127 & (o = t[e++])) * a, a *= 128, 128 & o;);
            e += s
          }
          return i
        }, void 0), l("jspb.utils.debugBytesToTextFormat", function(t) {
          var e = '"';
          if (t) {
            t = ot(t);
            for (var r = 0; r < t.length; r++) e += "\\x", 16 > t[r] && (e += "0"), e += t[r].toString(16)
          }
          return e + '"'
        }, void 0), l("jspb.utils.debugScalarToTextFormat", function(t) {
          if ("string" == typeof t) {
            t += "";
            for (var e = ['"'], r = 0; r < t.length; r++) {
              var n, i = t.charAt(r),
                o = i.charCodeAt(0),
                s = r + 1;
              (n = O[i]) || (o > 31 && 127 > o || ((o = i) in B ? i = B[o] : o in O ? i = B[o] = O[o] : ((n = o.charCodeAt(0)) > 31 && 127 > n ? i = o : (256 > n ? (i = "\\x", (16 > n || n > 256) && (i += "0")) : (i = "\\u", 4096 > n && (i += "0")), i += n.toString(16).toUpperCase()), i = B[o] = i)), n = i), e[s] = n
            }
            e.push('"'), t = e.join("")
          } else t = t.toString();
          return t
        }, void 0), l("jspb.utils.stringToByteArray", function(t) {
          for (var e = new Uint8Array(t.length), r = 0; r < t.length; r++) {
            var n = t.charCodeAt(r);
            if (n > 255) throw Error("Conversion error: string contains codepoint outside of byte range");
            e[r] = n
          }
          return e
        }, void 0), l("jspb.utils.byteSourceToUint8Array", ot, void 0), l("jspb.BinaryDecoder", st, void 0);
        var at = [];

        function ut(t, e, r) {
          if (at.length) {
            var n = at.pop();
            return t && n.H(t, e, r), n
          }
          return new st(t, e, r)
        }

        function ct(t, e, r) {
          this.a = ut(t, e, r), this.O = this.a.B(), this.b = this.c = -1, this.h = !1, this.v = null
        }
        st.getInstanceCacheLength = function() {
          return at.length
        }, st.alloc = ut, st.prototype.Ca = function() {
          this.clear(), 100 > at.length && at.push(this)
        }, st.prototype.free = st.prototype.Ca, st.prototype.clone = function() {
          return ut(this.b, this.h, this.c - this.h)
        }, st.prototype.clone = st.prototype.clone, st.prototype.clear = function() {
          this.b = null, this.a = this.c = this.h = 0, this.v = !1
        }, st.prototype.clear = st.prototype.clear, st.prototype.Y = function() {
          return this.b
        }, st.prototype.getBuffer = st.prototype.Y, st.prototype.H = function(t, e, r) {
          this.b = ot(t), this.h = void 0 !== e ? e : 0, this.c = void 0 !== r ? this.h + r : this.b.length, this.a = this.h
        }, st.prototype.setBlock = st.prototype.H, st.prototype.Db = function() {
          return this.c
        }, st.prototype.getEnd = st.prototype.Db, st.prototype.setEnd = function(t) {
          this.c = t
        }, st.prototype.setEnd = st.prototype.setEnd, st.prototype.reset = function() {
          this.a = this.h
        }, st.prototype.reset = st.prototype.reset, st.prototype.B = function() {
          return this.a
        }, st.prototype.getCursor = st.prototype.B, st.prototype.Ma = function(t) {
          this.a = t
        }, st.prototype.setCursor = st.prototype.Ma, st.prototype.advance = function(t) {
          this.a += t, v(this.a <= this.c)
        }, st.prototype.advance = st.prototype.advance, st.prototype.ya = function() {
          return this.a == this.c
        }, st.prototype.atEnd = st.prototype.ya, st.prototype.Qb = function() {
          return this.a > this.c
        }, st.prototype.pastEnd = st.prototype.Qb, st.prototype.getError = function() {
          return this.v || 0 > this.a || this.a > this.c
        }, st.prototype.getError = st.prototype.getError, st.prototype.w = function(t) {
          for (var e = 128, r = 0, n = 0, i = 0; 4 > i && e >= 128; i++) r |= (127 & (e = this.b[this.a++])) << 7 * i;
          if (e >= 128 && (r |= (127 & (e = this.b[this.a++])) << 28, n |= (127 & e) >> 4), e >= 128)
            for (i = 0; 5 > i && e >= 128; i++) n |= (127 & (e = this.b[this.a++])) << 7 * i + 3;
          if (128 > e) return t(r >>> 0, n >>> 0);
          w("Failed to read varint, encoding is invalid."), this.v = !0
        }, st.prototype.readSplitVarint64 = st.prototype.w, st.prototype.ea = function(t) {
          return this.w(function(e, r) {
            return Z(e, r, t)
          })
        }, st.prototype.readSplitZigzagVarint64 = st.prototype.ea, st.prototype.ta = function(t) {
          var e = this.b,
            r = this.a;
          this.a += 8;
          for (var n = 0, i = 0, o = r + 7; o >= r; o--) n = n << 8 | e[o], i = i << 8 | e[o + 4];
          return t(n, i)
        }, st.prototype.readSplitFixed64 = st.prototype.ta, st.prototype.kb = function() {
          for (; 128 & this.b[this.a];) this.a++;
          this.a++
        }, st.prototype.skipVarint = st.prototype.kb, st.prototype.mb = function(t) {
          for (; t > 128;) this.a--, t >>>= 7;
          this.a--
        }, st.prototype.unskipVarint = st.prototype.mb, st.prototype.o = function() {
          var t = this.b,
            e = t[this.a],
            r = 127 & e;
          return 128 > e ? (this.a += 1, v(this.a <= this.c), r) : (r |= (127 & (e = t[this.a + 1])) << 7, 128 > e ? (this.a += 2, v(this.a <= this.c), r) : (r |= (127 & (e = t[this.a + 2])) << 14, 128 > e ? (this.a += 3, v(this.a <= this.c), r) : (r |= (127 & (e = t[this.a + 3])) << 21, 128 > e ? (this.a += 4, v(this.a <= this.c), r) : (r |= (15 & (e = t[this.a + 4])) << 28, 128 > e ? (this.a += 5, v(this.a <= this.c), r >>> 0) : (this.a += 5, t[this.a++] >= 128 && t[this.a++] >= 128 && t[this.a++] >= 128 && t[this.a++] >= 128 && t[this.a++] >= 128 && v(!1), v(this.a <= this.c), r)))))
        }, st.prototype.readUnsignedVarint32 = st.prototype.o, st.prototype.da = function() {
          return ~~this.o()
        }, st.prototype.readSignedVarint32 = st.prototype.da, st.prototype.O = function() {
          return this.o().toString()
        }, st.prototype.Ea = function() {
          return this.da().toString()
        }, st.prototype.readSignedVarint32String = st.prototype.Ea, st.prototype.Ia = function() {
          var t = this.o();
          return t >>> 1 ^ -(1 & t)
        }, st.prototype.readZigzagVarint32 = st.prototype.Ia, st.prototype.Ga = function() {
          return this.w(H)
        }, st.prototype.readUnsignedVarint64 = st.prototype.Ga, st.prototype.Ha = function() {
          return this.w(Q)
        }, st.prototype.readUnsignedVarint64String = st.prototype.Ha, st.prototype.sa = function() {
          return this.w(G)
        }, st.prototype.readSignedVarint64 = st.prototype.sa, st.prototype.Fa = function() {
          return this.w(X)
        }, st.prototype.readSignedVarint64String = st.prototype.Fa, st.prototype.Ja = function() {
          return this.w(V)
        }, st.prototype.readZigzagVarint64 = st.prototype.Ja, st.prototype.fb = function() {
          return this.ea(Y)
        }, st.prototype.readZigzagVarintHash64 = st.prototype.fb, st.prototype.Ka = function() {
          return this.ea(X)
        }, st.prototype.readZigzagVarint64String = st.prototype.Ka, st.prototype.Gc = function() {
          var t = this.b[this.a];
          return this.a += 1, v(this.a <= this.c), t
        }, st.prototype.readUint8 = st.prototype.Gc, st.prototype.Ec = function() {
          var t = this.b[this.a],
            e = this.b[this.a + 1];
          return this.a += 2, v(this.a <= this.c), t | e << 8
        }, st.prototype.readUint16 = st.prototype.Ec, st.prototype.m = function() {
          var t = this.b[this.a],
            e = this.b[this.a + 1],
            r = this.b[this.a + 2],
            n = this.b[this.a + 3];
          return this.a += 4, v(this.a <= this.c), (t | e << 8 | r << 16 | n << 24) >>> 0
        }, st.prototype.readUint32 = st.prototype.m, st.prototype.ga = function() {
          return H(this.m(), this.m())
        }, st.prototype.readUint64 = st.prototype.ga, st.prototype.ha = function() {
          return Q(this.m(), this.m())
        }, st.prototype.readUint64String = st.prototype.ha, st.prototype.Xb = function() {
          var t = this.b[this.a];
          return this.a += 1, v(this.a <= this.c), t << 24 >> 24
        }, st.prototype.readInt8 = st.prototype.Xb, st.prototype.Vb = function() {
          var t = this.b[this.a],
            e = this.b[this.a + 1];
          return this.a += 2, v(this.a <= this.c), (t | e << 8) << 16 >> 16
        }, st.prototype.readInt16 = st.prototype.Vb, st.prototype.P = function() {
          var t = this.b[this.a],
            e = this.b[this.a + 1],
            r = this.b[this.a + 2],
            n = this.b[this.a + 3];
          return this.a += 4, v(this.a <= this.c), t | e << 8 | r << 16 | n << 24
        }, st.prototype.readInt32 = st.prototype.P, st.prototype.ba = function() {
          return G(this.m(), this.m())
        }, st.prototype.readInt64 = st.prototype.ba, st.prototype.ca = function() {
          return X(this.m(), this.m())
        }, st.prototype.readInt64String = st.prototype.ca, st.prototype.aa = function() {
          return q(this.m())
        }, st.prototype.readFloat = st.prototype.aa, st.prototype.Z = function() {
          return J(this.m(), this.m())
        }, st.prototype.readDouble = st.prototype.Z, st.prototype.pa = function() {
          return !!this.b[this.a++]
        }, st.prototype.readBool = st.prototype.pa, st.prototype.ra = function() {
          return this.da()
        }, st.prototype.readEnum = st.prototype.ra, st.prototype.fa = function(t) {
          var e = this.b,
            r = this.a;
          t = r + t;
          for (var n = [], i = ""; t > r;) {
            var o = e[r++];
            if (128 > o) n.push(o);
            else {
              if (192 > o) continue;
              if (224 > o) {
                var s = e[r++];
                n.push((31 & o) << 6 | 63 & s)
              } else if (240 > o) {
                s = e[r++];
                var a = e[r++];
                n.push((15 & o) << 12 | (63 & s) << 6 | 63 & a)
              } else 248 > o && (o = (7 & o) << 18 | (63 & (s = e[r++])) << 12 | (63 & (a = e[r++])) << 6 | 63 & e[r++], o -= 65536, n.push(55296 + (o >> 10 & 1023), 56320 + (1023 & o)))
            }
            n.length >= 8192 && (i += String.fromCharCode.apply(null, n), n.length = 0)
          }
          return i += S(n), this.a = r, i
        }, st.prototype.readString = st.prototype.fa, st.prototype.Dc = function() {
          var t = this.o();
          return this.fa(t)
        }, st.prototype.readStringWithLength = st.prototype.Dc, st.prototype.qa = function(t) {
          if (0 > t || this.a + t > this.b.length) return this.v = !0, w("Invalid byte length!"), new Uint8Array(0);
          var e = this.b.subarray(this.a, this.a + t);
          return this.a += t, v(this.a <= this.c), e
        }, st.prototype.readBytes = st.prototype.qa, st.prototype.ia = function() {
          return this.w(Y)
        }, st.prototype.readVarintHash64 = st.prototype.ia, st.prototype.$ = function() {
          var t = this.b,
            e = this.a,
            r = t[e],
            n = t[e + 1],
            i = t[e + 2],
            o = t[e + 3],
            s = t[e + 4],
            a = t[e + 5],
            u = t[e + 6];
          return t = t[e + 7], this.a += 8, String.fromCharCode(r, n, i, o, s, a, u, t)
        }, st.prototype.readFixedHash64 = st.prototype.$, l("jspb.BinaryReader", ct, void 0);
        var ft = [];

        function lt(t, e, r) {
          if (ft.length) {
            var n = ft.pop();
            return t && n.a.H(t, e, r), n
          }
          return new ct(t, e, r)
        }

        function ht(t, e) {
          v(2 == t.b);
          var r = t.a.o();
          r = t.a.B() + r;
          for (var n = []; t.a.B() < r;) n.push(e.call(t.a));
          return n
        }

        function dt(t, e, r, n, i) {
          this.ma = t, this.Ba = e, this.la = r, this.Na = n, this.na = i
        }

        function pt(t, e, r, n, i, o) {
          this.Za = t, this.za = e, this.Aa = r, this.Wa = n, this.Ab = i, this.Nb = o
        }

        function bt() {}
        ct.clearInstanceCache = function() {
          ft = []
        }, ct.getInstanceCacheLength = function() {
          return ft.length
        }, ct.alloc = lt, ct.prototype.zb = lt, ct.prototype.alloc = ct.prototype.zb, ct.prototype.Ca = function() {
          this.a.clear(), this.b = this.c = -1, this.h = !1, this.v = null, 100 > ft.length && ft.push(this)
        }, ct.prototype.free = ct.prototype.Ca, ct.prototype.Fb = function() {
          return this.O
        }, ct.prototype.getFieldCursor = ct.prototype.Fb, ct.prototype.B = function() {
          return this.a.B()
        }, ct.prototype.getCursor = ct.prototype.B, ct.prototype.Y = function() {
          return this.a.Y()
        }, ct.prototype.getBuffer = ct.prototype.Y, ct.prototype.Hb = function() {
          return this.c
        }, ct.prototype.getFieldNumber = ct.prototype.Hb, ct.prototype.Lb = function() {
          return this.b
        }, ct.prototype.getWireType = ct.prototype.Lb, ct.prototype.Mb = function() {
          return 2 == this.b
        }, ct.prototype.isDelimited = ct.prototype.Mb, ct.prototype.bb = function() {
          return 4 == this.b
        }, ct.prototype.isEndGroup = ct.prototype.bb, ct.prototype.getError = function() {
          return this.h || this.a.getError()
        }, ct.prototype.getError = ct.prototype.getError, ct.prototype.H = function(t, e, r) {
          this.a.H(t, e, r), this.b = this.c = -1
        }, ct.prototype.setBlock = ct.prototype.H, ct.prototype.reset = function() {
          this.a.reset(), this.b = this.c = -1
        }, ct.prototype.reset = ct.prototype.reset, ct.prototype.advance = function(t) {
          this.a.advance(t)
        }, ct.prototype.advance = ct.prototype.advance, ct.prototype.oa = function() {
          if (this.a.ya()) return !1;
          if (this.getError()) return w("Decoder hit an error"), !1;
          this.O = this.a.B();
          var t = this.a.o(),
            e = t >>> 3;
          return 0 != (t &= 7) && 5 != t && 1 != t && 2 != t && 3 != t && 4 != t ? (w("Invalid wire type: %s (at position %s)", t, this.O), this.h = !0, !1) : (this.c = e, this.b = t, !0)
        }, ct.prototype.nextField = ct.prototype.oa, ct.prototype.Oa = function() {
          this.a.mb(this.c << 3 | this.b)
        }, ct.prototype.unskipHeader = ct.prototype.Oa, ct.prototype.Lc = function() {
          var t = this.c;
          for (this.Oa(); this.oa() && this.c == t;) this.C();
          this.a.ya() || this.Oa()
        }, ct.prototype.skipMatchingFields = ct.prototype.Lc, ct.prototype.lb = function() {
          0 != this.b ? (w("Invalid wire type for skipVarintField"), this.C()) : this.a.kb()
        }, ct.prototype.skipVarintField = ct.prototype.lb, ct.prototype.gb = function() {
          if (2 != this.b) w("Invalid wire type for skipDelimitedField"), this.C();
          else {
            var t = this.a.o();
            this.a.advance(t)
          }
        }, ct.prototype.skipDelimitedField = ct.prototype.gb, ct.prototype.hb = function() {
          5 != this.b ? (w("Invalid wire type for skipFixed32Field"), this.C()) : this.a.advance(4)
        }, ct.prototype.skipFixed32Field = ct.prototype.hb, ct.prototype.ib = function() {
          1 != this.b ? (w("Invalid wire type for skipFixed64Field"), this.C()) : this.a.advance(8)
        }, ct.prototype.skipFixed64Field = ct.prototype.ib, ct.prototype.jb = function() {
          for (var t = this.c;;) {
            if (!this.oa()) {
              w("Unmatched start-group tag: stream EOF"), this.h = !0;
              break
            }
            if (4 == this.b) {
              this.c != t && (w("Unmatched end-group tag"), this.h = !0);
              break
            }
            this.C()
          }
        }, ct.prototype.skipGroup = ct.prototype.jb, ct.prototype.C = function() {
          switch (this.b) {
            case 0:
              this.lb();
              break;
            case 1:
              this.ib();
              break;
            case 2:
              this.gb();
              break;
            case 5:
              this.hb();
              break;
            case 3:
              this.jb();
              break;
            default:
              w("Invalid wire encoding for field.")
          }
        }, ct.prototype.skipField = ct.prototype.C, ct.prototype.Hc = function(t, e) {
          null === this.v && (this.v = {}), v(!this.v[t]), this.v[t] = e
        }, ct.prototype.registerReadCallback = ct.prototype.Hc, ct.prototype.Ic = function(t) {
          return v(null !== this.v), v(t = this.v[t]), t(this)
        }, ct.prototype.runReadCallback = ct.prototype.Ic, ct.prototype.Yb = function(t, e) {
          v(2 == this.b);
          var r = this.a.c,
            n = this.a.o();
          n = this.a.B() + n, this.a.setEnd(n), e(t, this), this.a.Ma(n), this.a.setEnd(r)
        }, ct.prototype.readMessage = ct.prototype.Yb, ct.prototype.Ub = function(t, e, r) {
          v(3 == this.b), v(this.c == t), r(e, this), this.h || 4 == this.b || (w("Group submessage did not end with an END_GROUP tag"), this.h = !0)
        }, ct.prototype.readGroup = ct.prototype.Ub, ct.prototype.Gb = function() {
          v(2 == this.b);
          var t = this.a.o(),
            e = this.a.B(),
            r = e + t;
          return t = ut(this.a.Y(), e, t), this.a.Ma(r), t
        }, ct.prototype.getFieldDecoder = ct.prototype.Gb, ct.prototype.P = function() {
          return v(0 == this.b), this.a.da()
        }, ct.prototype.readInt32 = ct.prototype.P, ct.prototype.Wb = function() {
          return v(0 == this.b), this.a.Ea()
        }, ct.prototype.readInt32String = ct.prototype.Wb, ct.prototype.ba = function() {
          return v(0 == this.b), this.a.sa()
        }, ct.prototype.readInt64 = ct.prototype.ba, ct.prototype.ca = function() {
          return v(0 == this.b), this.a.Fa()
        }, ct.prototype.readInt64String = ct.prototype.ca, ct.prototype.m = function() {
          return v(0 == this.b), this.a.o()
        }, ct.prototype.readUint32 = ct.prototype.m, ct.prototype.Fc = function() {
          return v(0 == this.b), this.a.O()
        }, ct.prototype.readUint32String = ct.prototype.Fc, ct.prototype.ga = function() {
          return v(0 == this.b), this.a.Ga()
        }, ct.prototype.readUint64 = ct.prototype.ga, ct.prototype.ha = function() {
          return v(0 == this.b), this.a.Ha()
        }, ct.prototype.readUint64String = ct.prototype.ha, ct.prototype.zc = function() {
          return v(0 == this.b), this.a.Ia()
        }, ct.prototype.readSint32 = ct.prototype.zc, ct.prototype.Ac = function() {
          return v(0 == this.b), this.a.Ja()
        }, ct.prototype.readSint64 = ct.prototype.Ac, ct.prototype.Bc = function() {
          return v(0 == this.b), this.a.Ka()
        }, ct.prototype.readSint64String = ct.prototype.Bc, ct.prototype.Rb = function() {
          return v(5 == this.b), this.a.m()
        }, ct.prototype.readFixed32 = ct.prototype.Rb, ct.prototype.Sb = function() {
          return v(1 == this.b), this.a.ga()
        }, ct.prototype.readFixed64 = ct.prototype.Sb, ct.prototype.Tb = function() {
          return v(1 == this.b), this.a.ha()
        }, ct.prototype.readFixed64String = ct.prototype.Tb, ct.prototype.vc = function() {
          return v(5 == this.b), this.a.P()
        }, ct.prototype.readSfixed32 = ct.prototype.vc, ct.prototype.wc = function() {
          return v(5 == this.b), this.a.P().toString()
        }, ct.prototype.readSfixed32String = ct.prototype.wc, ct.prototype.xc = function() {
          return v(1 == this.b), this.a.ba()
        }, ct.prototype.readSfixed64 = ct.prototype.xc, ct.prototype.yc = function() {
          return v(1 == this.b), this.a.ca()
        }, ct.prototype.readSfixed64String = ct.prototype.yc, ct.prototype.aa = function() {
          return v(5 == this.b), this.a.aa()
        }, ct.prototype.readFloat = ct.prototype.aa, ct.prototype.Z = function() {
          return v(1 == this.b), this.a.Z()
        }, ct.prototype.readDouble = ct.prototype.Z, ct.prototype.pa = function() {
          return v(0 == this.b), !!this.a.o()
        }, ct.prototype.readBool = ct.prototype.pa, ct.prototype.ra = function() {
          return v(0 == this.b), this.a.sa()
        }, ct.prototype.readEnum = ct.prototype.ra, ct.prototype.fa = function() {
          v(2 == this.b);
          var t = this.a.o();
          return this.a.fa(t)
        }, ct.prototype.readString = ct.prototype.fa, ct.prototype.qa = function() {
          v(2 == this.b);
          var t = this.a.o();
          return this.a.qa(t)
        }, ct.prototype.readBytes = ct.prototype.qa, ct.prototype.ia = function() {
          return v(0 == this.b), this.a.ia()
        }, ct.prototype.readVarintHash64 = ct.prototype.ia, ct.prototype.Cc = function() {
          return v(0 == this.b), this.a.fb()
        }, ct.prototype.readSintHash64 = ct.prototype.Cc, ct.prototype.w = function(t) {
          return v(0 == this.b), this.a.w(t)
        }, ct.prototype.readSplitVarint64 = ct.prototype.w, ct.prototype.ea = function(t) {
          return v(0 == this.b), this.a.w(function(e, r) {
            return Z(e, r, t)
          })
        }, ct.prototype.readSplitZigzagVarint64 = ct.prototype.ea, ct.prototype.$ = function() {
          return v(1 == this.b), this.a.$()
        }, ct.prototype.readFixedHash64 = ct.prototype.$, ct.prototype.ta = function(t) {
          return v(1 == this.b), this.a.ta(t)
        }, ct.prototype.readSplitFixed64 = ct.prototype.ta, ct.prototype.gc = function() {
          return ht(this, this.a.da)
        }, ct.prototype.readPackedInt32 = ct.prototype.gc, ct.prototype.hc = function() {
          return ht(this, this.a.Ea)
        }, ct.prototype.readPackedInt32String = ct.prototype.hc, ct.prototype.ic = function() {
          return ht(this, this.a.sa)
        }, ct.prototype.readPackedInt64 = ct.prototype.ic, ct.prototype.jc = function() {
          return ht(this, this.a.Fa)
        }, ct.prototype.readPackedInt64String = ct.prototype.jc, ct.prototype.qc = function() {
          return ht(this, this.a.o)
        }, ct.prototype.readPackedUint32 = ct.prototype.qc, ct.prototype.rc = function() {
          return ht(this, this.a.O)
        }, ct.prototype.readPackedUint32String = ct.prototype.rc, ct.prototype.sc = function() {
          return ht(this, this.a.Ga)
        }, ct.prototype.readPackedUint64 = ct.prototype.sc, ct.prototype.tc = function() {
          return ht(this, this.a.Ha)
        }, ct.prototype.readPackedUint64String = ct.prototype.tc, ct.prototype.nc = function() {
          return ht(this, this.a.Ia)
        }, ct.prototype.readPackedSint32 = ct.prototype.nc, ct.prototype.oc = function() {
          return ht(this, this.a.Ja)
        }, ct.prototype.readPackedSint64 = ct.prototype.oc, ct.prototype.pc = function() {
          return ht(this, this.a.Ka)
        }, ct.prototype.readPackedSint64String = ct.prototype.pc, ct.prototype.bc = function() {
          return ht(this, this.a.m)
        }, ct.prototype.readPackedFixed32 = ct.prototype.bc, ct.prototype.cc = function() {
          return ht(this, this.a.ga)
        }, ct.prototype.readPackedFixed64 = ct.prototype.cc, ct.prototype.dc = function() {
          return ht(this, this.a.ha)
        }, ct.prototype.readPackedFixed64String = ct.prototype.dc, ct.prototype.kc = function() {
          return ht(this, this.a.P)
        }, ct.prototype.readPackedSfixed32 = ct.prototype.kc, ct.prototype.lc = function() {
          return ht(this, this.a.ba)
        }, ct.prototype.readPackedSfixed64 = ct.prototype.lc, ct.prototype.mc = function() {
          return ht(this, this.a.ca)
        }, ct.prototype.readPackedSfixed64String = ct.prototype.mc, ct.prototype.fc = function() {
          return ht(this, this.a.aa)
        }, ct.prototype.readPackedFloat = ct.prototype.fc, ct.prototype.$b = function() {
          return ht(this, this.a.Z)
        }, ct.prototype.readPackedDouble = ct.prototype.$b, ct.prototype.Zb = function() {
          return ht(this, this.a.pa)
        }, ct.prototype.readPackedBool = ct.prototype.Zb, ct.prototype.ac = function() {
          return ht(this, this.a.ra)
        }, ct.prototype.readPackedEnum = ct.prototype.ac, ct.prototype.uc = function() {
          return ht(this, this.a.ia)
        }, ct.prototype.readPackedVarintHash64 = ct.prototype.uc, ct.prototype.ec = function() {
          return ht(this, this.a.$)
        }, ct.prototype.readPackedFixedHash64 = ct.prototype.ec, l("jspb.ExtensionFieldInfo", dt, void 0), l("jspb.ExtensionFieldBinaryInfo", pt, void 0), dt.prototype.F = function() {
          return !!this.la
        }, dt.prototype.isMessageType = dt.prototype.F, l("jspb.Message", bt, void 0), bt.GENERATE_TO_OBJECT = !0, bt.GENERATE_FROM_OBJECT = !0;
        var mt = "function" == typeof Uint8Array;
        bt.prototype.Ib = function() {
          return this.b
        }, bt.prototype.getJsPbMessageId = bt.prototype.Ib, bt.initialize = function(t, e, r, n, i, o) {
          if (t.f = null, e || (e = r ? [r] : []), t.b = r ? r + "" : void 0, t.D = 0 === r ? -1 : 0, t.u = e, e = -1, !(r = t.u.length) || (e = r - 1, null === (r = t.u[e]) || "object" != typeof r || Array.isArray(r) || mt && r instanceof Uint8Array) ? n > -1 ? (t.G = Math.max(n, e + 1 - t.D), t.i = null) : t.G = Number.MAX_VALUE : (t.G = e - t.D, t.i = r), t.a = {}, i)
            for (n = 0; n < i.length; n++)(e = i[n]) < t.G ? (e += t.D, t.u[e] = t.u[e] || yt) : (gt(t), t.i[e] = t.i[e] || yt);
          if (o && o.length)
            for (n = 0; n < o.length; n++) Bt(t, o[n])
        };
        var yt = Object.freeze ? Object.freeze([]) : [];

        function gt(t) {
          var e = t.G + t.D;
          t.u[e] || (t.i = t.u[e] = {})
        }

        function vt(t, e, r) {
          for (var n = [], i = 0; i < t.length; i++) n[i] = e.call(t[i], r, t[i]);
          return n
        }

        function wt(t, e) {
          if (e < t.G) {
            e += t.D;
            var r = t.u[e];
            return r === yt ? t.u[e] = [] : r
          }
          if (t.i) return (r = t.i[e]) === yt ? t.i[e] = [] : r
        }

        function At(t, e) {
          return null == (t = wt(t, e)) ? t : +t
        }

        function Tt(t, e) {
          return null == (t = wt(t, e)) ? t : !!t
        }

        function Et(t) {
          return null == t || "string" == typeof t ? t : mt && t instanceof Uint8Array ? C(t) : (w("Cannot coerce to b64 string: " + h(t)), null)
        }

        function Pt(t) {
          return null == t || t instanceof Uint8Array ? t : "string" == typeof t ? R(t) : (w("Cannot coerce to Uint8Array: " + h(t)), null)
        }

        function kt(t) {
          if (t && t.length > 1) {
            var e = h(t[0]);
            b(t, function(t) {
              h(t) != e && w("Inconsistent type in JSPB repeated field array. Got " + h(t) + " expected " + e)
            })
          }
        }

        function xt(t, e, r) {
          return (t = wt(t, e)) ?? r
        }

        function It(t, e, r) {
          return A(t, bt), e < t.G ? t.u[e + t.D] = r : (gt(t), t.i[e] = r), t
        }

        function St(t, e, r, n) {
          return A(t, bt), r !== n ? It(t, e, r) : e < t.G ? t.u[e + t.D] = null : (gt(t), delete t.i[e]), t
        }

        function Ot(t, e, r, n) {
          return A(t, bt), (r = Bt(t, r)) && r !== e && void 0 !== n && (t.f && r in t.f && (t.f[r] = void 0), It(t, r, void 0)), It(t, e, n)
        }

        function Bt(t, e) {
          for (var r, n, i = 0; i < e.length; i++) {
            var o = e[i],
              s = wt(t, o);
            null != s && (r = o, n = s, It(t, o, void 0))
          }
          return r ? (It(t, r, n), r) : 0
        }

        function Wt(t, e, r) {
          if (t.f || (t.f = {}), !t.f[r]) {
            for (var n = wt(t, r), i = [], o = 0; o < n.length; o++) i[o] = new e(n[o]);
            t.f[r] = i
          }
        }

        function Mt(t) {
          if (t.f)
            for (var e in t.f) {
              var r = t.f[e];
              if (Array.isArray(r))
                for (var n = 0; n < r.length; n++) r[n] && r[n].g();
              else r && r.g()
            }
        }

        function Ct(t, e) {
          t = t || {}, e = e || {};
          var r, n = {};
          for (r in t) n[r] = 0;
          for (r in e) n[r] = 0;
          for (r in n)
            if (!Rt(t[r], e[r])) return !1;
          return !0
        }

        function Rt(t, e) {
          if (t == e) return !0;
          if (!d(t) || !d(e)) return !!("number" == typeof t && isNaN(t) || "number" == typeof e && isNaN(e)) && t + "" == e + "";
          if (t.constructor != e.constructor) return !1;
          if (mt && t.constructor === Uint8Array) {
            if (t.length != e.length) return !1;
            for (var r = 0; r < t.length; r++)
              if (t[r] != e[r]) return !1;
            return !0
          }
          if (t.constructor === Array) {
            var n = void 0,
              i = void 0,
              o = Math.max(t.length, e.length);
            for (r = 0; o > r; r++) {
              var s = t[r],
                a = e[r];
              if (s && s.constructor == Object && (v(void 0 === n), v(r === t.length - 1), n = s, s = void 0), a && a.constructor == Object && (v(void 0 === i), v(r === e.length - 1), i = a, a = void 0), !Rt(s, a)) return !1
            }
            return !n && !i || Ct(n = n || {}, i = i || {})
          }
          if (t.constructor === Object) return Ct(t, e);
          throw Error("Invalid type in JSPB array")
        }

        function Nt(t) {
          return new t.constructor(jt(t.g()))
        }

        function jt(t) {
          if (Array.isArray(t)) {
            for (var e = Array(t.length), r = 0; r < t.length; r++) {
              var n = t[r];
              null != n && (e[r] = "object" == typeof n ? jt(v(n)) : n)
            }
            return e
          }
          if (mt && t instanceof Uint8Array) return new Uint8Array(t);
          for (r in e = {}, t) null != (n = t[r]) && (e[r] = "object" == typeof n ? jt(v(n)) : n);
          return e
        }
        bt.toObjectList = vt, bt.toObjectExtension = function(t, e, r, n, i) {
          for (var o in r) {
            var s = r[o],
              a = n.call(t, s);
            if (null != a) {
              for (var u in s.Ba)
                if (s.Ba.hasOwnProperty(u)) break;
              e[u] = s.Na ? s.na ? vt(a, s.Na, i) : s.Na(i, a) : a
            }
          }
        }, bt.serializeBinaryExtensions = function(t, e, r, n) {
          for (var i in r) {
            var o = r[i],
              s = o.Za;
            if (!o.Aa) throw Error("Message extension present that was generated without binary serialization support");
            var a = n.call(t, s);
            if (null != a)
              if (s.F()) {
                if (!o.Wa) throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
                o.Aa.call(e, s.ma, a, o.Wa)
              } else o.Aa.call(e, s.ma, a)
          }
        }, bt.readBinaryExtension = function(t, e, r, n, i) {
          var o = r[e.c];
          if (o) {
            if (r = o.Za, !o.za) throw Error("Deserializing extension whose generated code does not support binary format");
            if (r.F()) {
              var s = new r.la;
              o.za.call(e, s, o.Ab)
            } else s = o.za.call(e);
            r.na && !o.Nb ? (e = n.call(t, r)) ? e.push(s) : i.call(t, r, [s]) : i.call(t, r, s)
          } else e.C()
        }, bt.getField = wt, bt.getRepeatedField = function(t, e) {
          return wt(t, e)
        }, bt.getOptionalFloatingPointField = At, bt.getBooleanField = Tt, bt.getRepeatedFloatingPointField = function(t, e) {
          var r = wt(t, e);
          if (t.a || (t.a = {}), !t.a[e]) {
            for (var n = 0; n < r.length; n++) r[n] = +r[n];
            t.a[e] = !0
          }
          return r
        }, bt.getRepeatedBooleanField = function(t, e) {
          var r = wt(t, e);
          if (t.a || (t.a = {}), !t.a[e]) {
            for (var n = 0; n < r.length; n++) r[n] = !!r[n];
            t.a[e] = !0
          }
          return r
        }, bt.bytesAsB64 = Et, bt.bytesAsU8 = Pt, bt.bytesListAsB64 = function(t) {
          return kt(t), t.length && "string" != typeof t[0] ? m(t, Et) : t
        }, bt.bytesListAsU8 = function(t) {
          return kt(t), !t.length || t[0] instanceof Uint8Array ? t : m(t, Pt)
        }, bt.getFieldWithDefault = xt, bt.getBooleanFieldWithDefault = function(t, e, r) {
          return (t = Tt(t, e)) ?? r
        }, bt.getFloatingPointFieldWithDefault = function(t, e, r) {
          return (t = At(t, e)) ?? r
        }, bt.getFieldProto3 = xt, bt.getMapField = function(t, e, r, n) {
          if (t.f || (t.f = {}), e in t.f) return t.f[e];
          var i = wt(t, e);
          if (!i) {
            if (r) return;
            It(t, e, i = [])
          }
          return t.f[e] = new E(i, n)
        }, bt.setField = It, bt.setProto3IntField = function(t, e, r) {
          return St(t, e, r, 0)
        }, bt.setProto3FloatField = function(t, e, r) {
          return St(t, e, r, 0)
        }, bt.setProto3BooleanField = function(t, e, r) {
          return St(t, e, r, !1)
        }, bt.setProto3StringField = function(t, e, r) {
          return St(t, e, r, "")
        }, bt.setProto3BytesField = function(t, e, r) {
          return St(t, e, r, "")
        }, bt.setProto3EnumField = function(t, e, r) {
          return St(t, e, r, 0)
        }, bt.setProto3StringIntField = function(t, e, r) {
          return St(t, e, r, "0")
        }, bt.addToRepeatedField = function(t, e, r, n) {
          return A(t, bt), e = wt(t, e), null != n ? e.splice(n, 0, r) : e.push(r), t
        }, bt.setOneofField = Ot, bt.computeOneofCase = Bt, bt.getWrapperField = function(t, e, r, n) {
          if (t.f || (t.f = {}), !t.f[r]) {
            var i = wt(t, r);
            (n || i) && (t.f[r] = new e(i))
          }
          return t.f[r]
        }, bt.getRepeatedWrapperField = function(t, e, r) {
          return Wt(t, e, r), (e = t.f[r]) == yt && (e = t.f[r] = []), e
        }, bt.setWrapperField = function(t, e, r) {
          A(t, bt), t.f || (t.f = {});
          var n = r && r.g();
          return t.f[e] = r, It(t, e, n)
        }, bt.setOneofWrapperField = function(t, e, r, n) {
          A(t, bt), t.f || (t.f = {});
          var i = n && n.g();
          return t.f[e] = n, Ot(t, e, r, i)
        }, bt.setRepeatedWrapperField = function(t, e, r) {
          A(t, bt), t.f || (t.f = {}), r = r || [];
          for (var n = [], i = 0; i < r.length; i++) n[i] = r[i].g();
          return t.f[e] = r, It(t, e, n)
        }, bt.addToRepeatedWrapperField = function(t, e, r, n, i) {
          Wt(t, n, e);
          var o = t.f[e];
          return o || (o = t.f[e] = []), r = r || new n, t = wt(t, e), null != i ? (o.splice(i, 0, r), t.splice(i, 0, r.g())) : (o.push(r), t.push(r.g())), r
        }, bt.toMap = function(t, e, r, n) {
          for (var i = {}, o = 0; o < t.length; o++) i[e.call(t[o])] = r ? r.call(t[o], n, t[o]) : t[o];
          return i
        }, bt.prototype.g = function() {
          return Mt(this), this.u
        }, bt.prototype.toArray = bt.prototype.g, bt.prototype.toString = function() {
          return Mt(this), this.u.toString()
        }, bt.prototype.getExtension = function(t) {
          if (this.i) {
            this.f || (this.f = {});
            var e = t.ma;
            if (t.na) {
              if (t.F()) return this.f[e] || (this.f[e] = m(this.i[e] || [], function(e) {
                return new t.la(e)
              })), this.f[e]
            } else if (t.F()) return !this.f[e] && this.i[e] && (this.f[e] = new t.la(this.i[e])), this.f[e];
            return this.i[e]
          }
        }, bt.prototype.getExtension = bt.prototype.getExtension, bt.prototype.Kc = function(t, e) {
          this.f || (this.f = {}), gt(this);
          var r = t.ma;
          return t.na ? (e = e || [], t.F() ? (this.f[r] = e, this.i[r] = m(e, function(t) {
            return t.g()
          })) : this.i[r] = e) : t.F() ? (this.f[r] = e, this.i[r] = e && e.g()) : this.i[r] = e, this
        }, bt.prototype.setExtension = bt.prototype.Kc, bt.difference = function(t, e) {
          if (!(t instanceof e.constructor)) throw Error("Messages have different types.");
          var r = t.g();
          e = e.g();
          var n = [],
            i = 0,
            o = r.length > e.length ? r.length : e.length;
          for (t.b && (n[0] = t.b, i = 1); o > i; i++) Rt(r[i], e[i]) || (n[i] = e[i]);
          return new t.constructor(n)
        }, bt.equals = function(t, e) {
          return t == e || !(!t || !e) && t instanceof e.constructor && Rt(t.g(), e.g())
        }, bt.compareExtensions = Ct, bt.compareFields = Rt, bt.prototype.Bb = function() {
          return Nt(this)
        }, bt.prototype.cloneMessage = bt.prototype.Bb, bt.prototype.clone = function() {
          return Nt(this)
        }, bt.prototype.clone = bt.prototype.clone, bt.clone = function(t) {
          return Nt(t)
        }, bt.copyInto = function(t, e) {
          A(t, bt), A(e, bt), v(t.constructor == e.constructor, "Copy source and target message should have the same type."), t = Nt(t);
          for (var r = e.g(), n = t.g(), i = r.length = 0; i < n.length; i++) r[i] = n[i];
          e.f = t.f, e.i = t.i
        }, bt.registerMessageType = function(t, e) {
          e.we = t
        };
        var _t = {
          dump: function(t) {
            return A(t, bt, "jspb.Message instance expected"), v(t.getExtension, "Only unobfuscated and unoptimized compilation modes supported."), _t.X(t)
          }
        };

        function Dt() {
          this.a = []
        }

        function Ut(t, e) {
          this.lo = t, this.hi = e
        }

        function Lt(t, e) {
          var r = 65535 & t,
            n = 65535 & e,
            i = e >>> 16;
          for (e = r * n + 65536 * (r * i & 65535) + 65536 * ((t >>>= 16) * n & 65535), r = t * i + (r * i >>> 16) + (t * n >>> 16); e >= 4294967296;) e -= 4294967296, r += 1;
          return new Ut(e >>> 0, r >>> 0)
        }

        function Ft(t) {
          for (var e = new Ut(0, 0), r = new Ut(0, 0), n = 0; n < t.length; n++) {
            if ("0" > t[n] || t[n] > "9") return null;
            r.lo = parseInt(t[n], 10), e = e.eb(10).add(r)
          }
          return e
        }

        function $t(t, e) {
          this.lo = t, this.hi = e
        }

        function zt(t) {
          var e = t.length > 0 && "-" == t[0];
          return e && (t = t.substring(1)), null === (t = Ft(t)) ? null : (e && (t = new Ut(0, 0).sub(t)), new $t(t.lo, t.hi))
        }

        function Ht() {
          this.c = [], this.b = 0, this.a = new Dt, this.h = []
        }

        function Gt(t, e) {
          var r = t.a.end();
          t.c.push(r), t.c.push(e), t.b += r.length + e.length
        }

        function Kt(t, e) {
          return Zt(t, e, 2), e = t.a.end(), t.c.push(e), t.b += e.length, e.push(t.b), e
        }

        function Vt(t, e) {
          var r = e.pop();
          for (v((r = t.b + t.a.length() - r) >= 0); r > 127;) e.push(127 & r | 128), r >>>= 7, t.b++;
          e.push(r), t.b++
        }

        function Zt(t, e, r) {
          v(e >= 1 && e == Math.floor(e)), t.a.j(8 * e + r)
        }

        function qt(t, e, r) {
          null != r && (Zt(t, e, 0), t.a.j(r))
        }

        function Jt(t, e, r) {
          null != r && (Zt(t, e, 0), t.a.M(r))
        }
        l("jspb.debug.dump", _t.dump, void 0), _t.X = function(t) {
          var e = h(t);
          if ("number" == e || "string" == e || "boolean" == e || "null" == e || "undefined" == e || "u" > typeof Uint8Array && t instanceof Uint8Array) return t;
          if ("array" == e) return function(t, e, r) {
            for (var n = [], i = 2; arguments.length > i; ++i) n[i - 2] = arguments[i];
            Array.isArray(t) || g("Expected array but got %s: %s.", [h(t), t], e, n)
          }(t), m(t, _t.X);
          if (t instanceof E) {
            for (var r = {}, n = (t = t.entries()).next(); !n.done; n = t.next()) r[n.value[0]] = _t.X(n.value[1]);
            return r
          }
          A(t, bt, "Only messages expected: " + t);
          var i = {
            $name: (e = t.constructor).name || e.displayName
          };
          for (a in e.prototype) {
            var o = /^get([A-Z]\w*)/.exec(a);
            if (o && "getExtension" != a && "getJsPbMessageId" != a) {
              var s = "has" + o[1];
              (!t[s] || t[s]()) && (s = t[a](), i[_t.$a(o[1])] = _t.X(s))
            }
          }
          if (t.extensionObject_) return i.$extensions = "Recursive dumping of extensions not supported in compiled code. Switch to uncompiled or dump extension object directly", i;
          for (n in e.extensions)
            if (/^\d+$/.test(n)) {
              s = e.extensions[n];
              var a = t.getExtension(s);
              o = void 0, s = s.Ba;
              var u = [],
                c = 0;
              for (o in s) u[c++] = o;
              o = u[0], null != a && (r || (r = i.$extensions = {}), r[_t.$a(o)] = _t.X(a))
            } return i
        }, _t.$a = function(t) {
          return t.replace(/^[A-Z]/, function(t) {
            return t.toLowerCase()
          })
        }, l("jspb.BinaryEncoder", Dt, void 0), Dt.prototype.length = function() {
          return this.a.length
        }, Dt.prototype.length = Dt.prototype.length, Dt.prototype.end = function() {
          var t = this.a;
          return this.a = [], t
        }, Dt.prototype.end = Dt.prototype.end, Dt.prototype.l = function(t, e) {
          for (v(t == Math.floor(t)), v(e == Math.floor(e)), v(t >= 0 && 4294967296 > t), v(e >= 0 && 4294967296 > e); e > 0 || t > 127;) this.a.push(127 & t | 128), t = (t >>> 7 | e << 25) >>> 0, e >>>= 7;
          this.a.push(t)
        }, Dt.prototype.writeSplitVarint64 = Dt.prototype.l, Dt.prototype.A = function(t, e) {
          v(t == Math.floor(t)), v(e == Math.floor(e)), v(t >= 0 && 4294967296 > t), v(e >= 0 && 4294967296 > e), this.s(t), this.s(e)
        }, Dt.prototype.writeSplitFixed64 = Dt.prototype.A, Dt.prototype.j = function(t) {
          for (v(t == Math.floor(t)), v(t >= 0 && 4294967296 > t); t > 127;) this.a.push(127 & t | 128), t >>>= 7;
          this.a.push(t)
        }, Dt.prototype.writeUnsignedVarint32 = Dt.prototype.j, Dt.prototype.M = function(t) {
          if (v(t == Math.floor(t)), v(t >= -2147483648 && 2147483648 > t), 0 > t) {
            for (var e = 0; 9 > e; e++) this.a.push(127 & t | 128), t >>= 7;
            this.a.push(1)
          } else this.j(t)
        }, Dt.prototype.writeSignedVarint32 = Dt.prototype.M, Dt.prototype.va = function(t) {
          v(t == Math.floor(t)), v(t >= 0 && 0x10000000000000000 > t), U(t), this.l(j, _)
        }, Dt.prototype.writeUnsignedVarint64 = Dt.prototype.va, Dt.prototype.ua = function(t) {
          v(t == Math.floor(t)), v(t >= -0x8000000000000000 && 0x8000000000000000 > t), U(t), this.l(j, _)
        }, Dt.prototype.writeSignedVarint64 = Dt.prototype.ua, Dt.prototype.wa = function(t) {
          v(t == Math.floor(t)), v(t >= -2147483648 && 2147483648 > t), this.j((t << 1 ^ t >> 31) >>> 0)
        }, Dt.prototype.writeZigzagVarint32 = Dt.prototype.wa, Dt.prototype.xa = function(t) {
          v(t == Math.floor(t)), v(t >= -0x8000000000000000 && 0x8000000000000000 > t), L(t), this.l(j, _)
        }, Dt.prototype.writeZigzagVarint64 = Dt.prototype.xa, Dt.prototype.Ta = function(t) {
          this.W(et(t))
        }, Dt.prototype.writeZigzagVarint64String = Dt.prototype.Ta, Dt.prototype.W = function(t) {
          var e = this;
          z(t), K(j, _, function(t, r) {
            e.l(t >>> 0, r >>> 0)
          })
        }, Dt.prototype.writeZigzagVarintHash64 = Dt.prototype.W, Dt.prototype.be = function(t) {
          v(t == Math.floor(t)), v(t >= 0 && 256 > t), this.a.push(t >>> 0 & 255)
        }, Dt.prototype.writeUint8 = Dt.prototype.be, Dt.prototype.ae = function(t) {
          v(t == Math.floor(t)), v(t >= 0 && 65536 > t), this.a.push(t >>> 0 & 255), this.a.push(t >>> 8 & 255)
        }, Dt.prototype.writeUint16 = Dt.prototype.ae, Dt.prototype.s = function(t) {
          v(t == Math.floor(t)), v(t >= 0 && 4294967296 > t), this.a.push(t >>> 0 & 255), this.a.push(t >>> 8 & 255), this.a.push(t >>> 16 & 255), this.a.push(t >>> 24 & 255)
        }, Dt.prototype.writeUint32 = Dt.prototype.s, Dt.prototype.V = function(t) {
          v(t == Math.floor(t)), v(t >= 0 && 0x10000000000000000 > t), D(t), this.s(j), this.s(_)
        }, Dt.prototype.writeUint64 = Dt.prototype.V, Dt.prototype.Qc = function(t) {
          v(t == Math.floor(t)), v(t >= -128 && 128 > t), this.a.push(t >>> 0 & 255)
        }, Dt.prototype.writeInt8 = Dt.prototype.Qc, Dt.prototype.Pc = function(t) {
          v(t == Math.floor(t)), v(t >= -32768 && 32768 > t), this.a.push(t >>> 0 & 255), this.a.push(t >>> 8 & 255)
        }, Dt.prototype.writeInt16 = Dt.prototype.Pc, Dt.prototype.S = function(t) {
          v(t == Math.floor(t)), v(t >= -2147483648 && 2147483648 > t), this.a.push(t >>> 0 & 255), this.a.push(t >>> 8 & 255), this.a.push(t >>> 16 & 255), this.a.push(t >>> 24 & 255)
        }, Dt.prototype.writeInt32 = Dt.prototype.S, Dt.prototype.T = function(t) {
          v(t == Math.floor(t)), v(t >= -0x8000000000000000 && 0x8000000000000000 > t), U(t), this.A(j, _)
        }, Dt.prototype.writeInt64 = Dt.prototype.T, Dt.prototype.ka = function(t) {
          v(t == Math.floor(t)), v(+t >= -0x8000000000000000 && 0x8000000000000000 > +t), z(et(t)), this.A(j, _)
        }, Dt.prototype.writeInt64String = Dt.prototype.ka, Dt.prototype.L = function(t) {
          v(t === 1 / 0 || t === -1 / 0 || isNaN(t) || t >= -34028234663852886e22 && 34028234663852886e22 >= t), F(t), this.s(j)
        }, Dt.prototype.writeFloat = Dt.prototype.L, Dt.prototype.J = function(t) {
          v(t === 1 / 0 || t === -1 / 0 || isNaN(t) || t >= -17976931348623157e292 && 17976931348623157e292 >= t), $(t), this.s(j), this.s(_)
        }, Dt.prototype.writeDouble = Dt.prototype.J, Dt.prototype.I = function(t) {
          v("boolean" == typeof t || "number" == typeof t), this.a.push(t ? 1 : 0)
        }, Dt.prototype.writeBool = Dt.prototype.I, Dt.prototype.R = function(t) {
          v(t == Math.floor(t)), v(t >= -2147483648 && 2147483648 > t), this.M(t)
        }, Dt.prototype.writeEnum = Dt.prototype.R, Dt.prototype.ja = function(t) {
          this.a.push.apply(this.a, t)
        }, Dt.prototype.writeBytes = Dt.prototype.ja, Dt.prototype.N = function(t) {
          z(t), this.l(j, _)
        }, Dt.prototype.writeVarintHash64 = Dt.prototype.N, Dt.prototype.K = function(t) {
          z(t), this.s(j), this.s(_)
        }, Dt.prototype.writeFixedHash64 = Dt.prototype.K, Dt.prototype.U = function(t) {
          var e = this.a.length;
          ! function(t, e, r) {
            for (var n = [], i = 2; arguments.length > i; ++i) n[i - 2] = arguments[i];
            "string" != typeof t && g("Expected string but got %s: %s.", [h(t), t], e, n)
          }(t);
          for (var r = 0; r < t.length; r++) {
            var n = t.charCodeAt(r);
            if (128 > n) this.a.push(n);
            else if (2048 > n) this.a.push(n >> 6 | 192), this.a.push(63 & n | 128);
            else if (65536 > n)
              if (55296 > n || n > 56319 || r + 1 >= t.length) this.a.push(n >> 12 | 224), this.a.push(n >> 6 & 63 | 128), this.a.push(63 & n | 128);
              else {
                var i = t.charCodeAt(r + 1);
                i >= 56320 && 57343 >= i && (n = 1024 * (n - 55296) + i - 56320 + 65536, this.a.push(n >> 18 | 240), this.a.push(n >> 12 & 63 | 128), this.a.push(n >> 6 & 63 | 128), this.a.push(63 & n | 128), r++)
              }
          }
          return this.a.length - e
        }, Dt.prototype.writeString = Dt.prototype.U, l("jspb.arith.UInt64", Ut, void 0), Ut.prototype.cmp = function(t) {
          return this.hi < t.hi || this.hi == t.hi && this.lo < t.lo ? -1 : this.hi == t.hi && this.lo == t.lo ? 0 : 1
        }, Ut.prototype.cmp = Ut.prototype.cmp, Ut.prototype.La = function() {
          return new Ut((this.lo >>> 1 | (1 & this.hi) << 31) >>> 0, this.hi >>> 1 >>> 0)
        }, Ut.prototype.rightShift = Ut.prototype.La, Ut.prototype.Da = function() {
          return new Ut(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0)
        }, Ut.prototype.leftShift = Ut.prototype.Da, Ut.prototype.cb = function() {
          return !!(2147483648 & this.hi)
        }, Ut.prototype.msb = Ut.prototype.cb, Ut.prototype.Ob = function() {
          return !!(1 & this.lo)
        }, Ut.prototype.lsb = Ut.prototype.Ob, Ut.prototype.Ua = function() {
          return 0 == this.lo && 0 == this.hi
        }, Ut.prototype.zero = Ut.prototype.Ua, Ut.prototype.add = function(t) {
          return new Ut((this.lo + t.lo & 4294967295) >>> 0 >>> 0, ((this.hi + t.hi & 4294967295) >>> 0) + (4294967296 > this.lo + t.lo ? 0 : 1) >>> 0)
        }, Ut.prototype.add = Ut.prototype.add, Ut.prototype.sub = function(t) {
          return new Ut((this.lo - t.lo & 4294967295) >>> 0 >>> 0, ((this.hi - t.hi & 4294967295) >>> 0) - (0 > this.lo - t.lo ? 1 : 0) >>> 0)
        }, Ut.prototype.sub = Ut.prototype.sub, Ut.mul32x32 = Lt, Ut.prototype.eb = function(t) {
          var e = Lt(this.lo, t);
          return (t = Lt(this.hi, t)).hi = t.lo, t.lo = 0, e.add(t)
        }, Ut.prototype.mul = Ut.prototype.eb, Ut.prototype.Xa = function(t) {
          if (0 == t) return [];
          var e = new Ut(0, 0),
            r = new Ut(this.lo, this.hi);
          t = new Ut(t, 0);
          for (var n = new Ut(1, 0); !t.cb();) t = t.Da(), n = n.Da();
          for (; !n.Ua();) 0 >= t.cmp(r) && (e = e.add(n), r = r.sub(t)), t = t.La(), n = n.La();
          return [e, r]
        }, Ut.prototype.div = Ut.prototype.Xa, Ut.prototype.toString = function() {
          for (var t = "", e = this; !e.Ua();) {
            var r = (e = e.Xa(10))[0];
            t = e[1].lo + t, e = r
          }
          return "" == t && (t = "0"), t
        }, Ut.prototype.toString = Ut.prototype.toString, Ut.fromString = Ft, Ut.prototype.clone = function() {
          return new Ut(this.lo, this.hi)
        }, Ut.prototype.clone = Ut.prototype.clone, l("jspb.arith.Int64", $t, void 0), $t.prototype.add = function(t) {
          return new $t((this.lo + t.lo & 4294967295) >>> 0 >>> 0, ((this.hi + t.hi & 4294967295) >>> 0) + (4294967296 > this.lo + t.lo ? 0 : 1) >>> 0)
        }, $t.prototype.add = $t.prototype.add, $t.prototype.sub = function(t) {
          return new $t((this.lo - t.lo & 4294967295) >>> 0 >>> 0, ((this.hi - t.hi & 4294967295) >>> 0) - (0 > this.lo - t.lo ? 1 : 0) >>> 0)
        }, $t.prototype.sub = $t.prototype.sub, $t.prototype.clone = function() {
          return new $t(this.lo, this.hi)
        }, $t.prototype.clone = $t.prototype.clone, $t.prototype.toString = function() {
          var t = !!(2147483648 & this.hi),
            e = new Ut(this.lo, this.hi);
          return t && (e = new Ut(0, 0).sub(e)), (t ? "-" : "") + e.toString()
        }, $t.prototype.toString = $t.prototype.toString, $t.fromString = zt, l("jspb.BinaryWriter", Ht, void 0), Ht.prototype.pb = function(t, e, r) {
          Gt(this, t.subarray(e, r))
        }, Ht.prototype.writeSerializedMessage = Ht.prototype.pb, Ht.prototype.Pb = function(t, e, r) {
          null != t && null != e && null != r && this.pb(t, e, r)
        }, Ht.prototype.maybeWriteSerializedMessage = Ht.prototype.Pb, Ht.prototype.reset = function() {
          this.c = [], this.a.end(), this.b = 0, this.h = []
        }, Ht.prototype.reset = Ht.prototype.reset, Ht.prototype.ab = function() {
          v(0 == this.h.length);
          for (var t = new Uint8Array(this.b + this.a.length()), e = this.c, r = e.length, n = 0, i = 0; r > i; i++) {
            var o = e[i];
            t.set(o, n), n += o.length
          }
          return e = this.a.end(), t.set(e, n), v((n += e.length) == t.length), this.c = [t], t
        }, Ht.prototype.getResultBuffer = Ht.prototype.ab, Ht.prototype.Kb = function(t) {
          return C(this.ab(), t)
        }, Ht.prototype.getResultBase64String = Ht.prototype.Kb, Ht.prototype.Va = function(t) {
          this.h.push(Kt(this, t))
        }, Ht.prototype.beginSubMessage = Ht.prototype.Va, Ht.prototype.Ya = function() {
          v(this.h.length >= 0), Vt(this, this.h.pop())
        }, Ht.prototype.endSubMessage = Ht.prototype.Ya, Ht.prototype.Nc = function(t, e, r) {
          switch (t) {
            case 1:
              this.J(e, r);
              break;
            case 2:
              this.L(e, r);
              break;
            case 3:
              this.T(e, r);
              break;
            case 4:
              this.V(e, r);
              break;
            case 5:
              this.S(e, r);
              break;
            case 6:
              this.Qa(e, r);
              break;
            case 7:
              this.Pa(e, r);
              break;
            case 8:
              this.I(e, r);
              break;
            case 9:
              this.U(e, r);
              break;
            case 10:
              w("Group field type not supported in writeAny()");
              break;
            case 11:
              w("Message field type not supported in writeAny()");
              break;
            case 12:
              this.ja(e, r);
              break;
            case 13:
              this.s(e, r);
              break;
            case 14:
              this.R(e, r);
              break;
            case 15:
              this.Ra(e, r);
              break;
            case 16:
              this.Sa(e, r);
              break;
            case 17:
              this.rb(e, r);
              break;
            case 18:
              this.sb(e, r);
              break;
            case 30:
              this.K(e, r);
              break;
            case 31:
              this.N(e, r);
              break;
            default:
              w("Invalid field type in writeAny()")
          }
        }, Ht.prototype.writeAny = Ht.prototype.Nc, Ht.prototype.S = function(t, e) {
          null != e && (v(e >= -2147483648 && 2147483648 > e), Jt(this, t, e))
        }, Ht.prototype.writeInt32 = Ht.prototype.S, Ht.prototype.ob = function(t, e) {
          null != e && (v((e = parseInt(e, 10)) >= -2147483648 && 2147483648 > e), Jt(this, t, e))
        }, Ht.prototype.writeInt32String = Ht.prototype.ob, Ht.prototype.T = function(t, e) {
          null != e && (v(e >= -0x8000000000000000 && 0x8000000000000000 > e), null != e && (Zt(this, t, 0), this.a.ua(e)))
        }, Ht.prototype.writeInt64 = Ht.prototype.T, Ht.prototype.ka = function(t, e) {
          null != e && (e = zt(e), Zt(this, t, 0), this.a.l(e.lo, e.hi))
        }, Ht.prototype.writeInt64String = Ht.prototype.ka, Ht.prototype.s = function(t, e) {
          null != e && (v(e >= 0 && 4294967296 > e), qt(this, t, e))
        }, Ht.prototype.writeUint32 = Ht.prototype.s, Ht.prototype.ub = function(t, e) {
          null != e && (v((e = parseInt(e, 10)) >= 0 && 4294967296 > e), qt(this, t, e))
        }, Ht.prototype.writeUint32String = Ht.prototype.ub, Ht.prototype.V = function(t, e) {
          null != e && (v(e >= 0 && 0x10000000000000000 > e), null != e && (Zt(this, t, 0), this.a.va(e)))
        }, Ht.prototype.writeUint64 = Ht.prototype.V, Ht.prototype.vb = function(t, e) {
          null != e && (e = Ft(e), Zt(this, t, 0), this.a.l(e.lo, e.hi))
        }, Ht.prototype.writeUint64String = Ht.prototype.vb, Ht.prototype.rb = function(t, e) {
          null != e && (v(e >= -2147483648 && 2147483648 > e), null != e && (Zt(this, t, 0), this.a.wa(e)))
        }, Ht.prototype.writeSint32 = Ht.prototype.rb, Ht.prototype.sb = function(t, e) {
          null != e && (v(e >= -0x8000000000000000 && 0x8000000000000000 > e), null != e && (Zt(this, t, 0), this.a.xa(e)))
        }, Ht.prototype.writeSint64 = Ht.prototype.sb, Ht.prototype.$d = function(t, e) {
          null != e && null != e && (Zt(this, t, 0), this.a.W(e))
        }, Ht.prototype.writeSintHash64 = Ht.prototype.$d, Ht.prototype.Zd = function(t, e) {
          null != e && null != e && (Zt(this, t, 0), this.a.Ta(e))
        }, Ht.prototype.writeSint64String = Ht.prototype.Zd, Ht.prototype.Pa = function(t, e) {
          null != e && (v(e >= 0 && 4294967296 > e), Zt(this, t, 5), this.a.s(e))
        }, Ht.prototype.writeFixed32 = Ht.prototype.Pa, Ht.prototype.Qa = function(t, e) {
          null != e && (v(e >= 0 && 0x10000000000000000 > e), Zt(this, t, 1), this.a.V(e))
        }, Ht.prototype.writeFixed64 = Ht.prototype.Qa, Ht.prototype.nb = function(t, e) {
          null != e && (e = Ft(e), Zt(this, t, 1), this.a.A(e.lo, e.hi))
        }, Ht.prototype.writeFixed64String = Ht.prototype.nb, Ht.prototype.Ra = function(t, e) {
          null != e && (v(e >= -2147483648 && 2147483648 > e), Zt(this, t, 5), this.a.S(e))
        }, Ht.prototype.writeSfixed32 = Ht.prototype.Ra, Ht.prototype.Sa = function(t, e) {
          null != e && (v(e >= -0x8000000000000000 && 0x8000000000000000 > e), Zt(this, t, 1), this.a.T(e))
        }, Ht.prototype.writeSfixed64 = Ht.prototype.Sa, Ht.prototype.qb = function(t, e) {
          null != e && (e = zt(e), Zt(this, t, 1), this.a.A(e.lo, e.hi))
        }, Ht.prototype.writeSfixed64String = Ht.prototype.qb, Ht.prototype.L = function(t, e) {
          null != e && (Zt(this, t, 5), this.a.L(e))
        }, Ht.prototype.writeFloat = Ht.prototype.L, Ht.prototype.J = function(t, e) {
          null != e && (Zt(this, t, 1), this.a.J(e))
        }, Ht.prototype.writeDouble = Ht.prototype.J, Ht.prototype.I = function(t, e) {
          null != e && (v("boolean" == typeof e || "number" == typeof e), Zt(this, t, 0), this.a.I(e))
        }, Ht.prototype.writeBool = Ht.prototype.I, Ht.prototype.R = function(t, e) {
          null != e && (v(e >= -2147483648 && 2147483648 > e), Zt(this, t, 0), this.a.M(e))
        }, Ht.prototype.writeEnum = Ht.prototype.R, Ht.prototype.U = function(t, e) {
          null != e && (t = Kt(this, t), this.a.U(e), Vt(this, t))
        }, Ht.prototype.writeString = Ht.prototype.U, Ht.prototype.ja = function(t, e) {
          null != e && (e = ot(e), Zt(this, t, 2), this.a.j(e.length), Gt(this, e))
        }, Ht.prototype.writeBytes = Ht.prototype.ja, Ht.prototype.Rc = function(t, e, r) {
          null != e && (t = Kt(this, t), r(e, this), Vt(this, t))
        }, Ht.prototype.writeMessage = Ht.prototype.Rc, Ht.prototype.Sc = function(t, e, r) {
          null != e && (Zt(this, 1, 3), Zt(this, 2, 0), this.a.M(t), t = Kt(this, 3), r(e, this), Vt(this, t), Zt(this, 1, 4))
        }, Ht.prototype.writeMessageSet = Ht.prototype.Sc, Ht.prototype.Oc = function(t, e, r) {
          null != e && (Zt(this, t, 3), r(e, this), Zt(this, t, 4))
        }, Ht.prototype.writeGroup = Ht.prototype.Oc, Ht.prototype.K = function(t, e) {
          null != e && (v(8 == e.length), Zt(this, t, 1), this.a.K(e))
        }, Ht.prototype.writeFixedHash64 = Ht.prototype.K, Ht.prototype.N = function(t, e) {
          null != e && (v(8 == e.length), Zt(this, t, 0), this.a.N(e))
        }, Ht.prototype.writeVarintHash64 = Ht.prototype.N, Ht.prototype.A = function(t, e, r) {
          Zt(this, t, 1), this.a.A(e, r)
        }, Ht.prototype.writeSplitFixed64 = Ht.prototype.A, Ht.prototype.l = function(t, e, r) {
          Zt(this, t, 0), this.a.l(e, r)
        }, Ht.prototype.writeSplitVarint64 = Ht.prototype.l, Ht.prototype.tb = function(t, e, r) {
          Zt(this, t, 0);
          var n = this.a;
          K(e, r, function(t, e) {
            n.l(t >>> 0, e >>> 0)
          })
        }, Ht.prototype.writeSplitZigzagVarint64 = Ht.prototype.tb, Ht.prototype.Ed = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) Jt(this, t, e[r])
        }, Ht.prototype.writeRepeatedInt32 = Ht.prototype.Ed, Ht.prototype.Fd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.ob(t, e[r])
        }, Ht.prototype.writeRepeatedInt32String = Ht.prototype.Fd, Ht.prototype.Gd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.ua(n))
            }
        }, Ht.prototype.writeRepeatedInt64 = Ht.prototype.Gd, Ht.prototype.Qd = function(t, e, r, n) {
          if (null != e)
            for (var i = 0; i < e.length; i++) this.A(t, r(e[i]), n(e[i]))
        }, Ht.prototype.writeRepeatedSplitFixed64 = Ht.prototype.Qd, Ht.prototype.Rd = function(t, e, r, n) {
          if (null != e)
            for (var i = 0; i < e.length; i++) this.l(t, r(e[i]), n(e[i]))
        }, Ht.prototype.writeRepeatedSplitVarint64 = Ht.prototype.Rd, Ht.prototype.Sd = function(t, e, r, n) {
          if (null != e)
            for (var i = 0; i < e.length; i++) this.tb(t, r(e[i]), n(e[i]))
        }, Ht.prototype.writeRepeatedSplitZigzagVarint64 = Ht.prototype.Sd, Ht.prototype.Hd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.ka(t, e[r])
        }, Ht.prototype.writeRepeatedInt64String = Ht.prototype.Hd, Ht.prototype.Ud = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) qt(this, t, e[r])
        }, Ht.prototype.writeRepeatedUint32 = Ht.prototype.Ud, Ht.prototype.Vd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.ub(t, e[r])
        }, Ht.prototype.writeRepeatedUint32String = Ht.prototype.Vd, Ht.prototype.Wd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.va(n))
            }
        }, Ht.prototype.writeRepeatedUint64 = Ht.prototype.Wd, Ht.prototype.Xd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.vb(t, e[r])
        }, Ht.prototype.writeRepeatedUint64String = Ht.prototype.Xd, Ht.prototype.Md = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.wa(n))
            }
        }, Ht.prototype.writeRepeatedSint32 = Ht.prototype.Md, Ht.prototype.Nd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.xa(n))
            }
        }, Ht.prototype.writeRepeatedSint64 = Ht.prototype.Nd, Ht.prototype.Od = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.Ta(n))
            }
        }, Ht.prototype.writeRepeatedSint64String = Ht.prototype.Od, Ht.prototype.Pd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) {
              var n = e[r];
              null != n && (Zt(this, t, 0), this.a.W(n))
            }
        }, Ht.prototype.writeRepeatedSintHash64 = Ht.prototype.Pd, Ht.prototype.yd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.Pa(t, e[r])
        }, Ht.prototype.writeRepeatedFixed32 = Ht.prototype.yd, Ht.prototype.zd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.Qa(t, e[r])
        }, Ht.prototype.writeRepeatedFixed64 = Ht.prototype.zd, Ht.prototype.Ad = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.nb(t, e[r])
        }, Ht.prototype.writeRepeatedFixed64String = Ht.prototype.Ad, Ht.prototype.Jd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.Ra(t, e[r])
        }, Ht.prototype.writeRepeatedSfixed32 = Ht.prototype.Jd, Ht.prototype.Kd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.Sa(t, e[r])
        }, Ht.prototype.writeRepeatedSfixed64 = Ht.prototype.Kd, Ht.prototype.Ld = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.qb(t, e[r])
        }, Ht.prototype.writeRepeatedSfixed64String = Ht.prototype.Ld, Ht.prototype.Cd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.L(t, e[r])
        }, Ht.prototype.writeRepeatedFloat = Ht.prototype.Cd, Ht.prototype.wd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.J(t, e[r])
        }, Ht.prototype.writeRepeatedDouble = Ht.prototype.wd, Ht.prototype.ud = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.I(t, e[r])
        }, Ht.prototype.writeRepeatedBool = Ht.prototype.ud, Ht.prototype.xd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.R(t, e[r])
        }, Ht.prototype.writeRepeatedEnum = Ht.prototype.xd, Ht.prototype.Td = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.U(t, e[r])
        }, Ht.prototype.writeRepeatedString = Ht.prototype.Td, Ht.prototype.vd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.ja(t, e[r])
        }, Ht.prototype.writeRepeatedBytes = Ht.prototype.vd, Ht.prototype.Id = function(t, e, r) {
          if (null != e)
            for (var n = 0; n < e.length; n++) {
              var i = Kt(this, t);
              r(e[n], this), Vt(this, i)
            }
        }, Ht.prototype.writeRepeatedMessage = Ht.prototype.Id, Ht.prototype.Dd = function(t, e, r) {
          if (null != e)
            for (var n = 0; n < e.length; n++) Zt(this, t, 3), r(e[n], this), Zt(this, t, 4)
        }, Ht.prototype.writeRepeatedGroup = Ht.prototype.Dd, Ht.prototype.Bd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.K(t, e[r])
        }, Ht.prototype.writeRepeatedFixedHash64 = Ht.prototype.Bd, Ht.prototype.Yd = function(t, e) {
          if (null != e)
            for (var r = 0; r < e.length; r++) this.N(t, e[r])
        }, Ht.prototype.writeRepeatedVarintHash64 = Ht.prototype.Yd, Ht.prototype.ad = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.M(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedInt32 = Ht.prototype.ad, Ht.prototype.bd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.M(parseInt(e[r], 10));
            Vt(this, t)
          }
        }, Ht.prototype.writePackedInt32String = Ht.prototype.bd, Ht.prototype.cd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.ua(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedInt64 = Ht.prototype.cd, Ht.prototype.md = function(t, e, r, n) {
          if (null != e) {
            t = Kt(this, t);
            for (var i = 0; i < e.length; i++) this.a.A(r(e[i]), n(e[i]));
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSplitFixed64 = Ht.prototype.md, Ht.prototype.nd = function(t, e, r, n) {
          if (null != e) {
            t = Kt(this, t);
            for (var i = 0; i < e.length; i++) this.a.l(r(e[i]), n(e[i]));
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSplitVarint64 = Ht.prototype.nd, Ht.prototype.od = function(t, e, r, n) {
          if (null != e) {
            t = Kt(this, t);
            for (var i = this.a, o = 0; o < e.length; o++) K(r(e[o]), n(e[o]), function(t, e) {
              i.l(t >>> 0, e >>> 0)
            });
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSplitZigzagVarint64 = Ht.prototype.od, Ht.prototype.dd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) {
              var n = zt(e[r]);
              this.a.l(n.lo, n.hi)
            }
            Vt(this, t)
          }
        }, Ht.prototype.writePackedInt64String = Ht.prototype.dd, Ht.prototype.pd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.j(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedUint32 = Ht.prototype.pd, Ht.prototype.qd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.j(parseInt(e[r], 10));
            Vt(this, t)
          }
        }, Ht.prototype.writePackedUint32String = Ht.prototype.qd, Ht.prototype.rd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.va(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedUint64 = Ht.prototype.rd, Ht.prototype.sd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) {
              var n = Ft(e[r]);
              this.a.l(n.lo, n.hi)
            }
            Vt(this, t)
          }
        }, Ht.prototype.writePackedUint64String = Ht.prototype.sd, Ht.prototype.hd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.wa(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSint32 = Ht.prototype.hd, Ht.prototype.jd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.xa(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSint64 = Ht.prototype.jd, Ht.prototype.kd = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.W(et(e[r]));
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSint64String = Ht.prototype.kd, Ht.prototype.ld = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.W(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedSintHash64 = Ht.prototype.ld, Ht.prototype.Wc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(4 * e.length), t = 0; t < e.length; t++) this.a.s(e[t])
        }, Ht.prototype.writePackedFixed32 = Ht.prototype.Wc, Ht.prototype.Xc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) this.a.V(e[t])
        }, Ht.prototype.writePackedFixed64 = Ht.prototype.Xc, Ht.prototype.Yc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) {
              var r = Ft(e[t]);
              this.a.A(r.lo, r.hi)
            }
        }, Ht.prototype.writePackedFixed64String = Ht.prototype.Yc, Ht.prototype.ed = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(4 * e.length), t = 0; t < e.length; t++) this.a.S(e[t])
        }, Ht.prototype.writePackedSfixed32 = Ht.prototype.ed, Ht.prototype.fd = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) this.a.T(e[t])
        }, Ht.prototype.writePackedSfixed64 = Ht.prototype.fd, Ht.prototype.gd = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) this.a.ka(e[t])
        }, Ht.prototype.writePackedSfixed64String = Ht.prototype.gd, Ht.prototype.$c = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(4 * e.length), t = 0; t < e.length; t++) this.a.L(e[t])
        }, Ht.prototype.writePackedFloat = Ht.prototype.$c, Ht.prototype.Uc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) this.a.J(e[t])
        }, Ht.prototype.writePackedDouble = Ht.prototype.Uc, Ht.prototype.Tc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(e.length), t = 0; t < e.length; t++) this.a.I(e[t])
        }, Ht.prototype.writePackedBool = Ht.prototype.Tc, Ht.prototype.Vc = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.R(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedEnum = Ht.prototype.Vc, Ht.prototype.Zc = function(t, e) {
          if (null != e && e.length)
            for (Zt(this, t, 2), this.a.j(8 * e.length), t = 0; t < e.length; t++) this.a.K(e[t])
        }, Ht.prototype.writePackedFixedHash64 = Ht.prototype.Zc, Ht.prototype.td = function(t, e) {
          if (null != e && e.length) {
            t = Kt(this, t);
            for (var r = 0; r < e.length; r++) this.a.N(e[r]);
            Vt(this, t)
          }
        }, Ht.prototype.writePackedVarintHash64 = Ht.prototype.td, e.debug = _t, e.Map = E, e.Message = bt, e.BinaryReader = ct, e.BinaryWriter = Ht, e.ExtensionFieldInfo = dt, e.ExtensionFieldBinaryInfo = pt, e.exportSymbol = function(t, e, r) {
          l(t, e, r)
        }, e.inherits = function(t, e) {
          function r() {}
          r.prototype = e.prototype, t.prototype = new r, t.prototype.constructor = t
        }, e.object = {
          extend: function(t, e) {
            for (var r, n, i = 1; arguments.length > i; i++) {
              for (r in n = arguments[i]) t[r] = n[r];
              for (var o = 0; o < p.length; o++) r = p[o], {}.hasOwnProperty.call(n, r) && (t[r] = n[r])
            }
          }
        }, e.typeOf = h
      },
      65534: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(74772), e), i(r(94107), e), i(r(67295), e), i(r(4641), e), i(r(60027), e), i(r(50496), e), i(r(61461), e), i(r(17233), e), i(r(92443), e), i(r(17773), e), i(r(31352), e), i(r(86910), e), i(r(75069), e), i(r(15354), e), i(r(81009), e), i(r(95255), e), i(r(84965), e), i(r(18941), e), i(r(68486), e), i(r(75353), e)
      },
      65606: t => {
        var e, r, n = t.exports = {};

        function i() {
          throw Error("setTimeout has not been defined")
        }

        function o() {
          throw Error("clearTimeout has not been defined")
        }

        function s(t) {
          if (e === setTimeout) return setTimeout(t, 0);
          if ((e === i || !e) && setTimeout) return e = setTimeout, setTimeout(t, 0);
          try {
            return e(t, 0)
          } catch {
            try {
              return e.call(null, t, 0)
            } catch {
              return e.call(this, t, 0)
            }
          }
        }! function() {
          try {
            e = "function" == typeof setTimeout ? setTimeout : i
          } catch {
            e = i
          }
          try {
            r = "function" == typeof clearTimeout ? clearTimeout : o
          } catch {
            r = o
          }
        }();
        var a, u = [],
          c = !1,
          f = -1;

        function l() {
          !c || !a || (c = !1, a.length ? u = a.concat(u) : f = -1, u.length && h())
        }

        function h() {
          if (!c) {
            var t = s(l);
            c = !0;
            for (var e = u.length; e;) {
              for (a = u, u = []; ++f < e;) a && a[f].run();
              f = -1, e = u.length
            }
            a = null, c = !1,
              function(t) {
                if (r === clearTimeout) return clearTimeout(t);
                if ((r === o || !r) && clearTimeout) return r = clearTimeout, clearTimeout(t);
                try {
                  return r(t)
                } catch {
                  try {
                    return r.call(null, t)
                  } catch {
                    return r.call(this, t)
                  }
                }
              }(t)
          }
        }

        function d(t, e) {
          this.fun = t, this.array = e
        }

        function p() {}
        n.nextTick = function(t) {
          var e = Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var r = 1; arguments.length > r; r++) e[r - 1] = arguments[r];
          u.push(new d(t, e)), 1 === u.length && !c && s(h)
        }, d.prototype.run = function() {
          this.fun.apply(null, this.array)
        }, n.title = "browser", n.browser = !0, n.env = {}, n.argv = [], n.version = "", n.versions = {}, n.on = p, n.addListener = p, n.once = p, n.off = p, n.removeListener = p, n.removeAllListeners = p, n.emit = p, n.prependListener = p, n.prependOnceListener = p, n.listeners = function(t) {
          return []
        }, n.binding = function(t) {
          throw Error("process.binding is not supported")
        }, n.cwd = function() {
          return "/"
        }, n.chdir = function(t) {
          throw Error("process.chdir is not supported")
        }, n.umask = function() {
          return 0
        }
      },
      65871: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Builder = e.beginCell = void 0;
        const n = r(49924),
          i = r(66902),
          o = r(49556);

        function s() {
          return new a
        }
        e.beginCell = s;
        class a {
          constructor() {
            this.Tr = new n.BitBuilder, this.zr = []
          }
          get bits() {
            return this.Tr.length
          }
          get refs() {
            return this.zr.length
          }
          get availableBits() {
            return 1023 - this.bits
          }
          get availableRefs() {
            return 4 - this.refs
          }
          storeBit(t) {
            return this.Tr.writeBit(t), this
          }
          storeBits(t) {
            return this.Tr.writeBits(t), this
          }
          storeBuffer(t, e) {
            if (null != e && t.length !== e) throw Error(`Buffer length ${t.length} is not equal to ${e}`);
            return this.Tr.writeBuffer(t), this
          }
          storeMaybeBuffer(t, e) {
            return null !== t ? (this.storeBit(1), this.storeBuffer(t, e)) : this.storeBit(0), this
          }
          storeUint(t, e) {
            return this.Tr.writeUint(t, e), this
          }
          storeMaybeUint(t, e) {
            return null != t ? (this.storeBit(1), this.storeUint(t, e)) : this.storeBit(0), this
          }
          storeInt(t, e) {
            return this.Tr.writeInt(t, e), this
          }
          storeMaybeInt(t, e) {
            return null != t ? (this.storeBit(1), this.storeInt(t, e)) : this.storeBit(0), this
          }
          storeVarUint(t, e) {
            return this.Tr.writeVarUint(t, e), this
          }
          storeMaybeVarUint(t, e) {
            return null != t ? (this.storeBit(1), this.storeVarUint(t, e)) : this.storeBit(0), this
          }
          storeVarInt(t, e) {
            return this.Tr.writeVarInt(t, e), this
          }
          storeMaybeVarInt(t, e) {
            return null != t ? (this.storeBit(1), this.storeVarInt(t, e)) : this.storeBit(0), this
          }
          storeCoins(t) {
            return this.Tr.writeCoins(t), this
          }
          storeMaybeCoins(t) {
            return null != t ? (this.storeBit(1), this.storeCoins(t)) : this.storeBit(0), this
          }
          storeAddress(t) {
            return this.Tr.writeAddress(t), this
          }
          storeRef(t) {
            if (this.zr.length >= 4) throw Error("Too many references");
            if (t instanceof i.Cell) this.zr.push(t);
            else {
              if (!(t instanceof a)) throw Error("Invalid argument");
              this.zr.push(t.endCell())
            }
            return this
          }
          storeMaybeRef(t) {
            return t ? (this.storeBit(1), this.storeRef(t)) : this.storeBit(0), this
          }
          storeSlice(t) {
            let e = t.clone();
            for (e.remainingBits > 0 && this.storeBits(e.loadBits(e.remainingBits)); e.remainingRefs > 0;) this.storeRef(e.loadRef());
            return this
          }
          storeMaybeSlice(t) {
            return t ? (this.storeBit(1), this.storeSlice(t)) : this.storeBit(0), this
          }
          storeBuilder(t) {
            return this.storeSlice(t.endCell().beginParse())
          }
          storeMaybeBuilder(t) {
            return t ? (this.storeBit(1), this.storeBuilder(t)) : this.storeBit(0), this
          }
          storeWritable(t) {
            return "object" == typeof t ? t.writeTo(this) : t(this), this
          }
          storeMaybeWritable(t) {
            return t ? (this.storeBit(1), this.storeWritable(t)) : this.storeBit(0), this
          }
          store(t) {
            return this.storeWritable(t), this
          }
          storeStringTail(t) {
            return (0, o.writeString)(t, this), this
          }
          storeMaybeStringTail(t) {
            return null != t ? (this.storeBit(1), (0, o.writeString)(t, this)) : this.storeBit(0), this
          }
          storeStringRefTail(t) {
            return this.storeRef(s().storeStringTail(t)), this
          }
          storeMaybeStringRefTail(t) {
            return null != t ? (this.storeBit(1), this.storeStringRefTail(t)) : this.storeBit(0), this
          }
          storeDict(t, e, r) {
            return t ? t.store(this, e, r) : this.storeBit(0), this
          }
          storeDictDirect(t, e, r) {
            return t.storeDirect(this, e, r), this
          }
          endCell(t) {
            return new i.Cell({
              bits: this.Tr.build(),
              refs: this.zr,
              exotic: t?.exotic
            })
          }
          asCell() {
            return this.endCell()
          }
          asSlice() {
            return this.endCell().beginParse()
          }
        }
        e.Builder = a
      },
      65991: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.pick = e.partial = e.omit = e.lazy = e.dynamic = e.deprecated = e.define = e.assign = void 0;
        const n = r(99067),
          i = r(67792);
        e.assign = function(...t) {
          const e = "type" === t[0]?.type,
            r = t.map(({
              schema: t
            }) => t),
            n = Object.assign({}, ...r);
          return e ? (0, i.type)(n) : (0, i.object)(n)
        }, e.define = function(t, e) {
          return new n.Struct({
            type: t,
            schema: null,
            validator: e
          })
        }, e.deprecated = function(t, e) {
          return new n.Struct({
            ...t,
            refiner: (e, r) => void 0 === e || t.refiner(e, r),
            validator: (r, n) => void 0 === r || (e(r, n), t.validator(r, n))
          })
        }, e.dynamic = function(t) {
          return new n.Struct({
            type: "dynamic",
            schema: null,
            * entries(e, r) {
              yield* t(e, r).entries(e, r)
            },
            validator: (e, r) => t(e, r).validator(e, r),
            coercer: (e, r) => t(e, r).coercer(e, r),
            refiner: (e, r) => t(e, r).refiner(e, r)
          })
        }, e.lazy = function(t) {
          let e;
          return new n.Struct({
            type: "lazy",
            schema: null,
            * entries(r, n) {
              e ?? (e = t()), yield* e.entries(r, n)
            },
            validator: (r, n) => (e ?? (e = t()), e.validator(r, n)),
            coercer: (r, n) => (e ?? (e = t()), e.coercer(r, n)),
            refiner: (r, n) => (e ?? (e = t()), e.refiner(r, n))
          })
        }, e.omit = function(t, e) {
          const {
            schema: r
          } = t, n = {
            ...r
          };
          for (const t of e) delete n[t];
          return "type" === t.type ? (0, i.type)(n) : (0, i.object)(n)
        }, e.partial = function(t) {
          const e = t instanceof n.Struct,
            r = e ? {
              ...t.schema
            } : {
              ...t
            };
          for (const t in r) r[t] = (0, i.optional)(r[t]);
          return e && "type" === t.type ? (0, i.type)(r) : (0, i.object)(r)
        }, e.pick = function(t, e) {
          const {
            schema: r
          } = t, n = {};
          for (const t of e) n[t] = r[t];
          return "type" === t.type ? (0, i.type)(n) : (0, i.object)(n)
        }
      },
      66169: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
          (0, i.default)(t);
          var r = e.strictSeparator ? s.test(t) : o.test(t);
          return r && e.strict ? a(t) : r
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,
          s = /^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T]((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,
          a = function(t) {
            var e = t.match(/^(\d{4})-?(\d{3})([ T]{1}\.*|$)/);
            if (e) {
              var r = +e[1],
                n = +e[2];
              return r % 4 == 0 && r % 100 != 0 || r % 400 == 0 ? 366 >= n : 365 >= n
            }
            var i = t.match(/(\d{4})-?(\d{0,2})-?(\d*)/).map(Number),
              o = i[1],
              s = i[2],
              a = i[3],
              u = s && "0".concat(s).slice(-2),
              c = a && "0".concat(a).slice(-2),
              f = new Date("".concat(o, "-").concat(u || "01", "-").concat(c || "01"));
            return !s || !a || f.getUTCFullYear() === o && f.getUTCMonth() + 1 === s && f.getUTCDate() === a
          };
        t.exports = e.default, t.exports.default = e.default
      },
      66289: (t, e) => {
        "use strict";

        function r(t) {
          if (Array.isArray(t)) {
            const e = [];
            let n = 0;
            for (let i = 0; i < t.length; i++) {
              const o = r(t[i]);
              e.push(o), n += o.length
            }
            return h(o(n, 192), ...e)
          }
          const e = m(t);
          return 1 === e.length && 128 > e[0] ? e : h(o(e.length, 128), e)
        }

        function n(t, e, r) {
          if (r > t.length) throw Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
          return t.slice(e, r)
        }

        function i(t) {
          if (0 === t[0]) throw Error("invalid RLP: extra zeros");
          return f(c(t))
        }

        function o(t, e) {
          if (56 > t) return Uint8Array.from([t + e]);
          const r = p(t),
            n = p(e + 55 + r.length / 2);
          return Uint8Array.from(l(n + r))
        }

        function s(t, e = !1) {
          if (typeof t > "u" || null === t || 0 === t.length) return Uint8Array.from([]);
          const r = a(m(t));
          if (e) return r;
          if (0 !== r.remainder.length) throw Error("invalid RLP: remainder must be zero");
          return r.data
        }

        function a(t) {
          let e, r, o, s, u;
          const c = [],
            f = t[0];
          if (127 >= f) return {
            data: t.slice(0, 1),
            remainder: t.slice(1)
          };
          if (f > 183) {
            if (f > 191) {
              if (f > 247) {
                if (r = f - 246, e = i(n(t, 1, r)), 56 > e) throw Error("invalid RLP: encoded list too short");
                const o = r + e;
                if (o > t.length) throw Error("invalid RLP: total length is larger than the data");
                for (s = n(t, r, o); s.length;) u = a(s), c.push(u.data), s = u.remainder;
                return {
                  data: c,
                  remainder: t.slice(o)
                }
              }
              for (e = f - 191, s = n(t, 1, e); s.length;) u = a(s), c.push(u.data), s = u.remainder;
              return {
                data: c,
                remainder: t.slice(e)
              }
            }
            if (r = f - 182, t.length - 1 < r) throw Error("invalid RLP: not enough bytes for string length");
            if (e = i(n(t, 1, r)), 55 >= e) throw Error("invalid RLP: expected string length to be greater than 55");
            return o = n(t, r, e + r), {
              data: o,
              remainder: t.slice(e + r)
            }
          }
          if (e = f - 127, o = 128 === f ? Uint8Array.from([]) : n(t, 1, e), 2 === e && 128 > o[0]) throw Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
          return {
            data: o,
            remainder: t.slice(e)
          }
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.RLP = e.utils = e.decode = e.encode = void 0, e.encode = r, e.decode = s;
        const u = Array.from({
          length: 256
        }, (t, e) => e.toString(16).padStart(2, "0"));

        function c(t) {
          let e = "";
          for (let r = 0; r < t.length; r++) e += u[t[r]];
          return e
        }

        function f(t) {
          const e = Number.parseInt(t, 16);
          if (Number.isNaN(e)) throw Error("Invalid byte sequence");
          return e
        }

        function l(t) {
          if ("string" != typeof t) throw new TypeError("hexToBytes: expected string, got " + typeof t);
          if (t.length % 2) throw Error("hexToBytes: received invalid unpadded hex");
          const e = new Uint8Array(t.length / 2);
          for (let r = 0; r < e.length; r++) {
            const n = 2 * r;
            e[r] = f(t.slice(n, n + 2))
          }
          return e
        }

        function h(...t) {
          if (1 === t.length) return t[0];
          const e = t.reduce((t, e) => t + e.length, 0),
            r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), n += i.length
          }
          return r
        }

        function d(t) {
          return (new TextEncoder).encode(t)
        }

        function p(t) {
          if (0 > t) throw Error("Invalid integer as argument, must be unsigned!");
          const e = t.toString(16);
          return e.length % 2 ? "0" + e : e
        }

        function b(t) {
          return t.length >= 2 && "0" === t[0] && "x" === t[1]
        }

        function m(t) {
          if (t instanceof Uint8Array) return t;
          if ("string" == typeof t) return b(t) ? l(function(t) {
            return t.length % 2 ? "0" + t : t
          }(function(t) {
            return "string" != typeof t ? t : b(t) ? t.slice(2) : t
          }(t))) : d(t);
          if ("number" == typeof t || "bigint" == typeof t) return t ? l(p(t)) : Uint8Array.from([]);
          if (null == t) return Uint8Array.from([]);
          throw Error("toBytes: received unsupported type " + typeof t)
        }
        e.utils = {
          bytesToHex: c,
          concatBytes: h,
          hexToBytes: l,
          utf8ToBytes: d
        }, e.RLP = {
          encode: r,
          decode: s
        }
      },
      66408: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.loadWalletIdV5Beta = function(t) {
          const e = new i.BitReader(new i.BitString("bigint" == typeof t ? n.from(t.toString(16), "hex") : t instanceof i.Slice ? t.loadBuffer(10) : t, 0, 80)),
            r = e.loadInt(32),
            s = e.loadInt(8),
            a = e.loadUint(8),
            u = e.loadUint(32),
            c = Object.entries(o).find(([t, e]) => e === a)?.[0];
          if (void 0 === c) throw Error("Can't deserialize walletId: unknown wallet version " + a);
          return {
            networkGlobalId: r,
            workchain: s,
            walletVersion: c,
            subwalletNumber: u
          }
        }, e.storeWalletIdV5Beta = function(t) {
          return e => {
            e.storeInt(t.networkGlobalId, 32), e.storeInt(t.workchain, 8), e.storeUint(o[t.walletVersion], 8), e.storeUint(t.subwalletNumber, 32)
          }
        };
        const i = r(1307),
          o = {
            v5: 0
          }
      },
      66529: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US",
            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          (0, i.default)(t);
          var n = t,
            s = r.ignore;
          if (s)
            if (s instanceof RegExp) n = n.replace(s, "");
            else {
              if ("string" != typeof s) throw Error("ignore should be instance of a String or RegExp");
              n = n.replace(RegExp("[".concat(s.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "")
            } if (e in o.alpha) return o.alpha[e].test(n);
          throw Error("Invalid locale '".concat(e, "'"))
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(13237),
          s = Object.keys(o.alpha);
        e.locales = s
      },
      66658: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : new Date + "";
          (0, n.default)(t);
          var r = (0, i.default)(e),
            o = (0, i.default)(t);
          return !!(o && r && r > o)
        };
        var n = o(r(83399)),
          i = o(r(13752));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        t.exports = e.default, t.exports.default = e.default
      },
      66743: (t, e, r) => {
        "use strict";
        var n = r(89353);
        t.exports = function() {}.bind || n
      },
      66902: function(t, e, r) {
        "use strict";
        var n, i = r(48287).Buffer,
          o = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Cell = void 0;
        const s = o(r(29107)),
          a = r(62386),
          u = r(34654),
          c = r(56906),
          f = r(52231),
          l = r(52938),
          h = r(65229),
          d = r(53528),
          p = r(65871);
        class b {
          static fromBoc(t) {
            return (0, h.deserializeBoc)(t)
          }
          static fromBase64(t) {
            let e = b.fromBoc(i.from(t, "base64"));
            if (1 !== e.length) throw Error("Deserialized more than one cell");
            return e[0]
          }
          static fromHex(t) {
            let e = b.fromBoc(i.from(t, "hex"));
            if (1 !== e.length) throw Error("Deserialized more than one cell");
            return e[0]
          }
          constructor(t) {
            this.Xr = [], this.tn = [], this.beginParse = (t = !1) => {
              if (this.isExotic && !t) throw Error("Exotic cells cannot be parsed");
              return new c.Slice(new d.BitReader(this.bits), this.refs)
            }, this.hash = (t = 3) => this.Xr[Math.min(this.Xr.length - 1, t)], this.depth = (t = 3) => this.tn[Math.min(this.tn.length - 1, t)], this.level = () => this.mask.level, this.equals = t => this.hash().equals(t.hash()), this[n] = () => this.toString();
            let e = a.BitString.EMPTY;
            t && t.bits && (e = t.bits);
            let r = [];
            t && t.refs && (r = [...t.refs]);
            let i, o, s, h = u.CellType.Ordinary;
            if (t && t.exotic) {
              let t = (0, f.resolveExotic)(e, r),
                n = (0, l.wonderCalculator)(t.type, e, r);
              s = n.mask, o = n.depths, i = n.hashes, h = t.type
            } else {
              if (r.length > 4) throw Error("Invalid number of references");
              if (e.length > 1023) throw Error(`Bits overflow: ${e.length} > 1023`);
              let t = (0, l.wonderCalculator)(u.CellType.Ordinary, e, r);
              s = t.mask, o = t.depths, i = t.hashes, h = u.CellType.Ordinary
            }
            this.type = h, this.bits = e, this.refs = r, this.mask = s, this.tn = o, this.Xr = i, Object.freeze(this), Object.freeze(this.refs), Object.freeze(this.bits), Object.freeze(this.mask), Object.freeze(this.tn), Object.freeze(this.Xr)
          }
          get isExotic() {
            return this.type !== u.CellType.Ordinary
          }
          toBoc(t) {
            let e = !(!t || null === t.idx || void 0 === t.idx) && t.idx,
              r = !t || null === t.crc32 || void 0 === t.crc32 || t.crc32;
            return (0, h.serializeBoc)(this, {
              idx: e,
              crc32: r
            })
          }
          toString(t) {
            let e = t || "",
              r = "x";
            this.isExotic && (this.type === u.CellType.MerkleProof ? r = "p" : this.type === u.CellType.MerkleUpdate ? r = "u" : this.type === u.CellType.PrunedBranch && (r = "p"));
            let n = e + (this.isExotic ? r : "x") + "{" + this.bits.toString() + "}";
            for (let t in this.refs) n += "\n" + this.refs[t].toString(e + " ");
            return n
          }
          asSlice() {
            return this.beginParse()
          }
          asBuilder() {
            return (0, p.beginCell)().storeSlice(this.asSlice())
          }
        }
        e.Cell = b, n = s.default, b.EMPTY = new b
      },
      67295: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.createDataView = e.concatBytes = e.valueToBytes = e.base64ToBytes = e.stringToBytes = e.numberToBytes = e.signedBigIntToBytes = e.bigIntToBytes = e.hexToBytes = e.bytesToBase64 = e.bytesToString = e.bytesToNumber = e.bytesToSignedBigInt = e.bytesToBigInt = e.bytesToHex = e.assertIsBytes = e.isBytes = void 0;
        const i = r(63203),
          o = r(74772),
          s = r(17773),
          a = function() {
            const t = [];
            return () => {
              if (0 === t.length)
                for (let e = 0; 256 > e; e++) t.push(e.toString(16).padStart(2, "0"));
              return t
            }
          }();

        function u(t) {
          return t instanceof Uint8Array
        }

        function c(t) {
          (0, o.assert)(u(t), "Value must be a Uint8Array.")
        }

        function f(t) {
          if (c(t), 0 === t.length) return "0x";
          const e = a(),
            r = Array(t.length);
          for (let n = 0; n < t.length; n++) r[n] = e[t[n]];
          return (0, s.add0x)(r.join(""))
        }

        function l(t) {
          c(t);
          const e = f(t);
          return BigInt(e)
        }

        function h(t) {
          if ("0x" === t?.toLowerCase?.()) return new Uint8Array;
          (0, s.assertIsHexString)(t);
          const e = (0, s.remove0x)(t).toLowerCase(),
            r = e.length % 2 == 0 ? e : "0" + e,
            n = new Uint8Array(r.length / 2);
          for (let t = 0; t < n.length; t++) {
            const e = r.charCodeAt(2 * t),
              i = r.charCodeAt(2 * t + 1),
              o = e - (58 > e ? 48 : 87),
              s = i - (58 > i ? 48 : 87);
            n[t] = 16 * o + s
          }
          return n
        }

        function d(t) {
          return (0, o.assert)("bigint" == typeof t, "Value must be a bigint."), (0, o.assert)(t >= BigInt(0), "Value must be a non-negative bigint."), h(t.toString(16))
        }

        function p(t) {
          return (0, o.assert)("number" == typeof t, "Value must be a number."), (0, o.assert)(t >= 0, "Value must be a non-negative number."), (0, o.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `bigIntToBytes` instead."), h(t.toString(16))
        }

        function b(t) {
          return (0, o.assert)("string" == typeof t, "Value must be a string."), (new TextEncoder).encode(t)
        }

        function m(t) {
          if ("bigint" == typeof t) return d(t);
          if ("number" == typeof t) return p(t);
          if ("string" == typeof t) return t.startsWith("0x") ? h(t) : b(t);
          if (u(t)) return t;
          throw new TypeError(`Unsupported value type: "${typeof t}".`)
        }
        e.isBytes = u, e.assertIsBytes = c, e.bytesToHex = f, e.bytesToBigInt = l, e.bytesToSignedBigInt = function(t) {
          c(t);
          let e = BigInt(0);
          for (const r of t) e = (e << BigInt(8)) + BigInt(r);
          return BigInt.asIntN(8 * t.length, e)
        }, e.bytesToNumber = function(t) {
          c(t);
          const e = l(t);
          return (0, o.assert)(e <= BigInt(Number.MAX_SAFE_INTEGER), "Number is not a safe integer. Use `bytesToBigInt` instead."), +e
        }, e.bytesToString = function(t) {
          return c(t), (new TextDecoder).decode(t)
        }, e.bytesToBase64 = function(t) {
          return c(t), i.base64.encode(t)
        }, e.hexToBytes = h, e.bigIntToBytes = d, e.signedBigIntToBytes = function(t, e) {
          (0, o.assert)("bigint" == typeof t, "Value must be a bigint."), (0, o.assert)("number" == typeof e, "Byte length must be a number."), (0, o.assert)(e > 0, "Byte length must be greater than 0."), (0, o.assert)(function(t, e) {
            (0, o.assert)(e > 0);
            const r = t >> BigInt(31);
            return !((~t & r) + (t & ~r) >> BigInt(8 * e - 1))
          }(t, e), "Byte length is too small to represent the given value.");
          let r = t;
          const n = new Uint8Array(e);
          for (let t = 0; t < n.length; t++) n[t] = +BigInt.asUintN(8, r), r >>= BigInt(8);
          return n.reverse()
        }, e.numberToBytes = p, e.stringToBytes = b, e.base64ToBytes = function(t) {
          return (0, o.assert)("string" == typeof t, "Value must be a string."), i.base64.decode(t)
        }, e.valueToBytes = m, e.concatBytes = function(t) {
          const e = Array(t.length);
          let r = 0;
          for (let n = 0; n < t.length; n++) {
            const i = m(t[n]);
            e[n] = i, r += i.length
          }
          const n = new Uint8Array(r);
          for (let t = 0, r = 0; t < e.length; t++) n.set(e[t], r), r += e[t].length;
          return n
        }, e.createDataView = function(t) {
          if ("u" > typeof n && t instanceof n) {
            const e = t.buffer.slice(t.byteOffset, t.byteOffset + t.byteLength);
            return new DataView(e)
          }
          return new DataView(t.buffer, t.byteOffset, t.byteLength)
        }
      },
      67526: (t, e) => {
        "use strict";
        e.byteLength = function(t) {
          var e = a(t),
            r = e[0],
            n = e[1];
          return 3 * (r + n) / 4 - n
        }, e.toByteArray = function(t) {
          var e, r, o = a(t),
            s = o[0],
            u = o[1],
            c = new i(function(t, e, r) {
              return 3 * (e + r) / 4 - r
            }(0, s, u)),
            f = 0,
            l = u > 0 ? s - 4 : s;
          for (r = 0; l > r; r += 4) e = n[t.charCodeAt(r)] << 18 | n[t.charCodeAt(r + 1)] << 12 | n[t.charCodeAt(r + 2)] << 6 | n[t.charCodeAt(r + 3)], c[f++] = e >> 16 & 255, c[f++] = e >> 8 & 255, c[f++] = 255 & e;
          return 2 === u && (e = n[t.charCodeAt(r)] << 2 | n[t.charCodeAt(r + 1)] >> 4, c[f++] = 255 & e), 1 === u && (e = n[t.charCodeAt(r)] << 10 | n[t.charCodeAt(r + 1)] << 4 | n[t.charCodeAt(r + 2)] >> 2, c[f++] = e >> 8 & 255, c[f++] = 255 & e), c
        }, e.fromByteArray = function(t) {
          for (var e, n = t.length, i = n % 3, o = [], s = 16383, a = 0, u = n - i; u > a; a += s) o.push(c(t, a, a + s > u ? u : a + s));
          return 1 === i ? (e = t[n - 1], o.push(r[e >> 2] + r[e << 4 & 63] + "==")) : 2 === i && (e = (t[n - 2] << 8) + t[n - 1], o.push(r[e >> 10] + r[e >> 4 & 63] + r[e << 2 & 63] + "=")), o.join("")
        };
        for (var r = [], n = [], i = "u" > typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; 64 > s; ++s) r[s] = o[s], n[o.charCodeAt(s)] = s;

        function a(t) {
          var e = t.length;
          if (e % 4 > 0) throw Error("Invalid string. Length must be a multiple of 4");
          var r = t.indexOf("=");
          return -1 === r && (r = e), [r, r === e ? 0 : 4 - r % 4]
        }

        function u(t) {
          return r[t >> 18 & 63] + r[t >> 12 & 63] + r[t >> 6 & 63] + r[63 & t]
        }

        function c(t, e, r) {
          for (var n, i = [], o = e; r > o; o += 3) n = (t[o] << 16 & 16711680) + (t[o + 1] << 8 & 65280) + (255 & t[o + 2]), i.push(u(n));
          return i.join("")
        }
        n[45] = 62, n[95] = 63
      },
      67694: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.encodeToCurve = e.hashToCurve = e.schnorr = e.secp256k1 = void 0;
        const n = r(143),
          i = r(17412),
          o = r(40714),
          s = r(81761),
          a = r(89015),
          u = r(19372),
          c = r(20489),
          f = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
          l = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
          h = BigInt(1),
          d = BigInt(2),
          p = (t, e) => (t + e / d) / e;

        function b(t) {
          const e = f,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            u = BigInt(44),
            c = BigInt(88),
            l = t * t * t % e,
            h = l * l * t % e,
            p = (0, a.pow2)(h, r, e) * h % e,
            b = (0, a.pow2)(p, r, e) * h % e,
            y = (0, a.pow2)(b, d, e) * l % e,
            g = (0, a.pow2)(y, i, e) * y % e,
            v = (0, a.pow2)(g, o, e) * g % e,
            w = (0, a.pow2)(v, u, e) * v % e,
            A = (0, a.pow2)(w, c, e) * w % e,
            T = (0, a.pow2)(A, u, e) * v % e,
            E = (0, a.pow2)(T, r, e) * h % e,
            P = (0, a.pow2)(E, s, e) * g % e,
            k = (0, a.pow2)(P, n, e) * l % e,
            x = (0, a.pow2)(k, d, e);
          if (!m.eql(m.sqr(x), t)) throw Error("Cannot find square root");
          return x
        }
        const m = (0, a.Field)(f, void 0, void 0, {
          sqrt: b
        });
        e.secp256k1 = (0, o.createCurve)({
          a: BigInt(0),
          b: BigInt(7),
          Fp: m,
          n: l,
          Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
          Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
          h: BigInt(1),
          lowS: !0,
          endo: {
            beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
            splitScalar: t => {
              const e = l,
                r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
                n = -h * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
                i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
                o = r,
                s = BigInt("0x100000000000000000000000000000000"),
                u = p(o * t, e),
                c = p(-n * t, e);
              let f = (0, a.mod)(t - u * r - c * i, e),
                d = (0, a.mod)(-u * n - c * o, e);
              const b = f > s,
                m = d > s;
              if (b && (f = e - f), m && (d = e - d), f > s || d > s) throw Error("splitScalar: Endomorphism failed, k=" + t);
              return {
                k1neg: b,
                k1: f,
                k2neg: m,
                k2: d
              }
            }
          }
        }, n.sha256);
        const y = BigInt(0),
          g = t => "bigint" == typeof t && t > y && f > t,
          v = {};

        function w(t, ...e) {
          let r = v[t];
          if (void 0 === r) {
            const e = (0, n.sha256)(Uint8Array.from(t, t => t.charCodeAt(0)));
            r = (0, u.concatBytes)(e, e), v[t] = r
          }
          return (0, n.sha256)((0, u.concatBytes)(r, ...e))
        }
        const A = t => t.toRawBytes(!0).slice(1),
          T = t => (0, u.numberToBytesBE)(t, 32),
          E = t => (0, a.mod)(t, f),
          P = t => (0, a.mod)(t, l),
          k = e.secp256k1.ProjectivePoint;

        function x(t) {
          let r = e.secp256k1.utils.normPrivateKeyToScalar(t),
            n = k.fromPrivateKey(r);
          return {
            scalar: n.hasEvenY() ? r : P(-r),
            bytes: A(n)
          }
        }

        function I(t) {
          if (!g(t)) throw Error("bad x: need 0 < x < p");
          const e = E(t * t);
          let r = b(E(e * t + BigInt(7)));
          r % d !== y && (r = E(-r));
          const n = new k(t, r, h);
          return n.assertValidity(), n
        }

        function S(...t) {
          return P((0, u.bytesToNumberBE)(w("BIP0340/challenge", ...t)))
        }

        function O(t, e, r) {
          const n = (0, u.ensureBytes)("signature", t, 64),
            i = (0, u.ensureBytes)("message", e),
            o = (0, u.ensureBytes)("publicKey", r, 32);
          try {
            const t = I((0, u.bytesToNumberBE)(o)),
              e = (0, u.bytesToNumberBE)(n.subarray(0, 32));
            if (!g(e)) return !1;
            const r = (0, u.bytesToNumberBE)(n.subarray(32, 64));
            if (!(t => "bigint" == typeof t && t > y && l > t)(r)) return !1;
            const s = S(T(e), A(t), i),
              a = ((t, e, r) => k.BASE.multiplyAndAddUnsafe(t, e, r))(t, r, P(-s));
            return !(!a || !a.hasEvenY() || a.toAffine().x !== e)
          } catch {
            return !1
          }
        }
        e.schnorr = {
          getPublicKey: function(t) {
            return x(t).bytes
          },
          sign: function(t, e, r = (0, i.randomBytes)(32)) {
            const n = (0, u.ensureBytes)("message", t),
              {
                bytes: o,
                scalar: s
              } = x(e),
              a = (0, u.ensureBytes)("auxRand", r, 32),
              c = T(s ^ (0, u.bytesToNumberBE)(w("BIP0340/aux", a))),
              f = w("BIP0340/nonce", c, o, n),
              l = P((0, u.bytesToNumberBE)(f));
            if (l === y) throw Error("sign failed: k is zero");
            const {
              bytes: h,
              scalar: d
            } = x(l), p = S(h, o, n), b = new Uint8Array(64);
            if (b.set(h, 0), b.set(T(P(d + p * s)), 32), !O(b, n, o)) throw Error("sign: Invalid signature produced");
            return b
          },
          verify: O,
          utils: {
            randomPrivateKey: e.secp256k1.utils.randomPrivateKey,
            lift_x: I,
            pointToBytes: A,
            numberToBytesBE: u.numberToBytesBE,
            bytesToNumberBE: u.bytesToNumberBE,
            taggedHash: w,
            mod: a.mod
          }
        };
        const B = (0, s.isogenyMap)(m, [
            ["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7", "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581", "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262", "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],
            ["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b", "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14", "0x0000000000000000000000000000000000000000000000000000000000000001"],
            ["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c", "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3", "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931", "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],
            ["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b", "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573", "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f", "0x0000000000000000000000000000000000000000000000000000000000000001"]
          ].map(t => t.map(t => BigInt(t)))),
          W = (0, c.mapToCurveSimpleSWU)(m, {
            A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
            B: BigInt("1771"),
            Z: m.create(BigInt("-11"))
          }),
          M = (0, s.createHasher)(e.secp256k1.ProjectivePoint, t => {
            const {
              x: e,
              y: r
            } = W(m.create(t[0]));
            return B(e, r)
          }, {
            DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
            encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
            p: m.ORDER,
            m: 1,
            k: 128,
            expand: "xmd",
            hash: n.sha256
          });
        e.hashToCurve = M.hashToCurve, e.encodeToCurve = M.encodeToCurve
      },
      67775: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.decodeSingle = e.decode = e.encodePacked = e.encodeSingle = e.encode = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(34175);
        e.encode = (t, e, r, n) => {
          try {
            return (0, o.pack)({
              types: t,
              values: e,
              packed: r,
              tight: n
            })
          } catch (t) {
            throw t instanceof i.ParserError ? new i.ParserError("Unable to encode value: " + t.message, t) : new i.ParserError("An unexpected error occurred: " + (0, i.getErrorMessage)(t), t)
          }
        }, e.encodeSingle = (t, r) => (0, e.encode)([t], [r]), e.encodePacked = (t, r, n) => (0, e.encode)(t, r, !0, n), e.decode = (t, e) => {
          const r = (0, n.createBytes)(e);
          try {
            return (0, o.unpack)(t, r)
          } catch (t) {
            throw t instanceof i.ParserError ? new i.ParserError("Unable to decode value: " + t.message, t) : new i.ParserError("An unexpected error occurred: " + (0, i.getErrorMessage)(t), t)
          }
        }, e.decodeSingle = (t, r) => {
          const o = (0, e.decode)([t], r);
          return (0, n.assert)(1 === o.length, new i.ParserError("Decoded value array has unexpected length.")), o[0]
        }
      },
      67792: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.unknown = e.union = e.type = e.tuple = e.string = e.set = e.regexp = e.record = e.exactOptional = e.optional = e.object = e.number = e.nullable = e.never = e.map = e.literal = e.intersection = e.integer = e.instance = e.func = e.enums = e.date = e.boolean = e.bigint = e.array = e.any = void 0;
        const n = r(99067),
          i = r(70639),
          o = r(65991);

        function s() {
          return (0, o.define)("never", () => !1)
        }
        e.any = function() {
          return (0, o.define)("any", () => !0)
        }, e.array = function(t) {
          return new n.Struct({
            type: "array",
            schema: t,
            * entries(e) {
              if (t && Array.isArray(e))
                for (const [r, n] of e.entries()) yield [r, n, t]
            },
            coercer: t => Array.isArray(t) ? t.slice() : t,
            validator: t => Array.isArray(t) || "Expected an array value, but received: " + (0, i.print)(t)
          })
        }, e.bigint = function() {
          return (0, o.define)("bigint", t => "bigint" == typeof t)
        }, e.boolean = function() {
          return (0, o.define)("boolean", t => "boolean" == typeof t)
        }, e.date = function() {
          return (0, o.define)("date", t => t instanceof Date && !isNaN(t.getTime()) || "Expected a valid `Date` object, but received: " + (0, i.print)(t))
        }, e.enums = function(t) {
          const e = {},
            r = t.map(t => (0, i.print)(t)).join();
          for (const r of t) e[r] = r;
          return new n.Struct({
            type: "enums",
            schema: e,
            validator: e => t.includes(e) || `Expected one of \`${r}\`, but received: ${(0,i.print)(e)}`
          })
        }, e.func = function() {
          return (0, o.define)("func", t => "function" == typeof t || "Expected a function, but received: " + (0, i.print)(t))
        }, e.instance = function(t) {
          return (0, o.define)("instance", e => e instanceof t || `Expected a \`${t.name}\` instance, but received: ${(0,i.print)(e)}`)
        }, e.integer = function() {
          return (0, o.define)("integer", t => "number" == typeof t && !isNaN(t) && Number.isInteger(t) || "Expected an integer, but received: " + (0, i.print)(t))
        }, e.intersection = function(t) {
          return new n.Struct({
            type: "intersection",
            schema: null,
            * entries(e, r) {
              for (const {
                  entries: n
                }
                of t) yield* n(e, r)
            },
            * validator(e, r) {
              for (const {
                  validator: n
                }
                of t) yield* n(e, r)
            },
            * refiner(e, r) {
              for (const {
                  refiner: n
                }
                of t) yield* n(e, r)
            }
          })
        }, e.literal = function(t) {
          const e = (0, i.print)(t),
            r = typeof t;
          return new n.Struct({
            type: "literal",
            schema: "string" === r || "number" === r || "boolean" === r ? t : null,
            validator: r => r === t || `Expected the literal \`${e}\`, but received: ${(0,i.print)(r)}`
          })
        }, e.map = function(t, e) {
          return new n.Struct({
            type: "map",
            schema: null,
            * entries(r) {
              if (t && e && r instanceof Map)
                for (const [n, i] of r.entries()) yield [n, n, t], yield [n, i, e]
            },
            coercer: t => t instanceof Map ? new Map(t) : t,
            validator: t => t instanceof Map || "Expected a `Map` object, but received: " + (0, i.print)(t)
          })
        }, e.never = s, e.nullable = function(t) {
          return new n.Struct({
            ...t,
            validator: (e, r) => null === e || t.validator(e, r),
            refiner: (e, r) => null === e || t.refiner(e, r)
          })
        }, e.number = function() {
          return (0, o.define)("number", t => "number" == typeof t && !isNaN(t) || "Expected a number, but received: " + (0, i.print)(t))
        }, e.object = function(t) {
          const e = t ? Object.keys(t) : [],
            r = s();
          return new n.Struct({
            type: "object",
            schema: t ?? null,
            * entries(o) {
              if (t && (0, i.isObject)(o)) {
                const i = new Set(Object.keys(o));
                for (const r of e) {
                  i.delete(r);
                  const e = t[r];
                  n.ExactOptionalStruct.isExactOptional(e) && !{}.hasOwnProperty.call(o, r) || (yield [r, o[r], t[r]])
                }
                for (const t of i) yield [t, o[t], r]
              }
            },
            validator: t => (0, i.isObject)(t) || "Expected an object, but received: " + (0, i.print)(t),
            coercer: t => (0, i.isObject)(t) ? {
              ...t
            } : t
          })
        }, e.optional = function(t) {
          return new n.Struct({
            ...t,
            validator: (e, r) => void 0 === e || t.validator(e, r),
            refiner: (e, r) => void 0 === e || t.refiner(e, r)
          })
        }, e.exactOptional = function(t) {
          return new n.ExactOptionalStruct(t)
        }, e.record = function(t, e) {
          return new n.Struct({
            type: "record",
            schema: null,
            * entries(r) {
              if ((0, i.isObject)(r))
                for (const n in r) {
                  const i = r[n];
                  yield [n, n, t], yield [n, i, e]
                }
            },
            validator: t => (0, i.isObject)(t) || "Expected an object, but received: " + (0, i.print)(t)
          })
        }, e.regexp = function() {
          return (0, o.define)("regexp", t => t instanceof RegExp)
        }, e.set = function(t) {
          return new n.Struct({
            type: "set",
            schema: null,
            * entries(e) {
              if (t && e instanceof Set)
                for (const r of e) yield [r, r, t]
            },
            coercer: t => t instanceof Set ? new Set(t) : t,
            validator: t => t instanceof Set || "Expected a `Set` object, but received: " + (0, i.print)(t)
          })
        }, e.string = function() {
          return (0, o.define)("string", t => "string" == typeof t || "Expected a string, but received: " + (0, i.print)(t))
        }, e.tuple = function(t) {
          const e = s();
          return new n.Struct({
            type: "tuple",
            schema: null,
            * entries(r) {
              if (Array.isArray(r)) {
                const n = Math.max(t.length, r.length);
                for (let i = 0; n > i; i++) yield [i, r[i], t[i] || e]
              }
            },
            validator: t => Array.isArray(t) || "Expected an array, but received: " + (0, i.print)(t)
          })
        }, e.type = function(t) {
          const e = Object.keys(t);
          return new n.Struct({
            type: "type",
            schema: t,
            * entries(r) {
              if ((0, i.isObject)(r))
                for (const n of e) yield [n, r[n], t[n]]
            },
            validator: t => (0, i.isObject)(t) || "Expected an object, but received: " + (0, i.print)(t),
            coercer: t => (0, i.isObject)(t) ? {
              ...t
            } : t
          })
        }, e.union = function(t) {
          const e = t.map(t => t.type).join(" | ");
          return new n.Struct({
            type: "union",
            schema: null,
            coercer(e) {
              for (const r of t) {
                const [t, n] = r.validate(e, {
                  coerce: !0
                });
                if (!t) return n
              }
              return e
            },
            validator(r, n) {
              const o = [];
              for (const e of t) {
                const [...t] = (0, i.run)(r, e, n), [s] = t;
                if (!s?.[0]) return [];
                for (const [e] of t) e && o.push(e)
              }
              return [`Expected the value to satisfy a union of \`${e}\`, but received: ${(0,i.print)(r)}`, ...o]
            }
          })
        }, e.unknown = function() {
          return (0, o.define)("unknown", () => !0)
        }
      },
      68002: t => {
        "use strict";
        t.exports = Math.min
      },
      68343: function(t) {
        t.exports = function() {
          "use strict";
          var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

          function e(t, e, r, n) {
            var i, o, s, a = e || [0],
              u = (r = r || 0) >>> 3,
              c = -1 === n ? 3 : 0;
            for (i = 0; i < t.length; i += 1) o = (s = i + u) >>> 2, a.length <= o && a.push(0), a[o] |= t[i] << 8 * (c + n * (s % 4));
            return {
              value: a,
              binLen: 8 * t.length + r
            }
          }

          function r(r, n, i) {
            switch (n) {
              case "UTF8":
              case "UTF16BE":
              case "UTF16LE":
                break;
              default:
                throw Error("encoding must be UTF8, UTF16BE, or UTF16LE")
            }
            switch (r) {
              case "HEX":
                return function(t, e, r) {
                  return function(t, e, r, n) {
                    var i, o, s, a;
                    if (t.length % 2 != 0) throw Error("String of HEX type must be in byte increments");
                    var u = e || [0],
                      c = (r = r || 0) >>> 3,
                      f = -1 === n ? 3 : 0;
                    for (i = 0; i < t.length; i += 2) {
                      if (o = parseInt(t.substr(i, 2), 16), isNaN(o)) throw Error("String of HEX type contains invalid characters");
                      for (s = (a = (i >>> 1) + c) >>> 2; u.length <= s;) u.push(0);
                      u[s] |= o << 8 * (f + n * (a % 4))
                    }
                    return {
                      value: u,
                      binLen: 4 * t.length + r
                    }
                  }(t, e, r, i)
                };
              case "TEXT":
                return function(t, e, r) {
                  return function(t, e, r, n, i) {
                    var o, s, a, u, c, f, l, h, d = 0,
                      p = r || [0],
                      b = (n = n || 0) >>> 3;
                    if ("UTF8" === e)
                      for (l = -1 === i ? 3 : 0, a = 0; a < t.length; a += 1)
                        for (s = [], 128 > (o = t.charCodeAt(a)) ? s.push(o) : 2048 > o ? (s.push(192 | o >>> 6), s.push(128 | 63 & o)) : 55296 > o || o >= 57344 ? s.push(224 | o >>> 12, 128 | o >>> 6 & 63, 128 | 63 & o) : (a += 1, o = 65536 + ((1023 & o) << 10 | 1023 & t.charCodeAt(a)), s.push(240 | o >>> 18, 128 | o >>> 12 & 63, 128 | o >>> 6 & 63, 128 | 63 & o)), u = 0; u < s.length; u += 1) {
                          for (c = (f = d + b) >>> 2; p.length <= c;) p.push(0);
                          p[c] |= s[u] << 8 * (l + i * (f % 4)), d += 1
                        } else
                          for (l = -1 === i ? 2 : 0, h = "UTF16LE" === e && 1 !== i || "UTF16LE" !== e && 1 === i, a = 0; a < t.length; a += 1) {
                            for (o = t.charCodeAt(a), !0 === h && (o = (u = 255 & o) << 8 | o >>> 8), c = (f = d + b) >>> 2; p.length <= c;) p.push(0);
                            p[c] |= o << 8 * (l + i * (f % 4)), d += 2
                          }
                    return {
                      value: p,
                      binLen: 8 * d + n
                    }
                  }(t, n, e, r, i)
                };
              case "B64":
                return function(e, r, n) {
                  return function(e, r, n, i) {
                    var o, s, a, u, c, f, l = 0,
                      h = r || [0],
                      d = (n = n || 0) >>> 3,
                      p = -1 === i ? 3 : 0,
                      b = e.indexOf("=");
                    if (-1 === e.search(/^[a-zA-Z0-9=+/]+$/)) throw Error("Invalid character in base-64 string");
                    if (e = e.replace(/=/g, ""), -1 !== b && b < e.length) throw Error("Invalid '=' found in base-64 string");
                    for (o = 0; o < e.length; o += 4) {
                      for (u = e.substr(o, 4), a = 0, s = 0; s < u.length; s += 1) a |= t.indexOf(u.charAt(s)) << 18 - 6 * s;
                      for (s = 0; s < u.length - 1; s += 1) {
                        for (c = (f = l + d) >>> 2; h.length <= c;) h.push(0);
                        h[c] |= (a >>> 16 - 8 * s & 255) << 8 * (p + i * (f % 4)), l += 1
                      }
                    }
                    return {
                      value: h,
                      binLen: 8 * l + n
                    }
                  }(e, r, n, i)
                };
              case "BYTES":
                return function(t, e, r) {
                  return function(t, e, r, n) {
                    var i, o, s, a, u = e || [0],
                      c = (r = r || 0) >>> 3,
                      f = -1 === n ? 3 : 0;
                    for (o = 0; o < t.length; o += 1) i = t.charCodeAt(o), s = (a = o + c) >>> 2, u.length <= s && u.push(0), u[s] |= i << 8 * (f + n * (a % 4));
                    return {
                      value: u,
                      binLen: 8 * t.length + r
                    }
                  }(t, e, r, i)
                };
              case "ARRAYBUFFER":
                try {
                  new ArrayBuffer(0)
                } catch {
                  throw Error("ARRAYBUFFER not supported by this environment")
                }
                return function(t, r, n) {
                  return o = r, s = n, a = i, e(new Uint8Array(t), o, s, a);
                  var o, s, a
                };
              case "UINT8ARRAY":
                try {
                  new Uint8Array(0)
                } catch {
                  throw Error("UINT8ARRAY not supported by this environment")
                }
                return function(t, r, n) {
                  return e(t, r, n, i)
                };
              default:
                throw Error("format must be HEX, TEXT, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
          }

          function n(e, r, n, i) {
            switch (e) {
              case "HEX":
                return function(t) {
                  return function(t, e, r, n) {
                    var i, o, s = "",
                      a = e / 8,
                      u = -1 === r ? 3 : 0;
                    for (i = 0; a > i; i += 1) o = t[i >>> 2] >>> 8 * (u + r * (i % 4)), s += "0123456789abcdef".charAt(o >>> 4 & 15) + "0123456789abcdef".charAt(15 & o);
                    return n.outputUpper ? s.toUpperCase() : s
                  }(t, r, n, i)
                };
              case "B64":
                return function(e) {
                  return function(e, r, n, i) {
                    var o, s, a, u, c, f = "",
                      l = r / 8,
                      h = -1 === n ? 3 : 0;
                    for (o = 0; l > o; o += 3)
                      for (u = l > o + 1 ? e[o + 1 >>> 2] : 0, c = l > o + 2 ? e[o + 2 >>> 2] : 0, a = (e[o >>> 2] >>> 8 * (h + n * (o % 4)) & 255) << 16 | (u >>> 8 * (h + n * ((o + 1) % 4)) & 255) << 8 | c >>> 8 * (h + n * ((o + 2) % 4)) & 255, s = 0; 4 > s; s += 1) f += 8 * o + 6 * s > r ? i.b64Pad : t.charAt(a >>> 6 * (3 - s) & 63);
                    return f
                  }(e, r, n, i)
                };
              case "BYTES":
                return function(t) {
                  return function(t, e, r) {
                    var n, i, o = "",
                      s = e / 8,
                      a = -1 === r ? 3 : 0;
                    for (n = 0; s > n; n += 1) i = t[n >>> 2] >>> 8 * (a + r * (n % 4)) & 255, o += String.fromCharCode(i);
                    return o
                  }(t, r, n)
                };
              case "ARRAYBUFFER":
                try {
                  new ArrayBuffer(0)
                } catch {
                  throw Error("ARRAYBUFFER not supported by this environment")
                }
                return function(t) {
                  return function(t, e, r) {
                    var n, i = e / 8,
                      o = new ArrayBuffer(i),
                      s = new Uint8Array(o),
                      a = -1 === r ? 3 : 0;
                    for (n = 0; i > n; n += 1) s[n] = t[n >>> 2] >>> 8 * (a + r * (n % 4)) & 255;
                    return o
                  }(t, r, n)
                };
              case "UINT8ARRAY":
                try {
                  new Uint8Array(0)
                } catch {
                  throw Error("UINT8ARRAY not supported by this environment")
                }
                return function(t) {
                  return function(t, e, r) {
                    var n, i = e / 8,
                      o = -1 === r ? 3 : 0,
                      s = new Uint8Array(i);
                    for (n = 0; i > n; n += 1) s[n] = t[n >>> 2] >>> 8 * (o + r * (n % 4)) & 255;
                    return s
                  }(t, r, n)
                };
              default:
                throw Error("format must be HEX, B64, BYTES, ARRAYBUFFER, or UINT8ARRAY")
            }
          }
          var i = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
            o = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428],
            s = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225],
            a = "Chosen SHA variant is not supported";

          function u(t, e) {
            var r, n, i = t.binLen >>> 3,
              o = e.binLen >>> 3,
              s = i << 3,
              a = 4 - i << 3;
            if (i % 4 != 0) {
              for (r = 0; o > r; r += 4) n = i + r >>> 2, t.value[n] |= e.value[r >>> 2] << s, t.value.push(0), t.value[n + 1] |= e.value[r >>> 2] >>> a;
              return (t.value.length << 2) - 4 >= o + i && t.value.pop(), {
                value: t.value,
                binLen: t.binLen + e.binLen
              }
            }
            return {
              value: t.value.concat(e.value),
              binLen: t.binLen + e.binLen
            }
          }

          function c(t) {
            var e = {
                outputUpper: !1,
                b64Pad: "=",
                outputLen: -1
              },
              r = t || {},
              n = "Output length must be a multiple of 8";
            if (e.outputUpper = r.outputUpper || !1, r.b64Pad && (e.b64Pad = r.b64Pad), r.outputLen) {
              if (r.outputLen % 8 != 0) throw Error(n);
              e.outputLen = r.outputLen
            } else if (r.shakeLen) {
              if (r.shakeLen % 8 != 0) throw Error(n);
              e.outputLen = r.shakeLen
            }
            if ("boolean" != typeof e.outputUpper) throw Error("Invalid outputUpper formatting option");
            if ("string" != typeof e.b64Pad) throw Error("Invalid b64Pad formatting option");
            return e
          }

          function f(t, e, n, i) {
            var o = t + " must include a value and format";
            if (!e) {
              if (!i) throw Error(o);
              return i
            }
            if (void 0 === e.value || !e.format) throw Error(o);
            return r(e.format, e.encoding || "UTF8", n)(e.value)
          }
          var l = function() {
              function t(t, e, r) {
                var n = r || {};
                if (this.t = e, this.i = n.encoding || "UTF8", this.numRounds = n.numRounds || 1, isNaN(this.numRounds) || this.numRounds !== parseInt(this.numRounds, 10) || 1 > this.numRounds) throw Error("numRounds must a integer >= 1");
                this.o = t, this.u = [], this.s = 0, this.h = !1, this.v = 0, this.A = !1, this.l = [], this.H = []
              }
              return t.prototype.update = function(t) {
                var e, r = 0,
                  n = this.S >>> 5,
                  i = this.p(t, this.u, this.s),
                  o = i.binLen,
                  s = i.value,
                  a = o >>> 5;
                for (e = 0; a > e; e += n) r + this.S <= o && (this.m = this.R(s.slice(e, e + n), this.m), r += this.S);
                this.v += r, this.u = s.slice(r >>> 5), this.s = o % this.S, this.h = !0
              }, t.prototype.getHash = function(t, e) {
                var r, i, o = this.U,
                  s = c(e);
                if (this.T) {
                  if (-1 === s.outputLen) throw Error("Output length must be specified in options");
                  o = s.outputLen
                }
                var a = n(t, o, this.C, s);
                if (this.A && this.F) return a(this.F(s));
                for (i = this.K(this.u.slice(), this.s, this.v, this.B(this.m), o), r = 1; r < this.numRounds; r += 1) this.T && o % 32 != 0 && (i[i.length - 1] &= 16777215 >>> 24 - o % 32), i = this.K(i, o, 0, this.L(this.o), o);
                return a(i)
              }, t.prototype.setHMACKey = function(t, e, n) {
                if (!this.g) throw Error("Variant does not support HMAC");
                if (this.h) throw Error("Cannot set MAC key after calling update");
                var i = r(e, (n || {}).encoding || "UTF8", this.C);
                this.k(i(t))
              }, t.prototype.k = function(t) {
                var e, r = this.S >>> 3,
                  n = r / 4 - 1;
                if (1 !== this.numRounds) throw Error("Cannot set numRounds with MAC");
                if (this.A) throw Error("MAC key already set");
                for (r < t.binLen / 8 && (t.value = this.K(t.value, t.binLen, 0, this.L(this.o), this.U)); t.value.length <= n;) t.value.push(0);
                for (e = 0; n >= e; e += 1) this.l[e] = 909522486 ^ t.value[e], this.H[e] = 1549556828 ^ t.value[e];
                this.m = this.R(this.l, this.m), this.v = this.S, this.A = !0
              }, t.prototype.getHMAC = function(t, e) {
                var r = c(e);
                return n(t, this.U, this.C, r)(this.Y())
              }, t.prototype.Y = function() {
                var t;
                if (!this.A) throw Error("Cannot call getHMAC without first setting MAC key");
                var e = this.K(this.u.slice(), this.s, this.v, this.B(this.m), this.U);
                return t = this.R(this.H, this.L(this.o)), this.K(e, this.U, this.S, t, this.U)
              }, t
            }(),
            h = function(t, e) {
              return (h = Object.setPrototypeOf || {
                  __proto__: []
                }
                instanceof Array && function(t, e) {
                  t.__proto__ = e
                } || function(t, e) {
                  for (var r in e)({}).hasOwnProperty.call(e, r) && (t[r] = e[r])
                })(t, e)
            };

          function d(t, e) {
            function r() {
              this.constructor = t
            }
            h(t, e), t.prototype = null === e ? Object.create(e) : (r.prototype = e.prototype, new r)
          }

          function p(t, e) {
            return t << e | t >>> 32 - e
          }

          function b(t, e) {
            return t >>> e | t << 32 - e
          }

          function m(t, e) {
            return t >>> e
          }

          function y(t, e, r) {
            return t ^ e ^ r
          }

          function g(t, e, r) {
            return t & e ^ ~t & r
          }

          function v(t, e, r) {
            return t & e ^ t & r ^ e & r
          }

          function w(t) {
            return b(t, 2) ^ b(t, 13) ^ b(t, 22)
          }

          function A(t, e) {
            var r = (65535 & t) + (65535 & e);
            return (65535 & (t >>> 16) + (e >>> 16) + (r >>> 16)) << 16 | 65535 & r
          }

          function T(t, e, r, n) {
            var i = (65535 & t) + (65535 & e) + (65535 & r) + (65535 & n);
            return (65535 & (t >>> 16) + (e >>> 16) + (r >>> 16) + (n >>> 16) + (i >>> 16)) << 16 | 65535 & i
          }

          function E(t, e, r, n, i) {
            var o = (65535 & t) + (65535 & e) + (65535 & r) + (65535 & n) + (65535 & i);
            return (65535 & (t >>> 16) + (e >>> 16) + (r >>> 16) + (n >>> 16) + (i >>> 16) + (o >>> 16)) << 16 | 65535 & o
          }

          function P(t) {
            return b(t, 7) ^ b(t, 18) ^ m(t, 3)
          }

          function k(t) {
            return b(t, 6) ^ b(t, 11) ^ b(t, 25)
          }

          function x(t) {
            return [1732584193, 4023233417, 2562383102, 271733878, 3285377520]
          }

          function I(t, e) {
            var r, n, i, o, s, a, u, c = [];
            for (r = e[0], n = e[1], i = e[2], o = e[3], s = e[4], u = 0; 80 > u; u += 1) c[u] = 16 > u ? t[u] : p(c[u - 3] ^ c[u - 8] ^ c[u - 14] ^ c[u - 16], 1), a = 20 > u ? E(p(r, 5), g(n, i, o), s, 1518500249, c[u]) : 40 > u ? E(p(r, 5), y(n, i, o), s, 1859775393, c[u]) : 60 > u ? E(p(r, 5), v(n, i, o), s, 2400959708, c[u]) : E(p(r, 5), y(n, i, o), s, 3395469782, c[u]), s = o, o = i, i = p(n, 30), n = r, r = a;
            return e[0] = A(r, e[0]), e[1] = A(n, e[1]), e[2] = A(i, e[2]), e[3] = A(o, e[3]), e[4] = A(s, e[4]), e
          }

          function S(t, e, r, n) {
            for (var i, o = 15 + (e + 65 >>> 9 << 4), s = e + r; t.length <= o;) t.push(0);
            for (t[e >>> 5] |= 128 << 24 - e % 32, t[o] = 4294967295 & s, t[o - 1] = s / 4294967296 | 0, i = 0; i < t.length; i += 16) n = I(t.slice(i, i + 16), n);
            return n
          }
          var O = function(t) {
            function e(e, n, i) {
              var o = this;
              if ("SHA-1" !== e) throw Error(a);
              var s = i || {};
              return (o = t.call(this, e, n, i) || this).g = !0, o.F = o.Y, o.C = -1, o.p = r(o.t, o.i, o.C), o.R = I, o.B = function(t) {
                return t.slice()
              }, o.L = x, o.K = S, o.m = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], o.S = 512, o.U = 160, o.T = !1, s.hmacKey && o.k(f("hmacKey", s.hmacKey, o.C)), o
            }
            return d(e, t), e
          }(l);

          function B(t) {
            return "SHA-224" == t ? o.slice() : s.slice()
          }

          function W(t, e) {
            var r, n, o, s, a, u, c, f, l, h, d, p, y = [];
            for (r = e[0], n = e[1], o = e[2], s = e[3], a = e[4], u = e[5], c = e[6], f = e[7], d = 0; 64 > d; d += 1) y[d] = 16 > d ? t[d] : T(b(p = y[d - 2], 17) ^ b(p, 19) ^ m(p, 10), y[d - 7], P(y[d - 15]), y[d - 16]), l = E(f, k(a), g(a, u, c), i[d], y[d]), h = A(w(r), v(r, n, o)), f = c, c = u, u = a, a = A(s, l), s = o, o = n, n = r, r = A(l, h);
            return e[0] = A(r, e[0]), e[1] = A(n, e[1]), e[2] = A(o, e[2]), e[3] = A(s, e[3]), e[4] = A(a, e[4]), e[5] = A(u, e[5]), e[6] = A(c, e[6]), e[7] = A(f, e[7]), e
          }
          var M = function(t) {
              function e(e, n, i) {
                var o = this;
                if ("SHA-224" !== e && "SHA-256" !== e) throw Error(a);
                var s = i || {};
                return (o = t.call(this, e, n, i) || this).F = o.Y, o.g = !0, o.C = -1, o.p = r(o.t, o.i, o.C), o.R = W, o.B = function(t) {
                  return t.slice()
                }, o.L = B, o.K = function(t, r, n, i) {
                  return function(t, e, r, n, i) {
                    for (var o, s = 15 + (e + 65 >>> 9 << 4), a = e + r; t.length <= s;) t.push(0);
                    for (t[e >>> 5] |= 128 << 24 - e % 32, t[s] = 4294967295 & a, t[s - 1] = a / 4294967296 | 0, o = 0; o < t.length; o += 16) n = W(t.slice(o, o + 16), n);
                    return "SHA-224" === i ? [n[0], n[1], n[2], n[3], n[4], n[5], n[6]] : n
                  }(t, r, n, i, e)
                }, o.m = B(e), o.S = 512, o.U = "SHA-224" === e ? 224 : 256, o.T = !1, s.hmacKey && o.k(f("hmacKey", s.hmacKey, o.C)), o
              }
              return d(e, t), e
            }(l),
            C = function(t, e) {
              this.N = t, this.I = e
            };

          function R(t, e) {
            var r;
            return e > 32 ? (r = 64 - e, new C(t.I << e | t.N >>> r, t.N << e | t.I >>> r)) : 0 !== e ? (r = 32 - e, new C(t.N << e | t.I >>> r, t.I << e | t.N >>> r)) : t
          }

          function N(t, e) {
            var r;
            return 32 > e ? (r = 32 - e, new C(t.N >>> e | t.I << r, t.I >>> e | t.N << r)) : (r = 64 - e, new C(t.I >>> e | t.N << r, t.N >>> e | t.I << r))
          }

          function j(t, e) {
            return new C(t.N >>> e, t.I >>> e | t.N << 32 - e)
          }

          function _(t, e, r) {
            return new C(t.N & e.N ^ ~t.N & r.N, t.I & e.I ^ ~t.I & r.I)
          }

          function D(t, e, r) {
            return new C(t.N & e.N ^ t.N & r.N ^ e.N & r.N, t.I & e.I ^ t.I & r.I ^ e.I & r.I)
          }

          function U(t) {
            var e = N(t, 28),
              r = N(t, 34),
              n = N(t, 39);
            return new C(e.N ^ r.N ^ n.N, e.I ^ r.I ^ n.I)
          }

          function L(t, e) {
            var r, n;
            r = (65535 & t.I) + (65535 & e.I);
            var i = (65535 & (n = (t.I >>> 16) + (e.I >>> 16) + (r >>> 16))) << 16 | 65535 & r;
            return r = (65535 & t.N) + (65535 & e.N) + (n >>> 16), n = (t.N >>> 16) + (e.N >>> 16) + (r >>> 16), new C((65535 & n) << 16 | 65535 & r, i)
          }

          function F(t, e, r, n) {
            var i, o;
            i = (65535 & t.I) + (65535 & e.I) + (65535 & r.I) + (65535 & n.I);
            var s = (65535 & (o = (t.I >>> 16) + (e.I >>> 16) + (r.I >>> 16) + (n.I >>> 16) + (i >>> 16))) << 16 | 65535 & i;
            return i = (65535 & t.N) + (65535 & e.N) + (65535 & r.N) + (65535 & n.N) + (o >>> 16), o = (t.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (n.N >>> 16) + (i >>> 16), new C((65535 & o) << 16 | 65535 & i, s)
          }

          function $(t, e, r, n, i) {
            var o, s;
            o = (65535 & t.I) + (65535 & e.I) + (65535 & r.I) + (65535 & n.I) + (65535 & i.I);
            var a = (65535 & (s = (t.I >>> 16) + (e.I >>> 16) + (r.I >>> 16) + (n.I >>> 16) + (i.I >>> 16) + (o >>> 16))) << 16 | 65535 & o;
            return o = (65535 & t.N) + (65535 & e.N) + (65535 & r.N) + (65535 & n.N) + (65535 & i.N) + (s >>> 16), s = (t.N >>> 16) + (e.N >>> 16) + (r.N >>> 16) + (n.N >>> 16) + (i.N >>> 16) + (o >>> 16), new C((65535 & s) << 16 | 65535 & o, a)
          }

          function z(t, e) {
            return new C(t.N ^ e.N, t.I ^ e.I)
          }

          function H(t) {
            var e = N(t, 1),
              r = N(t, 8),
              n = j(t, 7);
            return new C(e.N ^ r.N ^ n.N, e.I ^ r.I ^ n.I)
          }

          function G(t) {
            var e = N(t, 14),
              r = N(t, 18),
              n = N(t, 41);
            return new C(e.N ^ r.N ^ n.N, e.I ^ r.I ^ n.I)
          }
          var K = [new C(i[0], 3609767458), new C(i[1], 602891725), new C(i[2], 3964484399), new C(i[3], 2173295548), new C(i[4], 4081628472), new C(i[5], 3053834265), new C(i[6], 2937671579), new C(i[7], 3664609560), new C(i[8], 2734883394), new C(i[9], 1164996542), new C(i[10], 1323610764), new C(i[11], 3590304994), new C(i[12], 4068182383), new C(i[13], 991336113), new C(i[14], 633803317), new C(i[15], 3479774868), new C(i[16], 2666613458), new C(i[17], 944711139), new C(i[18], 2341262773), new C(i[19], 2007800933), new C(i[20], 1495990901), new C(i[21], 1856431235), new C(i[22], 3175218132), new C(i[23], 2198950837), new C(i[24], 3999719339), new C(i[25], 766784016), new C(i[26], 2566594879), new C(i[27], 3203337956), new C(i[28], 1034457026), new C(i[29], 2466948901), new C(i[30], 3758326383), new C(i[31], 168717936), new C(i[32], 1188179964), new C(i[33], 1546045734), new C(i[34], 1522805485), new C(i[35], 2643833823), new C(i[36], 2343527390), new C(i[37], 1014477480), new C(i[38], 1206759142), new C(i[39], 344077627), new C(i[40], 1290863460), new C(i[41], 3158454273), new C(i[42], 3505952657), new C(i[43], 106217008), new C(i[44], 3606008344), new C(i[45], 1432725776), new C(i[46], 1467031594), new C(i[47], 851169720), new C(i[48], 3100823752), new C(i[49], 1363258195), new C(i[50], 3750685593), new C(i[51], 3785050280), new C(i[52], 3318307427), new C(i[53], 3812723403), new C(i[54], 2003034995), new C(i[55], 3602036899), new C(i[56], 1575990012), new C(i[57], 1125592928), new C(i[58], 2716904306), new C(i[59], 442776044), new C(i[60], 593698344), new C(i[61], 3733110249), new C(i[62], 2999351573), new C(i[63], 3815920427), new C(3391569614, 3928383900), new C(3515267271, 566280711), new C(3940187606, 3454069534), new C(4118630271, 4000239992), new C(116418474, 1914138554), new C(174292421, 2731055270), new C(289380356, 3203993006), new C(460393269, 320620315), new C(685471733, 587496836), new C(852142971, 1086792851), new C(1017036298, 365543100), new C(1126000580, 2618297676), new C(1288033470, 3409855158), new C(1501505948, 4234509866), new C(1607167915, 987167468), new C(1816402316, 1246189591)];

          function V(t) {
            return "SHA-384" === t ? [new C(3418070365, o[0]), new C(1654270250, o[1]), new C(2438529370, o[2]), new C(355462360, o[3]), new C(1731405415, o[4]), new C(41048885895, o[5]), new C(3675008525, o[6]), new C(1203062813, o[7])] : [new C(s[0], 4089235720), new C(s[1], 2227873595), new C(s[2], 4271175723), new C(s[3], 1595750129), new C(s[4], 2917565137), new C(s[5], 725511199), new C(s[6], 4215389547), new C(s[7], 327033209)]
          }

          function Z(t, e) {
            var r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y, g = [];
            for (r = e[0], n = e[1], i = e[2], o = e[3], s = e[4], a = e[5], u = e[6], c = e[7], h = 0; 80 > h; h += 1) 16 > h ? (d = 2 * h, g[h] = new C(t[d], t[d + 1])) : g[h] = F((b = N(p = g[h - 2], 19), m = N(p, 61), y = j(p, 6), new C(b.N ^ m.N ^ y.N, b.I ^ m.I ^ y.I)), g[h - 7], H(g[h - 15]), g[h - 16]), f = $(c, G(s), _(s, a, u), K[h], g[h]), l = L(U(r), D(r, n, i)), c = u, u = a, a = s, s = L(o, f), o = i, i = n, n = r, r = L(f, l);
            return e[0] = L(r, e[0]), e[1] = L(n, e[1]), e[2] = L(i, e[2]), e[3] = L(o, e[3]), e[4] = L(s, e[4]), e[5] = L(a, e[5]), e[6] = L(u, e[6]), e[7] = L(c, e[7]), e
          }
          var q = function(t) {
              function e(e, n, i) {
                var o = this;
                if ("SHA-384" !== e && "SHA-512" !== e) throw Error(a);
                var s = i || {};
                return (o = t.call(this, e, n, i) || this).F = o.Y, o.g = !0, o.C = -1, o.p = r(o.t, o.i, o.C), o.R = Z, o.B = function(t) {
                  return t.slice()
                }, o.L = V, o.K = function(t, r, n, i) {
                  return function(t, e, r, n, i) {
                    for (var o, s = 31 + (e + 129 >>> 10 << 5), a = e + r; t.length <= s;) t.push(0);
                    for (t[e >>> 5] |= 128 << 24 - e % 32, t[s] = 4294967295 & a, t[s - 1] = a / 4294967296 | 0, o = 0; o < t.length; o += 32) n = Z(t.slice(o, o + 32), n);
                    return "SHA-384" === i ? [n[0].N, n[0].I, n[1].N, n[1].I, n[2].N, n[2].I, n[3].N, n[3].I, n[4].N, n[4].I, n[5].N, n[5].I] : [n[0].N, n[0].I, n[1].N, n[1].I, n[2].N, n[2].I, n[3].N, n[3].I, n[4].N, n[4].I, n[5].N, n[5].I, n[6].N, n[6].I, n[7].N, n[7].I]
                  }(t, r, n, i, e)
                }, o.m = V(e), o.S = 1024, o.U = "SHA-384" === e ? 384 : 512, o.T = !1, s.hmacKey && o.k(f("hmacKey", s.hmacKey, o.C)), o
              }
              return d(e, t), e
            }(l),
            J = [new C(0, 1), new C(0, 32898), new C(2147483648, 32906), new C(2147483648, 2147516416), new C(0, 32907), new C(0, 2147483649), new C(2147483648, 2147516545), new C(2147483648, 32777), new C(0, 138), new C(0, 136), new C(0, 2147516425), new C(0, 2147483658), new C(0, 2147516555), new C(2147483648, 139), new C(2147483648, 32905), new C(2147483648, 32771), new C(2147483648, 32770), new C(2147483648, 128), new C(0, 32778), new C(2147483648, 2147483658), new C(2147483648, 2147516545), new C(2147483648, 32896), new C(0, 2147483649), new C(2147483648, 2147516424)],
            Y = [
              [0, 36, 3, 41, 18],
              [1, 44, 10, 45, 2],
              [62, 6, 43, 15, 61],
              [28, 55, 25, 21, 56],
              [27, 20, 39, 8, 14]
            ];

          function Q(t) {
            var e, r = [];
            for (e = 0; 5 > e; e += 1) r[e] = [new C(0, 0), new C(0, 0), new C(0, 0), new C(0, 0), new C(0, 0)];
            return r
          }

          function X(t) {
            var e, r = [];
            for (e = 0; 5 > e; e += 1) r[e] = t[e].slice();
            return r
          }

          function tt(t, e) {
            var r, n, i, o, s, a, u, c, f, l = [],
              h = [];
            if (null !== t)
              for (n = 0; n < t.length; n += 2) e[(n >>> 1) % 5][(n >>> 1) / 5 | 0] = z(e[(n >>> 1) % 5][(n >>> 1) / 5 | 0], new C(t[n + 1], t[n]));
            for (r = 0; 24 > r; r += 1) {
              for (o = Q(), n = 0; 5 > n; n += 1) l[n] = (s = e[n][0], a = e[n][1], u = e[n][2], c = e[n][3], f = e[n][4], new C(s.N ^ a.N ^ u.N ^ c.N ^ f.N, s.I ^ a.I ^ u.I ^ c.I ^ f.I));
              for (n = 0; 5 > n; n += 1) h[n] = z(l[(n + 4) % 5], R(l[(n + 1) % 5], 1));
              for (n = 0; 5 > n; n += 1)
                for (i = 0; 5 > i; i += 1) e[n][i] = z(e[n][i], h[n]);
              for (n = 0; 5 > n; n += 1)
                for (i = 0; 5 > i; i += 1) o[i][(2 * n + 3 * i) % 5] = R(e[n][i], Y[n][i]);
              for (n = 0; 5 > n; n += 1)
                for (i = 0; 5 > i; i += 1) e[n][i] = z(o[n][i], new C(~o[(n + 1) % 5][i].N & o[(n + 2) % 5][i].N, ~o[(n + 1) % 5][i].I & o[(n + 2) % 5][i].I));
              e[0][0] = z(e[0][0], J[r])
            }
            return e
          }

          function et(t) {
            var e, r, n = 0,
              i = [0, 0],
              o = [4294967295 & t, t / 4294967296 & 2097151];
            for (e = 6; e >= 0; e--) 0 == (r = o[e >> 2] >>> 8 * e & 255) && 0 === n || (i[n + 1 >> 2] |= r << 8 * (n + 1), n += 1);
            return n = 0 !== n ? n : 1, i[0] |= n, {
              value: n + 1 > 4 ? i : [i[0]],
              binLen: 8 + 8 * n
            }
          }

          function rt(t) {
            return u(et(t.binLen), t)
          }

          function nt(t, e) {
            var r, n = et(e),
              i = e >>> 2,
              o = (i - (n = u(n, t)).value.length % i) % i;
            for (r = 0; o > r; r++) n.value.push(0);
            return n.value
          }
          var it = function(t) {
            function e(e, n, i) {
              var o = this,
                s = 6,
                u = 0,
                c = i || {};
              if (1 !== (o = t.call(this, e, n, i) || this).numRounds) {
                if (c.kmacKey || c.hmacKey) throw Error("Cannot set numRounds with MAC");
                if ("CSHAKE128" === o.o || "CSHAKE256" === o.o) throw Error("Cannot set numRounds for CSHAKE variants")
              }
              switch (o.C = 1, o.p = r(o.t, o.i, o.C), o.R = tt, o.B = X, o.L = Q, o.m = Q(), o.T = !1, e) {
                case "SHA3-224":
                  o.S = u = 1152, o.U = 224, o.g = !0, o.F = o.Y;
                  break;
                case "SHA3-256":
                  o.S = u = 1088, o.U = 256, o.g = !0, o.F = o.Y;
                  break;
                case "SHA3-384":
                  o.S = u = 832, o.U = 384, o.g = !0, o.F = o.Y;
                  break;
                case "SHA3-512":
                  o.S = u = 576, o.U = 512, o.g = !0, o.F = o.Y;
                  break;
                case "SHAKE128":
                  s = 31, o.S = u = 1344, o.U = -1, o.T = !0, o.g = !1, o.F = null;
                  break;
                case "SHAKE256":
                  s = 31, o.S = u = 1088, o.U = -1, o.T = !0, o.g = !1, o.F = null;
                  break;
                case "KMAC128":
                  s = 4, o.S = u = 1344, o.M(i), o.U = -1, o.T = !0, o.g = !1, o.F = o.X;
                  break;
                case "KMAC256":
                  s = 4, o.S = u = 1088, o.M(i), o.U = -1, o.T = !0, o.g = !1, o.F = o.X;
                  break;
                case "CSHAKE128":
                  o.S = u = 1344, s = o.O(i), o.U = -1, o.T = !0, o.g = !1, o.F = null;
                  break;
                case "CSHAKE256":
                  o.S = u = 1088, s = o.O(i), o.U = -1, o.T = !0, o.g = !1, o.F = null;
                  break;
                default:
                  throw Error(a)
              }
              return o.K = function(t, e, r, n, i) {
                return function(t, e, r, n, i, o, s) {
                  var a, u, c = 0,
                    f = [],
                    l = i >>> 5,
                    h = e >>> 5;
                  for (a = 0; h > a && e >= i; a += l) n = tt(t.slice(a, a + l), n), e -= i;
                  for (t = t.slice(a), e %= i; t.length < l;) t.push(0);
                  for (t[(a = e >>> 3) >> 2] ^= o << a % 4 * 8, t[l - 1] ^= 2147483648, n = tt(t, n); 32 * f.length < s && (u = n[c % 5][c / 5 | 0], f.push(u.I), 32 * f.length < s);) f.push(u.N), 64 * (c += 1) % i == 0 && (tt(null, n), c = 0);
                  return f
                }(t, e, 0, n, u, s, i)
              }, c.hmacKey && o.k(f("hmacKey", c.hmacKey, o.C)), o
            }
            return d(e, t), e.prototype.O = function(t, e) {
              var r, n = {
                funcName: f("funcName", (r = t || {} || {}).funcName, 1, {
                  value: [],
                  binLen: 0
                }),
                customization: f("Customization", r.customization, 1, {
                  value: [],
                  binLen: 0
                })
              };
              e && (n.funcName = e);
              var i = u(rt(n.funcName), rt(n.customization));
              if (0 !== n.customization.binLen || 0 !== n.funcName.binLen) {
                for (var o = nt(i, this.S >>> 3), s = 0; s < o.length; s += this.S >>> 5) this.m = this.R(o.slice(s, s + (this.S >>> 5)), this.m), this.v += this.S;
                return 4
              }
              return 31
            }, e.prototype.M = function(t) {
              var e, r = {
                kmacKey: f("kmacKey", (e = t || {} || {}).kmacKey, 1),
                funcName: {
                  value: [1128353099],
                  binLen: 32
                },
                customization: f("Customization", e.customization, 1, {
                  value: [],
                  binLen: 0
                })
              };
              this.O(t, r.funcName);
              for (var n = nt(rt(r.kmacKey), this.S >>> 3), i = 0; i < n.length; i += this.S >>> 5) this.m = this.R(n.slice(i, i + (this.S >>> 5)), this.m), this.v += this.S;
              this.A = !0
            }, e.prototype.X = function(t) {
              var e = u({
                value: this.u.slice(),
                binLen: this.s
              }, function(t) {
                var e, r, n = 0,
                  i = [0, 0],
                  o = [4294967295 & t, t / 4294967296 & 2097151];
                for (e = 6; e >= 0; e--) 0 == (r = o[e >> 2] >>> 8 * e & 255) && 0 === n || (i[n >> 2] |= r << 8 * n, n += 1);
                return i[(n = 0 !== n ? n : 1) >> 2] |= n << 8 * n, {
                  value: n + 1 > 4 ? i : [i[0]],
                  binLen: 8 + 8 * n
                }
              }(t.outputLen));
              return this.K(e.value, e.binLen, this.v, this.B(this.m), t.outputLen)
            }, e
          }(l);
          return function() {
            function t(t, e, r) {
              if ("SHA-1" == t) this.j = new O(t, e, r);
              else if ("SHA-224" == t || "SHA-256" == t) this.j = new M(t, e, r);
              else if ("SHA-384" == t || "SHA-512" == t) this.j = new q(t, e, r);
              else {
                if ("SHA3-224" != t && "SHA3-256" != t && "SHA3-384" != t && "SHA3-512" != t && "SHAKE128" != t && "SHAKE256" != t && "CSHAKE128" != t && "CSHAKE256" != t && "KMAC128" != t && "KMAC256" != t) throw Error(a);
                this.j = new it(t, e, r)
              }
            }
            return t.prototype.update = function(t) {
              this.j.update(t)
            }, t.prototype.getHash = function(t, e) {
              return this.j.getHash(t, e)
            }, t.prototype.setHMACKey = function(t, e, r) {
              this.j.setHMACKey(t, e, r)
            }, t.prototype.getHMAC = function(t, e) {
              return this.j.getHMAC(t, e)
            }, t
          }()
        }()
      },
      68486: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      68546: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.toUrlSafe = function(t) {
          for (; t.indexOf("/") >= 0;) t = t.replace("/", "_");
          for (; t.indexOf("+") >= 0;) t = t.replace("+", "-");
          for (; t.indexOf("=") >= 0;) t = t.replace("=", "");
          return t
        }
      },
      68585: t => {
        "use strict";
        t.exports = {
          rE: "15.1.0"
        }
      },
      68683: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.toAscii = e.stripHexPrefix = e.padToEven = e.isHexString = e.isHexPrefixed = e.getKeys = e.getBinarySize = e.fromUtf8 = e.fromAscii = e.arrayContainsArray = void 0, i(r(89838), e), i(r(52652), e), i(r(16284), e), i(r(86727), e), i(r(37380), e), i(r(92133), e), i(r(77312), e), i(r(42666), e), i(r(45062), e), i(r(98421), e);
        var o = r(59498);
        Object.defineProperty(e, "arrayContainsArray", {
          enumerable: !0,
          get: function() {
            return o.arrayContainsArray
          }
        }), Object.defineProperty(e, "fromAscii", {
          enumerable: !0,
          get: function() {
            return o.fromAscii
          }
        }), Object.defineProperty(e, "fromUtf8", {
          enumerable: !0,
          get: function() {
            return o.fromUtf8
          }
        }), Object.defineProperty(e, "getBinarySize", {
          enumerable: !0,
          get: function() {
            return o.getBinarySize
          }
        }), Object.defineProperty(e, "getKeys", {
          enumerable: !0,
          get: function() {
            return o.getKeys
          }
        }), Object.defineProperty(e, "isHexPrefixed", {
          enumerable: !0,
          get: function() {
            return o.isHexPrefixed
          }
        }), Object.defineProperty(e, "isHexString", {
          enumerable: !0,
          get: function() {
            return o.isHexString
          }
        }), Object.defineProperty(e, "padToEven", {
          enumerable: !0,
          get: function() {
            return o.padToEven
          }
        }), Object.defineProperty(e, "stripHexPrefix", {
          enumerable: !0,
          get: function() {
            return o.stripHexPrefix
          }
        }), Object.defineProperty(e, "toAscii", {
          enumerable: !0,
          get: function() {
            return o.toAscii
          }
        }), i(r(31708), e), i(r(81862), e)
      },
      68794: t => {
        t.exports = class {
          constructor() {
            this.max = 1e3, this.map = new Map
          }
          get(t) {
            const e = this.map.get(t);
            if (void 0 !== e) return this.map.delete(t), this.map.set(t, e), e
          }
          delete(t) {
            return this.map.delete(t)
          }
          set(t, e) {
            if (!this.delete(t) && void 0 !== e) {
              if (this.map.size >= this.max) {
                const t = this.map.keys().next().value;
                this.delete(t)
              }
              this.map.set(t, e)
            }
            return this
          }
        }
      },
      69234: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[^\s-_](?!.*?[-_]{2,})[a-z0-9-\\][^\s]*[^-_\s]$/;
        t.exports = e.default, t.exports.default = e.default
      },
      69383: t => {
        "use strict";
        t.exports = Error
      },
      69456: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeStorageInfo = e.loadStorageInfo = void 0;
        const n = r(99100),
          i = r(92577);
        e.loadStorageInfo = function(t) {
          return {
            used: (0, i.loadStorageUsed)(t),
            storageExtra: (0, n.loadStorageExtraInfo)(t),
            lastPaid: t.loadUint(32),
            duePayment: t.loadMaybeCoins()
          }
        }, e.storeStorageInfo = function(t) {
          return e => {
            e.store((0, i.storeStorageUsed)(t.used)), e.store((0, n.storeStorageExtraInfo)(t.storageExtra)), e.storeUint(t.lastPaid, 32), e.storeMaybeCoins(t.duePayment)
          }
        }
      },
      69517: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, n.default)(t), (e = (0, a.default)(e, c)).require_display_name || e.allow_display_name) {
            var r = t.match(f);
            if (r) {
              var u = r[1];
              if (t = t.replace(u, "").replace(/(^<|>$)/g, ""), u.endsWith(" ") && (u = u.slice(0, -1)), ! function(t) {
                  var e = t.replace(/^"(.+)"$/, "$1");
                  if (!e.trim()) return !1;
                  if (/[\.";<>]/.test(e)) {
                    if (e === t) return !1;
                    if (e.split('"').length !== e.split('\\"').length) return !1
                  }
                  return !0
                }(u)) return !1
            } else if (e.require_display_name) return !1
          }
          if (!e.ignore_max_length && t.length > m) return !1;
          var y = t.split("@"),
            g = y.pop(),
            v = g.toLowerCase();
          if (e.host_blacklist.includes(v) || e.host_whitelist.length > 0 && !e.host_whitelist.includes(v)) return !1;
          var w = y.join("@");
          if (e.domain_specific_validation && ("gmail.com" === v || "googlemail.com" === v)) {
            var A = (w = w.toLowerCase()).split("+")[0];
            if (!(0, i.default)(A.replace(/\./g, ""), {
                min: 6,
                max: 30
              })) return !1;
            for (var T = A.split("."), E = 0; E < T.length; E++)
              if (!h.test(T[E])) return !1
          }
          if (!(!1 !== e.ignore_max_length || (0, i.default)(w, {
              max: 64
            }) && (0, i.default)(g, {
              max: 254
            }))) return !1;
          if (!(0, o.default)(g, {
              require_tld: e.require_tld,
              ignore_max_length: e.ignore_max_length,
              allow_underscores: e.allow_underscores
            })) {
            if (!e.allow_ip_domain) return !1;
            if (!(0, s.default)(g)) {
              if (!g.startsWith("[") || !g.endsWith("]")) return !1;
              var P = g.slice(1, -1);
              if (0 === P.length || !(0, s.default)(P)) return !1
            }
          }
          if ('"' === w[0]) return w = w.slice(1, w.length - 1), e.allow_utf8_local_part ? b.test(w) : d.test(w);
          for (var k = e.allow_utf8_local_part ? p : l, x = w.split("."), I = 0; I < x.length; I++)
            if (!k.test(x[I])) return !1;
          return !(e.blacklisted_chars && -1 !== w.search(RegExp("[".concat(e.blacklisted_chars, "]+"), "g")))
        };
        var n = u(r(83399)),
          i = u(r(46255)),
          o = u(r(57658)),
          s = u(r(35372)),
          a = u(r(71229));

        function u(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var c = {
            allow_display_name: !1,
            allow_underscores: !1,
            require_display_name: !1,
            allow_utf8_local_part: !0,
            require_tld: !0,
            blacklisted_chars: "",
            ignore_max_length: !1,
            host_blacklist: [],
            host_whitelist: []
          },
          f = /^([^\x00-\x1F\x7F-\x9F\cX]+)</i,
          l = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~]+$/i,
          h = /^[a-z\d]+$/,
          d = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f]))*$/i,
          p = /^[a-z\d!#\$%&'\*\+\-\/=\?\^_`{\|}~\u00A1-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+$/i,
          b = /^([\s\x01-\x08\x0b\x0c\x0e-\x1f\x7f\x21\x23-\x5b\x5d-\x7e\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]|(\\[\x01-\x09\x0b\x0c\x0d-\x7f\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))*$/i,
          m = 254;
        t.exports = e.default, t.exports.default = e.default
      },
      69597: (t, e, r) => {
        "use strict";

        function n(t) {
          return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }

        function i(t, e) {
          return (i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
            return t.__proto__ = e, t
          })(t, e)
        }

        function o(t) {
          return (o = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
            return t.__proto__ || Object.getPrototypeOf(t)
          })(t)
        }
        var s, a, u = {};

        function c(t, e, r) {
          r || (r = Error);
          var s = function(r) {
            ! function(t, e) {
              if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
              t.prototype = Object.create(e && e.prototype, {
                constructor: {
                  value: t,
                  writable: !0,
                  configurable: !0
                }
              }), Object.defineProperty(t, "prototype", {
                writable: !1
              }), e && i(t, e)
            }(a, r);
            var s = function(t) {
              var e = function() {
                if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                  return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {})), !0
                } catch {
                  return !1
                }
              }();
              return function() {
                var r, i = o(t);
                if (e) {
                  var s = o(this).constructor;
                  r = Reflect.construct(i, arguments, s)
                } else r = i.apply(this, arguments);
                return function(t, e) {
                  if (e && ("object" === n(e) || "function" == typeof e)) return e;
                  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                  return function(t) {
                    if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return t
                  }(t)
                }(this, r)
              }
            }(a);

            function a(r, n, i) {
              var o;
              return function(t, e) {
                if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
              }(this, a), o = s.call(this, function(t, r, n) {
                return "string" == typeof e ? e : e(t, r, n)
              }(r, n, i)), o.code = t, o
            }
            return function(t) {
              return Object.defineProperty(t, "prototype", {
                writable: !1
              }), t
            }(a)
          }(r);
          u[t] = s
        }

        function f(t, e) {
          if (Array.isArray(t)) {
            var r = t.length;
            return t = t.map(function(t) {
              return t + ""
            }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : 2 === r ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
          }
          return "of ".concat(e, " ").concat(t + "")
        }
        c("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), c("ERR_INVALID_ARG_TYPE", function(t, e, i) {
          var o, a;
          if (void 0 === s && (s = r(94148)), s("string" == typeof t, "'name' must be a string"), "string" == typeof e && function(t) {
              return "not " === t.substr(0, 4)
            }(e) ? (o = "must not be", e = e.replace(/^not /, "")) : o = "must be", function(t, e, r) {
              return (void 0 === r || r > t.length) && (r = t.length), " argument" === t.substring(r - 9, r)
            }(t)) a = "The ".concat(t, " ").concat(o, " ").concat(f(e, "type"));
          else {
            var u = function(t, e, r) {
              return "number" != typeof r && (r = 0), r + 1 <= t.length && -1 !== t.indexOf(".", r)
            }(t) ? "property" : "argument";
            a = 'The "'.concat(t, '" ').concat(u, " ").concat(o, " ").concat(f(e, "type"))
          }
          return a + ". Received type ".concat(n(i))
        }, TypeError), c("ERR_INVALID_ARG_VALUE", function(t, e) {
          var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
          void 0 === a && (a = r(40537));
          var i = a.inspect(e);
          return i.length > 128 && (i = "".concat(i.slice(0, 128), "...")), "The argument '".concat(t, "' ").concat(n, ". Received ").concat(i)
        }, TypeError), c("ERR_INVALID_RETURN_VALUE", function(t, e, r) {
          var i;
          return i = r && r.constructor && r.constructor.name ? "instance of ".concat(r.constructor.name) : "type ".concat(n(r)), "Expected ".concat(t, ' to be returned from the "').concat(e, '"') + " function but got ".concat(i, ".")
        }, TypeError), c("ERR_MISSING_ARGS", function() {
          for (var t = arguments.length, e = Array(t), n = 0; t > n; n++) e[n] = arguments[n];
          void 0 === s && (s = r(94148)), s(e.length > 0, "At least one arg needs to be specified");
          var i = "The ",
            o = e.length;
          switch (e = e.map(function(t) {
              return '"'.concat(t, '"')
            }), o) {
            case 1:
              i += "".concat(e[0], " argument");
              break;
            case 2:
              i += "".concat(e[0], " and ").concat(e[1], " arguments");
              break;
            default:
              i += e.slice(0, o - 1).join(", "), i += ", and ".concat(e[o - 1], " arguments")
          }
          return "".concat(i, " must be specified")
        }, TypeError), t.exports.codes = u
      },
      69600: t => {
        "use strict";
        var e, r, n = function() {}.toString,
          i = "object" == typeof Reflect && null !== Reflect && Reflect.apply;
        if ("function" == typeof i && "function" == typeof Object.defineProperty) try {
          e = Object.defineProperty({}, "length", {
            get: function() {
              throw r
            }
          }), r = {}, i(function() {
            throw 42
          }, null, e)
        } catch (t) {
          t !== r && (i = null)
        } else i = null;
        var o = /^\s*class\b/,
          s = function(t) {
            try {
              var e = n.call(t);
              return o.test(e)
            } catch {
              return !1
            }
          },
          a = function(t) {
            try {
              return !s(t) && (n.call(t), !0)
            } catch {
              return !1
            }
          },
          u = {}.toString,
          c = "function" == typeof Symbol && !!Symbol.toStringTag,
          f = !(0 in [, ]),
          l = function() {
            return !1
          };
        if ("object" == typeof document) {
          var h = document.all;
          u.call(h) === u.call(document.all) && (l = function(t) {
            if ((f || !t) && (typeof t > "u" || "object" == typeof t)) try {
              var e = u.call(t);
              return ("[object HTMLAllCollection]" === e || "[object HTML document.all class]" === e || "[object HTMLCollection]" === e || "[object Object]" === e) && null == t("")
            } catch {}
            return !1
          })
        }
        t.exports = i ? function(t) {
          if (l(t)) return !0;
          if (!t || "function" != typeof t && "object" != typeof t) return !1;
          try {
            i(t, null, e)
          } catch (t) {
            if (t !== r) return !1
          }
          return !s(t) && a(t)
        } : function(t) {
          if (l(t)) return !0;
          if (!t || "function" != typeof t && "object" != typeof t) return !1;
          if (c) return a(t);
          if (s(t)) return !1;
          var e = u.call(t);
          return !("[object Function]" !== e && "[object GeneratorFunction]" !== e && !/^\[object HTML/.test(e)) && a(t)
        }
      },
      69673: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.MultisigOrderBuilder = void 0;
        const n = r(1307),
          i = r(64204);
        e.MultisigOrderBuilder = class {
          constructor(t, e) {
            this.messages = (0, n.beginCell)(), this.queryId = 0n, this.walletId = t, this.queryOffset = e || 7200
          }
          addMessage(t, e) {
            if (this.messages.refs >= 4) throw Error("only 4 refs are allowed");
            this.updateQueryId(), this.messages.storeUint(e, 8), this.messages.storeRef((0, n.beginCell)().store((0, n.storeMessageRelaxed)(t)).endCell())
          }
          clearMessages() {
            this.messages = (0, n.beginCell)()
          }
          build() {
            return i.MultisigOrder.fromPayload((0, n.beginCell)().storeUint(this.walletId, 32).storeUint(this.queryId, 64).storeBuilder(this.messages).endCell())
          }
          updateQueryId() {
            const t = BigInt(Math.floor(Date.now() / 1e3 + this.queryOffset));
            this.queryId = t << 32n
          }
        }
      },
      69675: t => {
        "use strict";
        t.exports = TypeError
      },
      69790: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), t.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\//g, "&#x2F;").replace(/\\/g, "&#x5C;").replace(/`/g, "&#96;")
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      70414: t => {
        "use strict";
        t.exports = Math.round
      },
      70453: (t, e, r) => {
        "use strict";
        var n, i = r(79612),
          o = r(69383),
          s = r(41237),
          a = r(79290),
          u = r(79538),
          c = r(58068),
          f = r(69675),
          l = r(35345),
          h = r(71514),
          d = r(58968),
          p = r(6188),
          b = r(68002),
          m = r(75880),
          y = r(70414),
          g = r(73093),
          v = Function,
          w = function(t) {
            try {
              return v('"use strict"; return (' + t + ").constructor;")()
            } catch {}
          },
          A = r(75795),
          T = r(30655),
          E = function() {
            throw new f
          },
          P = A ? function() {
            try {
              return E
            } catch {
              try {
                return A(arguments, "callee").get
              } catch {
                return E
              }
            }
          }() : E,
          k = r(64039)(),
          x = r(93628),
          I = r(71064),
          S = r(48648),
          O = r(11002),
          B = r(10076),
          W = {},
          M = typeof Uint8Array > "u" || !x ? n : x(Uint8Array),
          C = {
            __proto__: null,
            "%AggregateError%": typeof AggregateError > "u" ? n : AggregateError,
            "%Array%": Array,
            "%ArrayBuffer%": typeof ArrayBuffer > "u" ? n : ArrayBuffer,
            "%ArrayIteratorPrototype%": k && x ? x([][Symbol.iterator]()) : n,
            "%AsyncFromSyncIteratorPrototype%": n,
            "%AsyncFunction%": W,
            "%AsyncGenerator%": W,
            "%AsyncGeneratorFunction%": W,
            "%AsyncIteratorPrototype%": W,
            "%Atomics%": typeof Atomics > "u" ? n : Atomics,
            "%BigInt%": typeof BigInt > "u" ? n : BigInt,
            "%BigInt64Array%": typeof BigInt64Array > "u" ? n : BigInt64Array,
            "%BigUint64Array%": typeof BigUint64Array > "u" ? n : BigUint64Array,
            "%Boolean%": Boolean,
            "%DataView%": typeof DataView > "u" ? n : DataView,
            "%Date%": Date,
            "%decodeURI%": decodeURI,
            "%decodeURIComponent%": decodeURIComponent,
            "%encodeURI%": encodeURI,
            "%encodeURIComponent%": encodeURIComponent,
            "%Error%": o,
            "%eval%": eval,
            "%EvalError%": s,
            "%Float16Array%": typeof Float16Array > "u" ? n : Float16Array,
            "%Float32Array%": typeof Float32Array > "u" ? n : Float32Array,
            "%Float64Array%": typeof Float64Array > "u" ? n : Float64Array,
            "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? n : FinalizationRegistry,
            "%Function%": v,
            "%GeneratorFunction%": W,
            "%Int8Array%": typeof Int8Array > "u" ? n : Int8Array,
            "%Int16Array%": typeof Int16Array > "u" ? n : Int16Array,
            "%Int32Array%": typeof Int32Array > "u" ? n : Int32Array,
            "%isFinite%": isFinite,
            "%isNaN%": isNaN,
            "%IteratorPrototype%": k && x ? x(x([][Symbol.iterator]())) : n,
            "%JSON%": "object" == typeof JSON ? JSON : n,
            "%Map%": typeof Map > "u" ? n : Map,
            "%MapIteratorPrototype%": "u" >= typeof Map && k && x ? x((new Map)[Symbol.iterator]()) : n,
            "%Math%": Math,
            "%Number%": Number,
            "%Object%": i,
            "%Object.getOwnPropertyDescriptor%": A,
            "%parseFloat%": parseFloat,
            "%parseInt%": parseInt,
            "%Promise%": typeof Promise > "u" ? n : Promise,
            "%Proxy%": typeof Proxy > "u" ? n : Proxy,
            "%RangeError%": a,
            "%ReferenceError%": u,
            "%Reflect%": typeof Reflect > "u" ? n : Reflect,
            "%RegExp%": RegExp,
            "%Set%": typeof Set > "u" ? n : Set,
            "%SetIteratorPrototype%": "u" >= typeof Set && k && x ? x((new Set)[Symbol.iterator]()) : n,
            "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? n : SharedArrayBuffer,
            "%String%": String,
            "%StringIteratorPrototype%": k && x ? x("" [Symbol.iterator]()) : n,
            "%Symbol%": k ? Symbol : n,
            "%SyntaxError%": c,
            "%ThrowTypeError%": P,
            "%TypedArray%": M,
            "%TypeError%": f,
            "%Uint8Array%": typeof Uint8Array > "u" ? n : Uint8Array,
            "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? n : Uint8ClampedArray,
            "%Uint16Array%": typeof Uint16Array > "u" ? n : Uint16Array,
            "%Uint32Array%": typeof Uint32Array > "u" ? n : Uint32Array,
            "%URIError%": l,
            "%WeakMap%": typeof WeakMap > "u" ? n : WeakMap,
            "%WeakRef%": typeof WeakRef > "u" ? n : WeakRef,
            "%WeakSet%": typeof WeakSet > "u" ? n : WeakSet,
            "%Function.prototype.call%": B,
            "%Function.prototype.apply%": O,
            "%Object.defineProperty%": T,
            "%Object.getPrototypeOf%": I,
            "%Math.abs%": h,
            "%Math.floor%": d,
            "%Math.max%": p,
            "%Math.min%": b,
            "%Math.pow%": m,
            "%Math.round%": y,
            "%Math.sign%": g,
            "%Reflect.getPrototypeOf%": S
          };
        if (x) try {
          null.error
        } catch (t) {
          var R = x(x(t));
          C["%Error.prototype%"] = R
        }
        var N = function t(e) {
            var r;
            if ("%AsyncFunction%" === e) r = w("async function () {}");
            else if ("%GeneratorFunction%" === e) r = w("function* () {}");
            else if ("%AsyncGeneratorFunction%" === e) r = w("async function* () {}");
            else if ("%AsyncGenerator%" === e) {
              var n = t("%AsyncGeneratorFunction%");
              n && (r = n.prototype)
            } else if ("%AsyncIteratorPrototype%" === e) {
              var i = t("%AsyncGenerator%");
              i && x && (r = x(i.prototype))
            }
            return C[e] = r, r
          },
          j = {
            __proto__: null,
            "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
            "%ArrayPrototype%": ["Array", "prototype"],
            "%ArrayProto_entries%": ["Array", "prototype", "entries"],
            "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
            "%ArrayProto_keys%": ["Array", "prototype", "keys"],
            "%ArrayProto_values%": ["Array", "prototype", "values"],
            "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
            "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
            "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
            "%BooleanPrototype%": ["Boolean", "prototype"],
            "%DataViewPrototype%": ["DataView", "prototype"],
            "%DatePrototype%": ["Date", "prototype"],
            "%ErrorPrototype%": ["Error", "prototype"],
            "%EvalErrorPrototype%": ["EvalError", "prototype"],
            "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
            "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
            "%FunctionPrototype%": ["Function", "prototype"],
            "%Generator%": ["GeneratorFunction", "prototype"],
            "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
            "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
            "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
            "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
            "%JSONParse%": ["JSON", "parse"],
            "%JSONStringify%": ["JSON", "stringify"],
            "%MapPrototype%": ["Map", "prototype"],
            "%NumberPrototype%": ["Number", "prototype"],
            "%ObjectPrototype%": ["Object", "prototype"],
            "%ObjProto_toString%": ["Object", "prototype", "toString"],
            "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
            "%PromisePrototype%": ["Promise", "prototype"],
            "%PromiseProto_then%": ["Promise", "prototype", "then"],
            "%Promise_all%": ["Promise", "all"],
            "%Promise_reject%": ["Promise", "reject"],
            "%Promise_resolve%": ["Promise", "resolve"],
            "%RangeErrorPrototype%": ["RangeError", "prototype"],
            "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
            "%RegExpPrototype%": ["RegExp", "prototype"],
            "%SetPrototype%": ["Set", "prototype"],
            "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
            "%StringPrototype%": ["String", "prototype"],
            "%SymbolPrototype%": ["Symbol", "prototype"],
            "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
            "%TypedArrayPrototype%": ["TypedArray", "prototype"],
            "%TypeErrorPrototype%": ["TypeError", "prototype"],
            "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
            "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
            "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
            "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
            "%URIErrorPrototype%": ["URIError", "prototype"],
            "%WeakMapPrototype%": ["WeakMap", "prototype"],
            "%WeakSetPrototype%": ["WeakSet", "prototype"]
          },
          _ = r(66743),
          D = r(9957),
          U = _.call(B, [].concat),
          L = _.call(O, [].splice),
          F = _.call(B, "".replace),
          $ = _.call(B, "".slice),
          z = _.call(B, /t/.exec),
          H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,
          G = /\\(\\)?/g,
          K = function(t, e) {
            var r, n = t;
            if (D(j, n) && (n = "%" + (r = j[n])[0] + "%"), D(C, n)) {
              var i = C[n];
              if (i === W && (i = N(n)), typeof i > "u" && !e) throw new f("intrinsic " + t + " exists, but is not available. Please file an issue!");
              return {
                alias: r,
                name: n,
                value: i
              }
            }
            throw new c("intrinsic " + t + " does not exist!")
          };
        t.exports = function(t, e) {
          if ("string" != typeof t || 0 === t.length) throw new f("intrinsic name must be a non-empty string");
          if (arguments.length > 1 && "boolean" != typeof e) throw new f('"allowMissing" argument must be a boolean');
          if (null === z(/^%?[^%]*%?$/, t)) throw new c("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
          var r = function(t) {
              var e = $(t, 0, 1),
                r = $(t, -1);
              if ("%" === e && "%" !== r) throw new c("invalid intrinsic syntax, expected closing `%`");
              if ("%" === r && "%" !== e) throw new c("invalid intrinsic syntax, expected opening `%`");
              var n = [];
              return F(t, H, function(t, e, r, i) {
                n[n.length] = r ? F(i, G, "$1") : e || t
              }), n
            }(t),
            n = r.length > 0 ? r[0] : "",
            i = K("%" + n + "%", e),
            o = i.name,
            s = i.value,
            a = !1,
            u = i.alias;
          u && (n = u[0], L(r, U([0, 1], u)));
          for (var l = 1, h = !0; l < r.length; l += 1) {
            var d = r[l],
              p = $(d, 0, 1),
              b = $(d, -1);
            if (('"' === p || "'" === p || "`" === p || '"' === b || "'" === b || "`" === b) && p !== b) throw new c("property names with quotes must have matching quotes");
            if (("constructor" === d || !h) && (a = !0), D(C, o = "%" + (n += "." + d) + "%")) s = C[o];
            else if (null != s) {
              if (!(d in s)) {
                if (!e) throw new f("base intrinsic for " + t + " exists, but the property is not available.");
                return
              }
              if (A && l + 1 >= r.length) {
                var m = A(s, d);
                s = (h = !!m) && "get" in m && !("originalValue" in m.get) ? m.get : s[d]
              } else h = D(s, d), s = s[d];
              h && !a && (C[o] = s)
            }
          }
          return s
        }
      },
      70639: (t, e) => {
        "use strict";

        function r(t) {
          return "object" == typeof t && null !== t
        }

        function n(t) {
          return "symbol" == typeof t ? t.toString() : "string" == typeof t ? JSON.stringify(t) : "" + t
        }

        function i(t, e, r, i) {
          if (!0 === t) return;
          !1 === t ? t = {} : "string" == typeof t && (t = {
            message: t
          });
          const {
            path: o,
            branch: s
          } = e, {
            type: a
          } = r, {
            refinement: u,
            message: c = `Expected a value of type \`${a}\`${u?` with refinement \`${u}\``:""}, but received: \`${n(i)}\``
          } = t;
          return {
            value: i,
            type: a,
            refinement: u,
            key: o[o.length - 1],
            path: o,
            branch: s,
            ...t,
            message: c
          }
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.run = e.toFailures = e.toFailure = e.shiftIterator = e.print = e.isPlainObject = e.isObject = void 0, e.isObject = r, e.isPlainObject = function(t) {
          if ("[object Object]" !== {}.toString.call(t)) return !1;
          const e = Object.getPrototypeOf(t);
          return null === e || e === Object.prototype
        }, e.print = n, e.shiftIterator = function(t) {
          const {
            done: e,
            value: r
          } = t.next();
          return e ? void 0 : r
        }, e.toFailure = i, e.toFailures = function*(t, e, n, o) {
          (function(t) {
            return r(t) && "function" == typeof t[Symbol.iterator]
          })(t) || (t = [t]);
          for (const r of t) {
            const t = i(r, e, n, o);
            t && (yield t)
          }
        }, e.run = function* t(e, n, i = {}) {
          const {
            path: o = [],
            branch: s = [e],
            coerce: a = !1,
            mask: u = !1
          } = i, c = {
            path: o,
            branch: s
          };
          if (a && (e = n.coercer(e, c), u && "type" !== n.type && r(n.schema) && r(e) && !Array.isArray(e)))
            for (const t in e) void 0 === n.schema[t] && delete e[t];
          let f = "valid";
          for (const t of n.validator(e, c)) t.explanation = i.message, f = "not_valid", yield [t, void 0];
          for (let [l, h, d] of n.entries(e, c)) {
            const n = t(h, d, {
              path: void 0 === l ? o : [...o, l],
              branch: void 0 === l ? s : [...s, h],
              coerce: a,
              mask: u,
              message: i.message
            });
            for (const t of n) t[0] ? (f = null === t[0].refinement || void 0 === t[0].refinement ? "not_valid" : "not_refined", yield [t[0], void 0]) : a && (h = t[1], void 0 === l ? e = h : e instanceof Map ? e.set(l, h) : e instanceof Set ? e.add(h) : r(e) && (void 0 !== h || l in e) && (e[l] = h))
          }
          if ("not_valid" !== f)
            for (const t of n.refiner(e, c)) t.explanation = i.message, f = "not_refined", yield [t, void 0];
          "valid" === f && (yield [void 0, e])
        }
      },
      71064: (t, e, r) => {
        "use strict";
        var n = r(79612);
        t.exports = n.getPrototypeOf || null
      },
      71195: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("TronWebProto.VoteWitnessContract", null, o), i.exportSymbol("TronWebProto.VoteWitnessContract.Vote", null, o), i.exportSymbol("TronWebProto.WitnessCreateContract", null, o), i.exportSymbol("TronWebProto.WitnessUpdateContract", null, o), TronWebProto.WitnessCreateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.WitnessCreateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.WitnessCreateContract.displayName = "TronWebProto.WitnessCreateContract"), TronWebProto.WitnessUpdateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.WitnessUpdateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.WitnessUpdateContract.displayName = "TronWebProto.WitnessUpdateContract"), TronWebProto.VoteWitnessContract = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.VoteWitnessContract.repeatedFields_, null)
        }, i.inherits(TronWebProto.VoteWitnessContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.displayName = "TronWebProto.VoteWitnessContract"), TronWebProto.VoteWitnessContract.Vote = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.VoteWitnessContract.Vote, n.Message), i.DEBUG && !COMPILED && (TronWebProto.VoteWitnessContract.Vote.displayName = "TronWebProto.VoteWitnessContract.Vote"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessCreateContract.prototype.toObject = function(t) {
          return TronWebProto.WitnessCreateContract.toObject(t, this)
        }, TronWebProto.WitnessCreateContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            url: e.getUrl_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.WitnessCreateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.WitnessCreateContract;
          return TronWebProto.WitnessCreateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.WitnessCreateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setUrl(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.WitnessCreateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.WitnessCreateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.WitnessCreateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getUrl_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.WitnessCreateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.WitnessCreateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.WitnessCreateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.WitnessCreateContract.prototype.getUrl = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.WitnessCreateContract.prototype.getUrl_asB64 = function() {
          return n.Message.bytesAsB64(this.getUrl())
        }, TronWebProto.WitnessCreateContract.prototype.getUrl_asU8 = function() {
          return n.Message.bytesAsU8(this.getUrl())
        }, TronWebProto.WitnessCreateContract.prototype.setUrl = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.WitnessUpdateContract.prototype.toObject = function(t) {
          return TronWebProto.WitnessUpdateContract.toObject(t, this)
        }, TronWebProto.WitnessUpdateContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            updateUrl: e.getUpdateUrl_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.WitnessUpdateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.WitnessUpdateContract;
          return TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.WitnessUpdateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 12:
              r = e.readBytes(), t.setUpdateUrl(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.WitnessUpdateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.WitnessUpdateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.WitnessUpdateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getUpdateUrl_asU8()).length > 0 && e.writeBytes(12, r)
        }, TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.WitnessUpdateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.WitnessUpdateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl = function() {
          return n.Message.getFieldWithDefault(this, 12, "")
        }, TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asB64 = function() {
          return n.Message.bytesAsB64(this.getUpdateUrl())
        }, TronWebProto.WitnessUpdateContract.prototype.getUpdateUrl_asU8 = function() {
          return n.Message.bytesAsU8(this.getUpdateUrl())
        }, TronWebProto.WitnessUpdateContract.prototype.setUpdateUrl = function(t) {
          return n.Message.setProto3BytesField(this, 12, t)
        }, TronWebProto.VoteWitnessContract.repeatedFields_ = [2], n.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.prototype.toObject = function(t) {
          return TronWebProto.VoteWitnessContract.toObject(t, this)
        }, TronWebProto.VoteWitnessContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            votesList: n.Message.toObjectList(e.getVotesList(), TronWebProto.VoteWitnessContract.Vote.toObject, t),
            support: n.Message.getBooleanFieldWithDefault(e, 3, !1)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.VoteWitnessContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.VoteWitnessContract;
          return TronWebProto.VoteWitnessContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.VoteWitnessContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = new TronWebProto.VoteWitnessContract.Vote, e.readMessage(r, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader), t.addVotes(r);
              break;
            case 3:
              r = e.readBool(), t.setSupport(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.VoteWitnessContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.VoteWitnessContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.VoteWitnessContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getVotesList()).length > 0 && e.writeRepeatedMessage(2, r, TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter), (r = t.getSupport()) && e.writeBool(3, r)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.VoteWitnessContract.Vote.prototype.toObject = function(t) {
          return TronWebProto.VoteWitnessContract.Vote.toObject(t, this)
        }, TronWebProto.VoteWitnessContract.Vote.toObject = function(t, e) {
          var r = {
            voteAddress: e.getVoteAddress_asB64(),
            voteCount: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.VoteWitnessContract.Vote.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.VoteWitnessContract.Vote;
          return TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader(r, e)
        }, TronWebProto.VoteWitnessContract.Vote.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setVoteAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setVoteCount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.VoteWitnessContract.Vote.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.VoteWitnessContract.Vote.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getVoteAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getVoteCount()) && e.writeInt64(2, r)
        }, TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getVoteAddress())
        }, TronWebProto.VoteWitnessContract.Vote.prototype.getVoteAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getVoteAddress())
        }, TronWebProto.VoteWitnessContract.Vote.prototype.setVoteAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.VoteWitnessContract.Vote.prototype.getVoteCount = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.VoteWitnessContract.Vote.prototype.setVoteCount = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.VoteWitnessContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.VoteWitnessContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.VoteWitnessContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.VoteWitnessContract.prototype.getVotesList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.VoteWitnessContract.Vote, 2)
        }, TronWebProto.VoteWitnessContract.prototype.setVotesList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 2, t)
        }, TronWebProto.VoteWitnessContract.prototype.addVotes = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 2, t, TronWebProto.VoteWitnessContract.Vote, e)
        }, TronWebProto.VoteWitnessContract.prototype.clearVotesList = function() {
          return this.setVotesList([])
        }, TronWebProto.VoteWitnessContract.prototype.getSupport = function() {
          return n.Message.getBooleanFieldWithDefault(this, 3, !1)
        }, TronWebProto.VoteWitnessContract.prototype.setSupport = function(t) {
          return n.Message.setProto3BooleanField(this, 3, t)
        }, i.object.extend(e, TronWebProto)
      },
      71229: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function() {
          var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
            e = arguments.length > 1 ? arguments[1] : void 0;
          for (var r in e) typeof t[r] > "u" && (t[r] = e[r]);
          return t
        }, t.exports = e.default, t.exports.default = e.default
      },
      71281: () => {},
      71447: (t, e, r) => {
        "use strict";
        var n = r(9805),
          i = r(53269),
          o = r(14823),
          s = r(47293),
          a = r(21998),
          u = -2,
          c = 12,
          f = 30;

        function l(t) {
          return (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24)
        }

        function h() {
          this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new n.Buf16(320), this.work = new n.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
        }

        function d(t) {
          var e;
          return t && t.state ? (e = t.state, t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = 1, e.last = 0, e.havedict = 0, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new n.Buf32(852), e.distcode = e.distdyn = new n.Buf32(592), e.sane = 1, e.back = -1, 0) : u
        }

        function p(t) {
          var e;
          return t && t.state ? ((e = t.state).wsize = 0, e.whave = 0, e.wnext = 0, d(t)) : u
        }

        function b(t, e) {
          var r, n;
          return t && t.state && (n = t.state, 0 > e ? (r = 0, e = -e) : (r = 1 + (e >> 4), 48 > e && (e &= 15)), !e || e >= 8 && 15 >= e) ? (null !== n.window && n.wbits !== e && (n.window = null), n.wrap = r, n.wbits = e, p(t)) : u
        }

        function m(t, e) {
          var r, n;
          return t ? (n = new h, t.state = n, n.window = null, 0 !== (r = b(t, e)) && (t.state = null), r) : u
        }
        var y, g, v = !0;

        function w(t) {
          if (v) {
            var e;
            for (y = new n.Buf32(512), g = new n.Buf32(32), e = 0; 144 > e;) t.lens[e++] = 8;
            for (; 256 > e;) t.lens[e++] = 9;
            for (; 280 > e;) t.lens[e++] = 7;
            for (; 288 > e;) t.lens[e++] = 8;
            for (a(1, t.lens, 0, 288, y, 0, t.work, {
                bits: 9
              }), e = 0; 32 > e;) t.lens[e++] = 5;
            a(2, t.lens, 0, 32, g, 0, t.work, {
              bits: 5
            }), v = !1
          }
          t.lencode = y, t.lenbits = 9, t.distcode = g, t.distbits = 5
        }

        function A(t, e, r, i) {
          var o, s = t.state;
          return null === s.window && (s.wsize = 1 << s.wbits, s.wnext = 0, s.whave = 0, s.window = new n.Buf8(s.wsize)), i < s.wsize ? ((o = s.wsize - s.wnext) > i && (o = i), n.arraySet(s.window, e, r - i, o, s.wnext), (i -= o) ? (n.arraySet(s.window, e, r - i, i, 0), s.wnext = i, s.whave = s.wsize) : (s.wnext += o, s.wnext === s.wsize && (s.wnext = 0), s.whave < s.wsize && (s.whave += o))) : (n.arraySet(s.window, e, r - s.wsize, s.wsize, 0), s.wnext = 0, s.whave = s.wsize), 0
        }
        e.inflateReset = p, e.inflateReset2 = b, e.inflateResetKeep = d, e.inflateInit = function(t) {
          return m(t, 15)
        }, e.inflateInit2 = m, e.inflate = function(t, e) {
          var r, h, d, p, b, m, y, g, v, T, E, P, k, x, I, S, O, B, W, M, C, R, N, j, _ = 0,
            D = new n.Buf8(4),
            U = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
          if (!t || !t.state || !t.output || !t.input && 0 !== t.avail_in) return u;
          (r = t.state).mode === c && (r.mode = 13), b = t.next_out, d = t.output, y = t.avail_out, p = t.next_in, h = t.input, m = t.avail_in, g = r.hold, v = r.bits, T = m, E = y, R = 0;
          t: for (;;) switch (r.mode) {
            case 1:
              if (0 === r.wrap) {
                r.mode = 13;
                break
              }
              for (; 16 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if (2 & r.wrap && 35615 === g) {
                r.check = 0, D[0] = 255 & g, D[1] = g >>> 8 & 255, r.check = o(r.check, D, 2, 0), g = 0, v = 0, r.mode = 2;
                break
              }
              if (r.flags = 0, r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & g) << 8) + (g >> 8)) % 31) {
                t.msg = "incorrect header check", r.mode = f;
                break
              }
              if (8 != (15 & g)) {
                t.msg = "unknown compression method", r.mode = f;
                break
              }
              if (v -= 4, C = 8 + (15 & (g >>>= 4)), 0 === r.wbits) r.wbits = C;
              else if (C > r.wbits) {
                t.msg = "invalid window size", r.mode = f;
                break
              }
              r.dmax = 1 << C, t.adler = r.check = 1, r.mode = 512 & g ? 10 : c, g = 0, v = 0;
              break;
            case 2:
              for (; 16 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if (r.flags = g, 8 != (255 & r.flags)) {
                t.msg = "unknown compression method", r.mode = f;
                break
              }
              if (57344 & r.flags) {
                t.msg = "unknown header flags set", r.mode = f;
                break
              }
              r.head && (r.head.text = g >> 8 & 1), 512 & r.flags && (D[0] = 255 & g, D[1] = g >>> 8 & 255, r.check = o(r.check, D, 2, 0)), g = 0, v = 0, r.mode = 3;
            case 3:
              for (; 32 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              r.head && (r.head.time = g), 512 & r.flags && (D[0] = 255 & g, D[1] = g >>> 8 & 255, D[2] = g >>> 16 & 255, D[3] = g >>> 24 & 255, r.check = o(r.check, D, 4, 0)), g = 0, v = 0, r.mode = 4;
            case 4:
              for (; 16 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              r.head && (r.head.xflags = 255 & g, r.head.os = g >> 8), 512 & r.flags && (D[0] = 255 & g, D[1] = g >>> 8 & 255, r.check = o(r.check, D, 2, 0)), g = 0, v = 0, r.mode = 5;
            case 5:
              if (1024 & r.flags) {
                for (; 16 > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                r.length = g, r.head && (r.head.extra_len = g), 512 & r.flags && (D[0] = 255 & g, D[1] = g >>> 8 & 255, r.check = o(r.check, D, 2, 0)), g = 0, v = 0
              } else r.head && (r.head.extra = null);
              r.mode = 6;
            case 6:
              if (1024 & r.flags && ((P = r.length) > m && (P = m), P && (r.head && (C = r.head.extra_len - r.length, r.head.extra || (r.head.extra = Array(r.head.extra_len)), n.arraySet(r.head.extra, h, p, P, C)), 512 & r.flags && (r.check = o(r.check, h, P, p)), m -= P, p += P, r.length -= P), r.length)) break t;
              r.length = 0, r.mode = 7;
            case 7:
              if (2048 & r.flags) {
                if (0 === m) break t;
                P = 0;
                do {
                  C = h[p + P++], r.head && C && 65536 > r.length && (r.head.name += String.fromCharCode(C))
                } while (C && m > P);
                if (512 & r.flags && (r.check = o(r.check, h, P, p)), m -= P, p += P, C) break t
              } else r.head && (r.head.name = null);
              r.length = 0, r.mode = 8;
            case 8:
              if (4096 & r.flags) {
                if (0 === m) break t;
                P = 0;
                do {
                  C = h[p + P++], r.head && C && 65536 > r.length && (r.head.comment += String.fromCharCode(C))
                } while (C && m > P);
                if (512 & r.flags && (r.check = o(r.check, h, P, p)), m -= P, p += P, C) break t
              } else r.head && (r.head.comment = null);
              r.mode = 9;
            case 9:
              if (512 & r.flags) {
                for (; 16 > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                if (g !== (65535 & r.check)) {
                  t.msg = "header crc mismatch", r.mode = f;
                  break
                }
                g = 0, v = 0
              }
              r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = c;
              break;
            case 10:
              for (; 32 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              t.adler = r.check = l(g), g = 0, v = 0, r.mode = 11;
            case 11:
              if (0 === r.havedict) return t.next_out = b, t.avail_out = y, t.next_in = p, t.avail_in = m, r.hold = g, r.bits = v, 2;
              t.adler = r.check = 1, r.mode = c;
            case c:
              if (5 === e || 6 === e) break t;
            case 13:
              if (r.last) {
                g >>>= 7 & v, v -= 7 & v, r.mode = 27;
                break
              }
              for (; 3 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              switch (r.last = 1 & g, v -= 1, 3 & (g >>>= 1)) {
                case 0:
                  r.mode = 14;
                  break;
                case 1:
                  if (w(r), r.mode = 20, 6 === e) {
                    g >>>= 2, v -= 2;
                    break t
                  }
                  break;
                case 2:
                  r.mode = 17;
                  break;
                case 3:
                  t.msg = "invalid block type", r.mode = f
              }
              g >>>= 2, v -= 2;
              break;
            case 14:
              for (g >>>= 7 & v, v -= 7 & v; 32 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if ((65535 & g) != (g >>> 16 ^ 65535)) {
                t.msg = "invalid stored block lengths", r.mode = f;
                break
              }
              if (r.length = 65535 & g, g = 0, v = 0, r.mode = 15, 6 === e) break t;
            case 15:
              r.mode = 16;
            case 16:
              if (P = r.length) {
                if (P > m && (P = m), P > y && (P = y), 0 === P) break t;
                n.arraySet(d, h, p, P, b), m -= P, p += P, y -= P, b += P, r.length -= P;
                break
              }
              r.mode = c;
              break;
            case 17:
              for (; 14 > v;) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if (r.nlen = 257 + (31 & g), g >>>= 5, v -= 5, r.ndist = 1 + (31 & g), g >>>= 5, v -= 5, r.ncode = 4 + (15 & g), g >>>= 4, v -= 4, r.nlen > 286 || r.ndist > 30) {
                t.msg = "too many length or distance symbols", r.mode = f;
                break
              }
              r.have = 0, r.mode = 18;
            case 18:
              for (; r.have < r.ncode;) {
                for (; 3 > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                r.lens[U[r.have++]] = 7 & g, g >>>= 3, v -= 3
              }
              for (; 19 > r.have;) r.lens[U[r.have++]] = 0;
              if (r.lencode = r.lendyn, r.lenbits = 7, N = {
                  bits: r.lenbits
                }, R = a(0, r.lens, 0, 19, r.lencode, 0, r.work, N), r.lenbits = N.bits, R) {
                t.msg = "invalid code lengths set", r.mode = f;
                break
              }
              r.have = 0, r.mode = 19;
            case 19:
              for (; r.have < r.nlen + r.ndist;) {
                for (; S = (_ = r.lencode[g & (1 << r.lenbits) - 1]) >>> 16 & 255, O = 65535 & _, v < (I = _ >>> 24);) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                if (16 > O) g >>>= I, v -= I, r.lens[r.have++] = O;
                else {
                  if (16 === O) {
                    for (j = I + 2; j > v;) {
                      if (0 === m) break t;
                      m--, g += h[p++] << v, v += 8
                    }
                    if (g >>>= I, v -= I, 0 === r.have) {
                      t.msg = "invalid bit length repeat", r.mode = f;
                      break
                    }
                    C = r.lens[r.have - 1], P = 3 + (3 & g), g >>>= 2, v -= 2
                  } else if (17 === O) {
                    for (j = I + 3; j > v;) {
                      if (0 === m) break t;
                      m--, g += h[p++] << v, v += 8
                    }
                    v -= I, C = 0, P = 3 + (7 & (g >>>= I)), g >>>= 3, v -= 3
                  } else {
                    for (j = I + 7; j > v;) {
                      if (0 === m) break t;
                      m--, g += h[p++] << v, v += 8
                    }
                    v -= I, C = 0, P = 11 + (127 & (g >>>= I)), g >>>= 7, v -= 7
                  }
                  if (r.have + P > r.nlen + r.ndist) {
                    t.msg = "invalid bit length repeat", r.mode = f;
                    break
                  }
                  for (; P--;) r.lens[r.have++] = C
                }
              }
              if (r.mode === f) break;
              if (0 === r.lens[256]) {
                t.msg = "invalid code -- missing end-of-block", r.mode = f;
                break
              }
              if (r.lenbits = 9, N = {
                  bits: r.lenbits
                }, R = a(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, N), r.lenbits = N.bits, R) {
                t.msg = "invalid literal/lengths set", r.mode = f;
                break
              }
              if (r.distbits = 6, r.distcode = r.distdyn, N = {
                  bits: r.distbits
                }, R = a(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, N), r.distbits = N.bits, R) {
                t.msg = "invalid distances set", r.mode = f;
                break
              }
              if (r.mode = 20, 6 === e) break t;
            case 20:
              r.mode = 21;
            case 21:
              if (m >= 6 && y >= 258) {
                t.next_out = b, t.avail_out = y, t.next_in = p, t.avail_in = m, r.hold = g, r.bits = v, s(t, E), b = t.next_out, d = t.output, y = t.avail_out, p = t.next_in, h = t.input, m = t.avail_in, g = r.hold, v = r.bits, r.mode === c && (r.back = -1);
                break
              }
              for (r.back = 0; S = (_ = r.lencode[g & (1 << r.lenbits) - 1]) >>> 16 & 255, O = 65535 & _, v < (I = _ >>> 24);) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if (S && !(240 & S)) {
                for (B = I, W = S, M = O; S = (_ = r.lencode[M + ((g & (1 << B + W) - 1) >> B)]) >>> 16 & 255, O = 65535 & _, v < B + (I = _ >>> 24);) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                g >>>= B, v -= B, r.back += B
              }
              if (g >>>= I, v -= I, r.back += I, r.length = O, 0 === S) {
                r.mode = 26;
                break
              }
              if (32 & S) {
                r.back = -1, r.mode = c;
                break
              }
              if (64 & S) {
                t.msg = "invalid literal/length code", r.mode = f;
                break
              }
              r.extra = 15 & S, r.mode = 22;
            case 22:
              if (r.extra) {
                for (j = r.extra; j > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                r.length += g & (1 << r.extra) - 1, g >>>= r.extra, v -= r.extra, r.back += r.extra
              }
              r.was = r.length, r.mode = 23;
            case 23:
              for (; S = (_ = r.distcode[g & (1 << r.distbits) - 1]) >>> 16 & 255, O = 65535 & _, v < (I = _ >>> 24);) {
                if (0 === m) break t;
                m--, g += h[p++] << v, v += 8
              }
              if (!(240 & S)) {
                for (B = I, W = S, M = O; S = (_ = r.distcode[M + ((g & (1 << B + W) - 1) >> B)]) >>> 16 & 255, O = 65535 & _, v < B + (I = _ >>> 24);) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                g >>>= B, v -= B, r.back += B
              }
              if (g >>>= I, v -= I, r.back += I, 64 & S) {
                t.msg = "invalid distance code", r.mode = f;
                break
              }
              r.offset = O, r.extra = 15 & S, r.mode = 24;
            case 24:
              if (r.extra) {
                for (j = r.extra; j > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                r.offset += g & (1 << r.extra) - 1, g >>>= r.extra, v -= r.extra, r.back += r.extra
              }
              if (r.offset > r.dmax) {
                t.msg = "invalid distance too far back", r.mode = f;
                break
              }
              r.mode = 25;
            case 25:
              if (0 === y) break t;
              if (P = E - y, r.offset > P) {
                if ((P = r.offset - P) > r.whave && r.sane) {
                  t.msg = "invalid distance too far back", r.mode = f;
                  break
                }
                P > r.wnext ? (P -= r.wnext, k = r.wsize - P) : k = r.wnext - P, P > r.length && (P = r.length), x = r.window
              } else x = d, k = b - r.offset, P = r.length;
              P > y && (P = y), y -= P, r.length -= P;
              do {
                d[b++] = x[k++]
              } while (--P);
              0 === r.length && (r.mode = 21);
              break;
            case 26:
              if (0 === y) break t;
              d[b++] = r.length, y--, r.mode = 21;
              break;
            case 27:
              if (r.wrap) {
                for (; 32 > v;) {
                  if (0 === m) break t;
                  m--, g |= h[p++] << v, v += 8
                }
                if (E -= y, t.total_out += E, r.total += E, E && (t.adler = r.check = r.flags ? o(r.check, d, E, b - E) : i(r.check, d, E, b - E)), E = y, (r.flags ? g : l(g)) !== r.check) {
                  t.msg = "incorrect data check", r.mode = f;
                  break
                }
                g = 0, v = 0
              }
              r.mode = 28;
            case 28:
              if (r.wrap && r.flags) {
                for (; 32 > v;) {
                  if (0 === m) break t;
                  m--, g += h[p++] << v, v += 8
                }
                if (g !== (4294967295 & r.total)) {
                  t.msg = "incorrect length check", r.mode = f;
                  break
                }
                g = 0, v = 0
              }
              r.mode = 29;
            case 29:
              R = 1;
              break t;
            case f:
              R = -3;
              break t;
            case 31:
              return -4;
            default:
              return u
          }
          return t.next_out = b, t.avail_out = y, t.next_in = p, t.avail_in = m, r.hold = g, r.bits = v, (r.wsize || E !== t.avail_out && r.mode < f && (27 > r.mode || 4 !== e)) && A(t, t.output, t.next_out, E - t.avail_out) ? (r.mode = 31, -4) : (T -= t.avail_in, E -= t.avail_out, t.total_in += T, t.total_out += E, r.total += E, r.wrap && E && (t.adler = r.check = r.flags ? o(r.check, d, E, t.next_out - E) : i(r.check, d, E, t.next_out - E)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === c ? 128 : 0) + (20 === r.mode || 15 === r.mode ? 256 : 0), (0 === T && 0 === E || 4 === e) && 0 === R && (R = -5), R)
        }, e.inflateEnd = function(t) {
          if (!t || !t.state) return u;
          var e = t.state;
          return e.window && (e.window = null), t.state = null, 0
        }, e.inflateGetHeader = function(t, e) {
          var r;
          return t && t.state && 2 & (r = t.state).wrap ? (r.head = e, e.done = !1, 0) : u
        }, e.inflateSetDictionary = function(t, e) {
          var r, n = e.length;
          return t && t.state && (0 === (r = t.state).wrap || 11 === r.mode) ? 11 === r.mode && i(1, e, n, 0) !== r.check ? -3 : A(t, e, n, n) ? (r.mode = 31, -4) : (r.havedict = 1, 0) : u
        }, e.inflateInfo = "pako inflate (from Nodeca project)"
      },
      71514: t => {
        "use strict";
        t.exports = Math.abs
      },
      71629: function(t, e, r) {
        "use strict";
        var n, i = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.ExternalAddress = void 0;
        const o = i(r(29107));
        class s {
          static isAddress(t) {
            return t instanceof s
          }
          constructor(t, e) {
            this[n] = () => this.toString(), this.value = t, this.bits = e
          }
          toString() {
            return `External<${this.bits}:${this.value}>`
          }
        }
        e.ExternalAddress = s, n = o.default
      },
      71784: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.packExtraCurrencyCell = e.packExtraCurrencyDict = e.storeExtraCurrency = e.loadMaybeExtraCurrency = e.loadExtraCurrency = void 0;
        const n = r(65871),
          i = r(97590);

        function o(t) {
          let e = t instanceof i.Dictionary ? t : i.Dictionary.loadDirect(i.Dictionary.Keys.Uint(32), i.Dictionary.Values.BigVarUint(5), t),
            r = {};
          for (let [t, n] of e) r[t] = n;
          return r
        }

        function s(t) {
          const e = i.Dictionary.empty(i.Dictionary.Keys.Uint(32), i.Dictionary.Values.BigVarUint(5));
          return Object.entries(t).map(([t, r]) => e.set(+t, r)), e
        }
        e.loadExtraCurrency = o, e.loadMaybeExtraCurrency = function(t) {
          const e = t.loadMaybeRef();
          return null === e ? e : o(e)
        }, e.storeExtraCurrency = function(t) {
          return e => {
            e.storeDict(s(t))
          }
        }, e.packExtraCurrencyDict = s, e.packExtraCurrencyCell = function(t) {
          return (0, n.beginCell)().storeDictDirect(s(t)).endCell()
        }
      },
      71843: (t, e, r) => {
        "use strict";
        const {
          ErrorWithCause: n
        } = r(75832), {
          findCauseByReference: i,
          getErrorCause: o,
          messageWithCauses: s,
          stackWithCauses: a
        } = r(94306);
        t.exports = {
          ErrorWithCause: n,
          findCauseByReference: i,
          getErrorCause: o,
          stackWithCauses: a,
          messageWithCauses: s
        }
      },
      71902: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV2R1 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey)
          }
          constructor(t, e) {
            this.workchain = t, this.publicKey = e;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEAVwAAqv8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VShNwu2", "base64"))[0],
              o = (0, i.beginCell)().storeUint(0, 32).storeBuffer(e).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(t, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            let e = i.SendMode.PAY_GAS_SEPARATELY;
            return null !== t.sendMode && void 0 !== t.sendMode && (e = t.sendMode), (0, o.createWalletTransferV2)({
              seqno: t.seqno,
              sendMode: e,
              secretKey: t.secretKey,
              messages: t.messages,
              timeout: t.timeout
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV2R1 = s
      },
      72111: (t, e, r) => {
        const n = r(94641),
          i = r(13999),
          o = r(35580),
          s = r(54089),
          a = r(7059),
          u = r(25200);
        t.exports = (t, e, r, c) => {
          switch (e) {
            case "===":
              return "object" == typeof t && (t = t.version), "object" == typeof r && (r = r.version), t === r;
            case "!==":
              return "object" == typeof t && (t = t.version), "object" == typeof r && (r = r.version), t !== r;
            case "":
            case "=":
            case "==":
              return n(t, r, c);
            case "!=":
              return i(t, r, c);
            case ">":
              return o(t, r, c);
            case ">=":
              return s(t, r, c);
            case "<":
              return a(t, r, c);
            case "<=":
              return u(t, r, c);
            default:
              throw new TypeError("Invalid operator: " + e)
          }
        }
      },
      72271: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(36556),
          o = r(58859),
          s = r(80507),
          a = r(69675),
          u = n("%WeakMap%", !0),
          c = i("WeakMap.prototype.get", !0),
          f = i("WeakMap.prototype.set", !0),
          l = i("WeakMap.prototype.has", !0),
          h = i("WeakMap.prototype.delete", !0);
        t.exports = u ? function() {
          var t, e, r = {
            assert: function(t) {
              if (!r.has(t)) throw new a("Side channel does not contain " + o(t))
            },
            delete: function(r) {
              if (u && r && ("object" == typeof r || "function" == typeof r)) {
                if (t) return h(t, r)
              } else if (s && e) return e.delete(r);
              return !1
            },
            get: function(r) {
              return u && r && ("object" == typeof r || "function" == typeof r) && t ? c(t, r) : e && e.get(r)
            },
            has: function(r) {
              return u && r && ("object" == typeof r || "function" == typeof r) && t ? l(t, r) : !!e && e.has(r)
            },
            set: function(r, n) {
              u && r && ("object" == typeof r || "function" == typeof r) ? (t || (t = new u), f(t, r, n)) : s && (e || (e = s()), e.set(r, n))
            }
          };
          return r
        } : s
      },
      72516: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.tuple = e.getTupleElements = void 0;
        const n = r(65534),
          i = r(49334),
          o = r(34175),
          s = /^\((.+)\)$/u;
        e.getTupleElements = t => {
          (0, n.assert)(t.startsWith("(") && t.endsWith(")"), new i.ParserError(`Invalid tuple type. Expected tuple type, but received "${t}".`));
          const e = [];
          let r = "",
            o = 0;
          for (let n = 1; n < t.length - 1; n++) {
            const i = t[n];
            "," === i && 0 === o ? (e.push(r.trim()), r = "") : (r += i, "(" === i ? o += 1 : ")" === i && (o -= 1))
          }
          return r.trim() && e.push(r.trim()), e
        }, e.tuple = {
          isDynamic: t => (0, e.getTupleElements)(t).some(t => {
            const e = (0, o.getParser)(t);
            return (0, o.isDynamicParser)(e, t)
          }),
          isType: t => (t => s.test(t))(t),
          getByteLength(t) {
            return (0, o.isDynamicParser)(this, t) ? 32 : (0, e.getTupleElements)(t).reduce((t, e) => t + (0, o.getParser)(e).getByteLength(e), 0)
          },
          encode({
            type: t,
            buffer: r,
            value: n,
            packed: i,
            tight: s
          }) {
            const a = (0, e.getTupleElements)(t);
            return (0, o.pack)({
              types: a,
              values: n,
              byteArray: r,
              packed: i,
              tight: s
            })
          },
          decode({
            type: t,
            value: r,
            skip: n
          }) {
            const i = (0, e.getTupleElements)(t);
            return n(this.getByteLength(t) - 32), (0, o.unpack)(i, r)
          }
        }
      },
      72525: (t, e, r) => {
        const n = r(97638),
          i = r(50560);
        t.exports = (t, e, r) => {
          const o = [];
          let s = null,
            a = null;
          const u = t.sort((t, e) => i(t, e, r));
          for (const t of u) n(t, e, r) ? (a = t, s || (s = t)) : (a && o.push([s, a]), a = null, s = null);
          s && o.push([s, null]);
          const c = [];
          for (const [t, e] of o) t === e ? c.push(t) : e || t !== u[0] ? e ? t === u[0] ? c.push("<=" + e) : c.push(`${t} - ${e}`) : c.push(">=" + t) : c.push("*");
          const f = c.join(" || "),
            l = "string" == typeof e.raw ? e.raw : e + "";
          return f.length < l.length ? f : e
        }
      },
      72576: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e, r) {
          return (0, i.default)(t), "[object RegExp]" !== {}.toString.call(e) && (e = RegExp(e, r)), !!t.match(e)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      72830: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /[^\x00-\x7F]/;
        t.exports = e.default, t.exports.default = e.default
      },
      73065: function(t, e, r) {
        var n, i;
        ! function() {
          "use strict";
          n = function() {
            var t = function() {},
              e = "undefined",
              r = typeof window !== e && typeof window.navigator !== e && /Trident\/|MSIE /.test(window.navigator.userAgent),
              n = ["trace", "debug", "info", "warn", "error"],
              i = {},
              o = null;

            function s(t, e) {
              var r = t[e];
              if ("function" == typeof r.bind) return r.bind(t);
              try {
                return function() {}.bind.call(r, t)
              } catch {
                return function() {
                  return function() {}.apply.call(r, t, arguments)
                }
              }
            }

            function a() {
              console.log && (console.log.apply ? console.log.apply(console, arguments) : function() {}.apply.call(console.log, console, arguments)), console.trace && console.trace()
            }

            function u() {
              for (var r = this.getLevel(), i = 0; n.length > i; i++) {
                var o = n[i];
                this[o] = r > i ? t : this.methodFactory(o, r, this.name)
              }
              if (this.log = this.debug, typeof console === e && r < this.levels.SILENT) return "No console available for logging"
            }

            function c(t) {
              return function() {
                typeof console !== e && (u.call(this), this[t].apply(this, arguments))
              }
            }

            function f(n, i, o) {
              return function(n) {
                return "debug" === n && (n = "log"), typeof console !== e && ("trace" === n && r ? a : void 0 !== console[n] ? s(console, n) : void 0 !== console.log ? s(console, "log") : t)
              }(n) || c.apply(this, arguments)
            }

            function l(t, r) {
              var s, a, c, l = this,
                h = "loglevel";

              function d() {
                var t;
                if (typeof window !== e && h) {
                  try {
                    t = window.localStorage[h]
                  } catch {}
                  if (typeof t === e) try {
                    var r = window.document.cookie,
                      n = encodeURIComponent(h),
                      i = r.indexOf(n + "="); - 1 !== i && (t = /^([^;]+)/.exec(r.slice(i + n.length + 1))[1])
                  } catch {}
                  return void 0 === l.levels[t] && (t = void 0), t
                }
              }

              function p(t) {
                var e = t;
                if ("string" == typeof e && void 0 !== l.levels[e.toUpperCase()] && (e = l.levels[e.toUpperCase()]), "number" == typeof e && e >= 0 && e <= l.levels.SILENT) return e;
                throw new TypeError("log.setLevel() called with invalid level: " + t)
              }
              "string" == typeof t ? h += ":" + t : "symbol" == typeof t && (h = void 0), l.name = t, l.levels = {
                TRACE: 0,
                DEBUG: 1,
                INFO: 2,
                WARN: 3,
                ERROR: 4,
                SILENT: 5
              }, l.methodFactory = r || f, l.getLevel = function() {
                return c ?? a ?? s
              }, l.setLevel = function(t, r) {
                return c = p(t), !1 !== r && function(t) {
                  var r = (n[t] || "silent").toUpperCase();
                  if (typeof window !== e && h) {
                    try {
                      return void(window.localStorage[h] = r)
                    } catch {}
                    try {
                      window.document.cookie = encodeURIComponent(h) + "=" + r + ";"
                    } catch {}
                  }
                }(c), u.call(l)
              }, l.setDefaultLevel = function(t) {
                a = p(t), d() || l.setLevel(t, !1)
              }, l.resetLevel = function() {
                c = null,
                  function() {
                    if (typeof window !== e && h) {
                      try {
                        window.localStorage.removeItem(h)
                      } catch {}
                      try {
                        window.document.cookie = encodeURIComponent(h) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC"
                      } catch {}
                    }
                  }(), u.call(l)
              }, l.enableAll = function(t) {
                l.setLevel(l.levels.TRACE, t)
              }, l.disableAll = function(t) {
                l.setLevel(l.levels.SILENT, t)
              }, l.rebuild = function() {
                if (o !== l && (s = p(o.getLevel())), u.call(l), o === l)
                  for (var t in i) i[t].rebuild()
              }, s = p(o ? o.getLevel() : "WARN");
              var b = d();
              null != b && (c = p(b)), u.call(l)
            }(o = new l).getLogger = function(t) {
              if ("symbol" != typeof t && "string" != typeof t || "" === t) throw new TypeError("You must supply a name when creating a logger.");
              var e = i[t];
              return e || (e = i[t] = new l(t, o.methodFactory)), e
            };
            var h = typeof window !== e ? window.log : void 0;
            return o.noConflict = function() {
              return typeof window !== e && window.log === o && (window.log = h), o
            }, o.getLoggers = function() {
              return i
            }, o.default = o, o
          }, void 0 !== (i = n()) && (t.exports = i)
        }()
      },
      73093: (t, e, r) => {
        "use strict";
        var n = r(94459);
        t.exports = function(t) {
          return n(t) || 0 === t ? t : 0 > t ? -1 : 1
        }
      },
      73126: (t, e, r) => {
        "use strict";
        var n = r(66743),
          i = r(69675),
          o = r(10076),
          s = r(13144);
        t.exports = function(t) {
          if (1 > t.length || "function" != typeof t[0]) throw new i("a function is required");
          return s(n, o, t)
        }
      },
      73150: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha256 = void 0, e.sha256 = async function(t) {
          return "string" == typeof t ? n.from(await crypto.subtle.digest("SHA-256", n.from(t, "utf-8"))) : n.from(await crypto.subtle.digest("SHA-256", t))
        }
      },
      73255: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(65165), e)
      },
      73289: (t, e, r) => {
        "use strict";
        const n = r(24253).v4;
        t.exports = function(t, e, r, i) {
          if ("string" != typeof t) throw new TypeError(t + " must be a string");
          const o = "number" == typeof(i = i || {}).version ? i.version : 2;
          if (1 !== o && 2 !== o) throw new TypeError(o + " must be 1 or 2");
          const s = {
            method: t
          };
          if (2 === o && (s.jsonrpc = "2.0"), e) {
            if ("object" != typeof e && !Array.isArray(e)) throw new TypeError(e + " must be an object, array or omitted");
            s.params = e
          }
          if (typeof r > "u") {
            const t = "function" == typeof i.generator ? i.generator : function() {
              return n()
            };
            s.id = t(s, i)
          } else 2 === o && null === r ? i.notificationIdNull && (s.id = null) : s.id = r;
          return s
        }
      },
      73583: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, i.default)(t);
          var e = t.split(",");
          if (2 > e.length) return !1;
          var r = e.shift().trim().split(";"),
            n = r.shift();
          if ("data:" !== n.slice(0, 5)) return !1;
          var u = n.slice(5);
          if ("" !== u && !o.test(u)) return !1;
          for (var c = 0; c < r.length; c++)
            if ((c !== r.length - 1 || "base64" !== r[c].toLowerCase()) && !s.test(r[c])) return !1;
          for (var f = 0; f < e.length; f++)
            if (!a.test(e[f])) return !1;
          return !0
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[a-z]+\/[a-z0-9\-\+\._]+$/i,
          s = /^[a-z\-]+=[a-z0-9\-]+$/i,
          a = /^[a-z0-9!\$&'\(\)\*\+,;=\-\._~:@\/\?%\s]*$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      73604: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          o = this && this.St || (Object.create ? function(t, e) {
            Object.defineProperty(t, "default", {
              enumerable: !0,
              value: e
            })
          } : function(t, e) {
            t.default = e
          }),
          s = this && this.Ot || function(t) {
            if (t && t._) return t;
            var e = {};
            if (null != t)
              for (var r in t) "default" !== r && {}.hasOwnProperty.call(t, r) && i(e, t, r);
            return o(e, t), e
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getEncryptionPublicKey = e.decryptSafely = e.decrypt = e.encryptSafely = e.encrypt = void 0;
        const a = r(63203),
          u = s(r(88947)),
          c = r(43007);

        function f({
          publicKey: t,
          data: e,
          version: r
        }) {
          if ((0, c.isNullish)(t)) throw Error("Missing publicKey parameter");
          if ((0, c.isNullish)(e)) throw Error("Missing data parameter");
          if ((0, c.isNullish)(r)) throw Error("Missing version parameter");
          if ("x25519-xsalsa20-poly1305" === r) {
            if ("string" != typeof e) throw Error("Message data must be given as a string");
            const r = u.box.keyPair();
            let n;
            try {
              n = a.base64.decode(t)
            } catch {
              throw Error("Bad public key")
            }
            const i = a.utf8.decode(e),
              o = u.randomBytes(u.box.nonceLength),
              s = u.box(i, o, n, r.secretKey);
            return {
              version: "x25519-xsalsa20-poly1305",
              nonce: a.base64.encode(o),
              ephemPublicKey: a.base64.encode(r.publicKey),
              ciphertext: a.base64.encode(s)
            }
          }
          throw Error("Encryption type/version not supported")
        }

        function l({
          encryptedData: t,
          privateKey: e
        }) {
          if ((0, c.isNullish)(t)) throw Error("Missing encryptedData parameter");
          if ((0, c.isNullish)(e)) throw Error("Missing privateKey parameter");
          if ("x25519-xsalsa20-poly1305" === t.version) {
            const r = n.from(e, "hex"),
              i = u.box.keyPair.fromSecretKey(r).secretKey,
              o = a.base64.decode(t.nonce),
              s = a.base64.decode(t.ciphertext),
              c = a.base64.decode(t.ephemPublicKey),
              f = u.box.open(s, o, c, i);
            try {
              if (!f) throw Error();
              const t = a.utf8.encode(f);
              if (!t) throw Error();
              return t
            } catch (t) {
              throw t && "string" == typeof t.message && t.message.length ? Error("Decryption failed: " + t.message) : Error("Decryption failed.")
            }
          }
          throw Error("Encryption type/version not supported.")
        }
        e.encrypt = f, e.encryptSafely = function({
          publicKey: t,
          data: e,
          version: r
        }) {
          if ((0, c.isNullish)(t)) throw Error("Missing publicKey parameter");
          if ((0, c.isNullish)(e)) throw Error("Missing data parameter");
          if ((0, c.isNullish)(r)) throw Error("Missing version parameter");
          if ("object" == typeof e && e && "toJSON" in e) throw Error("Cannot encrypt with toJSON property.  Please remove toJSON property");
          const i = {
              data: e,
              padding: ""
            },
            o = n.byteLength(JSON.stringify(i), "utf-8") % 2048;
          let s = 0;
          return o > 0 && (s = 2048 - o - 16), i.padding = "0".repeat(s), f({
            publicKey: t,
            data: JSON.stringify(i),
            version: r
          })
        }, e.decrypt = l, e.decryptSafely = function({
          encryptedData: t,
          privateKey: e
        }) {
          if ((0, c.isNullish)(t)) throw Error("Missing encryptedData parameter");
          if ((0, c.isNullish)(e)) throw Error("Missing privateKey parameter");
          return JSON.parse(l({
            encryptedData: t,
            privateKey: e
          })).data
        }, e.getEncryptionPublicKey = function(t) {
          const e = n.from(t, "hex"),
            r = u.box.keyPair.fromSecretKey(e).publicKey;
          return a.base64.encode(r)
        }
      },
      73609: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          (0, i.default)(t);
          for (var e, r, n, o = t.replace(/[- ]+/g, ""), s = 0, a = o.length - 1; a >= 0; a--) e = o.substring(a, a + 1), r = parseInt(e, 10), n ? 10 > (r *= 2) ? s += r : s += r % 10 + 1 : s += r, n = !n;
          return !(s % 10 != 0 || !o)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      73622: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("TronWebProto.AssetIssueContract", null, o), i.exportSymbol("TronWebProto.AssetIssueContract.FrozenSupply", null, o), i.exportSymbol("TronWebProto.ParticipateAssetIssueContract", null, o), i.exportSymbol("TronWebProto.TransferAssetContract", null, o), i.exportSymbol("TronWebProto.UnfreezeAssetContract", null, o), i.exportSymbol("TronWebProto.UpdateAssetContract", null, o), TronWebProto.AssetIssueContract = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.AssetIssueContract.repeatedFields_, null)
        }, i.inherits(TronWebProto.AssetIssueContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.displayName = "TronWebProto.AssetIssueContract"), TronWebProto.AssetIssueContract.FrozenSupply = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AssetIssueContract.FrozenSupply, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AssetIssueContract.FrozenSupply.displayName = "TronWebProto.AssetIssueContract.FrozenSupply"), TronWebProto.TransferAssetContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.TransferAssetContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.TransferAssetContract.displayName = "TronWebProto.TransferAssetContract"), TronWebProto.UnfreezeAssetContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UnfreezeAssetContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UnfreezeAssetContract.displayName = "TronWebProto.UnfreezeAssetContract"), TronWebProto.UpdateAssetContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UpdateAssetContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UpdateAssetContract.displayName = "TronWebProto.UpdateAssetContract"), TronWebProto.ParticipateAssetIssueContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ParticipateAssetIssueContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ParticipateAssetIssueContract.displayName = "TronWebProto.ParticipateAssetIssueContract"), TronWebProto.AssetIssueContract.repeatedFields_ = [5], n.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.prototype.toObject = function(t) {
          return TronWebProto.AssetIssueContract.toObject(t, this)
        }, TronWebProto.AssetIssueContract.toObject = function(t, e) {
          var r = {
            id: n.Message.getFieldWithDefault(e, 41, ""),
            ownerAddress: e.getOwnerAddress_asB64(),
            name: e.getName_asB64(),
            abbr: e.getAbbr_asB64(),
            totalSupply: n.Message.getFieldWithDefault(e, 4, 0),
            frozenSupplyList: n.Message.toObjectList(e.getFrozenSupplyList(), TronWebProto.AssetIssueContract.FrozenSupply.toObject, t),
            trxNum: n.Message.getFieldWithDefault(e, 6, 0),
            precision: n.Message.getFieldWithDefault(e, 7, 0),
            num: n.Message.getFieldWithDefault(e, 8, 0),
            startTime: n.Message.getFieldWithDefault(e, 9, 0),
            endTime: n.Message.getFieldWithDefault(e, 10, 0),
            order: n.Message.getFieldWithDefault(e, 11, 0),
            voteScore: n.Message.getFieldWithDefault(e, 16, 0),
            description: e.getDescription_asB64(),
            url: e.getUrl_asB64(),
            freeAssetNetLimit: n.Message.getFieldWithDefault(e, 22, 0),
            publicFreeAssetNetLimit: n.Message.getFieldWithDefault(e, 23, 0),
            publicFreeAssetNetUsage: n.Message.getFieldWithDefault(e, 24, 0),
            publicLatestFreeNetTime: n.Message.getFieldWithDefault(e, 25, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AssetIssueContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AssetIssueContract;
          return TronWebProto.AssetIssueContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AssetIssueContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 41:
              var r = e.readString();
              t.setId(r);
              break;
            case 1:
              r = e.readBytes(), t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setName(r);
              break;
            case 3:
              r = e.readBytes(), t.setAbbr(r);
              break;
            case 4:
              r = e.readInt64(), t.setTotalSupply(r);
              break;
            case 5:
              r = new TronWebProto.AssetIssueContract.FrozenSupply, e.readMessage(r, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader), t.addFrozenSupply(r);
              break;
            case 6:
              r = e.readInt32(), t.setTrxNum(r);
              break;
            case 7:
              r = e.readInt32(), t.setPrecision(r);
              break;
            case 8:
              r = e.readInt32(), t.setNum(r);
              break;
            case 9:
              r = e.readInt64(), t.setStartTime(r);
              break;
            case 10:
              r = e.readInt64(), t.setEndTime(r);
              break;
            case 11:
              r = e.readInt64(), t.setOrder(r);
              break;
            case 16:
              r = e.readInt32(), t.setVoteScore(r);
              break;
            case 20:
              r = e.readBytes(), t.setDescription(r);
              break;
            case 21:
              r = e.readBytes(), t.setUrl(r);
              break;
            case 22:
              r = e.readInt64(), t.setFreeAssetNetLimit(r);
              break;
            case 23:
              r = e.readInt64(), t.setPublicFreeAssetNetLimit(r);
              break;
            case 24:
              r = e.readInt64(), t.setPublicFreeAssetNetUsage(r);
              break;
            case 25:
              r = e.readInt64(), t.setPublicLatestFreeNetTime(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AssetIssueContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AssetIssueContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AssetIssueContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getId()).length > 0 && e.writeString(41, r), (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getName_asU8()).length > 0 && e.writeBytes(2, r), (r = t.getAbbr_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getTotalSupply()) && e.writeInt64(4, r), (r = t.getFrozenSupplyList()).length > 0 && e.writeRepeatedMessage(5, r, TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter), 0 !== (r = t.getTrxNum()) && e.writeInt32(6, r), 0 !== (r = t.getPrecision()) && e.writeInt32(7, r), 0 !== (r = t.getNum()) && e.writeInt32(8, r), 0 !== (r = t.getStartTime()) && e.writeInt64(9, r), 0 !== (r = t.getEndTime()) && e.writeInt64(10, r), 0 !== (r = t.getOrder()) && e.writeInt64(11, r), 0 !== (r = t.getVoteScore()) && e.writeInt32(16, r), (r = t.getDescription_asU8()).length > 0 && e.writeBytes(20, r), (r = t.getUrl_asU8()).length > 0 && e.writeBytes(21, r), 0 !== (r = t.getFreeAssetNetLimit()) && e.writeInt64(22, r), 0 !== (r = t.getPublicFreeAssetNetLimit()) && e.writeInt64(23, r), 0 !== (r = t.getPublicFreeAssetNetUsage()) && e.writeInt64(24, r), 0 !== (r = t.getPublicLatestFreeNetTime()) && e.writeInt64(25, r)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.AssetIssueContract.FrozenSupply.prototype.toObject = function(t) {
          return TronWebProto.AssetIssueContract.FrozenSupply.toObject(t, this)
        }, TronWebProto.AssetIssueContract.FrozenSupply.toObject = function(t, e) {
          var r = {
            frozenAmount: n.Message.getFieldWithDefault(e, 1, 0),
            frozenDays: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AssetIssueContract.FrozenSupply;
          return TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AssetIssueContract.FrozenSupply.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setFrozenAmount(r);
              break;
            case 2:
              r = e.readInt64(), t.setFrozenDays(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AssetIssueContract.FrozenSupply.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AssetIssueContract.FrozenSupply.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getFrozenAmount()) && e.writeInt64(1, r), 0 !== (r = t.getFrozenDays()) && e.writeInt64(2, r)
        }, TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenAmount = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenAmount = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.AssetIssueContract.FrozenSupply.prototype.getFrozenDays = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.AssetIssueContract.FrozenSupply.prototype.setFrozenDays = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.AssetIssueContract.prototype.getId = function() {
          return n.Message.getFieldWithDefault(this, 41, "")
        }, TronWebProto.AssetIssueContract.prototype.setId = function(t) {
          return n.Message.setProto3StringField(this, 41, t)
        }, TronWebProto.AssetIssueContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.AssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.AssetIssueContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.AssetIssueContract.prototype.getName = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.AssetIssueContract.prototype.getName_asB64 = function() {
          return n.Message.bytesAsB64(this.getName())
        }, TronWebProto.AssetIssueContract.prototype.getName_asU8 = function() {
          return n.Message.bytesAsU8(this.getName())
        }, TronWebProto.AssetIssueContract.prototype.setName = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.AssetIssueContract.prototype.getAbbr = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.AssetIssueContract.prototype.getAbbr_asB64 = function() {
          return n.Message.bytesAsB64(this.getAbbr())
        }, TronWebProto.AssetIssueContract.prototype.getAbbr_asU8 = function() {
          return n.Message.bytesAsU8(this.getAbbr())
        }, TronWebProto.AssetIssueContract.prototype.setAbbr = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.AssetIssueContract.prototype.getTotalSupply = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.AssetIssueContract.prototype.setTotalSupply = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.AssetIssueContract.prototype.getFrozenSupplyList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.AssetIssueContract.FrozenSupply, 5)
        }, TronWebProto.AssetIssueContract.prototype.setFrozenSupplyList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 5, t)
        }, TronWebProto.AssetIssueContract.prototype.addFrozenSupply = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 5, t, TronWebProto.AssetIssueContract.FrozenSupply, e)
        }, TronWebProto.AssetIssueContract.prototype.clearFrozenSupplyList = function() {
          return this.setFrozenSupplyList([])
        }, TronWebProto.AssetIssueContract.prototype.getTrxNum = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.AssetIssueContract.prototype.setTrxNum = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, TronWebProto.AssetIssueContract.prototype.getPrecision = function() {
          return n.Message.getFieldWithDefault(this, 7, 0)
        }, TronWebProto.AssetIssueContract.prototype.setPrecision = function(t) {
          return n.Message.setProto3IntField(this, 7, t)
        }, TronWebProto.AssetIssueContract.prototype.getNum = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.AssetIssueContract.prototype.setNum = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.AssetIssueContract.prototype.getStartTime = function() {
          return n.Message.getFieldWithDefault(this, 9, 0)
        }, TronWebProto.AssetIssueContract.prototype.setStartTime = function(t) {
          return n.Message.setProto3IntField(this, 9, t)
        }, TronWebProto.AssetIssueContract.prototype.getEndTime = function() {
          return n.Message.getFieldWithDefault(this, 10, 0)
        }, TronWebProto.AssetIssueContract.prototype.setEndTime = function(t) {
          return n.Message.setProto3IntField(this, 10, t)
        }, TronWebProto.AssetIssueContract.prototype.getOrder = function() {
          return n.Message.getFieldWithDefault(this, 11, 0)
        }, TronWebProto.AssetIssueContract.prototype.setOrder = function(t) {
          return n.Message.setProto3IntField(this, 11, t)
        }, TronWebProto.AssetIssueContract.prototype.getVoteScore = function() {
          return n.Message.getFieldWithDefault(this, 16, 0)
        }, TronWebProto.AssetIssueContract.prototype.setVoteScore = function(t) {
          return n.Message.setProto3IntField(this, 16, t)
        }, TronWebProto.AssetIssueContract.prototype.getDescription = function() {
          return n.Message.getFieldWithDefault(this, 20, "")
        }, TronWebProto.AssetIssueContract.prototype.getDescription_asB64 = function() {
          return n.Message.bytesAsB64(this.getDescription())
        }, TronWebProto.AssetIssueContract.prototype.getDescription_asU8 = function() {
          return n.Message.bytesAsU8(this.getDescription())
        }, TronWebProto.AssetIssueContract.prototype.setDescription = function(t) {
          return n.Message.setProto3BytesField(this, 20, t)
        }, TronWebProto.AssetIssueContract.prototype.getUrl = function() {
          return n.Message.getFieldWithDefault(this, 21, "")
        }, TronWebProto.AssetIssueContract.prototype.getUrl_asB64 = function() {
          return n.Message.bytesAsB64(this.getUrl())
        }, TronWebProto.AssetIssueContract.prototype.getUrl_asU8 = function() {
          return n.Message.bytesAsU8(this.getUrl())
        }, TronWebProto.AssetIssueContract.prototype.setUrl = function(t) {
          return n.Message.setProto3BytesField(this, 21, t)
        }, TronWebProto.AssetIssueContract.prototype.getFreeAssetNetLimit = function() {
          return n.Message.getFieldWithDefault(this, 22, 0)
        }, TronWebProto.AssetIssueContract.prototype.setFreeAssetNetLimit = function(t) {
          return n.Message.setProto3IntField(this, 22, t)
        }, TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetLimit = function() {
          return n.Message.getFieldWithDefault(this, 23, 0)
        }, TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetLimit = function(t) {
          return n.Message.setProto3IntField(this, 23, t)
        }, TronWebProto.AssetIssueContract.prototype.getPublicFreeAssetNetUsage = function() {
          return n.Message.getFieldWithDefault(this, 24, 0)
        }, TronWebProto.AssetIssueContract.prototype.setPublicFreeAssetNetUsage = function(t) {
          return n.Message.setProto3IntField(this, 24, t)
        }, TronWebProto.AssetIssueContract.prototype.getPublicLatestFreeNetTime = function() {
          return n.Message.getFieldWithDefault(this, 25, 0)
        }, TronWebProto.AssetIssueContract.prototype.setPublicLatestFreeNetTime = function(t) {
          return n.Message.setProto3IntField(this, 25, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.TransferAssetContract.prototype.toObject = function(t) {
          return TronWebProto.TransferAssetContract.toObject(t, this)
        }, TronWebProto.TransferAssetContract.toObject = function(t, e) {
          var r = {
            assetName: e.getAssetName_asB64(),
            ownerAddress: e.getOwnerAddress_asB64(),
            toAddress: e.getToAddress_asB64(),
            amount: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.TransferAssetContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.TransferAssetContract;
          return TronWebProto.TransferAssetContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.TransferAssetContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAssetName(r);
              break;
            case 2:
              r = e.readBytes(), t.setOwnerAddress(r);
              break;
            case 3:
              r = e.readBytes(), t.setToAddress(r);
              break;
            case 4:
              r = e.readInt64(), t.setAmount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.TransferAssetContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.TransferAssetContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.TransferAssetContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAssetName_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(2, r), (r = t.getToAddress_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getAmount()) && e.writeInt64(4, r)
        }, TronWebProto.TransferAssetContract.prototype.getAssetName = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.TransferAssetContract.prototype.getAssetName_asB64 = function() {
          return n.Message.bytesAsB64(this.getAssetName())
        }, TronWebProto.TransferAssetContract.prototype.getAssetName_asU8 = function() {
          return n.Message.bytesAsU8(this.getAssetName())
        }, TronWebProto.TransferAssetContract.prototype.setAssetName = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.TransferAssetContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.TransferAssetContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.TransferAssetContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.TransferAssetContract.prototype.getToAddress = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.TransferAssetContract.prototype.getToAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getToAddress())
        }, TronWebProto.TransferAssetContract.prototype.getToAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getToAddress())
        }, TronWebProto.TransferAssetContract.prototype.setToAddress = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.TransferAssetContract.prototype.getAmount = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.TransferAssetContract.prototype.setAmount = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UnfreezeAssetContract.prototype.toObject = function(t) {
          return TronWebProto.UnfreezeAssetContract.toObject(t, this)
        }, TronWebProto.UnfreezeAssetContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UnfreezeAssetContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UnfreezeAssetContract;
          return TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UnfreezeAssetContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = e.readBytes();
              t.setOwnerAddress(r)
            } else e.skipField();
          return t
        }, TronWebProto.UnfreezeAssetContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UnfreezeAssetContract.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r)
        }, TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UnfreezeAssetContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UnfreezeAssetContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateAssetContract.prototype.toObject = function(t) {
          return TronWebProto.UpdateAssetContract.toObject(t, this)
        }, TronWebProto.UpdateAssetContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            description: e.getDescription_asB64(),
            url: e.getUrl_asB64(),
            newLimit: n.Message.getFieldWithDefault(e, 4, 0),
            newPublicLimit: n.Message.getFieldWithDefault(e, 5, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UpdateAssetContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UpdateAssetContract;
          return TronWebProto.UpdateAssetContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UpdateAssetContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setDescription(r);
              break;
            case 3:
              r = e.readBytes(), t.setUrl(r);
              break;
            case 4:
              r = e.readInt64(), t.setNewLimit(r);
              break;
            case 5:
              r = e.readInt64(), t.setNewPublicLimit(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UpdateAssetContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UpdateAssetContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UpdateAssetContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getDescription_asU8()).length > 0 && e.writeBytes(2, r), (r = t.getUrl_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getNewLimit()) && e.writeInt64(4, r), 0 !== (r = t.getNewPublicLimit()) && e.writeInt64(5, r)
        }, TronWebProto.UpdateAssetContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UpdateAssetContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UpdateAssetContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UpdateAssetContract.prototype.getDescription = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.UpdateAssetContract.prototype.getDescription_asB64 = function() {
          return n.Message.bytesAsB64(this.getDescription())
        }, TronWebProto.UpdateAssetContract.prototype.getDescription_asU8 = function() {
          return n.Message.bytesAsU8(this.getDescription())
        }, TronWebProto.UpdateAssetContract.prototype.setDescription = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.UpdateAssetContract.prototype.getUrl = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.UpdateAssetContract.prototype.getUrl_asB64 = function() {
          return n.Message.bytesAsB64(this.getUrl())
        }, TronWebProto.UpdateAssetContract.prototype.getUrl_asU8 = function() {
          return n.Message.bytesAsU8(this.getUrl())
        }, TronWebProto.UpdateAssetContract.prototype.setUrl = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.UpdateAssetContract.prototype.getNewLimit = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.UpdateAssetContract.prototype.setNewLimit = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.UpdateAssetContract.prototype.getNewPublicLimit = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.UpdateAssetContract.prototype.setNewPublicLimit = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ParticipateAssetIssueContract.prototype.toObject = function(t) {
          return TronWebProto.ParticipateAssetIssueContract.toObject(t, this)
        }, TronWebProto.ParticipateAssetIssueContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            toAddress: e.getToAddress_asB64(),
            assetName: e.getAssetName_asB64(),
            amount: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ParticipateAssetIssueContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ParticipateAssetIssueContract;
          return TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ParticipateAssetIssueContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setToAddress(r);
              break;
            case 3:
              r = e.readBytes(), t.setAssetName(r);
              break;
            case 4:
              r = e.readInt64(), t.setAmount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ParticipateAssetIssueContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ParticipateAssetIssueContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getToAddress_asU8()).length > 0 && e.writeBytes(2, r), (r = t.getAssetName_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getAmount()) && e.writeInt64(4, r)
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getToAddress())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getToAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getToAddress())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.setToAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asB64 = function() {
          return n.Message.bytesAsB64(this.getAssetName())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getAssetName_asU8 = function() {
          return n.Message.bytesAsU8(this.getAssetName())
        }, TronWebProto.ParticipateAssetIssueContract.prototype.setAssetName = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.ParticipateAssetIssueContract.prototype.getAmount = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.ParticipateAssetIssueContract.prototype.setAmount = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, i.object.extend(e, TronWebProto)
      },
      73814: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.loadSimpleLibrary = e.loadShardStateUnsplit = e.storeShardIdent = e.loadShardIdent = e.storeShardAccounts = e.loadShardAccounts = e.ShardAccountRefValue = e.storeShardAccount = e.loadShardAccount = e.ReserveMode = e.SendMode = e.storeMessageRelaxed = e.loadMessageRelaxed = e.storeMessage = e.loadMessage = e.loadMasterchainStateExtra = e.storeHashUpdate = e.loadHashUpdate = e.storeExtraCurrency = e.loadMaybeExtraCurrency = e.loadExtraCurrency = e.packExtraCurrencyDict = e.packExtraCurrencyCell = e.storeDepthBalanceInfo = e.loadDepthBalanceInfo = e.storeCurrencyCollection = e.loadCurrencyCollection = e.storeComputeSkipReason = e.loadComputeSkipReason = e.storeCommonMessageInfoRelaxed = e.loadCommonMessageInfoRelaxed = e.storeCommonMessageInfo = e.loadCommonMessageInfo = e.storeOutList = e.loadOutList = e.storeOutAction = e.loadOutAction = e.storeAccountStorage = e.loadAccountStorage = e.storeAccountStatusChange = e.loadAccountStatusChange = e.storeAccountStatus = e.loadAccountStatus = e.storeAccountState = e.loadAccountState = e.storeAccount = e.loadAccount = e.comment = e.external = e.internal = void 0, e.storeTransactionsStoragePhase = e.loadTransactionStoragePhase = e.storeTransactionDescription = e.loadTransactionDescription = e.storeTransactionCreditPhase = e.loadTransactionCreditPhase = e.storeTransactionComputePhase = e.loadTransactionComputePhase = e.storeTransactionBouncePhase = e.loadTransactionBouncePhase = e.storeTransactionActionPhase = e.loadTransactionActionPhase = e.storeTransaction = e.loadTransaction = e.storeTickTock = e.loadTickTock = e.storeStorageUsed = e.loadStorageUsed = e.storeStorageInfo = e.loadStorageInfo = e.storeStateInit = e.loadStateInit = e.storeSplitMergeInfo = e.loadSplitMergeInfo = e.storeLibRef = e.loadLibRef = e.storeSimpleLibrary = void 0;
        var n = r(9447);
        Object.defineProperty(e, "internal", {
          enumerable: !0,
          get: function() {
            return n.internal
          }
        }), Object.defineProperty(e, "external", {
          enumerable: !0,
          get: function() {
            return n.external
          }
        }), Object.defineProperty(e, "comment", {
          enumerable: !0,
          get: function() {
            return n.comment
          }
        });
        var i = r(62142);
        Object.defineProperty(e, "loadAccount", {
          enumerable: !0,
          get: function() {
            return i.loadAccount
          }
        }), Object.defineProperty(e, "storeAccount", {
          enumerable: !0,
          get: function() {
            return i.storeAccount
          }
        });
        var o = r(83049);
        Object.defineProperty(e, "loadAccountState", {
          enumerable: !0,
          get: function() {
            return o.loadAccountState
          }
        }), Object.defineProperty(e, "storeAccountState", {
          enumerable: !0,
          get: function() {
            return o.storeAccountState
          }
        });
        var s = r(87676);
        Object.defineProperty(e, "loadAccountStatus", {
          enumerable: !0,
          get: function() {
            return s.loadAccountStatus
          }
        }), Object.defineProperty(e, "storeAccountStatus", {
          enumerable: !0,
          get: function() {
            return s.storeAccountStatus
          }
        });
        var a = r(62312);
        Object.defineProperty(e, "loadAccountStatusChange", {
          enumerable: !0,
          get: function() {
            return a.loadAccountStatusChange
          }
        }), Object.defineProperty(e, "storeAccountStatusChange", {
          enumerable: !0,
          get: function() {
            return a.storeAccountStatusChange
          }
        });
        var u = r(86161);
        Object.defineProperty(e, "loadAccountStorage", {
          enumerable: !0,
          get: function() {
            return u.loadAccountStorage
          }
        }), Object.defineProperty(e, "storeAccountStorage", {
          enumerable: !0,
          get: function() {
            return u.storeAccountStorage
          }
        });
        var c = r(63101);
        Object.defineProperty(e, "loadOutAction", {
          enumerable: !0,
          get: function() {
            return c.loadOutAction
          }
        }), Object.defineProperty(e, "storeOutAction", {
          enumerable: !0,
          get: function() {
            return c.storeOutAction
          }
        }), Object.defineProperty(e, "loadOutList", {
          enumerable: !0,
          get: function() {
            return c.loadOutList
          }
        }), Object.defineProperty(e, "storeOutList", {
          enumerable: !0,
          get: function() {
            return c.storeOutList
          }
        });
        var f = r(60445);
        Object.defineProperty(e, "loadCommonMessageInfo", {
          enumerable: !0,
          get: function() {
            return f.loadCommonMessageInfo
          }
        }), Object.defineProperty(e, "storeCommonMessageInfo", {
          enumerable: !0,
          get: function() {
            return f.storeCommonMessageInfo
          }
        });
        var l = r(92234);
        Object.defineProperty(e, "loadCommonMessageInfoRelaxed", {
          enumerable: !0,
          get: function() {
            return l.loadCommonMessageInfoRelaxed
          }
        }), Object.defineProperty(e, "storeCommonMessageInfoRelaxed", {
          enumerable: !0,
          get: function() {
            return l.storeCommonMessageInfoRelaxed
          }
        });
        var h = r(93471);
        Object.defineProperty(e, "loadComputeSkipReason", {
          enumerable: !0,
          get: function() {
            return h.loadComputeSkipReason
          }
        }), Object.defineProperty(e, "storeComputeSkipReason", {
          enumerable: !0,
          get: function() {
            return h.storeComputeSkipReason
          }
        });
        var d = r(10574);
        Object.defineProperty(e, "loadCurrencyCollection", {
          enumerable: !0,
          get: function() {
            return d.loadCurrencyCollection
          }
        }), Object.defineProperty(e, "storeCurrencyCollection", {
          enumerable: !0,
          get: function() {
            return d.storeCurrencyCollection
          }
        });
        var p = r(84458);
        Object.defineProperty(e, "loadDepthBalanceInfo", {
          enumerable: !0,
          get: function() {
            return p.loadDepthBalanceInfo
          }
        }), Object.defineProperty(e, "storeDepthBalanceInfo", {
          enumerable: !0,
          get: function() {
            return p.storeDepthBalanceInfo
          }
        });
        var b = r(71784);
        Object.defineProperty(e, "packExtraCurrencyCell", {
          enumerable: !0,
          get: function() {
            return b.packExtraCurrencyCell
          }
        }), Object.defineProperty(e, "packExtraCurrencyDict", {
          enumerable: !0,
          get: function() {
            return b.packExtraCurrencyDict
          }
        }), Object.defineProperty(e, "loadExtraCurrency", {
          enumerable: !0,
          get: function() {
            return b.loadExtraCurrency
          }
        }), Object.defineProperty(e, "loadMaybeExtraCurrency", {
          enumerable: !0,
          get: function() {
            return b.loadMaybeExtraCurrency
          }
        }), Object.defineProperty(e, "storeExtraCurrency", {
          enumerable: !0,
          get: function() {
            return b.storeExtraCurrency
          }
        });
        var m = r(14660);
        Object.defineProperty(e, "loadHashUpdate", {
          enumerable: !0,
          get: function() {
            return m.loadHashUpdate
          }
        }), Object.defineProperty(e, "storeHashUpdate", {
          enumerable: !0,
          get: function() {
            return m.storeHashUpdate
          }
        });
        var y = r(29039);
        Object.defineProperty(e, "loadMasterchainStateExtra", {
          enumerable: !0,
          get: function() {
            return y.loadMasterchainStateExtra
          }
        });
        var g = r(48178);
        Object.defineProperty(e, "loadMessage", {
          enumerable: !0,
          get: function() {
            return g.loadMessage
          }
        }), Object.defineProperty(e, "storeMessage", {
          enumerable: !0,
          get: function() {
            return g.storeMessage
          }
        });
        var v = r(84143);
        Object.defineProperty(e, "loadMessageRelaxed", {
          enumerable: !0,
          get: function() {
            return v.loadMessageRelaxed
          }
        }), Object.defineProperty(e, "storeMessageRelaxed", {
          enumerable: !0,
          get: function() {
            return v.storeMessageRelaxed
          }
        });
        var w = r(14568);
        Object.defineProperty(e, "SendMode", {
          enumerable: !0,
          get: function() {
            return w.SendMode
          }
        });
        var A = r(41766);
        Object.defineProperty(e, "ReserveMode", {
          enumerable: !0,
          get: function() {
            return A.ReserveMode
          }
        });
        var T = r(30594);
        Object.defineProperty(e, "loadShardAccount", {
          enumerable: !0,
          get: function() {
            return T.loadShardAccount
          }
        }), Object.defineProperty(e, "storeShardAccount", {
          enumerable: !0,
          get: function() {
            return T.storeShardAccount
          }
        });
        var E = r(28993);
        Object.defineProperty(e, "ShardAccountRefValue", {
          enumerable: !0,
          get: function() {
            return E.ShardAccountRefValue
          }
        }), Object.defineProperty(e, "loadShardAccounts", {
          enumerable: !0,
          get: function() {
            return E.loadShardAccounts
          }
        }), Object.defineProperty(e, "storeShardAccounts", {
          enumerable: !0,
          get: function() {
            return E.storeShardAccounts
          }
        });
        var P = r(32423);
        Object.defineProperty(e, "loadShardIdent", {
          enumerable: !0,
          get: function() {
            return P.loadShardIdent
          }
        }), Object.defineProperty(e, "storeShardIdent", {
          enumerable: !0,
          get: function() {
            return P.storeShardIdent
          }
        });
        var k = r(85787);
        Object.defineProperty(e, "loadShardStateUnsplit", {
          enumerable: !0,
          get: function() {
            return k.loadShardStateUnsplit
          }
        });
        var x = r(62672);
        Object.defineProperty(e, "loadSimpleLibrary", {
          enumerable: !0,
          get: function() {
            return x.loadSimpleLibrary
          }
        }), Object.defineProperty(e, "storeSimpleLibrary", {
          enumerable: !0,
          get: function() {
            return x.storeSimpleLibrary
          }
        });
        var I = r(63137);
        Object.defineProperty(e, "loadLibRef", {
          enumerable: !0,
          get: function() {
            return I.loadLibRef
          }
        }), Object.defineProperty(e, "storeLibRef", {
          enumerable: !0,
          get: function() {
            return I.storeLibRef
          }
        });
        var S = r(49589);
        Object.defineProperty(e, "loadSplitMergeInfo", {
          enumerable: !0,
          get: function() {
            return S.loadSplitMergeInfo
          }
        }), Object.defineProperty(e, "storeSplitMergeInfo", {
          enumerable: !0,
          get: function() {
            return S.storeSplitMergeInfo
          }
        });
        var O = r(22738);
        Object.defineProperty(e, "loadStateInit", {
          enumerable: !0,
          get: function() {
            return O.loadStateInit
          }
        }), Object.defineProperty(e, "storeStateInit", {
          enumerable: !0,
          get: function() {
            return O.storeStateInit
          }
        });
        var B = r(69456);
        Object.defineProperty(e, "loadStorageInfo", {
          enumerable: !0,
          get: function() {
            return B.loadStorageInfo
          }
        }), Object.defineProperty(e, "storeStorageInfo", {
          enumerable: !0,
          get: function() {
            return B.storeStorageInfo
          }
        });
        var W = r(92577);
        Object.defineProperty(e, "loadStorageUsed", {
          enumerable: !0,
          get: function() {
            return W.loadStorageUsed
          }
        }), Object.defineProperty(e, "storeStorageUsed", {
          enumerable: !0,
          get: function() {
            return W.storeStorageUsed
          }
        });
        var M = r(4599);
        Object.defineProperty(e, "loadTickTock", {
          enumerable: !0,
          get: function() {
            return M.loadTickTock
          }
        }), Object.defineProperty(e, "storeTickTock", {
          enumerable: !0,
          get: function() {
            return M.storeTickTock
          }
        });
        var C = r(96305);
        Object.defineProperty(e, "loadTransaction", {
          enumerable: !0,
          get: function() {
            return C.loadTransaction
          }
        }), Object.defineProperty(e, "storeTransaction", {
          enumerable: !0,
          get: function() {
            return C.storeTransaction
          }
        });
        var R = r(464);
        Object.defineProperty(e, "loadTransactionActionPhase", {
          enumerable: !0,
          get: function() {
            return R.loadTransactionActionPhase
          }
        }), Object.defineProperty(e, "storeTransactionActionPhase", {
          enumerable: !0,
          get: function() {
            return R.storeTransactionActionPhase
          }
        });
        var N = r(35726);
        Object.defineProperty(e, "loadTransactionBouncePhase", {
          enumerable: !0,
          get: function() {
            return N.loadTransactionBouncePhase
          }
        }), Object.defineProperty(e, "storeTransactionBouncePhase", {
          enumerable: !0,
          get: function() {
            return N.storeTransactionBouncePhase
          }
        });
        var j = r(53857);
        Object.defineProperty(e, "loadTransactionComputePhase", {
          enumerable: !0,
          get: function() {
            return j.loadTransactionComputePhase
          }
        }), Object.defineProperty(e, "storeTransactionComputePhase", {
          enumerable: !0,
          get: function() {
            return j.storeTransactionComputePhase
          }
        });
        var _ = r(11065);
        Object.defineProperty(e, "loadTransactionCreditPhase", {
          enumerable: !0,
          get: function() {
            return _.loadTransactionCreditPhase
          }
        }), Object.defineProperty(e, "storeTransactionCreditPhase", {
          enumerable: !0,
          get: function() {
            return _.storeTransactionCreditPhase
          }
        });
        var D = r(13543);
        Object.defineProperty(e, "loadTransactionDescription", {
          enumerable: !0,
          get: function() {
            return D.loadTransactionDescription
          }
        }), Object.defineProperty(e, "storeTransactionDescription", {
          enumerable: !0,
          get: function() {
            return D.storeTransactionDescription
          }
        });
        var U = r(58353);
        Object.defineProperty(e, "loadTransactionStoragePhase", {
          enumerable: !0,
          get: function() {
            return U.loadTransactionStoragePhase
          }
        }), Object.defineProperty(e, "storeTransactionsStoragePhase", {
          enumerable: !0,
          get: function() {
            return U.storeTransactionsStoragePhase
          }
        })
      },
      74277: (t, e, r) => {
        const n = r(40909);
        t.exports = (t, e) => t.sort((t, r) => n(r, t, e))
      },
      74294: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[\x00-\x7F]+$/;
        t.exports = e.default, t.exports.default = e.default
      },
      74610: (t, e, r) => {
        "use strict";
        t.exports = f;
        var n = r(86048).F,
          i = n.ERR_METHOD_NOT_IMPLEMENTED,
          o = n.ERR_MULTIPLE_CALLBACK,
          s = n.ERR_TRANSFORM_ALREADY_TRANSFORMING,
          a = n.ERR_TRANSFORM_WITH_LENGTH_0,
          u = r(25382);

        function c(t, e) {
          var r = this.rn;
          r.transforming = !1;
          var n = r.writecb;
          if (null === n) return this.emit("error", new o);
          r.writechunk = null, r.writecb = null, null != e && this.push(e), n(t);
          var i = this.rt;
          i.reading = !1, (i.needReadable || i.length < i.highWaterMark) && this.xt(i.highWaterMark)
        }

        function f(t) {
          if (!(this instanceof f)) return new f(t);
          u.call(this, t), this.rn = {
            afterTransform: c.bind(this),
            needTransform: !1,
            transforming: !1,
            writecb: null,
            writechunk: null,
            writeencoding: null
          }, this.rt.needReadable = !0, this.rt.sync = !1, t && ("function" == typeof t.transform && (this.Qr = t.transform), "function" == typeof t.flush && (this.nn = t.flush)), this.on("prefinish", l)
        }

        function l() {
          var t = this;
          "function" != typeof this.nn || this.rt.destroyed ? h(this, null, null) : this.nn(function(e, r) {
            h(t, e, r)
          })
        }

        function h(t, e, r) {
          if (e) return t.emit("error", e);
          if (null != r && t.push(r), t.Wt.length) throw new a;
          if (t.rn.transforming) throw new s;
          return t.push(null)
        }
        r(56698)(f, u), f.prototype.push = function(t, e) {
          return this.rn.needTransform = !1, u.prototype.push.call(this, t, e)
        }, f.prototype.Qr = function(t, e, r) {
          r(new i("_transform()"))
        }, f.prototype.it = function(t, e, r) {
          var n = this.rn;
          if (n.writecb = r, n.writechunk = t, n.writeencoding = e, !n.transforming) {
            var i = this.rt;
            (n.needTransform || i.needReadable || i.length < i.highWaterMark) && this.xt(i.highWaterMark)
          }
        }, f.prototype.xt = function(t) {
          var e = this.rn;
          null === e.writechunk || e.transforming ? e.needTransform = !0 : (e.transforming = !0, this.Qr(e.writechunk, e.writeencoding, e.afterTransform))
        }, f.prototype.Ct = function(t, e) {
          u.prototype.Ct.call(this, t, function(t) {
            e(t)
          })
        }
      },
      74765: t => {
        "use strict";
        var e = "".replace,
          r = /%20/g,
          n = "RFC3986";
        t.exports = {
          default: n,
          formatters: {
            RFC1738: function(t) {
              return e.call(t, r, "+")
            },
            RFC3986: function(t) {
              return t + ""
            }
          },
          RFC1738: "RFC1738",
          RFC3986: n
        }
      },
      74772: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.assertExhaustive = e.assertStruct = e.assert = e.AssertionError = void 0;
        const n = r(35620),
          i = r(92443);

        function o(t, e) {
          return function(t) {
            return "string" == typeof t?.prototype?.constructor?.name
          }(t) ? new t({
            message: e
          }) : t({
            message: e
          })
        }
        class s extends Error {
          constructor(t) {
            super(t.message), this.code = "ERR_ASSERTION"
          }
        }
        e.AssertionError = s, e.assert = function(t, e = "Assertion failed.", r = s) {
          if (!t) throw e instanceof Error ? e : o(r, e)
        }, e.assertStruct = function(t, e, r = "Assertion failed", a = s) {
          try {
            (0, n.assert)(t, e)
          } catch (t) {
            throw o(a, `${r}: ${function(t){return(0,i.getErrorMessage)(t).replace(/\.$/u,"")}(t)}.`)
          }
        }, e.assertExhaustive = function(t) {
          throw Error("Invalid branch reached. Should be detected during compilation.")
        }
      },
      75032: (t, e, r) => {
        const n = r(78311),
          i = r(93904),
          {
            ANY: o
          } = i,
          s = r(97638),
          a = r(50560),
          u = [new i(">=0.0.0-0")],
          c = [new i(">=0.0.0")],
          f = (t, e, r) => {
            if (t === e) return !0;
            if (1 === t.length && t[0].semver === o) {
              if (1 === e.length && e[0].semver === o) return !0;
              t = r.includePrerelease ? u : c
            }
            if (1 === e.length && e[0].semver === o) {
              if (r.includePrerelease) return !0;
              e = c
            }
            const n = new Set;
            let i, f, d;
            for (const e of t) ">" === e.operator || ">=" === e.operator ? i = l(i, e, r) : "<" === e.operator || "<=" === e.operator ? f = h(f, e, r) : n.add(e.semver);
            if (n.size > 1) return null;
            if (i && f) {
              if (d = a(i.semver, f.semver, r), d > 0) return null;
              if (0 === d && (">=" !== i.operator || "<=" !== f.operator)) return null
            }
            for (const t of n) {
              if (i && !s(t, i + "", r) || f && !s(t, f + "", r)) return null;
              for (const n of e)
                if (!s(t, n + "", r)) return !1;
              return !0
            }
            let p, b, m, y, g = !(!f || r.includePrerelease || !f.semver.prerelease.length) && f.semver,
              v = !(!i || r.includePrerelease || !i.semver.prerelease.length) && i.semver;
            g && 1 === g.prerelease.length && "<" === f.operator && 0 === g.prerelease[0] && (g = !1);
            for (const t of e) {
              if (y = y || ">" === t.operator || ">=" === t.operator, m = m || "<" === t.operator || "<=" === t.operator, i)
                if (v && t.semver.prerelease && t.semver.prerelease.length && t.semver.major === v.major && t.semver.minor === v.minor && t.semver.patch === v.patch && (v = !1), ">" === t.operator || ">=" === t.operator) {
                  if (p = l(i, t, r), p === t && p !== i) return !1
                } else if (">=" === i.operator && !s(i.semver, t + "", r)) return !1;
              if (f)
                if (g && t.semver.prerelease && t.semver.prerelease.length && t.semver.major === g.major && t.semver.minor === g.minor && t.semver.patch === g.patch && (g = !1), "<" === t.operator || "<=" === t.operator) {
                  if (b = h(f, t, r), b === t && b !== f) return !1
                } else if ("<=" === f.operator && !s(f.semver, t + "", r)) return !1;
              if (!t.operator && (f || i) && 0 !== d) return !1
            }
            return !(i && m && !f && 0 !== d || f && y && !i && 0 !== d || v || g)
          },
          l = (t, e, r) => {
            if (!t) return e;
            const n = a(t.semver, e.semver, r);
            return n > 0 ? t : 0 > n || ">" === e.operator && ">=" === t.operator ? e : t
          },
          h = (t, e, r) => {
            if (!t) return e;
            const n = a(t.semver, e.semver, r);
            return 0 > n ? t : n > 0 || "<" === e.operator && "<=" === t.operator ? e : t
          };
        t.exports = (t, e, r = {}) => {
          if (t === e) return !0;
          t = new n(t, r), e = new n(e, r);
          let i = !1;
          t: for (const n of t.set) {
            for (const t of e.set) {
              const e = f(n, t, r);
              if (i = i || null !== e, e) continue t
            }
            if (i) return !1
          }
          return !0
        }
      },
      75069: function(t, e, r) {
        "use strict";
        var n = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.createModuleLogger = e.createProjectLogger = void 0;
        const i = (0, n(r(17833)).default)("metamask");
        e.createProjectLogger = function(t) {
          return i.extend(t)
        }, e.createModuleLogger = function(t, e) {
          return t.extend(e)
        }
      },
      75269: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getMnemonicsMasterKeyFromSeed = e.deriveMnemonicHardenedKey = e.deriveMnemonicsPath = e.deriveSymmetricPath = e.deriveSymmetricHardenedKey = e.getSymmetricMasterKeyFromSeed = e.deriveEd25519Path = e.deriveED25519HardenedKey = e.getED25519MasterKeyFromSeed = e.signVerify = e.sign = e.keyPairFromSecretKey = e.keyPairFromSeed = e.openBox = e.sealBox = e.mnemonicWordList = e.mnemonicToHDSeed = e.mnemonicToSeed = e.mnemonicToWalletKey = e.mnemonicToPrivateKey = e.mnemonicValidate = e.mnemonicNew = e.newSecurePassphrase = e.newSecureWords = e.getSecureRandomNumber = e.getSecureRandomWords = e.getSecureRandomBytes = e.hmac_sha512 = e.pbkdf2_sha512 = e.sha512_sync = e.sha512 = e.sha256_sync = e.sha256 = void 0;
        var n = r(75650);
        Object.defineProperty(e, "sha256", {
          enumerable: !0,
          get: function() {
            return n.sha256
          }
        }), Object.defineProperty(e, "sha256_sync", {
          enumerable: !0,
          get: function() {
            return n.sha256_sync
          }
        });
        var i = r(56224);
        Object.defineProperty(e, "sha512", {
          enumerable: !0,
          get: function() {
            return i.sha512
          }
        }), Object.defineProperty(e, "sha512_sync", {
          enumerable: !0,
          get: function() {
            return i.sha512_sync
          }
        });
        var o = r(59256);
        Object.defineProperty(e, "pbkdf2_sha512", {
          enumerable: !0,
          get: function() {
            return o.pbkdf2_sha512
          }
        });
        var s = r(4870);
        Object.defineProperty(e, "hmac_sha512", {
          enumerable: !0,
          get: function() {
            return s.hmac_sha512
          }
        });
        var a = r(51682);
        Object.defineProperty(e, "getSecureRandomBytes", {
          enumerable: !0,
          get: function() {
            return a.getSecureRandomBytes
          }
        }), Object.defineProperty(e, "getSecureRandomWords", {
          enumerable: !0,
          get: function() {
            return a.getSecureRandomWords
          }
        }), Object.defineProperty(e, "getSecureRandomNumber", {
          enumerable: !0,
          get: function() {
            return a.getSecureRandomNumber
          }
        });
        var u = r(56622);
        Object.defineProperty(e, "newSecureWords", {
          enumerable: !0,
          get: function() {
            return u.newSecureWords
          }
        });
        var c = r(52279);
        Object.defineProperty(e, "newSecurePassphrase", {
          enumerable: !0,
          get: function() {
            return c.newSecurePassphrase
          }
        });
        var f = r(10132);
        Object.defineProperty(e, "mnemonicNew", {
          enumerable: !0,
          get: function() {
            return f.mnemonicNew
          }
        }), Object.defineProperty(e, "mnemonicValidate", {
          enumerable: !0,
          get: function() {
            return f.mnemonicValidate
          }
        }), Object.defineProperty(e, "mnemonicToPrivateKey", {
          enumerable: !0,
          get: function() {
            return f.mnemonicToPrivateKey
          }
        }), Object.defineProperty(e, "mnemonicToWalletKey", {
          enumerable: !0,
          get: function() {
            return f.mnemonicToWalletKey
          }
        }), Object.defineProperty(e, "mnemonicToSeed", {
          enumerable: !0,
          get: function() {
            return f.mnemonicToSeed
          }
        }), Object.defineProperty(e, "mnemonicToHDSeed", {
          enumerable: !0,
          get: function() {
            return f.mnemonicToHDSeed
          }
        });
        var l = r(4436);
        Object.defineProperty(e, "mnemonicWordList", {
          enumerable: !0,
          get: function() {
            return l.wordlist
          }
        });
        var h = r(95415);
        Object.defineProperty(e, "sealBox", {
          enumerable: !0,
          get: function() {
            return h.sealBox
          }
        }), Object.defineProperty(e, "openBox", {
          enumerable: !0,
          get: function() {
            return h.openBox
          }
        });
        var d = r(95415);
        Object.defineProperty(e, "keyPairFromSeed", {
          enumerable: !0,
          get: function() {
            return d.keyPairFromSeed
          }
        }), Object.defineProperty(e, "keyPairFromSecretKey", {
          enumerable: !0,
          get: function() {
            return d.keyPairFromSecretKey
          }
        }), Object.defineProperty(e, "sign", {
          enumerable: !0,
          get: function() {
            return d.sign
          }
        }), Object.defineProperty(e, "signVerify", {
          enumerable: !0,
          get: function() {
            return d.signVerify
          }
        });
        var p = r(35735);
        Object.defineProperty(e, "getED25519MasterKeyFromSeed", {
          enumerable: !0,
          get: function() {
            return p.getED25519MasterKeyFromSeed
          }
        }), Object.defineProperty(e, "deriveED25519HardenedKey", {
          enumerable: !0,
          get: function() {
            return p.deriveED25519HardenedKey
          }
        }), Object.defineProperty(e, "deriveEd25519Path", {
          enumerable: !0,
          get: function() {
            return p.deriveEd25519Path
          }
        });
        var b = r(8117);
        Object.defineProperty(e, "getSymmetricMasterKeyFromSeed", {
          enumerable: !0,
          get: function() {
            return b.getSymmetricMasterKeyFromSeed
          }
        }), Object.defineProperty(e, "deriveSymmetricHardenedKey", {
          enumerable: !0,
          get: function() {
            return b.deriveSymmetricHardenedKey
          }
        }), Object.defineProperty(e, "deriveSymmetricPath", {
          enumerable: !0,
          get: function() {
            return b.deriveSymmetricPath
          }
        });
        var m = r(46815);
        Object.defineProperty(e, "deriveMnemonicsPath", {
          enumerable: !0,
          get: function() {
            return m.deriveMnemonicsPath
          }
        }), Object.defineProperty(e, "deriveMnemonicHardenedKey", {
          enumerable: !0,
          get: function() {
            return m.deriveMnemonicHardenedKey
          }
        }), Object.defineProperty(e, "getMnemonicsMasterKeyFromSeed", {
          enumerable: !0,
          get: function() {
            return m.getMnemonicsMasterKeyFromSeed
          }
        })
      },
      75353: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.satisfiesVersionRange = e.gtRange = e.gtVersion = e.assertIsSemVerRange = e.assertIsSemVerVersion = e.isValidSemVerRange = e.isValidSemVerVersion = e.VersionRangeStruct = e.VersionStruct = void 0;
        const n = r(35620),
          i = r(99589),
          o = r(74772);
        e.VersionStruct = (0, n.refine)((0, n.string)(), "Version", t => null !== (0, i.valid)(t) || `Expected SemVer version, got "${t}"`), e.VersionRangeStruct = (0, n.refine)((0, n.string)(), "Version range", t => null !== (0, i.validRange)(t) || `Expected SemVer range, got "${t}"`), e.isValidSemVerVersion = function(t) {
          return (0, n.is)(t, e.VersionStruct)
        }, e.isValidSemVerRange = function(t) {
          return (0, n.is)(t, e.VersionRangeStruct)
        }, e.assertIsSemVerVersion = function(t) {
          (0, o.assertStruct)(t, e.VersionStruct)
        }, e.assertIsSemVerRange = function(t) {
          (0, o.assertStruct)(t, e.VersionRangeStruct)
        }, e.gtVersion = function(t, e) {
          return (0, i.gt)(t, e)
        }, e.gtRange = function(t, e) {
          return (0, i.gtr)(t, e)
        }, e.satisfiesVersionRange = function(t, e) {
          return (0, i.satisfies)(t, e, {
            includePrerelease: !0
          })
        }
      },
      75571: (t, e, r) => {
        const n = r(97075);
        t.exports = (t, e, r) => n(t, e, ">", r)
      },
      75577: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), t === t.toUpperCase()
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      75650: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.sha256 = e.sha256_fallback = e.sha256_sync = void 0;
        const o = i(r(68343)),
          s = r(32370);

        function a(t) {
          let e;
          e = "string" == typeof t ? n.from(t, "utf-8").toString("hex") : t.toString("hex");
          let r = new o.default("SHA-256", "HEX");
          r.update(e);
          let i = r.getHash("HEX");
          return n.from(i, "hex")
        }
        e.sha256_sync = a, e.sha256_fallback = async function(t) {
          return a(t)
        }, e.sha256 = function(t) {
          return (0, s.sha256)(t)
        }
      },
      75653: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        });
        const n = r(28651),
          i = r(92034);
        e.default = (t, e) => {
          let r;
          switch (t.code) {
            case n.ZodIssueCode.invalid_type:
              r = t.received === i.ZodParsedType.undefined ? "Required" : `Expected ${t.expected}, received ${t.received}`;
              break;
            case n.ZodIssueCode.invalid_literal:
              r = "Invalid literal value, expected " + JSON.stringify(t.expected, i.util.jsonStringifyReplacer);
              break;
            case n.ZodIssueCode.unrecognized_keys:
              r = "Unrecognized key(s) in object: " + i.util.joinValues(t.keys, ", ");
              break;
            case n.ZodIssueCode.invalid_union:
              r = "Invalid input";
              break;
            case n.ZodIssueCode.invalid_union_discriminator:
              r = "Invalid discriminator value. Expected " + i.util.joinValues(t.options);
              break;
            case n.ZodIssueCode.invalid_enum_value:
              r = `Invalid enum value. Expected ${i.util.joinValues(t.options)}, received '${t.received}'`;
              break;
            case n.ZodIssueCode.invalid_arguments:
              r = "Invalid function arguments";
              break;
            case n.ZodIssueCode.invalid_return_type:
              r = "Invalid function return type";
              break;
            case n.ZodIssueCode.invalid_date:
              r = "Invalid date";
              break;
            case n.ZodIssueCode.invalid_string:
              "object" == typeof t.validation ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, "number" == typeof t.validation.position && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : i.util.assertNever(t.validation) : r = "regex" !== t.validation ? "Invalid " + t.validation : "Invalid";
              break;
            case n.ZodIssueCode.too_small:
              r = "array" === t.type ? `Array must contain ${t.exact?"exactly":t.inclusive?"at least":"more than"} ${t.minimum} element(s)` : "string" === t.type ? `String must contain ${t.exact?"exactly":t.inclusive?"at least":"over"} ${t.minimum} character(s)` : "number" === t.type || "bigint" === t.type ? `Number must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${t.minimum}` : "date" === t.type ? `Date must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${new Date(+t.minimum)}` : "Invalid input";
              break;
            case n.ZodIssueCode.too_big:
              r = "array" === t.type ? `Array must contain ${t.exact?"exactly":t.inclusive?"at most":"less than"} ${t.maximum} element(s)` : "string" === t.type ? `String must contain ${t.exact?"exactly":t.inclusive?"at most":"under"} ${t.maximum} character(s)` : "number" === t.type ? `Number must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : "bigint" === t.type ? `BigInt must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : "date" === t.type ? `Date must be ${t.exact?"exactly":t.inclusive?"smaller than or equal to":"smaller than"} ${new Date(+t.maximum)}` : "Invalid input";
              break;
            case n.ZodIssueCode.custom:
              r = "Invalid input";
              break;
            case n.ZodIssueCode.invalid_intersection_types:
              r = "Intersection results could not be merged";
              break;
            case n.ZodIssueCode.not_multiple_of:
              r = "Number must be a multiple of " + t.multipleOf;
              break;
            case n.ZodIssueCode.not_finite:
              r = "Number must be finite";
              break;
            default:
              r = e.defaultError, i.util.assertNever(t)
          }
          return {
            message: r
          }
        }
      },
      75751: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, n.default)(t);
          try {
            e = (0, i.default)(e, a);
            var r = [];
            e.allow_primitives && (r = [null, !1, !0]);
            var o = JSON.parse(t);
            return r.includes(o) || !!o && "object" === s(o)
          } catch {}
          return !1
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }

        function s(t) {
          return (s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        var a = {
          allow_primitives: !1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      75795: (t, e, r) => {
        "use strict";
        var n = r(6549);
        if (n) try {
          n([], "length")
        } catch {
          n = null
        }
        t.exports = n
      },
      75832: t => {
        "use strict";
        class e extends Error {
          constructor(t, {
            cause: r
          } = {}) {
            super(t), this.name = e.name, r && (this.cause = r), this.message = t
          }
        }
        t.exports = {
          ErrorWithCause: e
        }
      },
      75880: t => {
        "use strict";
        t.exports = Math.pow
      },
      75896: (t, e, r) => {
        "use strict";
        var n = r(65606);

        function i(t, e) {
          s(t, e), o(t)
        }

        function o(t) {
          t.Wt && !t.Wt.emitClose || t.rt && !t.rt.emitClose || t.emit("close")
        }

        function s(t, e) {
          t.emit("error", e)
        }
        t.exports = {
          destroy: function(t, e) {
            var r = this,
              a = this.rt && this.rt.destroyed,
              u = this.Wt && this.Wt.destroyed;
            return a || u ? (e ? e(t) : t && (this.Wt ? this.Wt.errorEmitted || (this.Wt.errorEmitted = !0, n.nextTick(s, this, t)) : n.nextTick(s, this, t)), this) : (this.rt && (this.rt.destroyed = !0), this.Wt && (this.Wt.destroyed = !0), this.Ct(t || null, function(t) {
              !e && t ? r.Wt ? r.Wt.errorEmitted ? n.nextTick(o, r) : (r.Wt.errorEmitted = !0, n.nextTick(i, r, t)) : n.nextTick(i, r, t) : e ? (n.nextTick(o, r), e(t)) : n.nextTick(o, r)
            }), this)
          },
          undestroy: function() {
            this.rt && (this.rt.destroyed = !1, this.rt.reading = !1, this.rt.ended = !1, this.rt.endEmitted = !1), this.Wt && (this.Wt.destroyed = !1, this.Wt.ended = !1, this.Wt.ending = !1, this.Wt.finalCalled = !1, this.Wt.prefinished = !1, this.Wt.finished = !1, this.Wt.errorEmitted = !1)
          },
          errorOrDestroy: function(t, e) {
            var r = t.rt,
              n = t.Wt;
            r && r.autoDestroy || n && n.autoDestroy ? t.destroy(e) : t.emit("error", e)
          }
        }
      },
      76084: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = (e = e || {}).hasOwnProperty("allow_leading_zeroes") && !e.allow_leading_zeroes ? o : s,
            n = !e.hasOwnProperty("min") || t >= e.min,
            a = !e.hasOwnProperty("max") || t <= e.max,
            u = !e.hasOwnProperty("lt") || t < e.lt,
            c = !e.hasOwnProperty("gt") || t > e.gt;
          return r.test(t) && n && a && u && c
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(?:[-+]?(?:0|[1-9][0-9]*))$/,
          s = /^[-+]?[0-9]+$/;
        t.exports = e.default, t.exports.default = e.default
      },
      76291: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(24989), e)
      },
      76578: t => {
        "use strict";
        t.exports = ["Float16Array", "Float32Array", "Float64Array", "Int8Array", "Int16Array", "Int32Array", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array"]
      },
      76642: (t, e, r) => {
        "use strict";
        var n = r(13003);
        t.exports = function() {
          return Number.isNaN ? Number.isNaN : n
        }
      },
      76780: (t, e, r) => {
        const n = r(78311);
        t.exports = (t, e, r) => (t = new n(t, r), e = new n(e, r), t.intersects(e, r))
      },
      77312: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.intToUnpaddedBuffer = e.bigIntToUnpaddedBuffer = e.bigIntToHex = e.bufArrToArr = e.arrToBufArr = e.validateNoLeadingZeroes = e.baToJSON = e.toUtf8 = e.short = e.addHexPrefix = e.toUnsigned = e.fromSigned = e.bufferToInt = e.bigIntToBuffer = e.bufferToBigInt = e.bufferToHex = e.toBuffer = e.unpadHexString = e.unpadArray = e.unpadBuffer = e.setLengthRight = e.setLengthLeft = e.zeros = e.intToBuffer = e.intToHex = void 0;
        const i = r(35546),
          o = r(59498);
        e.intToHex = function(t) {
          if (!Number.isSafeInteger(t) || 0 > t) throw Error("Received an invalid integer type: " + t);
          return "0x" + t.toString(16)
        }, e.intToBuffer = function(t) {
          const r = (0, e.intToHex)(t);
          return n.from((0, o.padToEven)(r.slice(2)), "hex")
        }, e.zeros = function(t) {
          return n.allocUnsafe(t).fill(0)
        };
        const s = function(t, r, n) {
          const i = (0, e.zeros)(r);
          return n ? t.length < r ? (t.copy(i), i) : t.slice(0, r) : t.length < r ? (t.copy(i, r - t.length), i) : t.slice(-r)
        };
        e.setLengthLeft = function(t, e) {
          return (0, i.assertIsBuffer)(t), s(t, e, !1)
        }, e.setLengthRight = function(t, e) {
          return (0, i.assertIsBuffer)(t), s(t, e, !0)
        };
        const a = function(t) {
          let e = t[0];
          for (; t.length > 0 && "0" === e.toString();) e = (t = t.slice(1))[0];
          return t
        };

        function u(t) {
          const r = (0, e.bufferToHex)(t);
          return BigInt("0x" === r ? 0 : r)
        }

        function c(t) {
          return (0, e.toBuffer)("0x" + t.toString(16))
        }
        e.unpadBuffer = function(t) {
          return (0, i.assertIsBuffer)(t), a(t)
        }, e.unpadArray = function(t) {
          return (0, i.assertIsArray)(t), a(t)
        }, e.unpadHexString = function(t) {
          return (0, i.assertIsHexString)(t), t = (0, o.stripHexPrefix)(t), "0x" + a(t)
        }, e.toBuffer = function(t) {
          if (null == t) return n.allocUnsafe(0);
          if (n.isBuffer(t) || Array.isArray(t) || t instanceof Uint8Array) return n.from(t);
          if ("string" == typeof t) {
            if (!(0, o.isHexString)(t)) throw Error("Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: " + t);
            return n.from((0, o.padToEven)((0, o.stripHexPrefix)(t)), "hex")
          }
          if ("number" == typeof t) return (0, e.intToBuffer)(t);
          if ("bigint" == typeof t) {
            if (t < BigInt(0)) throw Error("Cannot convert negative bigint to buffer. Given: " + t);
            let e = t.toString(16);
            return e.length % 2 && (e = "0" + e), n.from(e, "hex")
          }
          if (t.toArray) return n.from(t.toArray());
          if (t.toBuffer) return n.from(t.toBuffer());
          throw Error("invalid type")
        }, e.bufferToHex = function(t) {
          return "0x" + (t = (0, e.toBuffer)(t)).toString("hex")
        }, e.bufferToBigInt = u, e.bigIntToBuffer = c, e.bufferToInt = function(t) {
          const e = +u(t);
          if (!Number.isSafeInteger(e)) throw Error("Number exceeds 53 bits");
          return e
        }, e.fromSigned = function(t) {
          return BigInt.asIntN(256, u(t))
        }, e.toUnsigned = function(t) {
          return c(BigInt.asUintN(256, t))
        }, e.addHexPrefix = function(t) {
          return "string" != typeof t || (0, o.isHexPrefixed)(t) ? t : "0x" + t
        }, e.short = function(t, e = 50) {
          const r = n.isBuffer(t) ? t.toString("hex") : t;
          return r.length > e ? r.slice(0, e) + "" : r
        }, e.toUtf8 = function(t) {
          if ((t = (0, o.stripHexPrefix)(t)).length % 2 != 0) throw Error("Invalid non-even hex string input for toUtf8() provided");
          return n.from(t.replace(/^(00)+|(00)+$/g, ""), "hex").toString("utf8")
        }, e.baToJSON = function(t) {
          if (n.isBuffer(t)) return "0x" + t.toString("hex");
          if (t instanceof Array) {
            const r = [];
            for (let n = 0; n < t.length; n++) r.push((0, e.baToJSON)(t[n]));
            return r
          }
        }, e.validateNoLeadingZeroes = function(t) {
          for (const [e, r] of Object.entries(t))
            if (void 0 !== r && r.length > 0 && 0 === r[0]) throw Error(`${e} cannot have leading zeroes, received: ${r.toString("hex")}`)
        }, e.arrToBufArr = function t(e) {
          return Array.isArray(e) ? e.map(e => t(e)) : n.from(e)
        }, e.bufArrToArr = function t(e) {
          return Array.isArray(e) ? e.map(e => t(e)) : Uint8Array.from(e ?? [])
        }, e.bigIntToHex = t => "0x" + t.toString(16), e.bigIntToUnpaddedBuffer = function(t) {
          return (0, e.unpadBuffer)(c(t))
        }, e.intToUnpaddedBuffer = function(t) {
          return (0, e.unpadBuffer)((0, e.intToBuffer)(t))
        }
      },
      77631: (t, e, r) => {
        const n = r(78311);
        t.exports = (t, e) => new n(t, e).set.map(t => t.map(t => t.value).join(" ").trim().split(" "))
      },
      77670: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeOutActionExtendedV5Beta = u, e.loadOutActionV5BetaExtended = c, e.storeOutListExtendedV5Beta = function t(e) {
          const [r, ...o] = e;
          if (!r || !(0, i.isOutActionExtended)(r)) {
            if (e.some(i.isOutActionExtended)) throw Error("Can't serialize actions list: all extended actions must be placed before out actions");
            return t => {
              t.storeUint(0, 1).storeRef((0, n.beginCell)().store((0, n.storeOutList)(e)).endCell())
            }
          }
          return e => {
            e.storeUint(1, 1).store(u(r)).storeRef((0, n.beginCell)().store(t(o)).endCell())
          }
        }, e.loadOutListExtendedV5Beta = function(t) {
          const e = [];
          for (; t.loadUint(1);) {
            const r = c(t);
            e.push(r), t = t.loadRef().beginParse()
          }
          const r = (0, n.loadOutList)(t.loadRef().beginParse());
          if (r.some(t => "setCode" === t.type)) throw Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5");
          return e.concat(r)
        };
        const n = r(1307),
          i = r(52273),
          o = 550222170,
          s = 474012575,
          a = 1588524196;

        function u(t) {
          switch (t.type) {
            case "setIsPublicKeyEnabled":
              return function(t) {
                return e => {
                  e.storeUint(o, 32).storeUint(t.isEnabled ? 1 : 0, 1)
                }
              }(t);
            case "addExtension":
              return function(t) {
                return e => {
                  e.storeUint(s, 32).storeAddress(t.address)
                }
              }(t);
            case "removeExtension":
              return function(t) {
                return e => {
                  e.storeUint(a, 32).storeAddress(t.address)
                }
              }(t);
            default:
              throw Error("Unknown action type" + t?.type)
          }
        }

        function c(t) {
          const e = t.loadUint(32);
          switch (e) {
            case o:
              return {
                type: "setIsPublicKeyEnabled", isEnabled: !!t.loadUint(1)
              };
            case s:
              return {
                type: "addExtension", address: t.loadAddress()
              };
            case a:
              return {
                type: "removeExtension", address: t.loadAddress()
              };
            default:
              throw Error("Unknown extended out action tag 0x" + e.toString(16))
          }
        }
      },
      77741: (t, e, r) => {
        "use strict";

        function n(t) {
          return (n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US";
          (0, i.default)(t);
          var r = t.slice(0);
          if (e in d) return e in m && (r = r.replace(m[e], "")), !!d[e].test(r) && (!(e in p) || p[e](r));
          throw Error("Invalid locale '".concat(e, "'"))
        };
        var i = u(r(83399)),
          o = function(t) {
            if (t && t._) return t;
            if (null === t || "object" !== n(t) && "function" != typeof t) return {
              default: t
            };
            var e = a();
            if (e && e.has(t)) return e.get(t);
            var r = {},
              i = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for (var o in t)
              if ({}.hasOwnProperty.call(t, o)) {
                var s = i ? Object.getOwnPropertyDescriptor(t, o) : null;
                s && (s.get || s.set) ? Object.defineProperty(r, o, s) : r[o] = t[o]
              } return r.default = t, e && e.set(t, r), r
          }(r(44834)),
          s = u(r(99013));

        function a() {
          if ("function" != typeof WeakMap) return null;
          var t = new WeakMap;
          return a = function() {
            return t
          }, t
        }

        function u(t) {
          return t && t._ ? t : {
            default: t
          }
        }

        function c(t) {
          return function(t) {
            if (Array.isArray(t)) return f(t)
          }(t) || function(t) {
            if ("u" > typeof Symbol && Symbol.iterator in Object(t)) return Array.from(t)
          }(t) || function(t, e) {
            if (t) {
              if ("string" == typeof t) return f(t, e);
              var r = {}.toString.call(t).slice(8, -1);
              if ("Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r) return Array.from(t);
              if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return f(t, e)
            }
          }(t) || function() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
          }()
        }

        function f(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = Array(e); e > r; r++) n[r] = t[r];
          return n
        }
        var l = {
          andover: ["10", "12"],
          atlanta: ["60", "67"],
          austin: ["50", "53"],
          brookhaven: ["01", "02", "03", "04", "05", "06", "11", "13", "14", "16", "21", "22", "23", "25", "34", "51", "52", "54", "55", "56", "57", "58", "59", "65"],
          cincinnati: ["30", "32", "35", "36", "37", "38", "61"],
          fresno: ["15", "24"],
          internet: ["20", "26", "27", "45", "46", "47"],
          kansas: ["40", "44"],
          memphis: ["94", "95"],
          ogden: ["80", "90"],
          philadelphia: ["33", "39", "41", "42", "43", "46", "48", "62", "63", "64", "66", "68", "71", "72", "73", "74", "75", "76", "77", "81", "82", "83", "84", "85", "86", "87", "88", "91", "92", "93", "98", "99"],
          sba: ["31"]
        };

        function h(t) {
          for (var e = !1, r = !1, n = 0; 3 > n; n++)
            if (!e && /[AEIOU]/.test(t[n])) e = !0;
            else if (!r && e && "X" === t[n]) r = !0;
          else if (n > 0 && (e && !r && !/[AEIOU]/.test(t[n]) || r && !/X/.test(t[n]))) return !1;
          return !0
        }
        var d = {
          "bg-BG": /^\d{10}$/,
          "cs-CZ": /^\d{6}\/{0,1}\d{3,4}$/,
          "de-AT": /^\d{9}$/,
          "de-DE": /^[1-9]\d{10}$/,
          "dk-DK": /^\d{6}-{0,1}\d{4}$/,
          "el-CY": /^[09]\d{7}[A-Z]$/,
          "el-GR": /^([0-4]|[7-9])\d{8}$/,
          "en-CA": /^\d{9}$/,
          "en-GB": /^\d{10}$|^(?!GB|NK|TN|ZZ)(?![DFIQUV])[A-Z](?![DFIQUVO])[A-Z]\d{6}[ABCD ]$/i,
          "en-IE": /^\d{7}[A-W][A-IW]{0,1}$/i,
          "en-US": /^\d{2}[- ]{0,1}\d{7}$/,
          "es-ES": /^(\d{0,8}|[XYZKLM]\d{7})[A-HJ-NP-TV-Z]$/i,
          "et-EE": /^[1-6]\d{6}(00[1-9]|0[1-9][0-9]|[1-6][0-9]{2}|70[0-9]|710)\d$/,
          "fi-FI": /^\d{6}[-+A]\d{3}[0-9A-FHJ-NPR-Y]$/i,
          "fr-BE": /^\d{11}$/,
          "fr-FR": /^[0-3]\d{12}$|^[0-3]\d\s\d{2}(\s\d{3}){3}$/,
          "fr-LU": /^\d{13}$/,
          "hr-HR": /^\d{11}$/,
          "hu-HU": /^8\d{9}$/,
          "it-IT": /^[A-Z]{6}[L-NP-V0-9]{2}[A-EHLMPRST][L-NP-V0-9]{2}[A-ILMZ][L-NP-V0-9]{3}[A-Z]$/i,
          "lv-LV": /^\d{6}-{0,1}\d{5}$/,
          "mt-MT": /^\d{3,7}[APMGLHBZ]$|^([1-8])\1\d{7}$/i,
          "nl-NL": /^\d{9}$/,
          "pl-PL": /^\d{10,11}$/,
          "pt-BR": /(?:^\d{11}$)|(?:^\d{14}$)/,
          "pt-PT": /^\d{9}$/,
          "ro-RO": /^\d{13}$/,
          "sk-SK": /^\d{6}\/{0,1}\d{3,4}$/,
          "sl-SI": /^[1-9]\d{7}$/,
          "sv-SE": /^(\d{6}[-+]{0,1}\d{4}|(18|19|20)\d{6}[-+]{0,1}\d{4})$/
        };
        d["lb-LU"] = d["fr-LU"], d["lt-LT"] = d["et-EE"], d["nl-BE"] = d["fr-BE"], d["fr-CA"] = d["en-CA"];
        var p = {
          "bg-BG": function(t) {
            var e = t.slice(0, 2),
              r = parseInt(t.slice(2, 4), 10);
            r > 40 ? (r -= 40, e = "20".concat(e)) : r > 20 ? (r -= 20, e = "18".concat(e)) : e = "19".concat(e), 10 > r && (r = "0".concat(r));
            var n = "".concat(e, "/").concat(r, "/").concat(t.slice(4, 6));
            if (!(0, s.default)(n, "YYYY/MM/DD")) return !1;
            for (var i = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), o = [2, 4, 8, 5, 10, 9, 7, 3, 6], a = 0, u = 0; 9 > u; u++) a += i[u] * o[u];
            return (a = a % 11 == 10 ? 0 : a % 11) === i[9]
          },
          "cs-CZ": function(t) {
            t = t.replace(/\W/, "");
            var e = parseInt(t.slice(0, 2), 10);
            if (10 === t.length) e = 54 > e ? "20".concat(e) : "19".concat(e);
            else {
              if ("000" === t.slice(6)) return !1;
              if (e >= 54) return !1;
              e = "19".concat(e)
            }
            3 === e.length && (e = e.slice(0, 2) + "0" + e.slice(2));
            var r = parseInt(t.slice(2, 4), 10);
            if (r > 50 && (r -= 50), r > 20) {
              if (2004 > parseInt(e, 10)) return !1;
              r -= 20
            }
            10 > r && (r = "0".concat(r));
            var n = "".concat(e, "/").concat(r, "/").concat(t.slice(4, 6));
            if (!(0, s.default)(n, "YYYY/MM/DD")) return !1;
            if (10 === t.length && parseInt(t, 10) % 11 != 0) {
              var i = parseInt(t.slice(0, 9), 10) % 11;
              if (parseInt(e, 10) >= 1986 || 10 !== i) return !1;
              if (0 !== parseInt(t.slice(9), 10)) return !1
            }
            return !0
          },
          "de-AT": function(t) {
            return o.luhnCheck(t)
          },
          "de-DE": function(t) {
            for (var e = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), r = [], n = 0; n < e.length - 1; n++) {
              r.push("");
              for (var i = 0; i < e.length - 1; i++) e[n] === e[i] && (r[n] += i)
            }
            if (2 !== (r = r.filter(function(t) {
                return t.length > 1
              })).length && 3 !== r.length) return !1;
            if (3 === r[0].length) {
              for (var s = r[0].split("").map(function(t) {
                  return parseInt(t, 10)
                }), a = 0, u = 0; u < s.length - 1; u++) s[u] + 1 === s[u + 1] && (a += 1);
              if (2 === a) return !1
            }
            return o.iso7064Check(t)
          },
          "dk-DK": function(t) {
            t = t.replace(/\W/, "");
            var e = parseInt(t.slice(4, 6), 10);
            switch (t.slice(6, 7)) {
              case "0":
              case "1":
              case "2":
              case "3":
                e = "19".concat(e);
                break;
              case "4":
              case "9":
                e = 37 > e ? "20".concat(e) : "19".concat(e);
                break;
              default:
                if (37 > e) e = "20".concat(e);
                else {
                  if (58 >= e) return !1;
                  e = "18".concat(e)
                }
            }
            3 === e.length && (e = e.slice(0, 2) + "0" + e.slice(2));
            var r = "".concat(e, "/").concat(t.slice(2, 4), "/").concat(t.slice(0, 2));
            if (!(0, s.default)(r, "YYYY/MM/DD")) return !1;
            for (var n = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), i = 0, o = 4, a = 0; 9 > a; a++) i += n[a] * o, 1 == (o -= 1) && (o = 7);
            return 1 != (i %= 11) && (0 === i ? 0 === n[9] : n[9] === 11 - i)
          },
          "el-CY": function(t) {
            for (var e = t.slice(0, 8).split("").map(function(t) {
                return parseInt(t, 10)
              }), r = 0, n = 1; n < e.length; n += 2) r += e[n];
            for (var i = 0; i < e.length; i += 2) 2 > e[i] ? r += 1 - e[i] : (r += 2 * (e[i] - 2) + 5, e[i] > 4 && (r += 2));
            return String.fromCharCode(r % 26 + 65) === t.charAt(8)
          },
          "el-GR": function(t) {
            for (var e = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), r = 0, n = 0; 8 > n; n++) r += e[n] * Math.pow(2, 8 - n);
            return r % 11 % 10 === e[8]
          },
          "en-CA": function(t) {
            var e = t.split(""),
              r = e.filter(function(t, e) {
                return e % 2
              }).map(function(t) {
                return 2 * +t
              }).join("").split("");
            return e.filter(function(t, e) {
              return !(e % 2)
            }).concat(r).map(function(t) {
              return +t
            }).reduce(function(t, e) {
              return t + e
            }) % 10 == 0
          },
          "en-IE": function(t) {
            var e = o.reverseMultiplyAndSum(t.split("").slice(0, 7).map(function(t) {
              return parseInt(t, 10)
            }), 8);
            return 9 === t.length && "W" !== t[8] && (e += 9 * (t[8].charCodeAt(0) - 64)), 0 == (e %= 23) ? "W" === t[7].toUpperCase() : t[7].toUpperCase() === String.fromCharCode(64 + e)
          },
          "en-US": function(t) {
            return -1 !== function() {
              var t = [];
              for (var e in l) l.hasOwnProperty(e) && t.push.apply(t, c(l[e]));
              return t
            }().indexOf(t.slice(0, 2))
          },
          "es-ES": function(t) {
            var e = t.toUpperCase().split("");
            if (isNaN(parseInt(e[0], 10)) && e.length > 1) {
              var r = 0;
              switch (e[0]) {
                case "Y":
                  r = 1;
                  break;
                case "Z":
                  r = 2
              }
              e.splice(0, 1, r)
            } else
              for (; 9 > e.length;) e.unshift(0);
            e = e.join("");
            var n = parseInt(e.slice(0, 8), 10) % 23;
            return e[8] === ["T", "R", "W", "A", "G", "M", "Y", "F", "P", "D", "X", "B", "N", "J", "Z", "S", "Q", "V", "H", "L", "C", "K", "E"][n]
          },
          "et-EE": function(t) {
            var e = t.slice(1, 3);
            switch (t.slice(0, 1)) {
              case "1":
              case "2":
                e = "18".concat(e);
                break;
              case "3":
              case "4":
                e = "19".concat(e);
                break;
              default:
                e = "20".concat(e)
            }
            var r = "".concat(e, "/").concat(t.slice(3, 5), "/").concat(t.slice(5, 7));
            if (!(0, s.default)(r, "YYYY/MM/DD")) return !1;
            for (var n = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), i = 0, o = 1, a = 0; 10 > a; a++) i += n[a] * o, 10 === (o += 1) && (o = 1);
            if (i % 11 == 10) {
              i = 0, o = 3;
              for (var u = 0; 10 > u; u++) i += n[u] * o, 10 === (o += 1) && (o = 1);
              if (i % 11 == 10) return 0 === n[10]
            }
            return i % 11 === n[10]
          },
          "fi-FI": function(t) {
            var e = t.slice(4, 6);
            switch (t.slice(6, 7)) {
              case "+":
                e = "18".concat(e);
                break;
              case "-":
                e = "19".concat(e);
                break;
              default:
                e = "20".concat(e)
            }
            var r = "".concat(e, "/").concat(t.slice(2, 4), "/").concat(t.slice(0, 2));
            if (!(0, s.default)(r, "YYYY/MM/DD")) return !1;
            var n = parseInt(t.slice(0, 6) + t.slice(7, 10), 10) % 31;
            return 10 > n ? n === parseInt(t.slice(10), 10) : ["A", "B", "C", "D", "E", "F", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y"][n -= 10] === t.slice(10)
          },
          "fr-BE": function(t) {
            if ("00" !== t.slice(2, 4) || "00" !== t.slice(4, 6)) {
              var e = "".concat(t.slice(0, 2), "/").concat(t.slice(2, 4), "/").concat(t.slice(4, 6));
              if (!(0, s.default)(e, "YY/MM/DD")) return !1
            }
            var r = 97 - parseInt(t.slice(0, 9), 10) % 97,
              n = parseInt(t.slice(9, 11), 10);
            return !(r !== n && (r = 97 - parseInt("2".concat(t.slice(0, 9)), 10) % 97, r !== n))
          },
          "fr-FR": function(t) {
            return t = t.replace(/\s/g, ""), parseInt(t.slice(0, 10), 10) % 511 === parseInt(t.slice(10, 13), 10)
          },
          "fr-LU": function(t) {
            var e = "".concat(t.slice(0, 4), "/").concat(t.slice(4, 6), "/").concat(t.slice(6, 8));
            return !(!(0, s.default)(e, "YYYY/MM/DD") || !o.luhnCheck(t.slice(0, 12))) && o.verhoeffCheck("".concat(t.slice(0, 11)).concat(t[12]))
          },
          "hr-HR": function(t) {
            return o.iso7064Check(t)
          },
          "hu-HU": function(t) {
            for (var e = t.split("").map(function(t) {
                return parseInt(t, 10)
              }), r = 8, n = 1; 9 > n; n++) r += e[n] * (n + 1);
            return r % 11 === e[9]
          },
          "it-IT": function(t) {
            var e = t.toUpperCase().split("");
            if (!h(e.slice(0, 3)) || !h(e.slice(3, 6))) return !1;
            for (var r = {
                L: "0",
                M: "1",
                N: "2",
                P: "3",
                Q: "4",
                R: "5",
                S: "6",
                T: "7",
                U: "8",
                V: "9"
              }, n = 0, i = [6, 7, 9, 10, 12, 13, 14]; i.length > n; n++) {
              var o = i[n];
              e[o] in r && e.splice(o, 1, r[e[o]])
            }
            var a = {
                A: "01",
                B: "02",
                C: "03",
                D: "04",
                E: "05",
                H: "06",
                L: "07",
                M: "08",
                P: "09",
                R: "10",
                S: "11",
                T: "12"
              } [e[8]],
              u = parseInt(e[9] + e[10], 10);
            u > 40 && (u -= 40), 10 > u && (u = "0".concat(u));
            var c = "".concat(e[6]).concat(e[7], "/").concat(a, "/").concat(u);
            if (!(0, s.default)(c, "YY/MM/DD")) return !1;
            for (var f = 0, l = 1; l < e.length - 1; l += 2) {
              var d = parseInt(e[l], 10);
              isNaN(d) && (d = e[l].charCodeAt(0) - 65), f += d
            }
            for (var p = {
                A: 1,
                B: 0,
                C: 5,
                D: 7,
                E: 9,
                F: 13,
                G: 15,
                H: 17,
                I: 19,
                J: 21,
                K: 2,
                L: 4,
                M: 18,
                N: 20,
                O: 11,
                P: 3,
                Q: 6,
                R: 8,
                S: 12,
                T: 14,
                U: 16,
                V: 10,
                W: 22,
                X: 25,
                Y: 24,
                Z: 23,
                0: 1,
                1: 0
              }, b = 0; b < e.length - 1; b += 2) {
              var m = 0;
              if (e[b] in p) m = p[e[b]];
              else {
                var y = parseInt(e[b], 10);
                m = 2 * y + 1, y > 4 && (m += 2)
              }
              f += m
            }
            return String.fromCharCode(65 + f % 26) === e[15]
          },
          "lv-LV": function(t) {
            var e = (t = t.replace(/\W/, "")).slice(0, 2);
            if ("32" !== e) {
              if ("00" !== t.slice(2, 4)) {
                var r = t.slice(4, 6);
                switch (t[6]) {
                  case "0":
                    r = "18".concat(r);
                    break;
                  case "1":
                    r = "19".concat(r);
                    break;
                  default:
                    r = "20".concat(r)
                }
                var n = "".concat(r, "/").concat(t.slice(2, 4), "/").concat(e);
                if (!(0, s.default)(n, "YYYY/MM/DD")) return !1
              }
              for (var i = 1101, o = [1, 6, 3, 7, 9, 10, 5, 8, 4, 2], a = 0; a < t.length - 1; a++) i -= parseInt(t[a], 10) * o[a];
              return parseInt(t[10], 10) === i % 11
            }
            return !0
          },
          "mt-MT": function(t) {
            if (9 !== t.length) {
              for (var e = t.toUpperCase().split(""); 8 > e.length;) e.unshift(0);
              switch (t[7]) {
                case "A":
                case "P":
                  if (0 === parseInt(e[6], 10)) return !1;
                  break;
                default:
                  var r = parseInt(e.join("").slice(0, 5), 10);
                  if (r > 32e3) return !1;
                  if (r === parseInt(e.join("").slice(5, 7), 10)) return !1
              }
            }
            return !0
          },
          "nl-NL": function(t) {
            return o.reverseMultiplyAndSum(t.split("").slice(0, 8).map(function(t) {
              return parseInt(t, 10)
            }), 9) % 11 === parseInt(t[8], 10)
          },
          "pl-PL": function(t) {
            if (10 === t.length) {
              for (var e = [6, 5, 7, 2, 3, 4, 5, 6, 7], r = 0, n = 0; 9 > n; n++) r += parseInt(t[n], 10) * e[n];
              return 10 != (r %= 11) && r === parseInt(t[9], 10)
            }
            var i = t.slice(0, 2),
              o = parseInt(t.slice(2, 4), 10);
            o > 80 ? (i = "18".concat(i), o -= 80) : o > 60 ? (i = "22".concat(i), o -= 60) : o > 40 ? (i = "21".concat(i), o -= 40) : o > 20 ? (i = "20".concat(i), o -= 20) : i = "19".concat(i), 10 > o && (o = "0".concat(o));
            var a = "".concat(i, "/").concat(o, "/").concat(t.slice(4, 6));
            if (!(0, s.default)(a, "YYYY/MM/DD")) return !1;
            for (var u = 0, c = 1, f = 0; f < t.length - 1; f++) u += parseInt(t[f], 10) * c % 10, (c += 2) > 10 ? c = 1 : 5 === c && (c += 2);
            return (u = 10 - u % 10) === parseInt(t[10], 10)
          },
          "pt-BR": function(t) {
            if (11 === t.length) {
              var e, r;
              if (e = 0, "11111111111" === t || "22222222222" === t || "33333333333" === t || "44444444444" === t || "55555555555" === t || "66666666666" === t || "77777777777" === t || "88888888888" === t || "99999999999" === t || "00000000000" === t) return !1;
              for (var n = 1; 9 >= n; n++) e += parseInt(t.substring(n - 1, n), 10) * (11 - n);
              if (10 == (r = 10 * e % 11) && (r = 0), r !== parseInt(t.substring(9, 10), 10)) return !1;
              e = 0;
              for (var i = 1; 10 >= i; i++) e += parseInt(t.substring(i - 1, i), 10) * (12 - i);
              return 10 == (r = 10 * e % 11) && (r = 0), r === parseInt(t.substring(10, 11), 10)
            }
            if ("00000000000000" === t || "11111111111111" === t || "22222222222222" === t || "33333333333333" === t || "44444444444444" === t || "55555555555555" === t || "66666666666666" === t || "77777777777777" === t || "88888888888888" === t || "99999999999999" === t) return !1;
            for (var o = t.length - 2, s = t.substring(0, o), a = t.substring(o), u = 0, c = o - 7, f = o; f >= 1; f--) u += s.charAt(o - f) * c, 2 > (c -= 1) && (c = 9);
            var l = 2 > u % 11 ? 0 : 11 - u % 11;
            if (l !== parseInt(a.charAt(0), 10)) return !1;
            o += 1, s = t.substring(0, o), u = 0, c = o - 7;
            for (var h = o; h >= 1; h--) u += s.charAt(o - h) * c, 2 > (c -= 1) && (c = 9);
            return (l = 2 > u % 11 ? 0 : 11 - u % 11) === parseInt(a.charAt(1), 10)
          },
          "pt-PT": function(t) {
            var e = 11 - o.reverseMultiplyAndSum(t.split("").slice(0, 8).map(function(t) {
              return parseInt(t, 10)
            }), 9) % 11;
            return e > 9 ? 0 === parseInt(t[8], 10) : e === parseInt(t[8], 10)
          },
          "ro-RO": function(t) {
            if ("9000" !== t.slice(0, 4)) {
              var e = t.slice(1, 3);
              switch (t[0]) {
                case "1":
                case "2":
                  e = "19".concat(e);
                  break;
                case "3":
                case "4":
                  e = "18".concat(e);
                  break;
                case "5":
                case "6":
                  e = "20".concat(e)
              }
              var r = "".concat(e, "/").concat(t.slice(3, 5), "/").concat(t.slice(5, 7));
              if (8 === r.length) {
                if (!(0, s.default)(r, "YY/MM/DD")) return !1
              } else if (!(0, s.default)(r, "YYYY/MM/DD")) return !1;
              for (var n = t.split("").map(function(t) {
                  return parseInt(t, 10)
                }), i = [2, 7, 9, 1, 4, 6, 3, 5, 8, 2, 7, 9], o = 0, a = 0; 12 > a; a++) o += n[a] * i[a];
              return o % 11 == 10 ? 1 === n[12] : n[12] === o % 11
            }
            return !0
          },
          "sk-SK": function(t) {
            if (9 === t.length) {
              if ("000" === (t = t.replace(/\W/, "")).slice(6)) return !1;
              var e = parseInt(t.slice(0, 2), 10);
              if (e > 53) return !1;
              e = 10 > e ? "190".concat(e) : "19".concat(e);
              var r = parseInt(t.slice(2, 4), 10);
              r > 50 && (r -= 50), 10 > r && (r = "0".concat(r));
              var n = "".concat(e, "/").concat(r, "/").concat(t.slice(4, 6));
              if (!(0, s.default)(n, "YYYY/MM/DD")) return !1
            }
            return !0
          },
          "sl-SI": function(t) {
            var e = 11 - o.reverseMultiplyAndSum(t.split("").slice(0, 7).map(function(t) {
              return parseInt(t, 10)
            }), 8) % 11;
            return 10 === e ? 0 === parseInt(t[7], 10) : e === parseInt(t[7], 10)
          },
          "sv-SE": function(t) {
            var e = t.slice(0);
            t.length > 11 && (e = e.slice(2));
            var r = "",
              n = e.slice(2, 4),
              i = parseInt(e.slice(4, 6), 10);
            if (t.length > 11) r = t.slice(0, 4);
            else if (r = t.slice(0, 2), 11 === t.length && 60 > i) {
              var a = (new Date).getFullYear().toString(),
                u = parseInt(a.slice(0, 2), 10);
              if (a = parseInt(a, 10), "-" === t[6]) r = parseInt("".concat(u).concat(r), 10) > a ? "".concat(u - 1).concat(r) : "".concat(u).concat(r);
              else if (r = "".concat(u - 1).concat(r), 100 > a - parseInt(r, 10)) return !1
            }
            i > 60 && (i -= 60), 10 > i && (i = "0".concat(i));
            var c = "".concat(r, "/").concat(n, "/").concat(i);
            if (8 === c.length) {
              if (!(0, s.default)(c, "YY/MM/DD")) return !1
            } else if (!(0, s.default)(c, "YYYY/MM/DD")) return !1;
            return o.luhnCheck(t.replace(/\W/, ""))
          }
        };
        p["lb-LU"] = p["fr-LU"], p["lt-LT"] = p["et-EE"], p["nl-BE"] = p["fr-BE"], p["fr-CA"] = p["en-CA"];
        var b = /[-\\\/!@#$%\^&\*\(\)\+\=\[\]]+/g,
          m = {
            "de-AT": b,
            "de-DE": /[\/\\]/g,
            "fr-BE": b
          };
        m["nl-BE"] = m["fr-BE"], t.exports = e.default, t.exports.default = e.default
      },
      77844: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, n.default)(t), !t || /[\s<>]/.test(t) || 0 === t.indexOf("mailto:") || (e = (0, s.default)(e, c)).validate_length && t.length >= 2083 || !e.allow_fragments && t.includes("#") || !e.allow_query_components && (t.includes("?") || t.includes("&"))) return !1;
          var r, a, l, d, p, b, m, y;
          if (m = t.split("#"), t = m.shift(), m = t.split("?"), t = m.shift(), (m = t.split("://")).length > 1) {
            if (r = m.shift().toLowerCase(), e.require_valid_protocol && -1 === e.protocols.indexOf(r)) return !1
          } else {
            if (e.require_protocol) return !1;
            if ("//" === t.slice(0, 2)) {
              if (!e.allow_protocol_relative_urls) return !1;
              m[0] = t.slice(2)
            }
          }
          if ("" === (t = m.join("://"))) return !1;
          if (m = t.split("/"), "" === (t = m.shift()) && !e.require_host) return !0;
          if ((m = t.split("@")).length > 1) {
            if (e.disallow_auth || "" === m[0] || (a = m.shift()).indexOf(":") >= 0 && a.split(":").length > 2) return !1;
            var g = function(t) {
                return function(t) {
                  if (Array.isArray(t)) return t
                }(t) || function(t) {
                  if ("u" >= typeof Symbol && Symbol.iterator in Object(t)) {
                    var e = [],
                      r = !0,
                      n = !1,
                      i = void 0;
                    try {
                      for (var o, s = t[Symbol.iterator](); !(r = (o = s.next()).done) && (e.push(o.value), 2 !== e.length); r = !0);
                    } catch (t) {
                      n = !0, i = t
                    } finally {
                      try {
                        !r && null != s.return && s.return()
                      } finally {
                        if (n) throw i
                      }
                    }
                    return e
                  }
                }(t) || function(t) {
                  if (t) {
                    if ("string" == typeof t) return u(t, 2);
                    var e = {}.toString.call(t).slice(8, -1);
                    if ("Object" === e && t.constructor && (e = t.constructor.name), "Map" === e || "Set" === e) return Array.from(t);
                    if ("Arguments" === e || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e)) return u(t, 2)
                  }
                }(t) || function() {
                  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }()
              }(a.split(":")),
              v = g[0],
              w = g[1];
            if ("" === v && "" === w) return !1
          }
          b = null, y = null;
          var A = (d = m.join("@")).match(f);
          if (A ? (l = "", y = A[1], b = A[2] || null) : (l = (m = d.split(":")).shift(), m.length && (b = m.join(":"))), null !== b && b.length > 0) {
            if (p = parseInt(b, 10), !/^[0-9]+$/.test(b) || 0 >= p || p > 65535) return !1
          } else if (e.require_port) return !1;
          return e.host_whitelist ? h(l, e.host_whitelist) : "" === l && !e.require_host || !(!(0, o.default)(l) && !(0, i.default)(l, e) && (!y || !(0, o.default)(y, 6)) || (l = l || y, e.host_blacklist && h(l, e.host_blacklist)))
        };
        var n = a(r(83399)),
          i = a(r(57658)),
          o = a(r(35372)),
          s = a(r(71229));

        function a(t) {
          return t && t._ ? t : {
            default: t
          }
        }

        function u(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = Array(e); e > r; r++) n[r] = t[r];
          return n
        }
        var c = {
            protocols: ["http", "https", "ftp"],
            require_tld: !0,
            require_protocol: !1,
            require_host: !0,
            require_port: !1,
            require_valid_protocol: !0,
            allow_underscores: !1,
            allow_trailing_dot: !1,
            allow_protocol_relative_urls: !1,
            allow_fragments: !0,
            allow_query_components: !0,
            validate_length: !0
          },
          f = /^\[([^\]]+)\](?::([0-9]+))?$/;

        function l(t) {
          return "[object RegExp]" === {}.toString.call(t)
        }

        function h(t, e) {
          for (var r = 0; r < e.length; r++) {
            var n = e[r];
            if (t === n || l(n) && n.test(t)) return !0
          }
          return !1
        }
        t.exports = e.default, t.exports.default = e.default
      },
      78311: (t, e, r) => {
        const n = /\s+/g;
        class i {
          constructor(t, e) {
            if (e = s(e), t instanceof i) return t.loose === !!e.loose && t.includePrerelease === !!e.includePrerelease ? t : new i(t.raw, e);
            if (t instanceof a) return this.raw = t.value, this.set = [
              [t]
            ], this.formatted = void 0, this;
            if (this.options = e, this.loose = !!e.loose, this.includePrerelease = !!e.includePrerelease, this.raw = t.trim().replace(n, " "), this.set = this.raw.split("||").map(t => this.parseRange(t.trim())).filter(t => t.length), !this.set.length) throw new TypeError("Invalid SemVer Range: " + this.raw);
            if (this.set.length > 1) {
              const t = this.set[0];
              if (this.set = this.set.filter(t => !y(t[0])), 0 === this.set.length) this.set = [t];
              else if (this.set.length > 1)
                for (const t of this.set)
                  if (1 === t.length && g(t[0])) {
                    this.set = [t];
                    break
                  }
            }
            this.formatted = void 0
          }
          get range() {
            if (void 0 === this.formatted) {
              this.formatted = "";
              for (let t = 0; t < this.set.length; t++) {
                t > 0 && (this.formatted += "||");
                const e = this.set[t];
                for (let t = 0; t < e.length; t++) t > 0 && (this.formatted += " "), this.formatted += e[t].toString().trim()
              }
            }
            return this.formatted
          }
          format() {
            return this.range
          }
          toString() {
            return this.range
          }
          parseRange(t) {
            const e = ((this.options.includePrerelease && b) | (this.options.loose && m)) + ":" + t,
              r = o.get(e);
            if (r) return r;
            const n = this.options.loose,
              i = n ? f[l.HYPHENRANGELOOSE] : f[l.HYPHENRANGE];
            t = t.replace(i, B(this.options.includePrerelease)), u("hyphen replace", t), t = t.replace(f[l.COMPARATORTRIM], h), u("comparator trim", t), t = t.replace(f[l.TILDETRIM], d), u("tilde trim", t), t = t.replace(f[l.CARETTRIM], p), u("caret trim", t);
            let s = t.split(" ").map(t => w(t, this.options)).join(" ").split(/\s+/).map(t => O(t, this.options));
            n && (s = s.filter(t => (u("loose invalid filter", t, this.options), !!t.match(f[l.COMPARATORLOOSE])))), u("range list", s);
            const c = new Map,
              g = s.map(t => new a(t, this.options));
            for (const t of g) {
              if (y(t)) return [t];
              c.set(t.value, t)
            }
            c.size > 1 && c.has("") && c.delete("");
            const v = [...c.values()];
            return o.set(e, v), v
          }
          intersects(t, e) {
            if (!(t instanceof i)) throw new TypeError("a Range is required");
            return this.set.some(r => v(r, e) && t.set.some(t => v(t, e) && r.every(r => t.every(t => r.intersects(t, e)))))
          }
          test(t) {
            if (!t) return !1;
            if ("string" == typeof t) try {
              t = new c(t, this.options)
            } catch {
              return !1
            }
            for (let e = 0; e < this.set.length; e++)
              if (W(this.set[e], t, this.options)) return !0;
            return !1
          }
        }
        t.exports = i;
        const o = new(r(68794)),
          s = r(98587),
          a = r(93904),
          u = r(57272),
          c = r(53908),
          {
            safeRe: f,
            t: l,
            comparatorTrimReplace: h,
            tildeTrimReplace: d,
            caretTrimReplace: p
          } = r(99718),
          {
            FLAG_INCLUDE_PRERELEASE: b,
            FLAG_LOOSE: m
          } = r(16874),
          y = t => "<0.0.0-0" === t.value,
          g = t => "" === t.value,
          v = (t, e) => {
            let r = !0;
            const n = t.slice();
            let i = n.pop();
            for (; r && n.length;) r = n.every(t => i.intersects(t, e)), i = n.pop();
            return r
          },
          w = (t, e) => (u("comp", t, e), t = P(t, e), u("caret", t), t = T(t, e), u("tildes", t), t = x(t, e), u("xrange", t), t = S(t, e), u("stars", t), t),
          A = t => !t || "x" === t.toLowerCase() || "*" === t,
          T = (t, e) => t.trim().split(/\s+/).map(t => E(t, e)).join(" "),
          E = (t, e) => {
            const r = e.loose ? f[l.TILDELOOSE] : f[l.TILDE];
            return t.replace(r, (e, r, n, i, o) => {
              let s;
              return u("tilde", t, e, r, n, i, o), A(r) ? s = "" : A(n) ? s = `>=${r}.0.0 <${+r+1}.0.0-0` : A(i) ? s = `>=${r}.${n}.0 <${r}.${+n+1}.0-0` : o ? (u("replaceTilde pr", o), s = `>=${r}.${n}.${i}-${o} <${r}.${+n+1}.0-0`) : s = `>=${r}.${n}.${i} <${r}.${+n+1}.0-0`, u("tilde return", s), s
            })
          },
          P = (t, e) => t.trim().split(/\s+/).map(t => k(t, e)).join(" "),
          k = (t, e) => {
            u("caret", t, e);
            const r = e.loose ? f[l.CARETLOOSE] : f[l.CARET],
              n = e.includePrerelease ? "-0" : "";
            return t.replace(r, (e, r, i, o, s) => {
              let a;
              return u("caret", t, e, r, i, o, s), A(r) ? a = "" : A(i) ? a = `>=${r}.0.0${n} <${+r+1}.0.0-0` : A(o) ? a = "0" === r ? `>=${r}.${i}.0${n} <${r}.${+i+1}.0-0` : `>=${r}.${i}.0${n} <${+r+1}.0.0-0` : s ? (u("replaceCaret pr", s), a = "0" === r ? "0" === i ? `>=${r}.${i}.${o}-${s} <${r}.${i}.${+o+1}-0` : `>=${r}.${i}.${o}-${s} <${r}.${+i+1}.0-0` : `>=${r}.${i}.${o}-${s} <${+r+1}.0.0-0`) : (u("no pr"), a = "0" === r ? "0" === i ? `>=${r}.${i}.${o}${n} <${r}.${i}.${+o+1}-0` : `>=${r}.${i}.${o}${n} <${r}.${+i+1}.0-0` : `>=${r}.${i}.${o} <${+r+1}.0.0-0`), u("caret return", a), a
            })
          },
          x = (t, e) => (u("replaceXRanges", t, e), t.split(/\s+/).map(t => I(t, e)).join(" ")),
          I = (t, e) => {
            t = t.trim();
            const r = e.loose ? f[l.XRANGELOOSE] : f[l.XRANGE];
            return t.replace(r, (r, n, i, o, s, a) => {
              u("xRange", t, r, n, i, o, s, a);
              const c = A(i),
                f = c || A(o),
                l = f || A(s),
                h = l;
              return "=" === n && h && (n = ""), a = e.includePrerelease ? "-0" : "", c ? r = ">" === n || "<" === n ? "<0.0.0-0" : "*" : n && h ? (f && (o = 0), s = 0, ">" === n ? (n = ">=", f ? (i = +i + 1, o = 0, s = 0) : (o = +o + 1, s = 0)) : "<=" === n && (n = "<", f ? i = +i + 1 : o = +o + 1), "<" === n && (a = "-0"), r = `${n+i}.${o}.${s}${a}`) : f ? r = `>=${i}.0.0${a} <${+i+1}.0.0-0` : l && (r = `>=${i}.${o}.0${a} <${i}.${+o+1}.0-0`), u("xRange return", r), r
            })
          },
          S = (t, e) => (u("replaceStars", t, e), t.trim().replace(f[l.STAR], "")),
          O = (t, e) => (u("replaceGTE0", t, e), t.trim().replace(f[e.includePrerelease ? l.GTE0PRE : l.GTE0], "")),
          B = t => (e, r, n, i, o, s, a, u, c, f, l, h) => `${r=A(n)?"":A(i)?`>=${n}.0.0${t?"-0":""}`:A(o)?`>=${n}.${i}.0${t?"-0":""}`:s?">="+r:`>=${r}${t?"-0":""}`} ${u=A(c)?"":A(f)?`<${+c+1}.0.0-0`:A(l)?`<${c}.${+f+1}.0-0`:h?`<=${c}.${f}.${l}-${h}`:t?`<${c}.${f}.${+l+1}-0`:"<="+u}`.trim(),
          W = (t, e, r) => {
            for (let r = 0; r < t.length; r++)
              if (!t[r].test(e)) return !1;
            if (e.prerelease.length && !r.includePrerelease) {
              for (let r = 0; r < t.length; r++)
                if (u(t[r].semver), t[r].semver !== a.ANY && t[r].semver.prerelease.length > 0) {
                  const n = t[r].semver;
                  if (n.major === e.major && n.minor === e.minor && n.patch === e.patch) return !0
                } return !1
            }
            return !0
          }
      },
      78366: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(50230), e), i(r(6579), e), i(r(47168), e), i(r(8653), e), i(r(64122), e), i(r(49604), e), i(r(1201), e), i(r(18335), e), i(r(7325), e), i(r(72516), e)
      },
      78371: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.extractPublicKey = e.recoverPersonalSignature = e.personalSign = void 0;
        const n = r(68683),
          i = r(43007);

        function o(t, e) {
          const r = (0, n.hashPersonalMessage)((0, i.legacyToBuffer)(t));
          return (0, i.recoverPublicKey)(r, e)
        }
        e.personalSign = function({
          privateKey: t,
          data: e
        }) {
          if ((0, i.isNullish)(e)) throw Error("Missing data parameter");
          if ((0, i.isNullish)(t)) throw Error("Missing privateKey parameter");
          const r = (0, i.legacyToBuffer)(e),
            o = (0, n.hashPersonalMessage)(r),
            s = (0, n.ecsign)(o, t);
          return (0, i.concatSig)((0, n.toBuffer)(s.v), s.r, s.s)
        }, e.recoverPersonalSignature = function({
          data: t,
          signature: e
        }) {
          if ((0, i.isNullish)(t)) throw Error("Missing data parameter");
          if ((0, i.isNullish)(e)) throw Error("Missing signature parameter");
          const r = o(t, e),
            s = (0, n.publicToAddress)(r);
          return (0, n.bufferToHex)(s)
        }, e.extractPublicKey = function({
          data: t,
          signature: e
        }) {
          if ((0, i.isNullish)(t)) throw Error("Missing data parameter");
          if ((0, i.isNullish)(e)) throw Error("Missing signature parameter");
          return "0x" + o(t, e).toString("hex")
        }
      },
      78559: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i = r(48287).Buffer,
          o = r(88310).Transform,
          s = r(5974),
          a = r(40537),
          u = r(94148).ok,
          c = r(48287).kMaxLength,
          f = "Cannot create final Buffer. It would be larger than 0x" + c.toString(16) + " bytes";
        s.Z_MIN_WINDOWBITS = 8, s.Z_MAX_WINDOWBITS = 15, s.Z_DEFAULT_WINDOWBITS = 15, s.Z_MIN_CHUNK = 64, s.Z_MAX_CHUNK = 1 / 0, s.Z_DEFAULT_CHUNK = 16384, s.Z_MIN_MEMLEVEL = 1, s.Z_MAX_MEMLEVEL = 9, s.Z_DEFAULT_MEMLEVEL = 8, s.Z_MIN_LEVEL = -1, s.Z_MAX_LEVEL = 9, s.Z_DEFAULT_LEVEL = s.Z_DEFAULT_COMPRESSION;
        for (var l = Object.keys(s), h = 0; h < l.length; h++) {
          var d = l[h];
          d.match(/^Z/) && Object.defineProperty(e, d, {
            enumerable: !0,
            value: s[d],
            writable: !1
          })
        }
        for (var p = {
            Z_OK: s.Z_OK,
            Z_STREAM_END: s.Z_STREAM_END,
            Z_NEED_DICT: s.Z_NEED_DICT,
            Z_ERRNO: s.Z_ERRNO,
            Z_STREAM_ERROR: s.Z_STREAM_ERROR,
            Z_DATA_ERROR: s.Z_DATA_ERROR,
            Z_MEM_ERROR: s.Z_MEM_ERROR,
            Z_BUF_ERROR: s.Z_BUF_ERROR,
            Z_VERSION_ERROR: s.Z_VERSION_ERROR
          }, b = Object.keys(p), m = 0; m < b.length; m++) {
          var y = b[m];
          p[p[y]] = y
        }

        function g(t, e, r) {
          var n = [],
            o = 0;

          function s() {
            for (var e; null !== (e = t.read());) n.push(e), o += e.length;
            t.once("readable", s)
          }

          function a() {
            var e, s = null;
            c > o ? e = i.concat(n, o) : s = new RangeError(f), n = [], t.close(), r(s, e)
          }
          t.on("error", function(e) {
            t.removeListener("end", a), t.removeListener("readable", s), r(e)
          }), t.on("end", a), t.end(e), s()
        }

        function v(t, e) {
          if ("string" == typeof e && (e = i.from(e)), !i.isBuffer(e)) throw new TypeError("Not a string or buffer");
          var r = t.sn;
          return t.an(e, r)
        }

        function w(t) {
          if (!(this instanceof w)) return new w(t);
          S.call(this, t, s.DEFLATE)
        }

        function A(t) {
          if (!(this instanceof A)) return new A(t);
          S.call(this, t, s.INFLATE)
        }

        function T(t) {
          if (!(this instanceof T)) return new T(t);
          S.call(this, t, s.GZIP)
        }

        function E(t) {
          if (!(this instanceof E)) return new E(t);
          S.call(this, t, s.GUNZIP)
        }

        function P(t) {
          if (!(this instanceof P)) return new P(t);
          S.call(this, t, s.DEFLATERAW)
        }

        function k(t) {
          if (!(this instanceof k)) return new k(t);
          S.call(this, t, s.INFLATERAW)
        }

        function x(t) {
          if (!(this instanceof x)) return new x(t);
          S.call(this, t, s.UNZIP)
        }

        function I(t) {
          return t === s.Z_NO_FLUSH || t === s.Z_PARTIAL_FLUSH || t === s.Z_SYNC_FLUSH || t === s.Z_FULL_FLUSH || t === s.Z_FINISH || t === s.Z_BLOCK
        }

        function S(t, r) {
          var n = this;
          if (this.Wr = t = t || {}, this.un = t.chunkSize || e.Z_DEFAULT_CHUNK, o.call(this, t), t.flush && !I(t.flush)) throw Error("Invalid flush flag: " + t.flush);
          if (t.finishFlush && !I(t.finishFlush)) throw Error("Invalid flush flag: " + t.finishFlush);
          if (this.cn = t.flush || s.Z_NO_FLUSH, this.sn = "u" > typeof t.finishFlush ? t.finishFlush : s.Z_FINISH, t.chunkSize && (t.chunkSize < e.Z_MIN_CHUNK || t.chunkSize > e.Z_MAX_CHUNK)) throw Error("Invalid chunk size: " + t.chunkSize);
          if (t.windowBits && (t.windowBits < e.Z_MIN_WINDOWBITS || t.windowBits > e.Z_MAX_WINDOWBITS)) throw Error("Invalid windowBits: " + t.windowBits);
          if (t.level && (t.level < e.Z_MIN_LEVEL || t.level > e.Z_MAX_LEVEL)) throw Error("Invalid compression level: " + t.level);
          if (t.memLevel && (t.memLevel < e.Z_MIN_MEMLEVEL || t.memLevel > e.Z_MAX_MEMLEVEL)) throw Error("Invalid memLevel: " + t.memLevel);
          if (t.strategy && t.strategy != e.Z_FILTERED && t.strategy != e.Z_HUFFMAN_ONLY && t.strategy != e.Z_RLE && t.strategy != e.Z_FIXED && t.strategy != e.Z_DEFAULT_STRATEGY) throw Error("Invalid strategy: " + t.strategy);
          if (t.dictionary && !i.isBuffer(t.dictionary)) throw Error("Invalid dictionary: it should be a Buffer instance");
          this.ln = new s.Zlib(r);
          var a = this;
          this.hn = !1, this.ln.onerror = function(t, r) {
            O(a), a.hn = !0;
            var n = Error(t);
            n.errno = r, n.code = e.codes[r], a.emit("error", n)
          };
          var u = e.Z_DEFAULT_COMPRESSION;
          "number" == typeof t.level && (u = t.level);
          var c = e.Z_DEFAULT_STRATEGY;
          "number" == typeof t.strategy && (c = t.strategy), this.ln.init(t.windowBits || e.Z_DEFAULT_WINDOWBITS, u, t.memLevel || e.Z_DEFAULT_MEMLEVEL, c, t.dictionary), this.yr = i.allocUnsafe(this.un), this.Er = 0, this.dn = u, this.pn = c, this.once("end", this.close), Object.defineProperty(this, "mn", {
            get: function() {
              return !n.ln
            },
            configurable: !0,
            enumerable: !0
          })
        }

        function O(t, e) {
          e && n.nextTick(e), t.ln && (t.ln.close(), t.ln = null)
        }

        function B(t) {
          t.emit("close")
        }
        Object.defineProperty(e, "codes", {
          enumerable: !0,
          value: Object.freeze(p),
          writable: !1
        }), e.Deflate = w, e.Inflate = A, e.Gzip = T, e.Gunzip = E, e.DeflateRaw = P, e.InflateRaw = k, e.Unzip = x, e.createDeflate = function(t) {
          return new w(t)
        }, e.createInflate = function(t) {
          return new A(t)
        }, e.createDeflateRaw = function(t) {
          return new P(t)
        }, e.createInflateRaw = function(t) {
          return new k(t)
        }, e.createGzip = function(t) {
          return new T(t)
        }, e.createGunzip = function(t) {
          return new E(t)
        }, e.createUnzip = function(t) {
          return new x(t)
        }, e.deflate = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new w(e), t, r)
        }, e.deflateSync = function(t, e) {
          return v(new w(e), t)
        }, e.gzip = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new T(e), t, r)
        }, e.gzipSync = function(t, e) {
          return v(new T(e), t)
        }, e.deflateRaw = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new P(e), t, r)
        }, e.deflateRawSync = function(t, e) {
          return v(new P(e), t)
        }, e.unzip = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new x(e), t, r)
        }, e.unzipSync = function(t, e) {
          return v(new x(e), t)
        }, e.inflate = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new A(e), t, r)
        }, e.inflateSync = function(t, e) {
          return v(new A(e), t)
        }, e.gunzip = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new E(e), t, r)
        }, e.gunzipSync = function(t, e) {
          return v(new E(e), t)
        }, e.inflateRaw = function(t, e, r) {
          return "function" == typeof e && (r = e, e = {}), g(new k(e), t, r)
        }, e.inflateRawSync = function(t, e) {
          return v(new k(e), t)
        }, a.inherits(S, o), S.prototype.params = function(t, r, i) {
          if (t < e.Z_MIN_LEVEL || t > e.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + t);
          if (r != e.Z_FILTERED && r != e.Z_HUFFMAN_ONLY && r != e.Z_RLE && r != e.Z_FIXED && r != e.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + r);
          if (this.dn !== t || this.pn !== r) {
            var o = this;
            this.flush(s.Z_SYNC_FLUSH, function() {
              u(o.ln, "zlib binding closed"), o.ln.params(t, r), o.hn || (o.dn = t, o.pn = r, i && i())
            })
          } else n.nextTick(i)
        }, S.prototype.reset = function() {
          return u(this.ln, "zlib binding closed"), this.ln.reset()
        }, S.prototype.nn = function(t) {
          this.Qr(i.alloc(0), "", t)
        }, S.prototype.flush = function(t, e) {
          var r = this,
            o = this.Wt;
          ("function" == typeof t || void 0 === t && !e) && (e = t, t = s.Z_FULL_FLUSH), o.ended ? e && n.nextTick(e) : o.ending ? e && this.once("end", e) : o.needDrain ? e && this.once("drain", function() {
            return r.flush(t, e)
          }) : (this.cn = t, this.write(i.alloc(0), "", e))
        }, S.prototype.close = function(t) {
          O(this, t), n.nextTick(B, this)
        }, S.prototype.Qr = function(t, e, r) {
          var n, o = this.Wt,
            a = (o.ending || o.ended) && (!t || o.length === t.length);
          return null === t || i.isBuffer(t) ? this.ln ? (a ? n = this.sn : (n = this.cn, t.length >= o.length && (this.cn = this.Wr.flush || s.Z_NO_FLUSH)), void this.an(t, n, r)) : r(Error("zlib binding closed")) : r(Error("invalid input"))
        }, S.prototype.an = function(t, e, r) {
          var n = t && t.length,
            o = this.un - this.Er,
            s = 0,
            a = this,
            l = "function" == typeof r;
          if (!l) {
            var h, d = [],
              p = 0;
            this.on("error", function(t) {
              h = t
            }), u(this.ln, "zlib binding closed");
            do {
              var b = this.ln.writeSync(e, t, s, n, this.yr, this.Er, o)
            } while (!this.hn && g(b[0], b[1]));
            if (this.hn) throw h;
            if (p >= c) throw O(this), new RangeError(f);
            var m = i.concat(d, p);
            return O(this), m
          }
          u(this.ln, "zlib binding closed");
          var y = this.ln.write(e, t, s, n, this.yr, this.Er, o);

          function g(c, f) {
            if (this && (this.buffer = null, this.callback = null), !a.hn) {
              var h = o - f;
              if (u(h >= 0, "have should not go down"), h > 0) {
                var b = a.yr.slice(a.Er, a.Er + h);
                a.Er += h, l ? a.push(b) : (d.push(b), p += b.length)
              }
              if ((0 === f || a.Er >= a.un) && (o = a.un, a.Er = 0, a.yr = i.allocUnsafe(a.un)), 0 === f) {
                if (s += n - c, n = c, !l) return !0;
                var m = a.ln.write(e, t, s, n, a.yr, a.Er, a.un);
                return m.callback = g, void(m.buffer = t)
              }
              if (!l) return !1;
              r()
            }
          }
          y.buffer = t, y.callback = g
        }, a.inherits(w, S), a.inherits(A, S), a.inherits(T, S), a.inherits(E, S), a.inherits(P, S), a.inherits(k, S), a.inherits(x, S)
      },
      78981: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.generateMerkleProof = e.generateMerkleProofDirect = void 0;
        const n = r(65871),
          i = r(50421),
          o = r(31459);

        function s(t, e, r, o) {
          const a = e.asCell();
          if (0 == o.length) return function(t) {
            return (0, n.beginCell)().storeUint(1, 8).storeUint(1, 8).storeBuffer(t.hash(0)).storeUint(t.depth(0), 16).endCell({
              exotic: !0
            })
          }(a);
          let u = e.loadBit() ? 1 : 0,
            c = 0,
            f = t;
          if (0 === u) {
            c = (0, i.readUnaryLength)(e);
            for (let t = 0; c > t; t++) f += e.loadBit() ? "1" : "0"
          } else if (0 == (e.loadBit() ? 1 : 0)) {
            c = e.loadUint(Math.ceil(Math.log2(r + 1)));
            for (let t = 0; c > t; t++) f += e.loadBit() ? "1" : "0"
          } else {
            let t = e.loadBit() ? "1" : "0";
            c = e.loadUint(Math.ceil(Math.log2(r + 1)));
            for (let e = 0; c > e; e++) f += t
          }
          if (r - c === 0) return a;
          {
            let t = a.beginParse(),
              e = t.loadRef(),
              i = t.loadRef();
            if (!e.isExotic) {
              const t = o.filter(t => f + "0" === t.slice(0, f.length + 1));
              e = s(f + "0", e.beginParse(), r - c - 1, t)
            }
            if (!i.isExotic) {
              const t = o.filter(t => f + "1" === t.slice(0, f.length + 1));
              i = s(f + "1", i.beginParse(), r - c - 1, t)
            }
            return (0, n.beginCell)().storeSlice(t).storeRef(e).storeRef(i).endCell()
          }
        }

        function a(t, e, r) {
          return e.forEach(e => {
            if (!t.has(e)) throw Error(`Trying to generate merkle proof for a missing key "${e}"`)
          }), s("", (0, n.beginCell)().storeDictDirect(t).asSlice(), r.bits, e.map(t => r.serialize(t).toString(2).padStart(r.bits, "0")))
        }
        e.generateMerkleProofDirect = a, e.generateMerkleProof = function(t, e, r) {
          return (0, o.convertToMerkleProof)(a(t, e, r))
        }
      },
      79145: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV3R1 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey, t.walletId)
          }
          constructor(t, e, r) {
            this.workchain = t, this.publicKey = e, this.walletId = null != r ? r : 698983191 + t;
            let o = i.Cell.fromBoc(n.from("te6cckEBAQEAYgAAwP8AIN0gggFMl7qXMO1E0NcLH+Ck8mCDCNcYINMf0x/TH/gjE7vyY+1E0NMf0x/T/9FRMrryoVFEuvKiBPkBVBBV+RDyo/gAkyDXSpbTB9QC+wDo0QGkyMsfyx/L/8ntVD++buA=", "base64"))[0],
              s = (0, i.beginCell)().storeUint(0, 32).storeUint(this.walletId, 32).storeBuffer(e).endCell();
            this.init = {
              code: o,
              data: s
            }, this.address = (0, i.contractAddress)(t, {
              code: o,
              data: s
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            return (0, o.createWalletTransferV3)({
              ...t,
              sendMode: t.sendMode ?? i.SendMode.PAY_GAS_SEPARATELY,
              walletId: this.walletId
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV3R1 = s
      },
      79265: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = void 0, e.default = function(t, e) {
          return t.some(function(t) {
            return e === t
          })
        }, t.exports = e.default, t.exports.default = e.default
      },
      79290: t => {
        "use strict";
        t.exports = RangeError
      },
      79325: function(t, e, r) {
        "use strict";
        var n = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r);
            var i = Object.getOwnPropertyDescriptor(e, r);
            (!i || ("get" in i ? !e._ : i.writable || i.configurable)) && (i = {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            }), Object.defineProperty(t, n, i)
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          i = this && this.tt || function(t, e) {
            for (var r in t) "default" !== r && !{}.hasOwnProperty.call(e, r) && n(e, t, r)
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), i(r(99317), e), i(r(90819), e), i(r(96370), e), i(r(92034), e), i(r(80491), e), i(r(28651), e)
      },
      79499: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.exoticPruned = void 0;
        const n = r(53528),
          i = r(20555);
        e.exoticPruned = function(t, e) {
          let r, o = new n.BitReader(t),
            s = o.loadUint(8);
          if (1 !== s) throw Error(`Pruned branch cell must have type 1, got "${s}"`);
          if (0 !== e.length) throw Error(`Pruned Branch cell can't has refs, got "${e.length}"`);
          if (280 === t.length) r = new i.LevelMask(1);
          else {
            if (r = new i.LevelMask(o.loadUint(8)), 1 > r.level || r.level > 3) throw Error(`Pruned Branch cell level must be >= 1 and <= 3, got "${r.level}/${r.value}"`);
            const e = 16 + 272 * r.apply(r.level - 1).hashCount;
            if (t.length !== e) throw Error(`Pruned branch cell must have exactly ${e} bits, got "${t.length}"`)
          }
          let a = [],
            u = [],
            c = [];
          for (let t = 0; t < r.level; t++) u.push(o.loadBuffer(32));
          for (let t = 0; t < r.level; t++) c.push(o.loadUint(16));
          for (let t = 0; t < r.level; t++) a.push({
            depth: c[t],
            hash: u[t]
          });
          return {
            mask: r.value,
            pruned: a
          }
        }
      },
      79538: t => {
        "use strict";
        t.exports = ReferenceError
      },
      79612: t => {
        "use strict";
        t.exports = Object
      },
      79838: () => {},
      80331: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeOutActionExtendedV5R1 = u, e.loadOutActionExtendedV5R1 = c, e.storeOutListExtendedV5R1 = function(t) {
          const e = t.filter(i.isOutActionExtended),
            r = t.filter(i.isOutActionBasic);
          return t => {
            const i = r.length ? (0, n.beginCell)().store((0, n.storeOutList)(r.slice().reverse())) : null;
            if (t.storeMaybeRef(i), 0 === e.length) t.storeUint(0, 1);
            else {
              const [r, ...n] = e;
              t.storeUint(1, 1).store(u(r)), n.length > 0 && t.storeRef(f(n))
            }
          }
        }, e.loadOutListExtendedV5R1 = function(t) {
          const e = [],
            r = t.loadMaybeRef();
          if (r) {
            const t = (0, n.loadOutList)(r.beginParse());
            if (t.some(t => "sendMsg" !== t.type)) throw Error("Can't deserialize actions list: only sendMsg actions are allowed for wallet v5r1");
            e.push(...t)
          }
          if (t.loadBoolean()) {
            const r = c(t);
            e.push(r)
          }
          for (; t.remainingRefs > 0;) {
            const r = c(t = t.loadRef().beginParse());
            e.push(r)
          }
          return e
        }, e.toSafeV5R1SendMode = l, e.patchV5R1ActionsSendMode = function(t, e) {
          return t.map(t => "sendMsg" === t.type ? {
            ...t,
            mode: l(t.mode, e)
          } : t)
        };
        const n = r(1307),
          i = r(52273),
          o = 4,
          s = 2,
          a = 3;

        function u(t) {
          switch (t.type) {
            case "setIsPublicKeyEnabled":
              return function(t) {
                return e => {
                  e.storeUint(o, 8).storeUint(t.isEnabled ? 1 : 0, 1)
                }
              }(t);
            case "addExtension":
              return function(t) {
                return e => {
                  e.storeUint(s, 8).storeAddress(t.address)
                }
              }(t);
            case "removeExtension":
              return function(t) {
                return e => {
                  e.storeUint(a, 8).storeAddress(t.address)
                }
              }(t);
            default:
              throw Error("Unknown action type" + t?.type)
          }
        }

        function c(t) {
          const e = t.loadUint(8);
          switch (e) {
            case o:
              return {
                type: "setIsPublicKeyEnabled", isEnabled: !!t.loadUint(1)
              };
            case s:
              return {
                type: "addExtension", address: t.loadAddress()
              };
            case a:
              return {
                type: "removeExtension", address: t.loadAddress()
              };
            default:
              throw Error("Unknown extended out action tag 0x" + e.toString(16))
          }
        }

        function f(t) {
          const [e, ...r] = t;
          let i = (0, n.beginCell)().store(u(e));
          return r.length > 0 && (i = i.storeRef(f(r))), i.endCell()
        }

        function l(t, e) {
          return "internal" === e || "extension" === e ? t : t | n.SendMode.IGNORE_ERRORS
        }
      },
      80345: (t, e, r) => {
        "use strict";

        function n(t, e) {
          var r = Object.keys(t);
          if (Object.getOwnPropertySymbols) {
            var n = Object.getOwnPropertySymbols(t);
            e && (n = n.filter(function(e) {
              return Object.getOwnPropertyDescriptor(t, e).enumerable
            })), r.push.apply(r, n)
          }
          return r
        }

        function i(t) {
          for (var e = 1; arguments.length > e; e++) {
            var r = null != arguments[e] ? arguments[e] : {};
            e % 2 ? n(Object(r), !0).forEach(function(e) {
              o(t, e, r[e])
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : n(Object(r)).forEach(function(e) {
              Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(r, e))
            })
          }
          return t
        }

        function o(t, e, r) {
          return (e = s(e)) in t ? Object.defineProperty(t, e, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0
          }) : t[e] = r, t
        }

        function s(t) {
          var e = function(t) {
            if ("object" != typeof t || null === t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
              var r = e.call(t, "string");
              if ("object" != typeof r) return r;
              throw new TypeError("@@toPrimitive must return a primitive value.")
            }
            return t + ""
          }(t);
          return "symbol" == typeof e ? e : e + ""
        }
        var a = r(48287).Buffer,
          u = r(15340).inspect,
          c = u && u.custom || "inspect";

        function f(t, e, r) {
          a.prototype.copy.call(t, e, r)
        }
        t.exports = function() {
          function t() {
            (function(t, e) {
              if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
            })(this, t), this.head = null, this.tail = null, this.length = 0
          }
          return function(t, e) {
            e && function(t, e) {
              for (var r = 0; r < e.length; r++) {
                var n = e[r];
                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(t, s(n.key), n)
              }
            }(t.prototype, e), Object.defineProperty(t, "prototype", {
              writable: !1
            })
          }(t, [{
            key: "push",
            value: function(t) {
              var e = {
                data: t,
                next: null
              };
              this.length > 0 ? this.tail.next = e : this.head = e, this.tail = e, ++this.length
            }
          }, {
            key: "unshift",
            value: function(t) {
              var e = {
                data: t,
                next: this.head
              };
              0 === this.length && (this.tail = e), this.head = e, ++this.length
            }
          }, {
            key: "shift",
            value: function() {
              if (0 !== this.length) {
                var t = this.head.data;
                return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, --this.length, t
              }
            }
          }, {
            key: "clear",
            value: function() {
              this.head = this.tail = null, this.length = 0
            }
          }, {
            key: "join",
            value: function(t) {
              if (0 === this.length) return "";
              for (var e = this.head, r = "" + e.data; e = e.next;) r += t + e.data;
              return r
            }
          }, {
            key: "concat",
            value: function(t) {
              if (0 === this.length) return a.alloc(0);
              for (var e = a.allocUnsafe(t >>> 0), r = this.head, n = 0; r;) f(r.data, e, n), n += r.data.length, r = r.next;
              return e
            }
          }, {
            key: "consume",
            value: function(t, e) {
              var r;
              return t < this.head.data.length ? (r = this.head.data.slice(0, t), this.head.data = this.head.data.slice(t)) : r = t === this.head.data.length ? this.shift() : e ? this.yn(t) : this.gn(t), r
            }
          }, {
            key: "first",
            value: function() {
              return this.head.data
            }
          }, {
            key: "_getString",
            value: function(t) {
              var e = this.head,
                r = 1,
                n = e.data;
              for (t -= n.length; e = e.next;) {
                var i = e.data,
                  o = t > i.length ? i.length : t;
                if (o === i.length ? n += i : n += i.slice(0, t), 0 === (t -= o)) {
                  o === i.length ? (++r, e.next ? this.head = e.next : this.head = this.tail = null) : (this.head = e, e.data = i.slice(o));
                  break
                }++r
              }
              return this.length -= r, n
            }
          }, {
            key: "_getBuffer",
            value: function(t) {
              var e = a.allocUnsafe(t),
                r = this.head,
                n = 1;
              for (r.data.copy(e), t -= r.data.length; r = r.next;) {
                var i = r.data,
                  o = t > i.length ? i.length : t;
                if (i.copy(e, e.length - t, 0, o), 0 === (t -= o)) {
                  o === i.length ? (++n, r.next ? this.head = r.next : this.head = this.tail = null) : (this.head = r, r.data = i.slice(o));
                  break
                }++n
              }
              return this.length -= n, e
            }
          }, {
            key: c,
            value: function(t, e) {
              return u(this, i(i({}, e), {}, {
                depth: 0,
                customInspect: !1
              }))
            }
          }]), t
        }()
      },
      80491: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.discriminatedUnion = e.date = e.boolean = e.bigint = e.array = e.any = e.coerce = e.ZodFirstPartyTypeKind = e.late = e.ZodSchema = e.Schema = e.ZodReadonly = e.ZodPipeline = e.ZodBranded = e.BRAND = e.ZodNaN = e.ZodCatch = e.ZodDefault = e.ZodNullable = e.ZodOptional = e.ZodTransformer = e.ZodEffects = e.ZodPromise = e.ZodNativeEnum = e.ZodEnum = e.ZodLiteral = e.ZodLazy = e.ZodFunction = e.ZodSet = e.ZodMap = e.ZodRecord = e.ZodTuple = e.ZodIntersection = e.ZodDiscriminatedUnion = e.ZodUnion = e.ZodObject = e.ZodArray = e.ZodVoid = e.ZodNever = e.ZodUnknown = e.ZodAny = e.ZodNull = e.ZodUndefined = e.ZodSymbol = e.ZodDate = e.ZodBoolean = e.ZodBigInt = e.ZodNumber = e.ZodString = e.ZodType = void 0, e.NEVER = e.void = e.unknown = e.union = e.undefined = e.tuple = e.transformer = e.symbol = e.string = e.strictObject = e.set = e.record = e.promise = e.preprocess = e.pipeline = e.ostring = e.optional = e.onumber = e.oboolean = e.object = e.number = e.nullable = e.null = e.never = e.nativeEnum = e.nan = e.map = e.literal = e.lazy = e.intersection = e.instanceof = e.function = e.enum = e.effect = void 0, e.datetimeRegex = W, e.custom = Et;
        const n = r(28651),
          i = r(99317),
          o = r(43368),
          s = r(90819),
          a = r(92034);
        class u {
          constructor(t, e, r, n) {
            this.vn = [], this.parent = t, this.data = e, this.wn = r, this.An = n
          }
          get path() {
            return this.vn.length || (Array.isArray(this.An) ? this.vn.push(...this.wn, ...this.An) : this.vn.push(...this.wn, this.An)), this.vn
          }
        }
        const c = (t, e) => {
          if ((0, s.isValid)(e)) return {
            success: !0,
            data: e.value
          };
          if (!t.common.issues.length) throw Error("Validation failed but no issues detected.");
          return {
            success: !1,
            get error() {
              if (this.ft) return this.ft;
              const e = new n.ZodError(t.common.issues);
              return this.ft = e, this.ft
            }
          }
        };

        function f(t) {
          if (!t) return {};
          const {
            errorMap: e,
            invalid_type_error: r,
            required_error: n,
            description: i
          } = t;
          if (e && (r || n)) throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
          return e ? {
            errorMap: e,
            description: i
          } : {
            errorMap: (e, i) => {
              const {
                message: o
              } = t;
              return "invalid_enum_value" === e.code ? {
                message: o ?? i.defaultError
              } : typeof i.data > "u" ? {
                message: o ?? n ?? i.defaultError
              } : "invalid_type" !== e.code ? {
                message: i.defaultError
              } : {
                message: o ?? r ?? i.defaultError
              }
            },
            description: i
          }
        }
        class l {
          get description() {
            return this.Tn.description
          }
          En(t) {
            return (0, a.getParsedType)(t.data)
          }
          Pn(t, e) {
            return e || {
              common: t.parent.common,
              data: t.data,
              parsedType: (0, a.getParsedType)(t.data),
              schemaErrorMap: this.Tn.errorMap,
              path: t.path,
              parent: t.parent
            }
          }
          kn(t) {
            return {
              status: new s.ParseStatus,
              ctx: {
                common: t.parent.common,
                data: t.data,
                parsedType: (0, a.getParsedType)(t.data),
                schemaErrorMap: this.Tn.errorMap,
                path: t.path,
                parent: t.parent
              }
            }
          }
          xn(t) {
            const e = this.In(t);
            if ((0, s.isAsync)(e)) throw Error("Synchronous parse encountered promise.");
            return e
          }
          Sn(t) {
            const e = this.In(t);
            return Promise.resolve(e)
          }
          parse(t, e) {
            const r = this.safeParse(t, e);
            if (r.success) return r.data;
            throw r.error
          }
          safeParse(t, e) {
            const r = {
                common: {
                  issues: [],
                  async: e?.async ?? !1,
                  contextualErrorMap: e?.errorMap
                },
                path: e?.path || [],
                schemaErrorMap: this.Tn.errorMap,
                parent: null,
                data: t,
                parsedType: (0, a.getParsedType)(t)
              },
              n = this.xn({
                data: t,
                path: r.path,
                parent: r
              });
            return c(r, n)
          }
          "~validate"(t) {
            const e = {
              common: {
                issues: [],
                async: !!this["~standard"].async
              },
              path: [],
              schemaErrorMap: this.Tn.errorMap,
              parent: null,
              data: t,
              parsedType: (0, a.getParsedType)(t)
            };
            if (!this["~standard"].async) try {
              const r = this.xn({
                data: t,
                path: [],
                parent: e
              });
              return (0, s.isValid)(r) ? {
                value: r.value
              } : {
                issues: e.common.issues
              }
            } catch (t) {
              t?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), e.common = {
                issues: [],
                async: !0
              }
            }
            return this.Sn({
              data: t,
              path: [],
              parent: e
            }).then(t => (0, s.isValid)(t) ? {
              value: t.value
            } : {
              issues: e.common.issues
            })
          }
          async parseAsync(t, e) {
            const r = await this.safeParseAsync(t, e);
            if (r.success) return r.data;
            throw r.error
          }
          async safeParseAsync(t, e) {
            const r = {
                common: {
                  issues: [],
                  contextualErrorMap: e?.errorMap,
                  async: !0
                },
                path: e?.path || [],
                schemaErrorMap: this.Tn.errorMap,
                parent: null,
                data: t,
                parsedType: (0, a.getParsedType)(t)
              },
              n = this.In({
                data: t,
                path: r.path,
                parent: r
              }),
              i = await ((0, s.isAsync)(n) ? n : Promise.resolve(n));
            return c(r, i)
          }
          refine(t, e) {
            const r = t => "string" == typeof e || typeof e > "u" ? {
              message: e
            } : "function" == typeof e ? e(t) : e;
            return this.On((e, i) => {
              const o = t(e),
                s = () => i.addIssue({
                  code: n.ZodIssueCode.custom,
                  ...r(e)
                });
              return "u" > typeof Promise && o instanceof Promise ? o.then(t => !!t || (s(), !1)) : !!o || (s(), !1)
            })
          }
          refinement(t, e) {
            return this.On((r, n) => !!t(r) || (n.addIssue("function" == typeof e ? e(r, n) : e), !1))
          }
          On(t) {
            return new dt({
              schema: this,
              typeName: Pt.ZodEffects,
              effect: {
                type: "refinement",
                refinement: t
              }
            })
          }
          superRefine(t) {
            return this.On(t)
          }
          constructor(t) {
            this.spa = this.safeParseAsync, this.Tn = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
              version: 1,
              vendor: "zod",
              validate: t => this["~validate"](t)
            }
          }
          optional() {
            return pt.create(this, this.Tn)
          }
          nullable() {
            return bt.create(this, this.Tn)
          }
          nullish() {
            return this.nullable().optional()
          }
          array() {
            return Z.create(this)
          }
          promise() {
            return ht.create(this, this.Tn)
          }
          or(t) {
            return Y.create([this, t], this.Tn)
          }
          and(t) {
            return et.create(this, t, this.Tn)
          }
          transform(t) {
            return new dt({
              ...f(this.Tn),
              schema: this,
              typeName: Pt.ZodEffects,
              effect: {
                type: "transform",
                transform: t
              }
            })
          }
          default (t) {
            const e = "function" == typeof t ? t : () => t;
            return new mt({
              ...f(this.Tn),
              innerType: this,
              defaultValue: e,
              typeName: Pt.ZodDefault
            })
          }
          brand() {
            return new vt({
              typeName: Pt.ZodBranded,
              type: this,
              ...f(this.Tn)
            })
          } catch (t) {
            const e = "function" == typeof t ? t : () => t;
            return new yt({
              ...f(this.Tn),
              innerType: this,
              catchValue: e,
              typeName: Pt.ZodCatch
            })
          }
          describe(t) {
            return new(0, this.constructor)({
              ...this.Tn,
              description: t
            })
          }
          pipe(t) {
            return wt.create(this, t)
          }
          readonly() {
            return At.create(this)
          }
          isOptional() {
            return this.safeParse(void 0).success
          }
          isNullable() {
            return this.safeParse(null).success
          }
        }
        e.ZodType = l, e.Schema = l, e.ZodSchema = l;
        const h = /^c[^\s-]{8,}$/i,
          d = /^[0-9a-z]+$/,
          p = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
          b = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
          m = /^[a-z0-9_-]{21}$/i,
          y = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
          g = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
          v = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
        let w;
        const A = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
          T = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
          E = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
          P = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
          k = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
          x = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
          I = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
          S = RegExp(`^${I}$`);

        function O(t) {
          let e = "[0-5]\\d";
          return t.precision ? e = `${e}\\.\\d{${t.precision}}` : null == t.precision && (e += "(\\.\\d+)?"), `([01]\\d|2[0-3]):[0-5]\\d(:${e})${t.precision?"+":"?"}`
        }

        function B(t) {
          return RegExp(`^${O(t)}$`)
        }

        function W(t) {
          let e = `${I}T${O(t)}`;
          const r = [];
          return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, RegExp(`^${e}$`)
        }

        function M(t, e) {
          return !(("v4" !== e && e || !A.test(t)) && ("v6" !== e && e || !E.test(t)))
        }

        function C(t, e) {
          if (!y.test(t)) return !1;
          try {
            const [r] = t.split(".");
            if (!r) return !1;
            const n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="),
              i = JSON.parse(atob(n));
            return !("object" != typeof i || null === i || "typ" in i && "JWT" !== i?.typ || !i.alg || e && i.alg !== e)
          } catch {
            return !1
          }
        }

        function R(t, e) {
          return !(("v4" !== e && e || !T.test(t)) && ("v6" !== e && e || !P.test(t)))
        }
        class N extends l {
          In(t) {
            if (this.Tn.coerce && (t.data = t.data + ""), this.En(t) !== a.ZodParsedType.string) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.string,
                received: e.parsedType
              }), s.INVALID
            }
            const e = new s.ParseStatus;
            let r;
            for (const i of this.Tn.checks)
              if ("min" === i.kind) t.data.length < i.value && (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
                code: n.ZodIssueCode.too_small,
                minimum: i.value,
                type: "string",
                inclusive: !0,
                exact: !1,
                message: i.message
              }), e.dirty());
              else if ("max" === i.kind) t.data.length > i.value && (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_big,
              maximum: i.value,
              type: "string",
              inclusive: !0,
              exact: !1,
              message: i.message
            }), e.dirty());
            else if ("length" === i.kind) {
              const o = t.data.length > i.value,
                a = t.data.length < i.value;
              (o || a) && (r = this.Pn(t, r), o ? (0, s.addIssueToContext)(r, {
                code: n.ZodIssueCode.too_big,
                maximum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message
              }) : a && (0, s.addIssueToContext)(r, {
                code: n.ZodIssueCode.too_small,
                minimum: i.value,
                type: "string",
                inclusive: !0,
                exact: !0,
                message: i.message
              }), e.dirty())
            } else if ("email" === i.kind) v.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "email",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("emoji" === i.kind) w || (w = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), w.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "emoji",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("uuid" === i.kind) b.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "uuid",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("nanoid" === i.kind) m.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "nanoid",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("cuid" === i.kind) h.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "cuid",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("cuid2" === i.kind) d.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "cuid2",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("ulid" === i.kind) p.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "ulid",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty());
            else if ("url" === i.kind) try {
              new URL(t.data)
            } catch {
              r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
                validation: "url",
                code: n.ZodIssueCode.invalid_string,
                message: i.message
              }), e.dirty()
            } else "regex" === i.kind ? (i.regex.lastIndex = 0, i.regex.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "regex",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty())) : "trim" === i.kind ? t.data = t.data.trim() : "includes" === i.kind ? t.data.includes(i.value, i.position) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: {
                includes: i.value,
                position: i.position
              },
              message: i.message
            }), e.dirty()) : "toLowerCase" === i.kind ? t.data = t.data.toLowerCase() : "toUpperCase" === i.kind ? t.data = t.data.toUpperCase() : "startsWith" === i.kind ? t.data.startsWith(i.value) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: {
                startsWith: i.value
              },
              message: i.message
            }), e.dirty()) : "endsWith" === i.kind ? t.data.endsWith(i.value) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: {
                endsWith: i.value
              },
              message: i.message
            }), e.dirty()) : "datetime" === i.kind ? W(i).test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: "datetime",
              message: i.message
            }), e.dirty()) : "date" === i.kind ? S.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: "date",
              message: i.message
            }), e.dirty()) : "time" === i.kind ? B(i).test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_string,
              validation: "time",
              message: i.message
            }), e.dirty()) : "duration" === i.kind ? g.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "duration",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : "ip" === i.kind ? M(t.data, i.version) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "ip",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : "jwt" === i.kind ? C(t.data, i.alg) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "jwt",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : "cidr" === i.kind ? R(t.data, i.version) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "cidr",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : "base64" === i.kind ? k.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "base64",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : "base64url" === i.kind ? x.test(t.data) || (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              validation: "base64url",
              code: n.ZodIssueCode.invalid_string,
              message: i.message
            }), e.dirty()) : a.util.assertNever(i);
            return {
              status: e.value,
              value: t.data
            }
          }
          Bn(t, e, r) {
            return this.refinement(e => t.test(e), {
              validation: e,
              code: n.ZodIssueCode.invalid_string,
              ...o.errorUtil.errToObj(r)
            })
          }
          Wn(t) {
            return new N({
              ...this.Tn,
              checks: [...this.Tn.checks, t]
            })
          }
          email(t) {
            return this.Wn({
              kind: "email",
              ...o.errorUtil.errToObj(t)
            })
          }
          url(t) {
            return this.Wn({
              kind: "url",
              ...o.errorUtil.errToObj(t)
            })
          }
          emoji(t) {
            return this.Wn({
              kind: "emoji",
              ...o.errorUtil.errToObj(t)
            })
          }
          uuid(t) {
            return this.Wn({
              kind: "uuid",
              ...o.errorUtil.errToObj(t)
            })
          }
          nanoid(t) {
            return this.Wn({
              kind: "nanoid",
              ...o.errorUtil.errToObj(t)
            })
          }
          cuid(t) {
            return this.Wn({
              kind: "cuid",
              ...o.errorUtil.errToObj(t)
            })
          }
          cuid2(t) {
            return this.Wn({
              kind: "cuid2",
              ...o.errorUtil.errToObj(t)
            })
          }
          ulid(t) {
            return this.Wn({
              kind: "ulid",
              ...o.errorUtil.errToObj(t)
            })
          }
          base64(t) {
            return this.Wn({
              kind: "base64",
              ...o.errorUtil.errToObj(t)
            })
          }
          base64url(t) {
            return this.Wn({
              kind: "base64url",
              ...o.errorUtil.errToObj(t)
            })
          }
          jwt(t) {
            return this.Wn({
              kind: "jwt",
              ...o.errorUtil.errToObj(t)
            })
          }
          ip(t) {
            return this.Wn({
              kind: "ip",
              ...o.errorUtil.errToObj(t)
            })
          }
          cidr(t) {
            return this.Wn({
              kind: "cidr",
              ...o.errorUtil.errToObj(t)
            })
          }
          datetime(t) {
            return "string" == typeof t ? this.Wn({
              kind: "datetime",
              precision: null,
              offset: !1,
              local: !1,
              message: t
            }) : this.Wn({
              kind: "datetime",
              precision: typeof t?.precision > "u" ? null : t?.precision,
              offset: t?.offset ?? !1,
              local: t?.local ?? !1,
              ...o.errorUtil.errToObj(t?.message)
            })
          }
          date(t) {
            return this.Wn({
              kind: "date",
              message: t
            })
          }
          time(t) {
            return "string" == typeof t ? this.Wn({
              kind: "time",
              precision: null,
              message: t
            }) : this.Wn({
              kind: "time",
              precision: typeof t?.precision > "u" ? null : t?.precision,
              ...o.errorUtil.errToObj(t?.message)
            })
          }
          duration(t) {
            return this.Wn({
              kind: "duration",
              ...o.errorUtil.errToObj(t)
            })
          }
          regex(t, e) {
            return this.Wn({
              kind: "regex",
              regex: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          includes(t, e) {
            return this.Wn({
              kind: "includes",
              value: t,
              position: e?.position,
              ...o.errorUtil.errToObj(e?.message)
            })
          }
          startsWith(t, e) {
            return this.Wn({
              kind: "startsWith",
              value: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          endsWith(t, e) {
            return this.Wn({
              kind: "endsWith",
              value: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          min(t, e) {
            return this.Wn({
              kind: "min",
              value: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          max(t, e) {
            return this.Wn({
              kind: "max",
              value: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          length(t, e) {
            return this.Wn({
              kind: "length",
              value: t,
              ...o.errorUtil.errToObj(e)
            })
          }
          nonempty(t) {
            return this.min(1, o.errorUtil.errToObj(t))
          }
          trim() {
            return new N({
              ...this.Tn,
              checks: [...this.Tn.checks, {
                kind: "trim"
              }]
            })
          }
          toLowerCase() {
            return new N({
              ...this.Tn,
              checks: [...this.Tn.checks, {
                kind: "toLowerCase"
              }]
            })
          }
          toUpperCase() {
            return new N({
              ...this.Tn,
              checks: [...this.Tn.checks, {
                kind: "toUpperCase"
              }]
            })
          }
          get isDatetime() {
            return !!this.Tn.checks.find(t => "datetime" === t.kind)
          }
          get isDate() {
            return !!this.Tn.checks.find(t => "date" === t.kind)
          }
          get isTime() {
            return !!this.Tn.checks.find(t => "time" === t.kind)
          }
          get isDuration() {
            return !!this.Tn.checks.find(t => "duration" === t.kind)
          }
          get isEmail() {
            return !!this.Tn.checks.find(t => "email" === t.kind)
          }
          get isURL() {
            return !!this.Tn.checks.find(t => "url" === t.kind)
          }
          get isEmoji() {
            return !!this.Tn.checks.find(t => "emoji" === t.kind)
          }
          get isUUID() {
            return !!this.Tn.checks.find(t => "uuid" === t.kind)
          }
          get isNANOID() {
            return !!this.Tn.checks.find(t => "nanoid" === t.kind)
          }
          get isCUID() {
            return !!this.Tn.checks.find(t => "cuid" === t.kind)
          }
          get isCUID2() {
            return !!this.Tn.checks.find(t => "cuid2" === t.kind)
          }
          get isULID() {
            return !!this.Tn.checks.find(t => "ulid" === t.kind)
          }
          get isIP() {
            return !!this.Tn.checks.find(t => "ip" === t.kind)
          }
          get isCIDR() {
            return !!this.Tn.checks.find(t => "cidr" === t.kind)
          }
          get isBase64() {
            return !!this.Tn.checks.find(t => "base64" === t.kind)
          }
          get isBase64url() {
            return !!this.Tn.checks.find(t => "base64url" === t.kind)
          }
          get minLength() {
            let t = null;
            for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
            return t
          }
          get maxLength() {
            let t = null;
            for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
            return t
          }
        }

        function j(t, e) {
          const r = (t.toString().split(".")[1] || "").length,
            n = (e.toString().split(".")[1] || "").length,
            i = r > n ? r : n;
          return Number.parseInt(t.toFixed(i).replace(".", "")) % Number.parseInt(e.toFixed(i).replace(".", "")) / 10 ** i
        }
        e.ZodString = N, N.create = t => new N({
          checks: [],
          typeName: Pt.ZodString,
          coerce: t?.coerce ?? !1,
          ...f(t)
        });
        class _ extends l {
          constructor() {
            super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
          }
          In(t) {
            if (this.Tn.coerce && (t.data = +t.data), this.En(t) !== a.ZodParsedType.number) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.number,
                received: e.parsedType
              }), s.INVALID
            }
            let e;
            const r = new s.ParseStatus;
            for (const i of this.Tn.checks) "int" === i.kind ? a.util.isInteger(t.data) || (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: i.message
            }), r.dirty()) : "min" === i.kind ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.too_small,
              minimum: i.value,
              type: "number",
              inclusive: i.inclusive,
              exact: !1,
              message: i.message
            }), r.dirty()) : "max" === i.kind ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.too_big,
              maximum: i.value,
              type: "number",
              inclusive: i.inclusive,
              exact: !1,
              message: i.message
            }), r.dirty()) : "multipleOf" === i.kind ? 0 !== j(t.data, i.value) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.not_multiple_of,
              multipleOf: i.value,
              message: i.message
            }), r.dirty()) : "finite" === i.kind ? Number.isFinite(t.data) || (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.not_finite,
              message: i.message
            }), r.dirty()) : a.util.assertNever(i);
            return {
              status: r.value,
              value: t.data
            }
          }
          gte(t, e) {
            return this.setLimit("min", t, !0, o.errorUtil.toString(e))
          }
          gt(t, e) {
            return this.setLimit("min", t, !1, o.errorUtil.toString(e))
          }
          lte(t, e) {
            return this.setLimit("max", t, !0, o.errorUtil.toString(e))
          }
          lt(t, e) {
            return this.setLimit("max", t, !1, o.errorUtil.toString(e))
          }
          setLimit(t, e, r, n) {
            return new _({
              ...this.Tn,
              checks: [...this.Tn.checks, {
                kind: t,
                value: e,
                inclusive: r,
                message: o.errorUtil.toString(n)
              }]
            })
          }
          Wn(t) {
            return new _({
              ...this.Tn,
              checks: [...this.Tn.checks, t]
            })
          }
          int(t) {
            return this.Wn({
              kind: "int",
              message: o.errorUtil.toString(t)
            })
          }
          positive(t) {
            return this.Wn({
              kind: "min",
              value: 0,
              inclusive: !1,
              message: o.errorUtil.toString(t)
            })
          }
          negative(t) {
            return this.Wn({
              kind: "max",
              value: 0,
              inclusive: !1,
              message: o.errorUtil.toString(t)
            })
          }
          nonpositive(t) {
            return this.Wn({
              kind: "max",
              value: 0,
              inclusive: !0,
              message: o.errorUtil.toString(t)
            })
          }
          nonnegative(t) {
            return this.Wn({
              kind: "min",
              value: 0,
              inclusive: !0,
              message: o.errorUtil.toString(t)
            })
          }
          multipleOf(t, e) {
            return this.Wn({
              kind: "multipleOf",
              value: t,
              message: o.errorUtil.toString(e)
            })
          }
          finite(t) {
            return this.Wn({
              kind: "finite",
              message: o.errorUtil.toString(t)
            })
          }
          safe(t) {
            return this.Wn({
              kind: "min",
              inclusive: !0,
              value: Number.MIN_SAFE_INTEGER,
              message: o.errorUtil.toString(t)
            }).Wn({
              kind: "max",
              inclusive: !0,
              value: Number.MAX_SAFE_INTEGER,
              message: o.errorUtil.toString(t)
            })
          }
          get minValue() {
            let t = null;
            for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
            return t
          }
          get maxValue() {
            let t = null;
            for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
            return t
          }
          get isInt() {
            return !!this.Tn.checks.find(t => "int" === t.kind || "multipleOf" === t.kind && a.util.isInteger(t.value))
          }
          get isFinite() {
            let t = null,
              e = null;
            for (const r of this.Tn.checks) {
              if ("finite" === r.kind || "int" === r.kind || "multipleOf" === r.kind) return !0;
              "min" === r.kind ? (null === e || r.value > e) && (e = r.value) : "max" === r.kind && (null === t || r.value < t) && (t = r.value)
            }
            return Number.isFinite(e) && Number.isFinite(t)
          }
        }
        e.ZodNumber = _, _.create = t => new _({
          checks: [],
          typeName: Pt.ZodNumber,
          coerce: t?.coerce || !1,
          ...f(t)
        });
        class D extends l {
          constructor() {
            super(...arguments), this.min = this.gte, this.max = this.lte
          }
          In(t) {
            if (this.Tn.coerce) try {
              t.data = BigInt(t.data)
            } catch {
              return this.Mn(t)
            }
            if (this.En(t) !== a.ZodParsedType.bigint) return this.Mn(t);
            let e;
            const r = new s.ParseStatus;
            for (const i of this.Tn.checks) "min" === i.kind ? (i.inclusive ? t.data < i.value : t.data <= i.value) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.too_small,
              type: "bigint",
              minimum: i.value,
              inclusive: i.inclusive,
              message: i.message
            }), r.dirty()) : "max" === i.kind ? (i.inclusive ? t.data > i.value : t.data >= i.value) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.too_big,
              type: "bigint",
              maximum: i.value,
              inclusive: i.inclusive,
              message: i.message
            }), r.dirty()) : "multipleOf" === i.kind ? t.data % i.value !== BigInt(0) && (e = this.Pn(t, e), (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.not_multiple_of,
              multipleOf: i.value,
              message: i.message
            }), r.dirty()) : a.util.assertNever(i);
            return {
              status: r.value,
              value: t.data
            }
          }
          Mn(t) {
            const e = this.Pn(t);
            return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.bigint,
              received: e.parsedType
            }), s.INVALID
          }
          gte(t, e) {
            return this.setLimit("min", t, !0, o.errorUtil.toString(e))
          }
          gt(t, e) {
            return this.setLimit("min", t, !1, o.errorUtil.toString(e))
          }
          lte(t, e) {
            return this.setLimit("max", t, !0, o.errorUtil.toString(e))
          }
          lt(t, e) {
            return this.setLimit("max", t, !1, o.errorUtil.toString(e))
          }
          setLimit(t, e, r, n) {
            return new D({
              ...this.Tn,
              checks: [...this.Tn.checks, {
                kind: t,
                value: e,
                inclusive: r,
                message: o.errorUtil.toString(n)
              }]
            })
          }
          Wn(t) {
            return new D({
              ...this.Tn,
              checks: [...this.Tn.checks, t]
            })
          }
          positive(t) {
            return this.Wn({
              kind: "min",
              value: BigInt(0),
              inclusive: !1,
              message: o.errorUtil.toString(t)
            })
          }
          negative(t) {
            return this.Wn({
              kind: "max",
              value: BigInt(0),
              inclusive: !1,
              message: o.errorUtil.toString(t)
            })
          }
          nonpositive(t) {
            return this.Wn({
              kind: "max",
              value: BigInt(0),
              inclusive: !0,
              message: o.errorUtil.toString(t)
            })
          }
          nonnegative(t) {
            return this.Wn({
              kind: "min",
              value: BigInt(0),
              inclusive: !0,
              message: o.errorUtil.toString(t)
            })
          }
          multipleOf(t, e) {
            return this.Wn({
              kind: "multipleOf",
              value: t,
              message: o.errorUtil.toString(e)
            })
          }
          get minValue() {
            let t = null;
            for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
            return t
          }
          get maxValue() {
            let t = null;
            for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
            return t
          }
        }
        e.ZodBigInt = D, D.create = t => new D({
          checks: [],
          typeName: Pt.ZodBigInt,
          coerce: t?.coerce ?? !1,
          ...f(t)
        });
        class U extends l {
          In(t) {
            if (this.Tn.coerce && (t.data = !!t.data), this.En(t) !== a.ZodParsedType.boolean) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.boolean,
                received: e.parsedType
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
        }
        e.ZodBoolean = U, U.create = t => new U({
          typeName: Pt.ZodBoolean,
          coerce: t?.coerce || !1,
          ...f(t)
        });
        class L extends l {
          In(t) {
            if (this.Tn.coerce && (t.data = new Date(t.data)), this.En(t) !== a.ZodParsedType.date) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.date,
                received: e.parsedType
              }), s.INVALID
            }
            if (Number.isNaN(t.data.getTime())) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_date
              }), s.INVALID
            }
            const e = new s.ParseStatus;
            let r;
            for (const i of this.Tn.checks) "min" === i.kind ? t.data.getTime() < i.value && (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_small,
              message: i.message,
              inclusive: !0,
              exact: !1,
              minimum: i.value,
              type: "date"
            }), e.dirty()) : "max" === i.kind ? t.data.getTime() > i.value && (r = this.Pn(t, r), (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_big,
              message: i.message,
              inclusive: !0,
              exact: !1,
              maximum: i.value,
              type: "date"
            }), e.dirty()) : a.util.assertNever(i);
            return {
              status: e.value,
              value: new Date(t.data.getTime())
            }
          }
          Wn(t) {
            return new L({
              ...this.Tn,
              checks: [...this.Tn.checks, t]
            })
          }
          min(t, e) {
            return this.Wn({
              kind: "min",
              value: t.getTime(),
              message: o.errorUtil.toString(e)
            })
          }
          max(t, e) {
            return this.Wn({
              kind: "max",
              value: t.getTime(),
              message: o.errorUtil.toString(e)
            })
          }
          get minDate() {
            let t = null;
            for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
            return null != t ? new Date(t) : null
          }
          get maxDate() {
            let t = null;
            for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
            return null != t ? new Date(t) : null
          }
        }
        e.ZodDate = L, L.create = t => new L({
          checks: [],
          coerce: t?.coerce || !1,
          typeName: Pt.ZodDate,
          ...f(t)
        });
        class F extends l {
          In(t) {
            if (this.En(t) !== a.ZodParsedType.symbol) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.symbol,
                received: e.parsedType
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
        }
        e.ZodSymbol = F, F.create = t => new F({
          typeName: Pt.ZodSymbol,
          ...f(t)
        });
        class $ extends l {
          In(t) {
            if (this.En(t) !== a.ZodParsedType.undefined) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.undefined,
                received: e.parsedType
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
        }
        e.ZodUndefined = $, $.create = t => new $({
          typeName: Pt.ZodUndefined,
          ...f(t)
        });
        class z extends l {
          In(t) {
            if (this.En(t) !== a.ZodParsedType.null) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.null,
                received: e.parsedType
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
        }
        e.ZodNull = z, z.create = t => new z({
          typeName: Pt.ZodNull,
          ...f(t)
        });
        class H extends l {
          constructor() {
            super(...arguments), this.Cn = !0
          }
          In(t) {
            return (0, s.OK)(t.data)
          }
        }
        e.ZodAny = H, H.create = t => new H({
          typeName: Pt.ZodAny,
          ...f(t)
        });
        class G extends l {
          constructor() {
            super(...arguments), this.Rn = !0
          }
          In(t) {
            return (0, s.OK)(t.data)
          }
        }
        e.ZodUnknown = G, G.create = t => new G({
          typeName: Pt.ZodUnknown,
          ...f(t)
        });
        class K extends l {
          In(t) {
            const e = this.Pn(t);
            return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.never,
              received: e.parsedType
            }), s.INVALID
          }
        }
        e.ZodNever = K, K.create = t => new K({
          typeName: Pt.ZodNever,
          ...f(t)
        });
        class V extends l {
          In(t) {
            if (this.En(t) !== a.ZodParsedType.undefined) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.void,
                received: e.parsedType
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
        }
        e.ZodVoid = V, V.create = t => new V({
          typeName: Pt.ZodVoid,
          ...f(t)
        });
        class Z extends l {
          In(t) {
            const {
              ctx: e,
              status: r
            } = this.kn(t), i = this.Tn;
            if (e.parsedType !== a.ZodParsedType.array) return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.array,
              received: e.parsedType
            }), s.INVALID;
            if (null !== i.exactLength) {
              const t = e.data.length > i.exactLength.value,
                o = e.data.length < i.exactLength.value;
              (t || o) && ((0, s.addIssueToContext)(e, {
                code: t ? n.ZodIssueCode.too_big : n.ZodIssueCode.too_small,
                minimum: o ? i.exactLength.value : void 0,
                maximum: t ? i.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: i.exactLength.message
              }), r.dirty())
            }
            if (null !== i.minLength && e.data.length < i.minLength.value && ((0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.too_small,
                minimum: i.minLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.minLength.message
              }), r.dirty()), null !== i.maxLength && e.data.length > i.maxLength.value && ((0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.too_big,
                maximum: i.maxLength.value,
                type: "array",
                inclusive: !0,
                exact: !1,
                message: i.maxLength.message
              }), r.dirty()), e.common.async) return Promise.all([...e.data].map((t, r) => i.type.Sn(new u(e, t, e.path, r)))).then(t => s.ParseStatus.mergeArray(r, t));
            const o = [...e.data].map((t, r) => i.type.xn(new u(e, t, e.path, r)));
            return s.ParseStatus.mergeArray(r, o)
          }
          get element() {
            return this.Tn.type
          }
          min(t, e) {
            return new Z({
              ...this.Tn,
              minLength: {
                value: t,
                message: o.errorUtil.toString(e)
              }
            })
          }
          max(t, e) {
            return new Z({
              ...this.Tn,
              maxLength: {
                value: t,
                message: o.errorUtil.toString(e)
              }
            })
          }
          length(t, e) {
            return new Z({
              ...this.Tn,
              exactLength: {
                value: t,
                message: o.errorUtil.toString(e)
              }
            })
          }
          nonempty(t) {
            return this.min(1, t)
          }
        }

        function q(t) {
          if (t instanceof J) {
            const e = {};
            for (const r in t.shape) {
              const n = t.shape[r];
              e[r] = pt.create(q(n))
            }
            return new J({
              ...t.Tn,
              shape: () => e
            })
          }
          return t instanceof Z ? new Z({
            ...t.Tn,
            type: q(t.element)
          }) : t instanceof pt ? pt.create(q(t.unwrap())) : t instanceof bt ? bt.create(q(t.unwrap())) : t instanceof rt ? rt.create(t.items.map(t => q(t))) : t
        }
        e.ZodArray = Z, Z.create = (t, e) => new Z({
          type: t,
          minLength: null,
          maxLength: null,
          exactLength: null,
          typeName: Pt.ZodArray,
          ...f(e)
        });
        class J extends l {
          constructor() {
            super(...arguments), this.Nn = null, this.nonstrict = this.passthrough, this.augment = this.extend
          }
          jn() {
            if (null !== this.Nn) return this.Nn;
            const t = this.Tn.shape(),
              e = a.util.objectKeys(t);
            return this.Nn = {
              shape: t,
              keys: e
            }, this.Nn
          }
          In(t) {
            if (this.En(t) !== a.ZodParsedType.object) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.object,
                received: e.parsedType
              }), s.INVALID
            }
            const {
              status: e,
              ctx: r
            } = this.kn(t), {
              shape: i,
              keys: o
            } = this.jn(), c = [];
            if (!(this.Tn.catchall instanceof K && "strip" === this.Tn.unknownKeys))
              for (const t in r.data) o.includes(t) || c.push(t);
            const f = [];
            for (const t of o) {
              const e = i[t],
                n = r.data[t];
              f.push({
                key: {
                  status: "valid",
                  value: t
                },
                value: e.In(new u(r, n, r.path, t)),
                alwaysSet: t in r.data
              })
            }
            if (this.Tn.catchall instanceof K) {
              const t = this.Tn.unknownKeys;
              if ("passthrough" === t)
                for (const t of c) f.push({
                  key: {
                    status: "valid",
                    value: t
                  },
                  value: {
                    status: "valid",
                    value: r.data[t]
                  }
                });
              else if ("strict" === t) c.length > 0 && ((0, s.addIssueToContext)(r, {
                code: n.ZodIssueCode.unrecognized_keys,
                keys: c
              }), e.dirty());
              else if ("strip" !== t) throw Error("Internal ZodObject error: invalid unknownKeys value.")
            } else {
              const t = this.Tn.catchall;
              for (const e of c) {
                const n = r.data[e];
                f.push({
                  key: {
                    status: "valid",
                    value: e
                  },
                  value: t.In(new u(r, n, r.path, e)),
                  alwaysSet: e in r.data
                })
              }
            }
            return r.common.async ? Promise.resolve().then(async () => {
              const t = [];
              for (const e of f) {
                const r = await e.key,
                  n = await e.value;
                t.push({
                  key: r,
                  value: n,
                  alwaysSet: e.alwaysSet
                })
              }
              return t
            }).then(t => s.ParseStatus.mergeObjectSync(e, t)) : s.ParseStatus.mergeObjectSync(e, f)
          }
          get shape() {
            return this.Tn.shape()
          }
          strict(t) {
            return o.errorUtil.errToObj, new J({
              ...this.Tn,
              unknownKeys: "strict",
              ...void 0 !== t ? {
                errorMap: (e, r) => {
                  const n = this.Tn.errorMap?.(e, r).message ?? r.defaultError;
                  return "unrecognized_keys" === e.code ? {
                    message: o.errorUtil.errToObj(t).message ?? n
                  } : {
                    message: n
                  }
                }
              } : {}
            })
          }
          strip() {
            return new J({
              ...this.Tn,
              unknownKeys: "strip"
            })
          }
          passthrough() {
            return new J({
              ...this.Tn,
              unknownKeys: "passthrough"
            })
          }
          extend(t) {
            return new J({
              ...this.Tn,
              shape: () => ({
                ...this.Tn.shape(),
                ...t
              })
            })
          }
          merge(t) {
            return new J({
              unknownKeys: t.Tn.unknownKeys,
              catchall: t.Tn.catchall,
              shape: () => ({
                ...this.Tn.shape(),
                ...t.Tn.shape()
              }),
              typeName: Pt.ZodObject
            })
          }
          setKey(t, e) {
            return this.augment({
              [t]: e
            })
          }
          catchall(t) {
            return new J({
              ...this.Tn,
              catchall: t
            })
          }
          pick(t) {
            const e = {};
            for (const r of a.util.objectKeys(t)) t[r] && this.shape[r] && (e[r] = this.shape[r]);
            return new J({
              ...this.Tn,
              shape: () => e
            })
          }
          omit(t) {
            const e = {};
            for (const r of a.util.objectKeys(this.shape)) t[r] || (e[r] = this.shape[r]);
            return new J({
              ...this.Tn,
              shape: () => e
            })
          }
          deepPartial() {
            return q(this)
          }
          partial(t) {
            const e = {};
            for (const r of a.util.objectKeys(this.shape)) {
              const n = this.shape[r];
              t && !t[r] ? e[r] = n : e[r] = n.optional()
            }
            return new J({
              ...this.Tn,
              shape: () => e
            })
          }
          required(t) {
            const e = {};
            for (const r of a.util.objectKeys(this.shape))
              if (t && !t[r]) e[r] = this.shape[r];
              else {
                let t = this.shape[r];
                for (; t instanceof pt;) t = t.Tn.innerType;
                e[r] = t
              } return new J({
              ...this.Tn,
              shape: () => e
            })
          }
          keyof() {
            return ct(a.util.objectKeys(this.shape))
          }
        }
        e.ZodObject = J, J.create = (t, e) => new J({
          shape: () => t,
          unknownKeys: "strip",
          catchall: K.create(),
          typeName: Pt.ZodObject,
          ...f(e)
        }), J.strictCreate = (t, e) => new J({
          shape: () => t,
          unknownKeys: "strict",
          catchall: K.create(),
          typeName: Pt.ZodObject,
          ...f(e)
        }), J.lazycreate = (t, e) => new J({
          shape: t,
          unknownKeys: "strip",
          catchall: K.create(),
          typeName: Pt.ZodObject,
          ...f(e)
        });
        class Y extends l {
          In(t) {
            const {
              ctx: e
            } = this.kn(t), r = this.Tn.options;
            if (e.common.async) return Promise.all(r.map(async t => {
              const r = {
                ...e,
                common: {
                  ...e.common,
                  issues: []
                },
                parent: null
              };
              return {
                result: await t.Sn({
                  data: e.data,
                  path: e.path,
                  parent: r
                }),
                ctx: r
              }
            })).then(function(t) {
              for (const e of t)
                if ("valid" === e.result.status) return e.result;
              for (const r of t)
                if ("dirty" === r.result.status) return e.common.issues.push(...r.ctx.common.issues), r.result;
              const r = t.map(t => new n.ZodError(t.ctx.common.issues));
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_union,
                unionErrors: r
              }), s.INVALID
            });
            {
              let t;
              const i = [];
              for (const n of r) {
                const r = {
                    ...e,
                    common: {
                      ...e.common,
                      issues: []
                    },
                    parent: null
                  },
                  o = n.xn({
                    data: e.data,
                    path: e.path,
                    parent: r
                  });
                if ("valid" === o.status) return o;
                "dirty" === o.status && !t && (t = {
                  result: o,
                  ctx: r
                }), r.common.issues.length && i.push(r.common.issues)
              }
              if (t) return e.common.issues.push(...t.ctx.common.issues), t.result;
              const o = i.map(t => new n.ZodError(t));
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_union,
                unionErrors: o
              }), s.INVALID
            }
          }
          get options() {
            return this.Tn.options
          }
        }
        e.ZodUnion = Y, Y.create = (t, e) => new Y({
          options: t,
          typeName: Pt.ZodUnion,
          ...f(e)
        });
        const Q = t => t instanceof at ? Q(t.schema) : t instanceof dt ? Q(t.innerType()) : t instanceof ut ? [t.value] : t instanceof ft ? t.options : t instanceof lt ? a.util.objectValues(t.enum) : t instanceof mt ? Q(t.Tn.innerType) : t instanceof $ ? [void 0] : t instanceof z ? [null] : t instanceof pt ? [void 0, ...Q(t.unwrap())] : t instanceof bt ? [null, ...Q(t.unwrap())] : t instanceof vt || t instanceof At ? Q(t.unwrap()) : t instanceof yt ? Q(t.Tn.innerType) : [];
        class X extends l {
          In(t) {
            const {
              ctx: e
            } = this.kn(t);
            if (e.parsedType !== a.ZodParsedType.object) return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.object,
              received: e.parsedType
            }), s.INVALID;
            const r = this.discriminator,
              i = e.data[r],
              o = this.optionsMap.get(i);
            return o ? e.common.async ? o.Sn({
              data: e.data,
              path: e.path,
              parent: e
            }) : o.xn({
              data: e.data,
              path: e.path,
              parent: e
            }) : ((0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_union_discriminator,
              options: Array.from(this.optionsMap.keys()),
              path: [r]
            }), s.INVALID)
          }
          get discriminator() {
            return this.Tn.discriminator
          }
          get options() {
            return this.Tn.options
          }
          get optionsMap() {
            return this.Tn.optionsMap
          }
          static create(t, e, r) {
            const n = new Map;
            for (const r of e) {
              const e = Q(r.shape[t]);
              if (!e.length) throw Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
              for (const i of e) {
                if (n.has(i)) throw Error(`Discriminator property ${t+""} has duplicate value ${i+""}`);
                n.set(i, r)
              }
            }
            return new X({
              typeName: Pt.ZodDiscriminatedUnion,
              discriminator: t,
              options: e,
              optionsMap: n,
              ...f(r)
            })
          }
        }

        function tt(t, e) {
          const r = (0, a.getParsedType)(t),
            n = (0, a.getParsedType)(e);
          if (t === e) return {
            valid: !0,
            data: t
          };
          if (r === a.ZodParsedType.object && n === a.ZodParsedType.object) {
            const r = a.util.objectKeys(e),
              n = a.util.objectKeys(t).filter(t => -1 !== r.indexOf(t)),
              i = {
                ...t,
                ...e
              };
            for (const r of n) {
              const n = tt(t[r], e[r]);
              if (!n.valid) return {
                valid: !1
              };
              i[r] = n.data
            }
            return {
              valid: !0,
              data: i
            }
          }
          if (r === a.ZodParsedType.array && n === a.ZodParsedType.array) {
            if (t.length !== e.length) return {
              valid: !1
            };
            const r = [];
            for (let n = 0; n < t.length; n++) {
              const i = tt(t[n], e[n]);
              if (!i.valid) return {
                valid: !1
              };
              r.push(i.data)
            }
            return {
              valid: !0,
              data: r
            }
          }
          return r === a.ZodParsedType.date && n === a.ZodParsedType.date && +t == +e ? {
            valid: !0,
            data: t
          } : {
            valid: !1
          }
        }
        e.ZodDiscriminatedUnion = X;
        class et extends l {
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t), i = (t, i) => {
              if ((0, s.isAborted)(t) || (0, s.isAborted)(i)) return s.INVALID;
              const o = tt(t.value, i.value);
              return o.valid ? (((0, s.isDirty)(t) || (0, s.isDirty)(i)) && e.dirty(), {
                status: e.value,
                value: o.data
              }) : ((0, s.addIssueToContext)(r, {
                code: n.ZodIssueCode.invalid_intersection_types
              }), s.INVALID)
            };
            return r.common.async ? Promise.all([this.Tn.left.Sn({
              data: r.data,
              path: r.path,
              parent: r
            }), this.Tn.right.Sn({
              data: r.data,
              path: r.path,
              parent: r
            })]).then(([t, e]) => i(t, e)) : i(this.Tn.left.xn({
              data: r.data,
              path: r.path,
              parent: r
            }), this.Tn.right.xn({
              data: r.data,
              path: r.path,
              parent: r
            }))
          }
        }
        e.ZodIntersection = et, et.create = (t, e, r) => new et({
          left: t,
          right: e,
          typeName: Pt.ZodIntersection,
          ...f(r)
        });
        class rt extends l {
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t);
            if (r.parsedType !== a.ZodParsedType.array) return (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.array,
              received: r.parsedType
            }), s.INVALID;
            if (r.data.length < this.Tn.items.length) return (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_small,
              minimum: this.Tn.items.length,
              inclusive: !0,
              exact: !1,
              type: "array"
            }), s.INVALID;
            !this.Tn.rest && r.data.length > this.Tn.items.length && ((0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_big,
              maximum: this.Tn.items.length,
              inclusive: !0,
              exact: !1,
              type: "array"
            }), e.dirty());
            const i = [...r.data].map((t, e) => {
              const n = this.Tn.items[e] || this.Tn.rest;
              return n ? n.In(new u(r, t, r.path, e)) : null
            }).filter(t => !!t);
            return r.common.async ? Promise.all(i).then(t => s.ParseStatus.mergeArray(e, t)) : s.ParseStatus.mergeArray(e, i)
          }
          get items() {
            return this.Tn.items
          }
          rest(t) {
            return new rt({
              ...this.Tn,
              rest: t
            })
          }
        }
        e.ZodTuple = rt, rt.create = (t, e) => {
          if (!Array.isArray(t)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
          return new rt({
            items: t,
            typeName: Pt.ZodTuple,
            rest: null,
            ...f(e)
          })
        };
        class nt extends l {
          get keySchema() {
            return this.Tn.keyType
          }
          get valueSchema() {
            return this.Tn.valueType
          }
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t);
            if (r.parsedType !== a.ZodParsedType.object) return (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.object,
              received: r.parsedType
            }), s.INVALID;
            const i = [],
              o = this.Tn.keyType,
              c = this.Tn.valueType;
            for (const t in r.data) i.push({
              key: o.In(new u(r, t, r.path, t)),
              value: c.In(new u(r, r.data[t], r.path, t)),
              alwaysSet: t in r.data
            });
            return r.common.async ? s.ParseStatus.mergeObjectAsync(e, i) : s.ParseStatus.mergeObjectSync(e, i)
          }
          get element() {
            return this.Tn.valueType
          }
          static create(t, e, r) {
            return new nt(e instanceof l ? {
              keyType: t,
              valueType: e,
              typeName: Pt.ZodRecord,
              ...f(r)
            } : {
              keyType: N.create(),
              valueType: t,
              typeName: Pt.ZodRecord,
              ...f(e)
            })
          }
        }
        e.ZodRecord = nt;
        class it extends l {
          get keySchema() {
            return this.Tn.keyType
          }
          get valueSchema() {
            return this.Tn.valueType
          }
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t);
            if (r.parsedType !== a.ZodParsedType.map) return (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.map,
              received: r.parsedType
            }), s.INVALID;
            const i = this.Tn.keyType,
              o = this.Tn.valueType,
              c = [...r.data.entries()].map(([t, e], n) => ({
                key: i.In(new u(r, t, r.path, [n, "key"])),
                value: o.In(new u(r, e, r.path, [n, "value"]))
              }));
            if (r.common.async) {
              const t = new Map;
              return Promise.resolve().then(async () => {
                for (const r of c) {
                  const n = await r.key,
                    i = await r.value;
                  if ("aborted" === n.status || "aborted" === i.status) return s.INVALID;
                  ("dirty" === n.status || "dirty" === i.status) && e.dirty(), t.set(n.value, i.value)
                }
                return {
                  status: e.value,
                  value: t
                }
              })
            } {
              const t = new Map;
              for (const r of c) {
                const n = r.key,
                  i = r.value;
                if ("aborted" === n.status || "aborted" === i.status) return s.INVALID;
                ("dirty" === n.status || "dirty" === i.status) && e.dirty(), t.set(n.value, i.value)
              }
              return {
                status: e.value,
                value: t
              }
            }
          }
        }
        e.ZodMap = it, it.create = (t, e, r) => new it({
          valueType: e,
          keyType: t,
          typeName: Pt.ZodMap,
          ...f(r)
        });
        class ot extends l {
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t);
            if (r.parsedType !== a.ZodParsedType.set) return (0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.set,
              received: r.parsedType
            }), s.INVALID;
            const i = this.Tn;
            null !== i.minSize && r.data.size < i.minSize.value && ((0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_small,
              minimum: i.minSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.minSize.message
            }), e.dirty()), null !== i.maxSize && r.data.size > i.maxSize.value && ((0, s.addIssueToContext)(r, {
              code: n.ZodIssueCode.too_big,
              maximum: i.maxSize.value,
              type: "set",
              inclusive: !0,
              exact: !1,
              message: i.maxSize.message
            }), e.dirty());
            const o = this.Tn.valueType;

            function c(t) {
              const r = new Set;
              for (const n of t) {
                if ("aborted" === n.status) return s.INVALID;
                "dirty" === n.status && e.dirty(), r.add(n.value)
              }
              return {
                status: e.value,
                value: r
              }
            }
            const f = [...r.data.values()].map((t, e) => o.In(new u(r, t, r.path, e)));
            return r.common.async ? Promise.all(f).then(t => c(t)) : c(f)
          }
          min(t, e) {
            return new ot({
              ...this.Tn,
              minSize: {
                value: t,
                message: o.errorUtil.toString(e)
              }
            })
          }
          max(t, e) {
            return new ot({
              ...this.Tn,
              maxSize: {
                value: t,
                message: o.errorUtil.toString(e)
              }
            })
          }
          size(t, e) {
            return this.min(t, e).max(t, e)
          }
          nonempty(t) {
            return this.min(1, t)
          }
        }
        e.ZodSet = ot, ot.create = (t, e) => new ot({
          valueType: t,
          minSize: null,
          maxSize: null,
          typeName: Pt.ZodSet,
          ...f(e)
        });
        class st extends l {
          constructor() {
            super(...arguments), this.validate = this.implement
          }
          In(t) {
            const {
              ctx: e
            } = this.kn(t);
            if (e.parsedType !== a.ZodParsedType.function) return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.function,
              received: e.parsedType
            }), s.INVALID;

            function r(t, r) {
              return (0, s.makeIssue)({
                data: t,
                path: e.path,
                errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, (0, i.getErrorMap)(), i.defaultErrorMap].filter(t => !!t),
                issueData: {
                  code: n.ZodIssueCode.invalid_arguments,
                  argumentsError: r
                }
              })
            }

            function o(t, r) {
              return (0, s.makeIssue)({
                data: t,
                path: e.path,
                errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, (0, i.getErrorMap)(), i.defaultErrorMap].filter(t => !!t),
                issueData: {
                  code: n.ZodIssueCode.invalid_return_type,
                  returnTypeError: r
                }
              })
            }
            const u = {
                errorMap: e.common.contextualErrorMap
              },
              c = e.data;
            if (this.Tn.returns instanceof ht) {
              const t = this;
              return (0, s.OK)(async function(...e) {
                const i = new n.ZodError([]),
                  s = await t.Tn.args.parseAsync(e, u).catch(t => {
                    throw i.addIssue(r(e, t)), i
                  }),
                  a = await Reflect.apply(c, this, s);
                return await t.Tn.returns.Tn.type.parseAsync(a, u).catch(t => {
                  throw i.addIssue(o(a, t)), i
                })
              })
            } {
              const t = this;
              return (0, s.OK)(function(...e) {
                const i = t.Tn.args.safeParse(e, u);
                if (!i.success) throw new n.ZodError([r(e, i.error)]);
                const s = Reflect.apply(c, this, i.data),
                  a = t.Tn.returns.safeParse(s, u);
                if (!a.success) throw new n.ZodError([o(s, a.error)]);
                return a.data
              })
            }
          }
          parameters() {
            return this.Tn.args
          }
          returnType() {
            return this.Tn.returns
          }
          args(...t) {
            return new st({
              ...this.Tn,
              args: rt.create(t).rest(G.create())
            })
          }
          returns(t) {
            return new st({
              ...this.Tn,
              returns: t
            })
          }
          implement(t) {
            return this.parse(t)
          }
          strictImplement(t) {
            return this.parse(t)
          }
          static create(t, e, r) {
            return new st({
              args: t || rt.create([]).rest(G.create()),
              returns: e || G.create(),
              typeName: Pt.ZodFunction,
              ...f(r)
            })
          }
        }
        e.ZodFunction = st;
        class at extends l {
          get schema() {
            return this.Tn.getter()
          }
          In(t) {
            const {
              ctx: e
            } = this.kn(t);
            return this.Tn.getter().In({
              data: e.data,
              path: e.path,
              parent: e
            })
          }
        }
        e.ZodLazy = at, at.create = (t, e) => new at({
          getter: t,
          typeName: Pt.ZodLazy,
          ...f(e)
        });
        class ut extends l {
          In(t) {
            if (t.data !== this.Tn.value) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                received: e.data,
                code: n.ZodIssueCode.invalid_literal,
                expected: this.Tn.value
              }), s.INVALID
            }
            return {
              status: "valid",
              value: t.data
            }
          }
          get value() {
            return this.Tn.value
          }
        }

        function ct(t, e) {
          return new ft({
            values: t,
            typeName: Pt.ZodEnum,
            ...f(e)
          })
        }
        e.ZodLiteral = ut, ut.create = (t, e) => new ut({
          value: t,
          typeName: Pt.ZodLiteral,
          ...f(e)
        });
        class ft extends l {
          In(t) {
            if ("string" != typeof t.data) {
              const e = this.Pn(t),
                r = this.Tn.values;
              return (0, s.addIssueToContext)(e, {
                expected: a.util.joinValues(r),
                received: e.parsedType,
                code: n.ZodIssueCode.invalid_type
              }), s.INVALID
            }
            if (this._n || (this._n = new Set(this.Tn.values)), !this._n.has(t.data)) {
              const e = this.Pn(t),
                r = this.Tn.values;
              return (0, s.addIssueToContext)(e, {
                received: e.data,
                code: n.ZodIssueCode.invalid_enum_value,
                options: r
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
          get options() {
            return this.Tn.values
          }
          get enum() {
            const t = {};
            for (const e of this.Tn.values) t[e] = e;
            return t
          }
          get Values() {
            const t = {};
            for (const e of this.Tn.values) t[e] = e;
            return t
          }
          get Enum() {
            const t = {};
            for (const e of this.Tn.values) t[e] = e;
            return t
          }
          extract(t, e = this.Tn) {
            return ft.create(t, {
              ...this.Tn,
              ...e
            })
          }
          exclude(t, e = this.Tn) {
            return ft.create(this.options.filter(e => !t.includes(e)), {
              ...this.Tn,
              ...e
            })
          }
        }
        e.ZodEnum = ft, ft.create = ct;
        class lt extends l {
          In(t) {
            const e = a.util.getValidEnumValues(this.Tn.values),
              r = this.Pn(t);
            if (r.parsedType !== a.ZodParsedType.string && r.parsedType !== a.ZodParsedType.number) {
              const t = a.util.objectValues(e);
              return (0, s.addIssueToContext)(r, {
                expected: a.util.joinValues(t),
                received: r.parsedType,
                code: n.ZodIssueCode.invalid_type
              }), s.INVALID
            }
            if (this._n || (this._n = new Set(a.util.getValidEnumValues(this.Tn.values))), !this._n.has(t.data)) {
              const t = a.util.objectValues(e);
              return (0, s.addIssueToContext)(r, {
                received: r.data,
                code: n.ZodIssueCode.invalid_enum_value,
                options: t
              }), s.INVALID
            }
            return (0, s.OK)(t.data)
          }
          get enum() {
            return this.Tn.values
          }
        }
        e.ZodNativeEnum = lt, lt.create = (t, e) => new lt({
          values: t,
          typeName: Pt.ZodNativeEnum,
          ...f(e)
        });
        class ht extends l {
          unwrap() {
            return this.Tn.type
          }
          In(t) {
            const {
              ctx: e
            } = this.kn(t);
            if (e.parsedType !== a.ZodParsedType.promise && !1 === e.common.async) return (0, s.addIssueToContext)(e, {
              code: n.ZodIssueCode.invalid_type,
              expected: a.ZodParsedType.promise,
              received: e.parsedType
            }), s.INVALID;
            const r = e.parsedType === a.ZodParsedType.promise ? e.data : Promise.resolve(e.data);
            return (0, s.OK)(r.then(t => this.Tn.type.parseAsync(t, {
              path: e.path,
              errorMap: e.common.contextualErrorMap
            })))
          }
        }
        e.ZodPromise = ht, ht.create = (t, e) => new ht({
          type: t,
          typeName: Pt.ZodPromise,
          ...f(e)
        });
        class dt extends l {
          innerType() {
            return this.Tn.schema
          }
          sourceType() {
            return this.Tn.schema.Tn.typeName === Pt.ZodEffects ? this.Tn.schema.sourceType() : this.Tn.schema
          }
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t), n = this.Tn.effect || null, i = {
              addIssue: t => {
                (0, s.addIssueToContext)(r, t), t.fatal ? e.abort() : e.dirty()
              },
              get path() {
                return r.path
              }
            };
            if (i.addIssue = i.addIssue.bind(i), "preprocess" === n.type) {
              const t = n.transform(r.data, i);
              if (r.common.async) return Promise.resolve(t).then(async t => {
                if ("aborted" === e.value) return s.INVALID;
                const n = await this.Tn.schema.Sn({
                  data: t,
                  path: r.path,
                  parent: r
                });
                return "aborted" === n.status ? s.INVALID : "dirty" === n.status || "dirty" === e.value ? (0, s.DIRTY)(n.value) : n
              });
              {
                if ("aborted" === e.value) return s.INVALID;
                const n = this.Tn.schema.xn({
                  data: t,
                  path: r.path,
                  parent: r
                });
                return "aborted" === n.status ? s.INVALID : "dirty" === n.status || "dirty" === e.value ? (0, s.DIRTY)(n.value) : n
              }
            }
            if ("refinement" === n.type) {
              const t = t => {
                const e = n.refinement(t, i);
                if (r.common.async) return Promise.resolve(e);
                if (e instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return t
              };
              if (!1 === r.common.async) {
                const n = this.Tn.schema.xn({
                  data: r.data,
                  path: r.path,
                  parent: r
                });
                return "aborted" === n.status ? s.INVALID : ("dirty" === n.status && e.dirty(), t(n.value), {
                  status: e.value,
                  value: n.value
                })
              }
              return this.Tn.schema.Sn({
                data: r.data,
                path: r.path,
                parent: r
              }).then(r => "aborted" === r.status ? s.INVALID : ("dirty" === r.status && e.dirty(), t(r.value).then(() => ({
                status: e.value,
                value: r.value
              }))))
            }
            if ("transform" === n.type) {
              if (!1 === r.common.async) {
                const t = this.Tn.schema.xn({
                  data: r.data,
                  path: r.path,
                  parent: r
                });
                if (!(0, s.isValid)(t)) return s.INVALID;
                const o = n.transform(t.value, i);
                if (o instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                  status: e.value,
                  value: o
                }
              }
              return this.Tn.schema.Sn({
                data: r.data,
                path: r.path,
                parent: r
              }).then(t => (0, s.isValid)(t) ? Promise.resolve(n.transform(t.value, i)).then(t => ({
                status: e.value,
                value: t
              })) : s.INVALID)
            }
            a.util.assertNever(n)
          }
        }
        e.ZodEffects = dt, e.ZodTransformer = dt, dt.create = (t, e, r) => new dt({
          schema: t,
          typeName: Pt.ZodEffects,
          effect: e,
          ...f(r)
        }), dt.createWithPreprocess = (t, e, r) => new dt({
          schema: e,
          effect: {
            type: "preprocess",
            transform: t
          },
          typeName: Pt.ZodEffects,
          ...f(r)
        });
        class pt extends l {
          In(t) {
            return this.En(t) === a.ZodParsedType.undefined ? (0, s.OK)(void 0) : this.Tn.innerType.In(t)
          }
          unwrap() {
            return this.Tn.innerType
          }
        }
        e.ZodOptional = pt, pt.create = (t, e) => new pt({
          innerType: t,
          typeName: Pt.ZodOptional,
          ...f(e)
        });
        class bt extends l {
          In(t) {
            return this.En(t) === a.ZodParsedType.null ? (0, s.OK)(null) : this.Tn.innerType.In(t)
          }
          unwrap() {
            return this.Tn.innerType
          }
        }
        e.ZodNullable = bt, bt.create = (t, e) => new bt({
          innerType: t,
          typeName: Pt.ZodNullable,
          ...f(e)
        });
        class mt extends l {
          In(t) {
            const {
              ctx: e
            } = this.kn(t);
            let r = e.data;
            return e.parsedType === a.ZodParsedType.undefined && (r = this.Tn.defaultValue()), this.Tn.innerType.In({
              data: r,
              path: e.path,
              parent: e
            })
          }
          removeDefault() {
            return this.Tn.innerType
          }
        }
        e.ZodDefault = mt, mt.create = (t, e) => new mt({
          innerType: t,
          typeName: Pt.ZodDefault,
          defaultValue: "function" == typeof e.default ? e.default : () => e.default,
          ...f(e)
        });
        class yt extends l {
          In(t) {
            const {
              ctx: e
            } = this.kn(t), r = {
              ...e,
              common: {
                ...e.common,
                issues: []
              }
            }, i = this.Tn.innerType.In({
              data: r.data,
              path: r.path,
              parent: {
                ...r
              }
            });
            return (0, s.isAsync)(i) ? i.then(t => ({
              status: "valid",
              value: "valid" === t.status ? t.value : this.Tn.catchValue({
                get error() {
                  return new n.ZodError(r.common.issues)
                },
                input: r.data
              })
            })) : {
              status: "valid",
              value: "valid" === i.status ? i.value : this.Tn.catchValue({
                get error() {
                  return new n.ZodError(r.common.issues)
                },
                input: r.data
              })
            }
          }
          removeCatch() {
            return this.Tn.innerType
          }
        }
        e.ZodCatch = yt, yt.create = (t, e) => new yt({
          innerType: t,
          typeName: Pt.ZodCatch,
          catchValue: "function" == typeof e.catch ? e.catch : () => e.catch,
          ...f(e)
        });
        class gt extends l {
          In(t) {
            if (this.En(t) !== a.ZodParsedType.nan) {
              const e = this.Pn(t);
              return (0, s.addIssueToContext)(e, {
                code: n.ZodIssueCode.invalid_type,
                expected: a.ZodParsedType.nan,
                received: e.parsedType
              }), s.INVALID
            }
            return {
              status: "valid",
              value: t.data
            }
          }
        }
        e.ZodNaN = gt, gt.create = t => new gt({
          typeName: Pt.ZodNaN,
          ...f(t)
        }), e.BRAND = Symbol("zod_brand");
        class vt extends l {
          In(t) {
            const {
              ctx: e
            } = this.kn(t), r = e.data;
            return this.Tn.type.In({
              data: r,
              path: e.path,
              parent: e
            })
          }
          unwrap() {
            return this.Tn.type
          }
        }
        e.ZodBranded = vt;
        class wt extends l {
          In(t) {
            const {
              status: e,
              ctx: r
            } = this.kn(t);
            if (r.common.async) return (async () => {
              const t = await this.Tn.in.Sn({
                data: r.data,
                path: r.path,
                parent: r
              });
              return "aborted" === t.status ? s.INVALID : "dirty" === t.status ? (e.dirty(), (0, s.DIRTY)(t.value)) : this.Tn.out.Sn({
                data: t.value,
                path: r.path,
                parent: r
              })
            })();
            {
              const t = this.Tn.in.xn({
                data: r.data,
                path: r.path,
                parent: r
              });
              return "aborted" === t.status ? s.INVALID : "dirty" === t.status ? (e.dirty(), {
                status: "dirty",
                value: t.value
              }) : this.Tn.out.xn({
                data: t.value,
                path: r.path,
                parent: r
              })
            }
          }
          static create(t, e) {
            return new wt({
              in: t,
              out: e,
              typeName: Pt.ZodPipeline
            })
          }
        }
        e.ZodPipeline = wt;
        class At extends l {
          In(t) {
            const e = this.Tn.innerType.In(t),
              r = t => ((0, s.isValid)(t) && (t.value = Object.freeze(t.value)), t);
            return (0, s.isAsync)(e) ? e.then(t => r(t)) : r(e)
          }
          unwrap() {
            return this.Tn.innerType
          }
        }

        function Tt(t, e) {
          const r = "function" == typeof t ? t(e) : "string" == typeof t ? {
            message: t
          } : t;
          return "string" == typeof r ? {
            message: r
          } : r
        }

        function Et(t, e = {}, r) {
          return t ? H.create().superRefine((n, i) => {
            const o = t(n);
            if (o instanceof Promise) return o.then(t => {
              if (!t) {
                const t = Tt(e, n),
                  o = t.fatal ?? r ?? !0;
                i.addIssue({
                  code: "custom",
                  ...t,
                  fatal: o
                })
              }
            });
            if (!o) {
              const t = Tt(e, n),
                o = t.fatal ?? r ?? !0;
              i.addIssue({
                code: "custom",
                ...t,
                fatal: o
              })
            }
          }) : H.create()
        }
        var Pt, kt;
        e.ZodReadonly = At, At.create = (t, e) => new At({
          innerType: t,
          typeName: Pt.ZodReadonly,
          ...f(e)
        }), e.late = {
          object: J.lazycreate
        }, (kt = Pt || (e.ZodFirstPartyTypeKind = Pt = {})).ZodString = "ZodString", kt.ZodNumber = "ZodNumber", kt.ZodNaN = "ZodNaN", kt.ZodBigInt = "ZodBigInt", kt.ZodBoolean = "ZodBoolean", kt.ZodDate = "ZodDate", kt.ZodSymbol = "ZodSymbol", kt.ZodUndefined = "ZodUndefined", kt.ZodNull = "ZodNull", kt.ZodAny = "ZodAny", kt.ZodUnknown = "ZodUnknown", kt.ZodNever = "ZodNever", kt.ZodVoid = "ZodVoid", kt.ZodArray = "ZodArray", kt.ZodObject = "ZodObject", kt.ZodUnion = "ZodUnion", kt.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", kt.ZodIntersection = "ZodIntersection", kt.ZodTuple = "ZodTuple", kt.ZodRecord = "ZodRecord", kt.ZodMap = "ZodMap", kt.ZodSet = "ZodSet", kt.ZodFunction = "ZodFunction", kt.ZodLazy = "ZodLazy", kt.ZodLiteral = "ZodLiteral", kt.ZodEnum = "ZodEnum", kt.ZodEffects = "ZodEffects", kt.ZodNativeEnum = "ZodNativeEnum", kt.ZodOptional = "ZodOptional", kt.ZodNullable = "ZodNullable", kt.ZodDefault = "ZodDefault", kt.ZodCatch = "ZodCatch", kt.ZodPromise = "ZodPromise", kt.ZodBranded = "ZodBranded", kt.ZodPipeline = "ZodPipeline", kt.ZodReadonly = "ZodReadonly", e.instanceof = (t, e = {
          message: "Input not instance of " + t.name
        }) => Et(e => e instanceof t, e);
        const xt = N.create;
        e.string = xt;
        const It = _.create;
        e.number = It;
        const St = gt.create;
        e.nan = St;
        const Ot = D.create;
        e.bigint = Ot;
        const Bt = U.create;
        e.boolean = Bt;
        const Wt = L.create;
        e.date = Wt;
        const Mt = F.create;
        e.symbol = Mt;
        const Ct = $.create;
        e.undefined = Ct;
        const Rt = z.create;
        e.null = Rt;
        const Nt = H.create;
        e.any = Nt;
        const jt = G.create;
        e.unknown = jt;
        const _t = K.create;
        e.never = _t;
        const Dt = V.create;
        e.void = Dt;
        const Ut = Z.create;
        e.array = Ut;
        const Lt = J.create;
        e.object = Lt;
        const Ft = J.strictCreate;
        e.strictObject = Ft;
        const $t = Y.create;
        e.union = $t;
        const zt = X.create;
        e.discriminatedUnion = zt;
        const Ht = et.create;
        e.intersection = Ht;
        const Gt = rt.create;
        e.tuple = Gt;
        const Kt = nt.create;
        e.record = Kt;
        const Vt = it.create;
        e.map = Vt;
        const Zt = ot.create;
        e.set = Zt;
        const qt = st.create;
        e.function = qt;
        const Jt = at.create;
        e.lazy = Jt;
        const Yt = ut.create;
        e.literal = Yt;
        const Qt = ft.create;
        e.enum = Qt;
        const Xt = lt.create;
        e.nativeEnum = Xt;
        const te = ht.create;
        e.promise = te;
        const ee = dt.create;
        e.effect = ee, e.transformer = ee;
        const re = pt.create;
        e.optional = re;
        const ne = bt.create;
        e.nullable = ne;
        const ie = dt.createWithPreprocess;
        e.preprocess = ie;
        const oe = wt.create;
        e.pipeline = oe, e.ostring = () => xt().optional(), e.onumber = () => It().optional(), e.oboolean = () => Bt().optional(), e.coerce = {
          string: t => N.create({
            ...t,
            coerce: !0
          }),
          number: t => _.create({
            ...t,
            coerce: !0
          }),
          boolean: t => U.create({
            ...t,
            coerce: !0
          }),
          bigint: t => D.create({
            ...t,
            coerce: !0
          }),
          date: t => L.create({
            ...t,
            coerce: !0
          })
        }, e.NEVER = s.INVALID
      },
      80507: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(36556),
          o = r(58859),
          s = r(69675),
          a = n("%Map%", !0),
          u = i("Map.prototype.get", !0),
          c = i("Map.prototype.set", !0),
          f = i("Map.prototype.has", !0),
          l = i("Map.prototype.delete", !0),
          h = i("Map.prototype.size", !0);
        t.exports = !!a && function() {
          var t, e = {
            assert: function(t) {
              if (!e.has(t)) throw new s("Side channel does not contain " + o(t))
            },
            delete: function(e) {
              if (t) {
                var r = l(t, e);
                return 0 === h(t) && (t = void 0), r
              }
              return !1
            },
            get: function(e) {
              if (t) return u(t, e)
            },
            has: function(e) {
              return !!t && f(t, e)
            },
            set: function(e, r) {
              t || (t = new a), c(t, e, r)
            }
          };
          return e
        }
      },
      80868: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.computeStorageFees = function(t) {
          const {
            lastPaid: e,
            now: r,
            storagePrices: n,
            storageStat: i,
            special: o,
            masterchain: a
          } = t;
          if (e >= r || 0 === n.length || r < n[0].utime_since || o) return BigInt(0);
          let u = Math.max(e, n[0].utime_since),
            c = BigInt(0);
          for (let t = 0; t < n.length && r > u; t++) {
            let e = t < n.length - 1 ? Math.min(r, n[t + 1].utime_since) : r,
              o = BigInt(0);
            if (e > u) {
              let r = e - u;
              o += BigInt(i.cells) * (a ? n[t].mc_cell_price_ps : n[t].cell_price_ps), o += BigInt(i.bits) * (a ? n[t].mc_bit_price_ps : n[t].bit_price_ps), o *= BigInt(r)
            }
            u = e, c += o
          }
          return s(c)
        }, e.computeFwdFees = i, e.computeGasPrices = function(t, e) {
          return t > e.flatLimit ? e.flatPrice + (e.price * (t - e.flatLimit) >> 16n) : e.flatPrice
        }, e.computeExternalMessageFees = function(t, e) {
          let r = o(e);
          return r.bits -= e.bits.length, r.cells -= 1, i(t, BigInt(r.cells), BigInt(r.bits))
        }, e.computeMessageForwardFees = function(t, e) {
          let r = (0, n.loadMessageRelaxed)(e.beginParse()),
            s = {
              bits: 0,
              cells: 0
            };
          if (r.init) {
            const t = (new n.Cell).asBuilder();
            (0, n.storeStateInit)(r.init)(t);
            const e = t.endCell();
            let i = o(e);
            i.bits -= e.bits.length, i.cells -= 1, s.bits += i.bits, s.cells += i.cells
          }
          let a = o(r.body);
          a.bits -= r.body.bits.length, a.cells -= 1, s.bits += a.bits, s.cells += a.cells;
          let u = i(t, BigInt(s.cells), BigInt(s.bits)),
            c = u * BigInt(t.firstFrac) >> 16n;
          return {
            fees: c,
            remaining: u - c
          }
        };
        const n = r(1307);

        function i(t, e, r) {
          return t.lumpPrice + s(t.bitPrice * r + t.cellPrice * e)
        }

        function o(t) {
          let e = t.bits.length,
            r = 1;
          for (let n of t.refs) {
            let t = o(n);
            r += t.cells, e += t.bits
          }
          return {
            bits: e,
            cells: r
          }
        }

        function s(t) {
          let e = t >> 16n;
          return 0n != t % 65536n && (e += 1n), e
        }
      },
      81009: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.hexToBigInt = e.hexToNumber = e.bigIntToHex = e.numberToHex = void 0;
        const n = r(74772),
          i = r(17773);
        e.numberToHex = t => ((0, n.assert)("number" == typeof t, "Value must be a number."), (0, n.assert)(t >= 0, "Value must be a non-negative number."), (0, n.assert)(Number.isSafeInteger(t), "Value is not a safe integer. Use `bigIntToHex` instead."), (0, i.add0x)(t.toString(16))), e.bigIntToHex = t => ((0, n.assert)("bigint" == typeof t, "Value must be a bigint."), (0, n.assert)(t >= 0, "Value must be a non-negative bigint."), (0, i.add0x)(t.toString(16))), e.hexToNumber = t => {
          (0, i.assertIsHexString)(t);
          const e = parseInt(t, 16);
          return (0, n.assert)(Number.isSafeInteger(e), "Value is not a safe integer. Use `hexToBigInt` instead."), e
        }, e.hexToBigInt = t => ((0, i.assertIsHexString)(t), BigInt((0, i.add0x)(t)))
      },
      81128: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          e = (0, i.default)(e, o);
          var r = t.split("@"),
            n = r.pop(),
            l = [r.join("@"), n];
          if (l[1] = l[1].toLowerCase(), "gmail.com" === l[1] || "googlemail.com" === l[1]) {
            if (e.gmail_remove_subaddress && (l[0] = l[0].split("+")[0]), e.gmail_remove_dots && (l[0] = l[0].replace(/\.+/g, f)), !l[0].length) return !1;
            (e.all_lowercase || e.gmail_lowercase) && (l[0] = l[0].toLowerCase()), l[1] = e.gmail_convert_googlemaildotcom ? "gmail.com" : l[1]
          } else if (0 > s.indexOf(l[1]))
            if (0 > a.indexOf(l[1]))
              if (0 > u.indexOf(l[1])) 0 > c.indexOf(l[1]) ? e.all_lowercase && (l[0] = l[0].toLowerCase()) : ((e.all_lowercase || e.yandex_lowercase) && (l[0] = l[0].toLowerCase()), l[1] = "yandex.ru");
              else {
                if (e.yahoo_remove_subaddress) {
                  var h = l[0].split("-");
                  l[0] = h.length > 1 ? h.slice(0, -1).join("-") : h[0]
                }
                if (!l[0].length) return !1;
                (e.all_lowercase || e.yahoo_lowercase) && (l[0] = l[0].toLowerCase())
              }
          else {
            if (e.outlookdotcom_remove_subaddress && (l[0] = l[0].split("+")[0]), !l[0].length) return !1;
            (e.all_lowercase || e.outlookdotcom_lowercase) && (l[0] = l[0].toLowerCase())
          } else {
            if (e.icloud_remove_subaddress && (l[0] = l[0].split("+")[0]), !l[0].length) return !1;
            (e.all_lowercase || e.icloud_lowercase) && (l[0] = l[0].toLowerCase())
          }
          return l.join("@")
        };
        var n, i = (n = r(71229)) && n._ ? n : {
            default: n
          },
          o = {
            all_lowercase: !0,
            gmail_lowercase: !0,
            gmail_remove_dots: !0,
            gmail_remove_subaddress: !0,
            gmail_convert_googlemaildotcom: !0,
            outlookdotcom_lowercase: !0,
            outlookdotcom_remove_subaddress: !0,
            yahoo_lowercase: !0,
            yahoo_remove_subaddress: !0,
            yandex_lowercase: !0,
            icloud_lowercase: !0,
            icloud_remove_subaddress: !0
          },
          s = ["icloud.com", "me.com"],
          a = ["hotmail.at", "hotmail.be", "hotmail.ca", "hotmail.cl", "hotmail.co.il", "hotmail.co.nz", "hotmail.co.th", "hotmail.co.uk", "hotmail.com", "hotmail.com.ar", "hotmail.com.au", "hotmail.com.br", "hotmail.com.gr", "hotmail.com.mx", "hotmail.com.pe", "hotmail.com.tr", "hotmail.com.vn", "hotmail.cz", "hotmail.de", "hotmail.dk", "hotmail.es", "hotmail.fr", "hotmail.hu", "hotmail.id", "hotmail.ie", "hotmail.in", "hotmail.it", "hotmail.jp", "hotmail.kr", "hotmail.lv", "hotmail.my", "hotmail.ph", "hotmail.pt", "hotmail.sa", "hotmail.sg", "hotmail.sk", "live.be", "live.co.uk", "live.com", "live.com.ar", "live.com.mx", "live.de", "live.es", "live.eu", "live.fr", "live.it", "live.nl", "msn.com", "outlook.at", "outlook.be", "outlook.cl", "outlook.co.il", "outlook.co.nz", "outlook.co.th", "outlook.com", "outlook.com.ar", "outlook.com.au", "outlook.com.br", "outlook.com.gr", "outlook.com.pe", "outlook.com.tr", "outlook.com.vn", "outlook.cz", "outlook.de", "outlook.dk", "outlook.es", "outlook.fr", "outlook.hu", "outlook.id", "outlook.ie", "outlook.in", "outlook.it", "outlook.jp", "outlook.kr", "outlook.lv", "outlook.my", "outlook.ph", "outlook.pt", "outlook.sa", "outlook.sg", "outlook.sk", "passport.com"],
          u = ["rocketmail.com", "yahoo.ca", "yahoo.co.uk", "yahoo.com", "yahoo.de", "yahoo.fr", "yahoo.in", "yahoo.it", "ymail.com"],
          c = ["yandex.ru", "yandex.ua", "yandex.kz", "yandex.com", "yandex.by", "ya.ru"];

        function f(t) {
          return t.length > 1 ? t : ""
        }
        t.exports = e.default, t.exports.default = e.default
      },
      81135: t => {
        t.exports = function(t) {
          return t && "object" == typeof t && "function" == typeof t.copy && "function" == typeof t.fill && "function" == typeof t.readUInt8
        }
      },
      81761: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.expand_message_xmd = c, e.expand_message_xof = f, e.hash_to_field = l, e.isogenyMap = function(t, e) {
          const r = e.map(t => Array.from(t).reverse());
          return (e, n) => {
            const [i, o, s, a] = r.map(r => r.reduce((r, n) => t.add(t.mul(r, e), n)));
            return e = t.div(i, o), n = t.mul(n, t.div(s, a)), {
              x: e,
              y: n
            }
          }
        }, e.createHasher = function(t, e, r) {
          if ("function" != typeof e) throw Error("mapToCurve() must be defined");
          return {
            hashToCurve(n, i) {
              const o = l(n, 2, {
                  ...r,
                  DST: r.DST,
                  ...i
                }),
                s = t.fromAffine(e(o[0])),
                a = t.fromAffine(e(o[1])),
                u = s.add(a).clearCofactor();
              return u.assertValidity(), u
            },
            encodeToCurve(n, i) {
              const o = l(n, 1, {
                  ...r,
                  DST: r.encodeDST,
                  ...i
                }),
                s = t.fromAffine(e(o[0])).clearCofactor();
              return s.assertValidity(), s
            },
            mapToCurve(r) {
              if (!Array.isArray(r)) throw Error("mapToCurve: expected array of bigints");
              for (const t of r)
                if ("bigint" != typeof t) throw Error(`mapToCurve: expected array of bigints, got ${t} in array`);
              const n = t.fromAffine(e(r)).clearCofactor();
              return n.assertValidity(), n
            }
          }
        };
        const n = r(89015),
          i = r(19372),
          o = i.bytesToNumberBE;

        function s(t, e) {
          if (0 > t || t >= 1 << 8 * e) throw Error(`bad I2OSP call: value=${t} length=${e}`);
          const r = Array.from({
            length: e
          }).fill(0);
          for (let n = e - 1; n >= 0; n--) r[n] = 255 & t, t >>>= 8;
          return new Uint8Array(r)
        }

        function a(t, e) {
          const r = new Uint8Array(t.length);
          for (let n = 0; n < t.length; n++) r[n] = t[n] ^ e[n];
          return r
        }

        function u(t) {
          if (!Number.isSafeInteger(t)) throw Error("number expected")
        }

        function c(t, e, r, n) {
          (0, i.abytes)(t), (0, i.abytes)(e), u(r), e.length > 255 && (e = n((0, i.concatBytes)((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-"), e)));
          const {
            outputLen: o,
            blockLen: c
          } = n, f = Math.ceil(r / o);
          if (f > 255) throw Error("Invalid xmd length");
          const l = (0, i.concatBytes)(e, s(e.length, 1)),
            h = s(0, c),
            d = s(r, 2),
            p = Array(f),
            b = n((0, i.concatBytes)(h, t, d, s(0, 1), l));
          p[0] = n((0, i.concatBytes)(b, s(1, 1), l));
          for (let t = 1; f >= t; t++) {
            const e = [a(b, p[t - 1]), s(t + 1, 1), l];
            p[t] = n((0, i.concatBytes)(...e))
          }
          return (0, i.concatBytes)(...p).slice(0, r)
        }

        function f(t, e, r, n, o) {
          if ((0, i.abytes)(t), (0, i.abytes)(e), u(r), e.length > 255) {
            const t = Math.ceil(2 * n / 8);
            e = o.create({
              dkLen: t
            }).update((0, i.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(e).digest()
          }
          if (r > 65535 || e.length > 255) throw Error("expand_message_xof: invalid lenInBytes");
          return o.create({
            dkLen: r
          }).update(t).update(s(r, 2)).update(e).update(s(e.length, 1)).digest()
        }

        function l(t, e, r) {
          (0, i.validateObject)(r, {
            DST: "stringOrUint8Array",
            p: "bigint",
            m: "isSafeInteger",
            k: "isSafeInteger",
            hash: "hash"
          });
          const {
            p: s,
            k: a,
            m: l,
            hash: h,
            expand: d,
            DST: p
          } = r;
          (0, i.abytes)(t), u(e);
          const b = "string" == typeof p ? (0, i.utf8ToBytes)(p) : p,
            m = s.toString(2).length,
            y = Math.ceil((m + a) / 8),
            g = e * l * y;
          let v;
          if ("xmd" === d) v = c(t, b, g, h);
          else if ("xof" === d) v = f(t, b, g, a, h);
          else {
            if ("_internal_pass" !== d) throw Error('expand must be "xmd" or "xof"');
            v = t
          }
          const w = Array(e);
          for (let t = 0; e > t; t++) {
            const e = Array(l);
            for (let r = 0; l > r; r++) {
              const i = y * (r + t * l),
                a = v.subarray(i, i + y);
              e[r] = (0, n.mod)(o(a), s)
            }
            w[t] = e
          }
          return w
        }
      },
      81862: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.getProvider = e.fetchFromProvider = void 0;
        const n = r(6215);
        e.fetchFromProvider = async (t, e) => (await (0, n.default)(t, {
          headers: {
            "content-type": "application/json"
          },
          type: "json",
          data: {
            method: e.method,
            params: e.params,
            jsonrpc: "2.0",
            id: 1
          }
        })).result, e.getProvider = t => {
          if ("string" == typeof t) return t;
          if (void 0 !== t?.connection?.url) return t.connection.url;
          throw Error("Must provide valid provider URL or Web3Provider")
        }
      },
      82002: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(0x|0h)?[0-9A-F]+$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      82237: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")(),
          s = r(99135);
        i.object.extend(proto, s), i.exportSymbol("TronWebProto.ClearABIContract", null, o), i.exportSymbol("TronWebProto.ContractState", null, o), i.exportSymbol("TronWebProto.CreateSmartContract", null, o), i.exportSymbol("TronWebProto.SmartContract", null, o), i.exportSymbol("TronWebProto.SmartContract.ABI", null, o), i.exportSymbol("TronWebProto.SmartContract.ABI.Entry", null, o), i.exportSymbol("TronWebProto.SmartContract.ABI.Entry.EntryType", null, o), i.exportSymbol("TronWebProto.SmartContract.ABI.Entry.Param", null, o), i.exportSymbol("TronWebProto.SmartContract.ABI.Entry.StateMutabilityType", null, o), i.exportSymbol("TronWebProto.SmartContractDataWrapper", null, o), i.exportSymbol("TronWebProto.TriggerSmartContract", null, o), i.exportSymbol("TronWebProto.UpdateEnergyLimitContract", null, o), i.exportSymbol("TronWebProto.UpdateSettingContract", null, o), TronWebProto.SmartContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.SmartContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SmartContract.displayName = "TronWebProto.SmartContract"), TronWebProto.SmartContract.ABI = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.SmartContract.ABI.repeatedFields_, null)
        }, i.inherits(TronWebProto.SmartContract.ABI, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.displayName = "TronWebProto.SmartContract.ABI"), TronWebProto.SmartContract.ABI.Entry = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.SmartContract.ABI.Entry.repeatedFields_, null)
        }, i.inherits(TronWebProto.SmartContract.ABI.Entry, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.displayName = "TronWebProto.SmartContract.ABI.Entry"), TronWebProto.SmartContract.ABI.Entry.Param = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.SmartContract.ABI.Entry.Param, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SmartContract.ABI.Entry.Param.displayName = "TronWebProto.SmartContract.ABI.Entry.Param"), TronWebProto.ContractState = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ContractState, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ContractState.displayName = "TronWebProto.ContractState"), TronWebProto.CreateSmartContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.CreateSmartContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.CreateSmartContract.displayName = "TronWebProto.CreateSmartContract"), TronWebProto.TriggerSmartContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.TriggerSmartContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.TriggerSmartContract.displayName = "TronWebProto.TriggerSmartContract"), TronWebProto.ClearABIContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ClearABIContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ClearABIContract.displayName = "TronWebProto.ClearABIContract"), TronWebProto.UpdateSettingContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UpdateSettingContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UpdateSettingContract.displayName = "TronWebProto.UpdateSettingContract"), TronWebProto.UpdateEnergyLimitContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.UpdateEnergyLimitContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.UpdateEnergyLimitContract.displayName = "TronWebProto.UpdateEnergyLimitContract"), TronWebProto.SmartContractDataWrapper = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.SmartContractDataWrapper, n.Message), i.DEBUG && !COMPILED && (TronWebProto.SmartContractDataWrapper.displayName = "TronWebProto.SmartContractDataWrapper"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.prototype.toObject = function(t) {
          return TronWebProto.SmartContract.toObject(t, this)
        }, TronWebProto.SmartContract.toObject = function(t, e) {
          var r, i = {
            originAddress: e.getOriginAddress_asB64(),
            contractAddress: e.getContractAddress_asB64(),
            abi: (r = e.getAbi()) && TronWebProto.SmartContract.ABI.toObject(t, r),
            bytecode: e.getBytecode_asB64(),
            callValue: n.Message.getFieldWithDefault(e, 5, 0),
            consumeUserResourcePercent: n.Message.getFieldWithDefault(e, 6, 0),
            name: n.Message.getFieldWithDefault(e, 7, ""),
            originEnergyLimit: n.Message.getFieldWithDefault(e, 8, 0),
            codeHash: e.getCodeHash_asB64(),
            trxHash: e.getTrxHash_asB64(),
            version: n.Message.getFieldWithDefault(e, 11, 0)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.SmartContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SmartContract;
          return TronWebProto.SmartContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SmartContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOriginAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setContractAddress(r);
              break;
            case 3:
              r = new TronWebProto.SmartContract.ABI, e.readMessage(r, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader), t.setAbi(r);
              break;
            case 4:
              r = e.readBytes(), t.setBytecode(r);
              break;
            case 5:
              r = e.readInt64(), t.setCallValue(r);
              break;
            case 6:
              r = e.readInt64(), t.setConsumeUserResourcePercent(r);
              break;
            case 7:
              r = e.readString(), t.setName(r);
              break;
            case 8:
              r = e.readInt64(), t.setOriginEnergyLimit(r);
              break;
            case 9:
              r = e.readBytes(), t.setCodeHash(r);
              break;
            case 10:
              r = e.readBytes(), t.setTrxHash(r);
              break;
            case 11:
              r = e.readInt32(), t.setVersion(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SmartContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SmartContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SmartContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOriginAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getContractAddress_asU8()).length > 0 && e.writeBytes(2, r), null != (r = t.getAbi()) && e.writeMessage(3, r, TronWebProto.SmartContract.ABI.serializeBinaryToWriter), (r = t.getBytecode_asU8()).length > 0 && e.writeBytes(4, r), 0 !== (r = t.getCallValue()) && e.writeInt64(5, r), 0 !== (r = t.getConsumeUserResourcePercent()) && e.writeInt64(6, r), (r = t.getName()).length > 0 && e.writeString(7, r), 0 !== (r = t.getOriginEnergyLimit()) && e.writeInt64(8, r), (r = t.getCodeHash_asU8()).length > 0 && e.writeBytes(9, r), (r = t.getTrxHash_asU8()).length > 0 && e.writeBytes(10, r), 0 !== (r = t.getVersion()) && e.writeInt32(11, r)
        }, TronWebProto.SmartContract.ABI.repeatedFields_ = [1], n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.prototype.toObject = function(t) {
          return TronWebProto.SmartContract.ABI.toObject(t, this)
        }, TronWebProto.SmartContract.ABI.toObject = function(t, e) {
          var r = {
            entrysList: n.Message.toObjectList(e.getEntrysList(), TronWebProto.SmartContract.ABI.Entry.toObject, t)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.SmartContract.ABI.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SmartContract.ABI;
          return TronWebProto.SmartContract.ABI.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SmartContract.ABI.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();)
            if (1 === e.getFieldNumber()) {
              var r = new TronWebProto.SmartContract.ABI.Entry;
              e.readMessage(r, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader), t.addEntrys(r)
            } else e.skipField();
          return t
        }, TronWebProto.SmartContract.ABI.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SmartContract.ABI.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SmartContract.ABI.serializeBinaryToWriter = function(t, e) {
          var r;
          (r = t.getEntrysList()).length > 0 && e.writeRepeatedMessage(1, r, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter)
        }, TronWebProto.SmartContract.ABI.Entry.repeatedFields_ = [4, 5], n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.prototype.toObject = function(t) {
          return TronWebProto.SmartContract.ABI.Entry.toObject(t, this)
        }, TronWebProto.SmartContract.ABI.Entry.toObject = function(t, e) {
          var r = {
            anonymous: n.Message.getBooleanFieldWithDefault(e, 1, !1),
            constant: n.Message.getBooleanFieldWithDefault(e, 2, !1),
            name: n.Message.getFieldWithDefault(e, 3, ""),
            inputsList: n.Message.toObjectList(e.getInputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, t),
            outputsList: n.Message.toObjectList(e.getOutputsList(), TronWebProto.SmartContract.ABI.Entry.Param.toObject, t),
            type: n.Message.getFieldWithDefault(e, 6, 0),
            payable: n.Message.getBooleanFieldWithDefault(e, 7, !1),
            statemutability: n.Message.getFieldWithDefault(e, 8, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.SmartContract.ABI.Entry.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SmartContract.ABI.Entry;
          return TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SmartContract.ABI.Entry.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBool();
              t.setAnonymous(r);
              break;
            case 2:
              r = e.readBool(), t.setConstant(r);
              break;
            case 3:
              r = e.readString(), t.setName(r);
              break;
            case 4:
              r = new TronWebProto.SmartContract.ABI.Entry.Param, e.readMessage(r, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader), t.addInputs(r);
              break;
            case 5:
              r = new TronWebProto.SmartContract.ABI.Entry.Param, e.readMessage(r, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader), t.addOutputs(r);
              break;
            case 6:
              r = e.readEnum(), t.setType(r);
              break;
            case 7:
              r = e.readBool(), t.setPayable(r);
              break;
            case 8:
              r = e.readEnum(), t.setStatemutability(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SmartContract.ABI.Entry.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SmartContract.ABI.Entry.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAnonymous()) && e.writeBool(1, r), (r = t.getConstant()) && e.writeBool(2, r), (r = t.getName()).length > 0 && e.writeString(3, r), (r = t.getInputsList()).length > 0 && e.writeRepeatedMessage(4, r, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter), (r = t.getOutputsList()).length > 0 && e.writeRepeatedMessage(5, r, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter), 0 !== (r = t.getType()) && e.writeEnum(6, r), (r = t.getPayable()) && e.writeBool(7, r), 0 !== (r = t.getStatemutability()) && e.writeEnum(8, r)
        }, TronWebProto.SmartContract.ABI.Entry.EntryType = {
          UNKNOWNENTRYTYPE: 0,
          CONSTRUCTOR: 1,
          FUNCTION: 2,
          EVENT: 3,
          FALLBACK: 4,
          RECEIVE: 5,
          ERROR: 6
        }, TronWebProto.SmartContract.ABI.Entry.StateMutabilityType = {
          UNKNOWNMUTABILITYTYPE: 0,
          PURE: 1,
          VIEW: 2,
          NONPAYABLE: 3,
          PAYABLE: 4
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContract.ABI.Entry.Param.prototype.toObject = function(t) {
          return TronWebProto.SmartContract.ABI.Entry.Param.toObject(t, this)
        }, TronWebProto.SmartContract.ABI.Entry.Param.toObject = function(t, e) {
          var r = {
            indexed: n.Message.getBooleanFieldWithDefault(e, 1, !1),
            name: n.Message.getFieldWithDefault(e, 2, ""),
            type: n.Message.getFieldWithDefault(e, 3, "")
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SmartContract.ABI.Entry.Param;
          return TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SmartContract.ABI.Entry.Param.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBool();
              t.setIndexed(r);
              break;
            case 2:
              r = e.readString(), t.setName(r);
              break;
            case 3:
              r = e.readString(), t.setType(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SmartContract.ABI.Entry.Param.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getIndexed()) && e.writeBool(1, r), (r = t.getName()).length > 0 && e.writeString(2, r), (r = t.getType()).length > 0 && e.writeString(3, r)
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.getIndexed = function() {
          return n.Message.getBooleanFieldWithDefault(this, 1, !1)
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.setIndexed = function(t) {
          return n.Message.setProto3BooleanField(this, 1, t)
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.getName = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.setName = function(t) {
          return n.Message.setProto3StringField(this, 2, t)
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.SmartContract.ABI.Entry.Param.prototype.setType = function(t) {
          return n.Message.setProto3StringField(this, 3, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getAnonymous = function() {
          return n.Message.getBooleanFieldWithDefault(this, 1, !1)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setAnonymous = function(t) {
          return n.Message.setProto3BooleanField(this, 1, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getConstant = function() {
          return n.Message.getBooleanFieldWithDefault(this, 2, !1)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setConstant = function(t) {
          return n.Message.setProto3BooleanField(this, 2, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getName = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setName = function(t) {
          return n.Message.setProto3StringField(this, 3, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getInputsList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 4)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setInputsList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 4, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.addInputs = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 4, t, TronWebProto.SmartContract.ABI.Entry.Param, e)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.clearInputsList = function() {
          return this.setInputsList([])
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getOutputsList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry.Param, 5)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setOutputsList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 5, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.addOutputs = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 5, t, TronWebProto.SmartContract.ABI.Entry.Param, e)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.clearOutputsList = function() {
          return this.setOutputsList([])
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setType = function(t) {
          return n.Message.setProto3EnumField(this, 6, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getPayable = function() {
          return n.Message.getBooleanFieldWithDefault(this, 7, !1)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setPayable = function(t) {
          return n.Message.setProto3BooleanField(this, 7, t)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.getStatemutability = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.SmartContract.ABI.Entry.prototype.setStatemutability = function(t) {
          return n.Message.setProto3EnumField(this, 8, t)
        }, TronWebProto.SmartContract.ABI.prototype.getEntrysList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.SmartContract.ABI.Entry, 1)
        }, TronWebProto.SmartContract.ABI.prototype.setEntrysList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 1, t)
        }, TronWebProto.SmartContract.ABI.prototype.addEntrys = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 1, t, TronWebProto.SmartContract.ABI.Entry, e)
        }, TronWebProto.SmartContract.ABI.prototype.clearEntrysList = function() {
          return this.setEntrysList([])
        }, TronWebProto.SmartContract.prototype.getOriginAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.SmartContract.prototype.getOriginAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOriginAddress())
        }, TronWebProto.SmartContract.prototype.getOriginAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOriginAddress())
        }, TronWebProto.SmartContract.prototype.setOriginAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.SmartContract.prototype.getContractAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.SmartContract.prototype.getContractAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractAddress())
        }, TronWebProto.SmartContract.prototype.getContractAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractAddress())
        }, TronWebProto.SmartContract.prototype.setContractAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.SmartContract.prototype.getAbi = function() {
          return n.Message.getWrapperField(this, TronWebProto.SmartContract.ABI, 3)
        }, TronWebProto.SmartContract.prototype.setAbi = function(t) {
          return n.Message.setWrapperField(this, 3, t)
        }, TronWebProto.SmartContract.prototype.clearAbi = function() {
          return this.setAbi(void 0)
        }, TronWebProto.SmartContract.prototype.hasAbi = function() {
          return null != n.Message.getField(this, 3)
        }, TronWebProto.SmartContract.prototype.getBytecode = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.SmartContract.prototype.getBytecode_asB64 = function() {
          return n.Message.bytesAsB64(this.getBytecode())
        }, TronWebProto.SmartContract.prototype.getBytecode_asU8 = function() {
          return n.Message.bytesAsU8(this.getBytecode())
        }, TronWebProto.SmartContract.prototype.setBytecode = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.SmartContract.prototype.getCallValue = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.SmartContract.prototype.setCallValue = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.SmartContract.prototype.getConsumeUserResourcePercent = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.SmartContract.prototype.setConsumeUserResourcePercent = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, TronWebProto.SmartContract.prototype.getName = function() {
          return n.Message.getFieldWithDefault(this, 7, "")
        }, TronWebProto.SmartContract.prototype.setName = function(t) {
          return n.Message.setProto3StringField(this, 7, t)
        }, TronWebProto.SmartContract.prototype.getOriginEnergyLimit = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.SmartContract.prototype.setOriginEnergyLimit = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.SmartContract.prototype.getCodeHash = function() {
          return n.Message.getFieldWithDefault(this, 9, "")
        }, TronWebProto.SmartContract.prototype.getCodeHash_asB64 = function() {
          return n.Message.bytesAsB64(this.getCodeHash())
        }, TronWebProto.SmartContract.prototype.getCodeHash_asU8 = function() {
          return n.Message.bytesAsU8(this.getCodeHash())
        }, TronWebProto.SmartContract.prototype.setCodeHash = function(t) {
          return n.Message.setProto3BytesField(this, 9, t)
        }, TronWebProto.SmartContract.prototype.getTrxHash = function() {
          return n.Message.getFieldWithDefault(this, 10, "")
        }, TronWebProto.SmartContract.prototype.getTrxHash_asB64 = function() {
          return n.Message.bytesAsB64(this.getTrxHash())
        }, TronWebProto.SmartContract.prototype.getTrxHash_asU8 = function() {
          return n.Message.bytesAsU8(this.getTrxHash())
        }, TronWebProto.SmartContract.prototype.setTrxHash = function(t) {
          return n.Message.setProto3BytesField(this, 10, t)
        }, TronWebProto.SmartContract.prototype.getVersion = function() {
          return n.Message.getFieldWithDefault(this, 11, 0)
        }, TronWebProto.SmartContract.prototype.setVersion = function(t) {
          return n.Message.setProto3IntField(this, 11, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ContractState.prototype.toObject = function(t) {
          return TronWebProto.ContractState.toObject(t, this)
        }, TronWebProto.ContractState.toObject = function(t, e) {
          var r = {
            energyUsage: n.Message.getFieldWithDefault(e, 1, 0),
            energyFactor: n.Message.getFieldWithDefault(e, 2, 0),
            updateCycle: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ContractState.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ContractState;
          return TronWebProto.ContractState.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ContractState.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setEnergyUsage(r);
              break;
            case 2:
              r = e.readInt64(), t.setEnergyFactor(r);
              break;
            case 3:
              r = e.readInt64(), t.setUpdateCycle(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ContractState.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ContractState.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ContractState.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getEnergyUsage()) && e.writeInt64(1, r), 0 !== (r = t.getEnergyFactor()) && e.writeInt64(2, r), 0 !== (r = t.getUpdateCycle()) && e.writeInt64(3, r)
        }, TronWebProto.ContractState.prototype.getEnergyUsage = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.ContractState.prototype.setEnergyUsage = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.ContractState.prototype.getEnergyFactor = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ContractState.prototype.setEnergyFactor = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.ContractState.prototype.getUpdateCycle = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.ContractState.prototype.setUpdateCycle = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.CreateSmartContract.prototype.toObject = function(t) {
          return TronWebProto.CreateSmartContract.toObject(t, this)
        }, TronWebProto.CreateSmartContract.toObject = function(t, e) {
          var r, i = {
            ownerAddress: e.getOwnerAddress_asB64(),
            newContract: (r = e.getNewContract()) && TronWebProto.SmartContract.toObject(t, r),
            callTokenValue: n.Message.getFieldWithDefault(e, 3, 0),
            tokenId: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.CreateSmartContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.CreateSmartContract;
          return TronWebProto.CreateSmartContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.CreateSmartContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = new TronWebProto.SmartContract, e.readMessage(r, TronWebProto.SmartContract.deserializeBinaryFromReader), t.setNewContract(r);
              break;
            case 3:
              r = e.readInt64(), t.setCallTokenValue(r);
              break;
            case 4:
              r = e.readInt64(), t.setTokenId(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.CreateSmartContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.CreateSmartContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.CreateSmartContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), null != (r = t.getNewContract()) && e.writeMessage(2, r, TronWebProto.SmartContract.serializeBinaryToWriter), 0 !== (r = t.getCallTokenValue()) && e.writeInt64(3, r), 0 !== (r = t.getTokenId()) && e.writeInt64(4, r)
        }, TronWebProto.CreateSmartContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.CreateSmartContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.CreateSmartContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.CreateSmartContract.prototype.getNewContract = function() {
          return n.Message.getWrapperField(this, TronWebProto.SmartContract, 2)
        }, TronWebProto.CreateSmartContract.prototype.setNewContract = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.CreateSmartContract.prototype.clearNewContract = function() {
          return this.setNewContract(void 0)
        }, TronWebProto.CreateSmartContract.prototype.hasNewContract = function() {
          return null != n.Message.getField(this, 2)
        }, TronWebProto.CreateSmartContract.prototype.getCallTokenValue = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.CreateSmartContract.prototype.setCallTokenValue = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.CreateSmartContract.prototype.getTokenId = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.CreateSmartContract.prototype.setTokenId = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.TriggerSmartContract.prototype.toObject = function(t) {
          return TronWebProto.TriggerSmartContract.toObject(t, this)
        }, TronWebProto.TriggerSmartContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            contractAddress: e.getContractAddress_asB64(),
            callValue: n.Message.getFieldWithDefault(e, 3, 0),
            data: e.getData_asB64(),
            callTokenValue: n.Message.getFieldWithDefault(e, 5, 0),
            tokenId: n.Message.getFieldWithDefault(e, 6, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.TriggerSmartContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.TriggerSmartContract;
          return TronWebProto.TriggerSmartContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.TriggerSmartContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setContractAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setCallValue(r);
              break;
            case 4:
              r = e.readBytes(), t.setData(r);
              break;
            case 5:
              r = e.readInt64(), t.setCallTokenValue(r);
              break;
            case 6:
              r = e.readInt64(), t.setTokenId(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.TriggerSmartContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.TriggerSmartContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.TriggerSmartContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getContractAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getCallValue()) && e.writeInt64(3, r), (r = t.getData_asU8()).length > 0 && e.writeBytes(4, r), 0 !== (r = t.getCallTokenValue()) && e.writeInt64(5, r), 0 !== (r = t.getTokenId()) && e.writeInt64(6, r)
        }, TronWebProto.TriggerSmartContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.TriggerSmartContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.TriggerSmartContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.TriggerSmartContract.prototype.getContractAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.TriggerSmartContract.prototype.getContractAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractAddress())
        }, TronWebProto.TriggerSmartContract.prototype.getContractAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractAddress())
        }, TronWebProto.TriggerSmartContract.prototype.setContractAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.TriggerSmartContract.prototype.getCallValue = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.TriggerSmartContract.prototype.setCallValue = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.TriggerSmartContract.prototype.getData = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.TriggerSmartContract.prototype.getData_asB64 = function() {
          return n.Message.bytesAsB64(this.getData())
        }, TronWebProto.TriggerSmartContract.prototype.getData_asU8 = function() {
          return n.Message.bytesAsU8(this.getData())
        }, TronWebProto.TriggerSmartContract.prototype.setData = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.TriggerSmartContract.prototype.getCallTokenValue = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.TriggerSmartContract.prototype.setCallTokenValue = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.TriggerSmartContract.prototype.getTokenId = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.TriggerSmartContract.prototype.setTokenId = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ClearABIContract.prototype.toObject = function(t) {
          return TronWebProto.ClearABIContract.toObject(t, this)
        }, TronWebProto.ClearABIContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            contractAddress: e.getContractAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ClearABIContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ClearABIContract;
          return TronWebProto.ClearABIContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ClearABIContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setContractAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ClearABIContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ClearABIContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ClearABIContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getContractAddress_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.ClearABIContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ClearABIContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ClearABIContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ClearABIContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ClearABIContract.prototype.getContractAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.ClearABIContract.prototype.getContractAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractAddress())
        }, TronWebProto.ClearABIContract.prototype.getContractAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractAddress())
        }, TronWebProto.ClearABIContract.prototype.setContractAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateSettingContract.prototype.toObject = function(t) {
          return TronWebProto.UpdateSettingContract.toObject(t, this)
        }, TronWebProto.UpdateSettingContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            contractAddress: e.getContractAddress_asB64(),
            consumeUserResourcePercent: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UpdateSettingContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UpdateSettingContract;
          return TronWebProto.UpdateSettingContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UpdateSettingContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setContractAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setConsumeUserResourcePercent(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UpdateSettingContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UpdateSettingContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UpdateSettingContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getContractAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getConsumeUserResourcePercent()) && e.writeInt64(3, r)
        }, TronWebProto.UpdateSettingContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UpdateSettingContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UpdateSettingContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UpdateSettingContract.prototype.getContractAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.UpdateSettingContract.prototype.getContractAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractAddress())
        }, TronWebProto.UpdateSettingContract.prototype.getContractAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractAddress())
        }, TronWebProto.UpdateSettingContract.prototype.setContractAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.UpdateSettingContract.prototype.getConsumeUserResourcePercent = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.UpdateSettingContract.prototype.setConsumeUserResourcePercent = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.UpdateEnergyLimitContract.prototype.toObject = function(t) {
          return TronWebProto.UpdateEnergyLimitContract.toObject(t, this)
        }, TronWebProto.UpdateEnergyLimitContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            contractAddress: e.getContractAddress_asB64(),
            originEnergyLimit: n.Message.getFieldWithDefault(e, 3, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.UpdateEnergyLimitContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.UpdateEnergyLimitContract;
          return TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.UpdateEnergyLimitContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readBytes(), t.setContractAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setOriginEnergyLimit(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.UpdateEnergyLimitContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.UpdateEnergyLimitContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getContractAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getOriginEnergyLimit()) && e.writeInt64(3, r)
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.UpdateEnergyLimitContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractAddress())
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getContractAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractAddress())
        }, TronWebProto.UpdateEnergyLimitContract.prototype.setContractAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.UpdateEnergyLimitContract.prototype.getOriginEnergyLimit = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.UpdateEnergyLimitContract.prototype.setOriginEnergyLimit = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.SmartContractDataWrapper.prototype.toObject = function(t) {
          return TronWebProto.SmartContractDataWrapper.toObject(t, this)
        }, TronWebProto.SmartContractDataWrapper.toObject = function(t, e) {
          var r, n = {
            smartContract: (r = e.getSmartContract()) && TronWebProto.SmartContract.toObject(t, r),
            runtimecode: e.getRuntimecode_asB64(),
            contractState: (r = e.getContractState()) && TronWebProto.ContractState.toObject(t, r)
          };
          return t && (n.$jspbMessageInstance = e), n
        }), TronWebProto.SmartContractDataWrapper.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.SmartContractDataWrapper;
          return TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader(r, e)
        }, TronWebProto.SmartContractDataWrapper.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = new TronWebProto.SmartContract;
              e.readMessage(r, TronWebProto.SmartContract.deserializeBinaryFromReader), t.setSmartContract(r);
              break;
            case 2:
              r = e.readBytes(), t.setRuntimecode(r);
              break;
            case 3:
              r = new TronWebProto.ContractState, e.readMessage(r, TronWebProto.ContractState.deserializeBinaryFromReader), t.setContractState(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.SmartContractDataWrapper.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.SmartContractDataWrapper.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          null != (r = t.getSmartContract()) && e.writeMessage(1, r, TronWebProto.SmartContract.serializeBinaryToWriter), (r = t.getRuntimecode_asU8()).length > 0 && e.writeBytes(2, r), null != (r = t.getContractState()) && e.writeMessage(3, r, TronWebProto.ContractState.serializeBinaryToWriter)
        }, TronWebProto.SmartContractDataWrapper.prototype.getSmartContract = function() {
          return n.Message.getWrapperField(this, TronWebProto.SmartContract, 1)
        }, TronWebProto.SmartContractDataWrapper.prototype.setSmartContract = function(t) {
          return n.Message.setWrapperField(this, 1, t)
        }, TronWebProto.SmartContractDataWrapper.prototype.clearSmartContract = function() {
          return this.setSmartContract(void 0)
        }, TronWebProto.SmartContractDataWrapper.prototype.hasSmartContract = function() {
          return null != n.Message.getField(this, 1)
        }, TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asB64 = function() {
          return n.Message.bytesAsB64(this.getRuntimecode())
        }, TronWebProto.SmartContractDataWrapper.prototype.getRuntimecode_asU8 = function() {
          return n.Message.bytesAsU8(this.getRuntimecode())
        }, TronWebProto.SmartContractDataWrapper.prototype.setRuntimecode = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.SmartContractDataWrapper.prototype.getContractState = function() {
          return n.Message.getWrapperField(this, TronWebProto.ContractState, 3)
        }, TronWebProto.SmartContractDataWrapper.prototype.setContractState = function(t) {
          return n.Message.setWrapperField(this, 3, t)
        }, TronWebProto.SmartContractDataWrapper.prototype.clearContractState = function() {
          return this.setContractState(void 0)
        }, TronWebProto.SmartContractDataWrapper.prototype.hasContractState = function() {
          return null != n.Message.getField(this, 3)
        }, i.object.extend(e, TronWebProto)
      },
      82299: (t, e, r) => {
        "use strict";

        function n(t, e) {
          return function(t) {
            if (Array.isArray(t)) return t
          }(t) || function(t, e) {
            var r = null == t ? null : "u" > typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (null != r) {
              var n, i, o, s, a = [],
                u = !0,
                c = !1;
              try {
                if (o = (r = r.call(t)).next, 0 === e) {
                  if (Object(r) !== r) return;
                  u = !1
                } else
                  for (; !(u = (n = o.call(r)).done) && (a.push(n.value), a.length !== e); u = !0);
              } catch (t) {
                c = !0, i = t
              } finally {
                try {
                  if (!u && null != r.return && (s = r.return(), Object(s) !== s)) return
                } finally {
                  if (c) throw i
                }
              }
              return a
            }
          }(t, e) || function(t, e) {
            if (t) {
              if ("string" == typeof t) return i(t, e);
              var r = {}.toString.call(t).slice(8, -1);
              if ("Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r) return Array.from(t);
              if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return i(t, e)
            }
          }(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
          }()
        }

        function i(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = Array(e); e > r; r++) n[r] = t[r];
          return n
        }

        function o(t) {
          return (o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        var s = function(t) {
            var e = [];
            return t.forEach(function(t) {
              return e.push(t)
            }), e
          },
          a = function(t) {
            var e = [];
            return t.forEach(function(t, r) {
              return e.push([r, t])
            }), e
          },
          u = Object.is ? Object.is : r(37653),
          c = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
            return []
          },
          f = Number.isNaN ? Number.isNaN : r(24133);

        function l(t) {
          return t.call.bind(t)
        }
        var h = l({}.hasOwnProperty),
          d = l({}.propertyIsEnumerable),
          p = l({}.toString),
          b = r(40537).types,
          m = b.isAnyArrayBuffer,
          y = b.isArrayBufferView,
          g = b.isDate,
          v = b.isMap,
          w = b.isRegExp,
          A = b.isSet,
          T = b.isNativeError,
          E = b.isBoxedPrimitive,
          P = b.isNumberObject,
          k = b.isStringObject,
          x = b.isBooleanObject,
          I = b.isBigIntObject,
          S = b.isSymbolObject,
          O = b.isFloat32Array,
          B = b.isFloat64Array;

        function W(t) {
          if (0 === t.length || t.length > 10) return !0;
          for (var e = 0; e < t.length; e++) {
            var r = t.charCodeAt(e);
            if (48 > r || r > 57) return !0
          }
          return 10 === t.length && t >= 4294967296
        }

        function M(t) {
          return Object.keys(t).filter(W).concat(c(t).filter({}.propertyIsEnumerable.bind(t)))
        }

        function C(t, e) {
          if (t === e) return 0;
          for (var r = t.length, n = e.length, i = 0, o = Math.min(r, n); o > i; ++i)
            if (t[i] !== e[i]) {
              r = t[i], n = e[i];
              break
            } return n > r ? -1 : r > n ? 1 : 0
        }

        function R(t, e, r, n) {
          if (t === e) return 0 !== t || !r || u(t, e);
          if (r) {
            if ("object" !== o(t)) return "number" == typeof t && f(t) && f(e);
            if ("object" !== o(e) || null === t || null === e || Object.getPrototypeOf(t) !== Object.getPrototypeOf(e)) return !1
          } else {
            if (null === t || "object" !== o(t)) return (null === e || "object" !== o(e)) && t == e;
            if (null === e || "object" !== o(e)) return !1
          }
          var i = p(t);
          if (i !== p(e)) return !1;
          if (Array.isArray(t)) {
            if (t.length !== e.length) return !1;
            var s = M(t),
              a = M(e);
            return s.length === a.length && j(t, e, r, n, 1, s)
          }
          if ("[object Object]" === i && (!v(t) && v(e) || !A(t) && A(e))) return !1;
          if (g(t)) {
            if (!g(e) || Date.prototype.getTime.call(t) !== Date.prototype.getTime.call(e)) return !1
          } else if (w(t)) {
            if (!w(e) || ! function(t, e) {
                return t.source === e.source && t.flags === e.flags
              }(t, e)) return !1
          } else if (T(t) || t instanceof Error) {
            if (t.message !== e.message || t.name !== e.name) return !1
          } else {
            if (y(t)) {
              if (r || !O(t) && !B(t)) {
                if (! function(t, e) {
                    return t.byteLength === e.byteLength && 0 === C(new Uint8Array(t.buffer, t.byteOffset, t.byteLength), new Uint8Array(e.buffer, e.byteOffset, e.byteLength))
                  }(t, e)) return !1
              } else if (! function(t, e) {
                  if (t.byteLength !== e.byteLength) return !1;
                  for (var r = 0; r < t.byteLength; r++)
                    if (t[r] !== e[r]) return !1;
                  return !0
                }(t, e)) return !1;
              var c = M(t),
                l = M(e);
              return c.length === l.length && j(t, e, r, n, 0, c)
            }
            if (A(t)) return !(!A(e) || t.size !== e.size) && j(t, e, r, n, 2);
            if (v(t)) return !(!v(e) || t.size !== e.size) && j(t, e, r, n, 3);
            if (m(t)) {
              if (! function(t, e) {
                  return t.byteLength === e.byteLength && 0 === C(new Uint8Array(t), new Uint8Array(e))
                }(t, e)) return !1
            } else if (E(t) && ! function(t, e) {
                return P(t) ? P(e) && u((0).valueOf.call(t), (0).valueOf.call(e)) : k(t) ? k(e) && "".valueOf.call(t) === "".valueOf.call(e) : x(t) ? x(e) && Boolean.prototype.valueOf.call(t) === Boolean.prototype.valueOf.call(e) : I(t) ? I(e) && BigInt.prototype.valueOf.call(t) === BigInt.prototype.valueOf.call(e) : S(e) && Symbol.prototype.valueOf.call(t) === Symbol.prototype.valueOf.call(e)
              }(t, e)) return !1
          }
          return j(t, e, r, n, 0)
        }

        function N(t, e) {
          return e.filter(function(e) {
            return d(t, e)
          })
        }

        function j(t, e, r, i, u, f) {
          if (5 === arguments.length) {
            f = Object.keys(t);
            var l = Object.keys(e);
            if (f.length !== l.length) return !1
          }
          for (var p = 0; p < f.length; p++)
            if (!h(e, f[p])) return !1;
          if (r && 5 === arguments.length) {
            var b = c(t);
            if (0 !== b.length) {
              var m = 0;
              for (p = 0; p < b.length; p++) {
                var y = b[p];
                if (d(t, y)) {
                  if (!d(e, y)) return !1;
                  f.push(y), m++
                } else if (d(e, y)) return !1
              }
              var g = c(e);
              if (b.length !== g.length && N(e, g).length !== m) return !1
            } else {
              var v = c(e);
              if (0 !== v.length && 0 !== N(e, v).length) return !1
            }
          }
          if (0 === f.length && (0 === u || 1 === u && 0 === t.length || 0 === t.size)) return !0;
          if (void 0 === i) i = {
            val1: new Map,
            val2: new Map,
            position: 0
          };
          else {
            var w = i.val1.get(t);
            if (void 0 !== w) {
              var A = i.val2.get(e);
              if (void 0 !== A) return w === A
            }
            i.position++
          }
          i.val1.set(t, i.position), i.val2.set(e, i.position);
          var T = function(t, e, r, i, u, c) {
            var f = 0;
            if (2 === c) {
              if (! function(t, e, r, n) {
                  for (var i = null, a = s(t), u = 0; u < a.length; u++) {
                    var c = a[u];
                    if ("object" === o(c) && null !== c) null === i && (i = new Set), i.add(c);
                    else if (!e.has(c)) {
                      if (r || !U(t, e, c)) return !1;
                      null === i && (i = new Set), i.add(c)
                    }
                  }
                  if (null !== i) {
                    for (var f = s(e), l = 0; l < f.length; l++) {
                      var h = f[l];
                      if ("object" === o(h) && null !== h) {
                        if (!_(i, h, r, n)) return !1
                      } else if (!r && !t.has(h) && !_(i, h, r, n)) return !1
                    }
                    return 0 === i.size
                  }
                  return !0
                }(t, e, r, u)) return !1
            } else if (3 === c) {
              if (! function(t, e, r, i) {
                  for (var s = null, u = a(t), c = 0; c < u.length; c++) {
                    var f = n(u[c], 2),
                      l = f[0],
                      h = f[1];
                    if ("object" === o(l) && null !== l) null === s && (s = new Set), s.add(l);
                    else {
                      var d = e.get(l);
                      if (void 0 === d && !e.has(l) || !R(h, d, r, i)) {
                        if (r || !L(t, e, l, h, i)) return !1;
                        null === s && (s = new Set), s.add(l)
                      }
                    }
                  }
                  if (null !== s) {
                    for (var p = a(e), b = 0; b < p.length; b++) {
                      var m = n(p[b], 2),
                        y = m[0],
                        g = m[1];
                      if ("object" === o(y) && null !== y) {
                        if (!F(s, t, y, g, r, i)) return !1
                      } else if (!(r || t.has(y) && R(t.get(y), g, !1, i) || F(s, t, y, g, !1, i))) return !1
                    }
                    return 0 === s.size
                  }
                  return !0
                }(t, e, r, u)) return !1
            } else if (1 === c)
              for (; f < t.length; f++) {
                if (!h(t, f)) {
                  if (h(e, f)) return !1;
                  for (var l = Object.keys(t); f < l.length; f++) {
                    var d = l[f];
                    if (!h(e, d) || !R(t[d], e[d], r, u)) return !1
                  }
                  return l.length === Object.keys(e).length
                }
                if (!h(e, f) || !R(t[f], e[f], r, u)) return !1
              }
            for (f = 0; f < i.length; f++) {
              var p = i[f];
              if (!R(t[p], e[p], r, u)) return !1
            }
            return !0
          }(t, e, r, f, i, u);
          return i.val1.delete(t), i.val2.delete(e), T
        }

        function _(t, e, r, n) {
          for (var i = s(t), o = 0; o < i.length; o++) {
            var a = i[o];
            if (R(e, a, r, n)) return t.delete(a), !0
          }
          return !1
        }

        function D(t) {
          switch (o(t)) {
            case "undefined":
              return null;
            case "object":
              return;
            case "symbol":
              return !1;
            case "string":
              t = +t;
            case "number":
              if (f(t)) return !1
          }
          return !0
        }

        function U(t, e, r) {
          var n = D(r);
          return n ?? (e.has(n) && !t.has(n))
        }

        function L(t, e, r, n, i) {
          var o = D(r);
          if (null != o) return o;
          var s = e.get(o);
          return !(void 0 === s && !e.has(o) || !R(n, s, !1, i)) && !t.has(o) && R(n, s, !1, i)
        }

        function F(t, e, r, n, i, o) {
          for (var a = s(t), u = 0; u < a.length; u++) {
            var c = a[u];
            if (R(r, c, i, o) && R(n, e.get(c), i, o)) return t.delete(c), !0
          }
          return !1
        }
        t.exports = {
          isDeepEqual: function(t, e) {
            return R(t, e, !1)
          },
          isDeepStrictEqual: function(t, e) {
            return R(t, e, !0)
          }
        }
      },
      82672: function(t, e, r) {
        "use strict";
        t = r.nmd(t);
        var n = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.crypto = e.utf8ToBytes = e.createView = e.concatBytes = e.toHex = e.bytesToHex = e.assertBytes = e.assertBool = void 0, e.bytesToUtf8 = function(t) {
          if (!(t instanceof Uint8Array)) throw new TypeError("bytesToUtf8 expected Uint8Array, got " + typeof t);
          return (new TextDecoder).decode(t)
        }, e.hexToBytes = function(t) {
          const e = t.startsWith("0x") ? t.substring(2) : t;
          return (0, o.hexToBytes)(e)
        }, e.equalsBytes = function(t, e) {
          if (t.length !== e.length) return !1;
          for (let r = 0; r < t.length; r++)
            if (t[r] !== e[r]) return !1;
          return !0
        }, e.wrapHash = function(t) {
          return e => (i.default.bytes(e), t(e))
        };
        const i = n(r(28021)),
          o = r(17412),
          s = i.default.bool;
        e.assertBool = s;
        const a = i.default.bytes;
        e.assertBytes = a;
        var u = r(17412);
        Object.defineProperty(e, "bytesToHex", {
          enumerable: !0,
          get: function() {
            return u.bytesToHex
          }
        }), Object.defineProperty(e, "toHex", {
          enumerable: !0,
          get: function() {
            return u.bytesToHex
          }
        }), Object.defineProperty(e, "concatBytes", {
          enumerable: !0,
          get: function() {
            return u.concatBytes
          }
        }), Object.defineProperty(e, "createView", {
          enumerable: !0,
          get: function() {
            return u.createView
          }
        }), Object.defineProperty(e, "utf8ToBytes", {
          enumerable: !0,
          get: function() {
            return u.utf8ToBytes
          }
        }), e.crypto = (() => {
          const e = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
            r = "function" == typeof t.require && t.require.bind(t);
          return {
            node: r && !e ? r("crypto") : void 0,
            web: e
          }
        })()
      },
      82682: (t, e, r) => {
        "use strict";
        var n = r(69600),
          i = {}.toString,
          o = {}.hasOwnProperty;
        t.exports = function(t, e, r) {
          if (!n(e)) throw new TypeError("iterator must be a function");
          var s, a;
          arguments.length >= 3 && (s = r), a = t, "[object Array]" === i.call(a) ? function(t, e, r) {
            for (var n = 0, i = t.length; i > n; n++) o.call(t, n) && (null == r ? e(t[n], n, t) : e.call(r, t[n], n, t))
          }(t, e, s) : "string" == typeof t ? function(t, e, r) {
            for (var n = 0, i = t.length; i > n; n++) null == r ? e(t.charAt(n), n, t) : e.call(r, t.charAt(n), n, t)
          }(t, e, s) : function(t, e, r) {
            for (var n in t) o.call(t, n) && (null == r ? e(t[n], n, t) : e.call(r, t[n], n, t))
          }(t, e, s)
        }
      },
      83049: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeAccountState = e.loadAccountState = void 0;
        const n = r(22738);
        e.loadAccountState = function(t) {
          return t.loadBit() ? {
            type: "active",
            state: (0, n.loadStateInit)(t)
          } : t.loadBit() ? {
            type: "frozen",
            stateHash: t.loadUintBig(256)
          } : {
            type: "uninit"
          }
        }, e.storeAccountState = function(t) {
          return e => {
            "active" === t.type ? (e.storeBit(!0), e.store((0, n.storeStateInit)(t.state))) : "frozen" === t.type ? (e.storeBit(!1), e.storeBit(!0), e.storeUint(t.stateHash, 256)) : "uninit" === t.type && (e.storeBit(!1), e.storeBit(!1))
          }
        }
      },
      83141: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer,
          i = n.isEncoding || function(t) {
            switch ((t = "" + t) && t.toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
              case "raw":
                return !0;
              default:
                return !1
            }
          };

        function o(t) {
          var e;
          switch (this.encoding = function(t) {
              var e = function(t) {
                if (!t) return "utf8";
                for (var e;;) switch (t) {
                  case "utf8":
                  case "utf-8":
                    return "utf8";
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return "utf16le";
                  case "latin1":
                  case "binary":
                    return "latin1";
                  case "base64":
                  case "ascii":
                  case "hex":
                    return t;
                  default:
                    if (e) return;
                    t = ("" + t).toLowerCase(), e = !0
                }
              }(t);
              if ("string" != typeof e && (n.isEncoding === i || !i(t))) throw Error("Unknown encoding: " + t);
              return e || t
            }(t), this.encoding) {
            case "utf16le":
              this.text = u, this.end = c, e = 4;
              break;
            case "utf8":
              this.fillLast = a, e = 4;
              break;
            case "base64":
              this.text = f, this.end = l, e = 3;
              break;
            default:
              return this.write = h, void(this.end = d)
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = n.allocUnsafe(e)
        }

        function s(t) {
          return t > 127 ? t >> 5 == 6 ? 2 : t >> 4 == 14 ? 3 : t >> 3 == 30 ? 4 : t >> 6 == 2 ? -1 : -2 : 0
        }

        function a(t) {
          var e = this.lastTotal - this.lastNeed,
            r = function(t, e) {
              if (128 != (192 & e[0])) return t.lastNeed = 0, "";
              if (t.lastNeed > 1 && e.length > 1) {
                if (128 != (192 & e[1])) return t.lastNeed = 1, "";
                if (t.lastNeed > 2 && e.length > 2 && 128 != (192 & e[2])) return t.lastNeed = 2, ""
              }
            }(this, t);
          return void 0 !== r ? r : this.lastNeed > t.length ? (t.copy(this.lastChar, e, 0, t.length), void(this.lastNeed -= t.length)) : (t.copy(this.lastChar, e, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal))
        }

        function u(t, e) {
          if ((t.length - e) % 2 == 0) {
            var r = t.toString("utf16le", e);
            if (r) {
              var n = r.charCodeAt(r.length - 1);
              if (n >= 55296 && 56319 >= n) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1], r.slice(0, -1)
            }
            return r
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t[t.length - 1], t.toString("utf16le", e, t.length - 1)
        }

        function c(t) {
          var e = t && t.length ? this.write(t) : "";
          if (this.lastNeed) {
            var r = this.lastTotal - this.lastNeed;
            return e + this.lastChar.toString("utf16le", 0, r)
          }
          return e
        }

        function f(t, e) {
          var r = (t.length - e) % 3;
          return 0 === r ? t.toString("base64", e) : (this.lastNeed = 3 - r, this.lastTotal = 3, 1 === r ? this.lastChar[0] = t[t.length - 1] : (this.lastChar[0] = t[t.length - 2], this.lastChar[1] = t[t.length - 1]), t.toString("base64", e, t.length - r))
        }

        function l(t) {
          var e = t && t.length ? this.write(t) : "";
          return this.lastNeed ? e + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e
        }

        function h(t) {
          return t.toString(this.encoding)
        }

        function d(t) {
          return t && t.length ? this.write(t) : ""
        }
        e.I = o, o.prototype.write = function(t) {
          if (0 === t.length) return "";
          var e, r;
          if (this.lastNeed) {
            if (void 0 === (e = this.fillLast(t))) return "";
            r = this.lastNeed, this.lastNeed = 0
          } else r = 0;
          return r < t.length ? e ? e + this.text(t, r) : this.text(t, r) : e || ""
        }, o.prototype.end = function(t) {
          var e = t && t.length ? this.write(t) : "";
          return this.lastNeed ? e + "" : e
        }, o.prototype.text = function(t, e) {
          var r = function(t, e, r) {
            var n = e.length - 1;
            if (r > n) return 0;
            var i = s(e[n]);
            return 0 > i ? --n < r || -2 === i ? 0 : 0 > (i = s(e[n])) ? --n < r || -2 === i || 0 > (i = s(e[n])) ? 0 : (i > 0 && (2 === i ? i = 0 : t.lastNeed = i - 3), i) : (i > 0 && (t.lastNeed = i - 2), i) : (i > 0 && (t.lastNeed = i - 1), i)
          }(this, t, e);
          if (!this.lastNeed) return t.toString("utf8", e);
          this.lastTotal = r;
          var n = t.length - (r - this.lastNeed);
          return t.copy(this.lastChar, 0, n), t.toString("utf8", e, n)
        }, o.prototype.fillLast = function(t) {
          if (this.lastNeed <= t.length) return t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
          t.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t.length), this.lastNeed -= t.length
        }
      },
      83399: (t, e) => {
        "use strict";

        function r(t) {
          return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          if (!("string" == typeof t || t instanceof String)) {
            var e = r(t);
            throw null === t ? e = "null" : "object" === e && (e = t.constructor.name), new TypeError("Expected a string but received a ".concat(e))
          }
        }, t.exports = e.default, t.exports.default = e.default
      },
      84143: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeMessageRelaxed = e.loadMessageRelaxed = void 0;
        const n = r(65871),
          i = r(92234),
          o = r(22738);
        e.loadMessageRelaxed = function(t) {
          const e = (0, i.loadCommonMessageInfoRelaxed)(t);
          let r = null;
          return t.loadBit() && (r = t.loadBit() ? (0, o.loadStateInit)(t.loadRef().beginParse()) : (0, o.loadStateInit)(t)), {
            info: e,
            init: r,
            body: t.loadBit() ? t.loadRef() : t.asCell()
          }
        }, e.storeMessageRelaxed = function(t, e) {
          return r => {
            if (r.store((0, i.storeCommonMessageInfoRelaxed)(t.info)), t.init) {
              r.storeBit(!0);
              let i = (0, n.beginCell)().store((0, o.storeStateInit)(t.init)),
                s = !1;
              s = !(!e || !e.forceRef) || r.availableBits - 2 < i.bits, s ? (r.storeBit(!0), r.storeRef(i)) : (r.storeBit(!1), r.storeBuilder(i))
            } else r.storeBit(!1);
            let s = !1;
            s = !(!e || !e.forceRef) || !!(r.availableBits - 1 < t.body.bits.length || r.refs + t.body.refs.length > 4 || t.body.isExotic), s ? (r.storeBit(!0), r.storeRef(t.body)) : (r.storeBit(!1), r.storeBuilder(t.body.asBuilder()))
          }
        }
      },
      84458: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeDepthBalanceInfo = e.loadDepthBalanceInfo = void 0;
        const n = r(10574);
        e.loadDepthBalanceInfo = function(t) {
          return {
            splitDepth: t.loadUint(5),
            balance: (0, n.loadCurrencyCollection)(t)
          }
        }, e.storeDepthBalanceInfo = function(t) {
          return e => {
            e.storeUint(t.splitDepth, 5), e.store((0, n.storeCurrencyCollection)(t.balance))
          }
        }
      },
      84742: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.openContract = void 0;
        const n = r(3512),
          i = r(66902);
        e.openContract = function(t, e) {
          let r, o = null;
          if (!n.Address.isAddress(t.address)) throw Error("Invalid address");
          if (r = t.address, t.init) {
            if (!(t.init.code instanceof i.Cell)) throw Error("Invalid init.code");
            if (!(t.init.data instanceof i.Cell)) throw Error("Invalid init.data");
            o = t.init
          }
          let s = e({
            address: r,
            init: o
          });
          return new Proxy(t, {
            get(t, e) {
              const r = t[e];
              return "string" == typeof e && (e.startsWith("get") || e.startsWith("send") || e.startsWith("is")) && "function" == typeof r ? (...e) => r.call(t, s, ...e) : r
            }
          })
        }
      },
      84965: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.createDeferredPromise = void 0, e.createDeferredPromise = function({
          suppressUnhandledRejection: t = !1
        } = {}) {
          let e, r;
          const n = new Promise((t, n) => {
            e = t, r = n
          });
          return t && n.catch(t => {}), {
            promise: n,
            resolve: e,
            reject: r
          }
        }
      },
      85787: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.loadShardStateUnsplit = void 0;
        const n = r(29039),
          i = r(28993),
          o = r(32423);
        e.loadShardStateUnsplit = function(t) {
          if (2418257890 !== t.loadUint(32)) throw Error("Invalid data");
          let e = t.loadInt(32),
            r = (0, o.loadShardIdent)(t),
            s = t.loadUint(32),
            a = t.loadUint(32),
            u = t.loadUint(32),
            c = t.loadUintBig(64),
            f = t.loadUint(32);
          t.loadRef();
          let l, h = t.loadBit(),
            d = t.loadRef();
          d.isExotic || (l = (0, i.loadShardAccounts)(d.beginParse())), t.loadRef();
          let p = null;
          if (t.loadBit()) {
            let e = t.loadRef();
            e.isExotic || (p = (0, n.loadMasterchainStateExtra)(e.beginParse()))
          }
          return {
            globalId: e,
            shardId: r,
            seqno: s,
            vertSeqNo: a,
            genUtime: u,
            genLt: c,
            minRefMcSeqno: f,
            beforeSplit: h,
            accounts: l,
            extras: p
          }
        }
      },
      86048: t => {
        "use strict";
        var e = {};

        function r(t, r, n) {
          n || (n = Error);
          var i = function(t) {
            function e(e, n, i) {
              return t.call(this, function(t, e, n) {
                return "string" == typeof r ? r : r(t, e, n)
              }(e, n, i)) || this
            }
            return function(t, e) {
              t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
            }(e, t), e
          }(n);
          i.prototype.name = n.name, i.prototype.code = t, e[t] = i
        }

        function n(t, e) {
          if (Array.isArray(t)) {
            var r = t.length;
            return t = t.map(function(t) {
              return t + ""
            }), r > 2 ? "one of ".concat(e, " ").concat(t.slice(0, r - 1).join(", "), ", or ") + t[r - 1] : 2 === r ? "one of ".concat(e, " ").concat(t[0], " or ").concat(t[1]) : "of ".concat(e, " ").concat(t[0])
          }
          return "of ".concat(e, " ").concat(t + "")
        }
        r("ERR_INVALID_OPT_VALUE", function(t, e) {
          return 'The value "' + e + '" is invalid for option "' + t + '"'
        }, TypeError), r("ERR_INVALID_ARG_TYPE", function(t, e, r) {
          var i, o;
          if ("string" == typeof e && function(t) {
              return "not " === t.substr(0, 4)
            }(e) ? (i = "must not be", e = e.replace(/^not /, "")) : i = "must be", function(t, e, r) {
              return (void 0 === r || r > t.length) && (r = t.length), " argument" === t.substring(r - 9, r)
            }(t)) o = "The ".concat(t, " ").concat(i, " ").concat(n(e, "type"));
          else {
            var s = function(t, e, r) {
              return "number" != typeof r && (r = 0), r + 1 <= t.length && -1 !== t.indexOf(".", r)
            }(t) ? "property" : "argument";
            o = 'The "'.concat(t, '" ').concat(s, " ").concat(i, " ").concat(n(e, "type"))
          }
          return o + ". Received type ".concat(typeof r)
        }, TypeError), r("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r("ERR_METHOD_NOT_IMPLEMENTED", function(t) {
          return "The " + t + " method is not implemented"
        }), r("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r("ERR_STREAM_DESTROYED", function(t) {
          return "Cannot call " + t + " after a stream was destroyed"
        }), r("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r("ERR_STREAM_WRITE_AFTER_END", "write after end"), r("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r("ERR_UNKNOWN_ENCODING", function(t) {
          return "Unknown encoding: " + t
        }, TypeError), r("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t.exports.F = e
      },
      86161: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeAccountStorage = e.loadAccountStorage = void 0;
        const n = r(83049),
          i = r(10574);
        e.loadAccountStorage = function(t) {
          return {
            lastTransLt: t.loadUintBig(64),
            balance: (0, i.loadCurrencyCollection)(t),
            state: (0, n.loadAccountState)(t)
          }
        }, e.storeAccountStorage = function(t) {
          return e => {
            e.storeUint(t.lastTransLt, 64), e.store((0, i.storeCurrencyCollection)(t.balance)), e.store((0, n.storeAccountState)(t.state))
          }
        }
      },
      86238: (t, e, r) => {
        "use strict";
        var n = r(86048).F.ERR_STREAM_PREMATURE_CLOSE;

        function i() {}
        t.exports = function t(e, r, o) {
          if ("function" == typeof r) return t(e, null, r);
          r || (r = {}), o = function(t) {
            var e = !1;
            return function() {
              if (!e) {
                e = !0;
                for (var r = arguments.length, n = Array(r), i = 0; r > i; i++) n[i] = arguments[i];
                t.apply(this, n)
              }
            }
          }(o || i);
          var s = r.readable || !1 !== r.readable && e.readable,
            a = r.writable || !1 !== r.writable && e.writable,
            u = function() {
              e.writable || f()
            },
            c = e.Wt && e.Wt.finished,
            f = function() {
              a = !1, c = !0, s || o.call(e)
            },
            l = e.rt && e.rt.endEmitted,
            h = function() {
              s = !1, l = !0, a || o.call(e)
            },
            d = function(t) {
              o.call(e, t)
            },
            p = function() {
              var t;
              return s && !l ? ((!e.rt || !e.rt.ended) && (t = new n), o.call(e, t)) : a && !c ? ((!e.Wt || !e.Wt.ended) && (t = new n), o.call(e, t)) : void 0
            },
            b = function() {
              e.req.on("finish", f)
            };
          return function(t) {
              return t.setHeader && "function" == typeof t.abort
            }(e) ? (e.on("complete", f), e.on("abort", p), e.req ? b() : e.on("request", b)) : a && !e.Wt && (e.on("end", u), e.on("close", u)), e.on("end", h), e.on("finish", f), !1 !== r.error && e.on("error", d), e.on("close", p),
            function() {
              e.removeListener("complete", f), e.removeListener("abort", p), e.removeListener("request", b), e.req && e.req.removeListener("finish", f), e.removeListener("end", u), e.removeListener("close", u), e.removeListener("finish", f), e.removeListener("end", h), e.removeListener("error", d), e.removeListener("close", p)
            }
        }
      },
      86425: (t, e, r) => {
        "use strict";
        var n = r(65606),
          i = r(48287).Buffer;

        function o(t, e) {
          return function() {
            return t.apply(e, arguments)
          }
        }
        const {
          toString: s
        } = Object.prototype, {
          getPrototypeOf: a
        } = Object, {
          iterator: u,
          toStringTag: c
        } = Symbol, f = (b = Object.create(null), t => {
          const e = s.call(t);
          return b[e] || (b[e] = e.slice(8, -1).toLowerCase())
        }), l = t => (t = t.toLowerCase(), e => f(e) === t), h = t => e => typeof e === t, {
          isArray: d
        } = Array, p = h("undefined");
        var b;
        const m = l("ArrayBuffer"),
          y = h("string"),
          g = h("function"),
          v = h("number"),
          w = t => null !== t && "object" == typeof t,
          A = t => {
            if ("object" !== f(t)) return !1;
            const e = a(t);
            return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || c in t || u in t)
          },
          T = l("Date"),
          E = l("File"),
          P = l("Blob"),
          k = l("FileList"),
          x = l("URLSearchParams"),
          [I, S, O, B] = ["ReadableStream", "Request", "Response", "Headers"].map(l);

        function W(t, e, {
          allOwnKeys: r = !1
        } = {}) {
          if (null === t || typeof t > "u") return;
          let n, i;
          if ("object" != typeof t && (t = [t]), d(t))
            for (n = 0, i = t.length; i > n; n++) e.call(null, t[n], n, t);
          else {
            const i = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
              o = i.length;
            let s;
            for (n = 0; o > n; n++) s = i[n], e.call(null, t[s], s, t)
          }
        }

        function M(t, e) {
          e = e.toLowerCase();
          const r = Object.keys(t);
          let n, i = r.length;
          for (; i-- > 0;)
            if (n = r[i], e === n.toLowerCase()) return n;
          return null
        }
        const C = "u" > typeof globalThis ? globalThis : "u" > typeof self ? self : "u" > typeof window ? window : r.g,
          R = t => !p(t) && t !== C,
          N = (t => e => t && e instanceof t)("u" > typeof Uint8Array && a(Uint8Array)),
          j = l("HTMLFormElement"),
          _ = (({
            hasOwnProperty: t
          }) => (e, r) => t.call(e, r))(Object.prototype),
          D = l("RegExp"),
          U = (t, e) => {
            const r = Object.getOwnPropertyDescriptors(t),
              n = {};
            W(r, (r, i) => {
              let o;
              !1 !== (o = e(r, i, t)) && (n[i] = o || r)
            }), Object.defineProperties(t, n)
          },
          L = l("AsyncFunction"),
          F = ((t, e) => {
            return t ? setImmediate : e ? (r = "axios@" + Math.random(), n = [], C.addEventListener("message", ({
              source: t,
              data: e
            }) => {
              t === C && e === r && n.length && n.shift()()
            }, !1), t => {
              n.push(t), C.postMessage(r, "*")
            }) : t => setTimeout(t);
            var r, n
          })("function" == typeof setImmediate, g(C.postMessage)),
          $ = "u" > typeof queueMicrotask ? queueMicrotask.bind(C) : "u" > typeof n && n.nextTick || F;
        var z = {
          isArray: d,
          isArrayBuffer: m,
          isBuffer: function(t) {
            return null !== t && !p(t) && null !== t.constructor && !p(t.constructor) && g(t.constructor.isBuffer) && t.constructor.isBuffer(t)
          },
          isFormData: t => {
            let e;
            return t && ("function" == typeof FormData && t instanceof FormData || g(t.append) && ("formdata" === (e = f(t)) || "object" === e && g(t.toString) && "[object FormData]" === t.toString()))
          },
          isArrayBufferView: function(t) {
            let e;
            return e = "u" > typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && m(t.buffer), e
          },
          isString: y,
          isNumber: v,
          isBoolean: t => !0 === t || !1 === t,
          isObject: w,
          isPlainObject: A,
          isReadableStream: I,
          isRequest: S,
          isResponse: O,
          isHeaders: B,
          isUndefined: p,
          isDate: T,
          isFile: E,
          isBlob: P,
          isRegExp: D,
          isFunction: g,
          isStream: t => w(t) && g(t.pipe),
          isURLSearchParams: x,
          isTypedArray: N,
          isFileList: k,
          forEach: W,
          merge: function t() {
            const {
              caseless: e
            } = R(this) && this || {}, r = {}, n = (n, i) => {
              const o = e && M(r, i) || i;
              A(r[o]) && A(n) ? r[o] = t(r[o], n) : A(n) ? r[o] = t({}, n) : d(n) ? r[o] = n.slice() : r[o] = n
            };
            for (let t = 0, e = arguments.length; e > t; t++) arguments[t] && W(arguments[t], n);
            return r
          },
          extend: (t, e, r, {
            allOwnKeys: n
          } = {}) => (W(e, (e, n) => {
            r && g(e) ? t[n] = o(e, r) : t[n] = e
          }, {
            allOwnKeys: n
          }), t),
          trim: t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
          stripBOM: t => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
          inherits: (t, e, r, n) => {
            t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
              value: e.prototype
            }), r && Object.assign(t.prototype, r)
          },
          toFlatObject: (t, e, r, n) => {
            let i, o, s;
            const u = {};
            if (e = e || {}, null == t) return e;
            do {
              for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0;) s = i[o], (!n || n(s, t, e)) && !u[s] && (e[s] = t[s], u[s] = !0);
              t = !1 !== r && a(t)
            } while (t && (!r || r(t, e)) && t !== Object.prototype);
            return e
          },
          kindOf: f,
          kindOfTest: l,
          endsWith: (t, e, r) => {
            t += "", (void 0 === r || r > t.length) && (r = t.length), r -= e.length;
            const n = t.indexOf(e, r);
            return -1 !== n && n === r
          },
          toArray: t => {
            if (!t) return null;
            if (d(t)) return t;
            let e = t.length;
            if (!v(e)) return null;
            const r = Array(e);
            for (; e-- > 0;) r[e] = t[e];
            return r
          },
          forEachEntry: (t, e) => {
            const r = (t && t[u]).call(t);
            let n;
            for (;
              (n = r.next()) && !n.done;) {
              const r = n.value;
              e.call(t, r[0], r[1])
            }
          },
          matchAll: (t, e) => {
            let r;
            const n = [];
            for (; null !== (r = t.exec(e));) n.push(r);
            return n
          },
          isHTMLForm: j,
          hasOwnProperty: _,
          hasOwnProp: _,
          reduceDescriptors: U,
          freezeMethods: t => {
            U(t, (e, r) => {
              if (g(t) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1;
              const n = t[r];
              if (g(n)) {
                if (e.enumerable = !1, "writable" in e) return void(e.writable = !1);
                e.set || (e.set = () => {
                  throw Error("Can not rewrite read-only method '" + r + "'")
                })
              }
            })
          },
          toObjectSet: (t, e) => {
            const r = {},
              n = t => {
                t.forEach(t => {
                  r[t] = !0
                })
              };
            return d(t) ? n(t) : n((t + "").split(e)), r
          },
          toCamelCase: t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, e, r) {
            return e.toUpperCase() + r
          }),
          noop: () => {},
          toFiniteNumber: (t, e) => null != t && Number.isFinite(t = +t) ? t : e,
          findKey: M,
          global: C,
          isContextDefined: R,
          isSpecCompliantForm: function(t) {
            return !!(t && g(t.append) && "FormData" === t[c] && t[u])
          },
          toJSONObject: t => {
            const e = [, , , , , , , , , , ],
              r = (t, n) => {
                if (w(t)) {
                  if (e.indexOf(t) >= 0) return;
                  if (!("toJSON" in t)) {
                    e[n] = t;
                    const i = d(t) ? [] : {};
                    return W(t, (t, e) => {
                      const o = r(t, n + 1);
                      !p(o) && (i[e] = o)
                    }), e[n] = void 0, i
                  }
                }
                return t
              };
            return r(t, 0)
          },
          isAsyncFn: L,
          isThenable: t => t && (w(t) || g(t)) && g(t.then) && g(t.catch),
          setImmediate: F,
          asap: $,
          isIterable: t => null != t && g(t[u])
        };

        function H(t, e, r, n, i) {
          Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null)
        }
        z.inherits(H, Error, {
          toJSON: function() {
            return {
              message: this.message,
              name: this.name,
              description: this.description,
              number: this.number,
              fileName: this.fileName,
              lineNumber: this.lineNumber,
              columnNumber: this.columnNumber,
              stack: this.stack,
              config: z.toJSONObject(this.config),
              code: this.code,
              status: this.status
            }
          }
        });
        const G = H.prototype,
          K = {};

        function V(t) {
          return z.isPlainObject(t) || z.isArray(t)
        }

        function Z(t) {
          return z.endsWith(t, "[]") ? t.slice(0, -2) : t
        }

        function q(t, e, r) {
          return t ? t.concat(e).map(function(t, e) {
            return t = Z(t), !r && e ? "[" + t + "]" : t
          }).join(r ? "." : "") : e
        } ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
          K[t] = {
            value: t
          }
        }), Object.defineProperties(H, K), Object.defineProperty(G, "isAxiosError", {
          value: !0
        }), H.from = (t, e, r, n, i, o) => {
          const s = Object.create(G);
          return z.toFlatObject(t, s, function(t) {
            return t !== Error.prototype
          }, t => "isAxiosError" !== t), H.call(s, t.message, e, r, n, i), s.cause = t, s.name = t.name, o && Object.assign(s, o), s
        };
        const J = z.toFlatObject(z, {}, null, function(t) {
          return /^is[A-Z]/.test(t)
        });

        function Y(t, e, r) {
          if (!z.isObject(t)) throw new TypeError("target must be an object");
          e = e || new FormData;
          const n = (r = z.toFlatObject(r, {
              metaTokens: !0,
              dots: !1,
              indexes: !1
            }, !1, function(t, e) {
              return !z.isUndefined(e[t])
            })).metaTokens,
            o = r.visitor || f,
            s = r.dots,
            a = r.indexes,
            u = (r.Blob || "u" > typeof Blob && Blob) && z.isSpecCompliantForm(e);
          if (!z.isFunction(o)) throw new TypeError("visitor must be a function");

          function c(t) {
            if (null === t) return "";
            if (z.isDate(t)) return t.toISOString();
            if (z.isBoolean(t)) return t.toString();
            if (!u && z.isBlob(t)) throw new H("Blob is not supported. Use a Buffer instead.");
            return z.isArrayBuffer(t) || z.isTypedArray(t) ? u && "function" == typeof Blob ? new Blob([t]) : i.from(t) : t
          }

          function f(t, r, i) {
            let o = t;
            if (t && !i && "object" == typeof t)
              if (z.endsWith(r, "{}")) r = n ? r : r.slice(0, -2), t = JSON.stringify(t);
              else if (z.isArray(t) && function(t) {
                return z.isArray(t) && !t.some(V)
              }(t) || (z.isFileList(t) || z.endsWith(r, "[]")) && (o = z.toArray(t))) return r = Z(r), o.forEach(function(t, n) {
              !z.isUndefined(t) && null !== t && e.append(!0 === a ? q([r], n, s) : null === a ? r : r + "[]", c(t))
            }), !1;
            return !!V(t) || (e.append(q(i, r, s), c(t)), !1)
          }
          const l = [],
            h = Object.assign(J, {
              defaultVisitor: f,
              convertValue: c,
              isVisitable: V
            });
          if (!z.isObject(t)) throw new TypeError("data must be an object");
          return function t(r, n) {
            if (!z.isUndefined(r)) {
              if (-1 !== l.indexOf(r)) throw Error("Circular reference detected in " + n.join("."));
              l.push(r), z.forEach(r, function(r, i) {
                !0 === (!(z.isUndefined(r) || null === r) && o.call(e, r, z.isString(i) ? i.trim() : i, n, h)) && t(r, n ? n.concat(i) : [i])
              }), l.pop()
            }
          }(t), e
        }

        function Q(t) {
          const e = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+",
            "%00": "\0"
          };
          return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(t) {
            return e[t]
          })
        }

        function X(t, e) {
          this.Dn = [], t && Y(t, this, e)
        }
        const tt = X.prototype;

        function et(t) {
          return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
        }

        function rt(t, e, r) {
          if (!e) return t;
          const n = r && r.encode || et;
          z.isFunction(r) && (r = {
            serialize: r
          });
          const i = r && r.serialize;
          let o;
          if (o = i ? i(e, r) : z.isURLSearchParams(e) ? e.toString() : new X(e, r).toString(n), o) {
            const e = t.indexOf("#"); - 1 !== e && (t = t.slice(0, e)), t += (-1 === t.indexOf("?") ? "?" : "&") + o
          }
          return t
        }
        tt.append = function(t, e) {
          this.Dn.push([t, e])
        }, tt.toString = function(t) {
          const e = t ? function(e) {
            return t.call(this, e, Q)
          } : Q;
          return this.Dn.map(function(t) {
            return e(t[0]) + "=" + e(t[1])
          }, "").join("&")
        };
        var nt = class {
            constructor() {
              this.handlers = []
            }
            use(t, e, r) {
              return this.handlers.push({
                fulfilled: t,
                rejected: e,
                synchronous: !!r && r.synchronous,
                runWhen: r ? r.runWhen : null
              }), this.handlers.length - 1
            }
            eject(t) {
              this.handlers[t] && (this.handlers[t] = null)
            }
            clear() {
              this.handlers && (this.handlers = [])
            }
            forEach(t) {
              z.forEach(this.handlers, function(e) {
                null !== e && t(e)
              })
            }
          },
          it = {
            silentJSONParsing: !0,
            forcedJSONParsing: !0,
            clarifyTimeoutError: !1
          },
          ot = {
            isBrowser: !0,
            classes: {
              URLSearchParams: "u" > typeof URLSearchParams ? URLSearchParams : X,
              FormData: "u" > typeof FormData ? FormData : null,
              Blob: "u" > typeof Blob ? Blob : null
            },
            protocols: ["http", "https", "file", "blob", "url", "data"]
          };
        const st = "u" > typeof window && "u" > typeof document,
          at = "object" == typeof navigator && navigator || void 0,
          ut = st && (!at || 0 > ["ReactNative", "NativeScript", "NS"].indexOf(at.product)),
          ct = "u" > typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
          ft = st && window.location.href || "http://localhost";
        var lt = {
          ...Object.freeze({
            __proto__: null,
            hasBrowserEnv: st,
            hasStandardBrowserWebWorkerEnv: ct,
            hasStandardBrowserEnv: ut,
            navigator: at,
            origin: ft
          }),
          ...ot
        };

        function ht(t) {
          function e(t, r, n, i) {
            let o = t[i++];
            if ("__proto__" === o) return !0;
            const s = Number.isFinite(+o),
              a = i >= t.length;
            return o = !o && z.isArray(n) ? n.length : o, a ? (z.hasOwnProp(n, o) ? n[o] = [n[o], r] : n[o] = r, !s) : ((!n[o] || !z.isObject(n[o])) && (n[o] = []), e(t, r, n[o], i) && z.isArray(n[o]) && (n[o] = function(t) {
              const e = {},
                r = Object.keys(t);
              let n;
              const i = r.length;
              let o;
              for (n = 0; i > n; n++) o = r[n], e[o] = t[o];
              return e
            }(n[o])), !s)
          }
          if (z.isFormData(t) && z.isFunction(t.entries)) {
            const r = {};
            return z.forEachEntry(t, (t, n) => {
              e(function(t) {
                return z.matchAll(/\w+|\[(\w*)]/g, t).map(t => "[]" === t[0] ? "" : t[1] || t[0])
              }(t), n, r, 0)
            }), r
          }
          return null
        }
        const dt = {
          transitional: it,
          adapter: ["xhr", "http", "fetch"],
          transformRequest: [function(t, e) {
            const r = e.getContentType() || "",
              n = r.indexOf("application/json") > -1,
              i = z.isObject(t);
            if (i && z.isHTMLForm(t) && (t = new FormData(t)), z.isFormData(t)) return n ? JSON.stringify(ht(t)) : t;
            if (z.isArrayBuffer(t) || z.isBuffer(t) || z.isStream(t) || z.isFile(t) || z.isBlob(t) || z.isReadableStream(t)) return t;
            if (z.isArrayBufferView(t)) return t.buffer;
            if (z.isURLSearchParams(t)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
            let o;
            if (i) {
              if (r.indexOf("application/x-www-form-urlencoded") > -1) return function(t, e) {
                return Y(t, new lt.classes.URLSearchParams, Object.assign({
                  visitor: function(t, e, r, n) {
                    return lt.isNode && z.isBuffer(t) ? (this.append(e, t.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments)
                  }
                }, e))
              }(t, this.formSerializer).toString();
              if ((o = z.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
                const e = this.env && this.env.FormData;
                return Y(o ? {
                  "files[]": t
                } : t, e && new e, this.formSerializer)
              }
            }
            return i || n ? (e.setContentType("application/json", !1), function(t) {
              if (z.isString(t)) try {
                return (0, JSON.parse)(t), z.trim(t)
              } catch (t) {
                if ("SyntaxError" !== t.name) throw t
              }
              return (0, JSON.stringify)(t)
            }(t)) : t
          }],
          transformResponse: [function(t) {
            const e = this.transitional || dt.transitional,
              r = e && e.forcedJSONParsing,
              n = "json" === this.responseType;
            if (z.isResponse(t) || z.isReadableStream(t)) return t;
            if (t && z.isString(t) && (r && !this.responseType || n)) {
              const r = !(e && e.silentJSONParsing) && n;
              try {
                return JSON.parse(t)
              } catch (t) {
                if (r) throw "SyntaxError" === t.name ? H.from(t, H.ERR_BAD_RESPONSE, this, null, this.response) : t
              }
            }
            return t
          }],
          timeout: 0,
          xsrfCookieName: "XSRF-TOKEN",
          xsrfHeaderName: "X-XSRF-TOKEN",
          maxContentLength: -1,
          maxBodyLength: -1,
          env: {
            FormData: lt.classes.FormData,
            Blob: lt.classes.Blob
          },
          validateStatus: function(t) {
            return t >= 200 && 300 > t
          },
          headers: {
            common: {
              Accept: "application/json, text/plain, */*",
              "Content-Type": void 0
            }
          }
        };
        z.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
          dt.headers[t] = {}
        });
        var pt = dt;
        const bt = z.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
          mt = Symbol("internals");

        function yt(t) {
          return t && (t + "").trim().toLowerCase()
        }

        function gt(t) {
          return !1 === t || null == t ? t : z.isArray(t) ? t.map(gt) : t + ""
        }

        function vt(t, e, r, n, i) {
          if (z.isFunction(n)) return n.call(this, e, r);
          if (i && (e = r), z.isString(e)) {
            if (z.isString(n)) return -1 !== e.indexOf(n);
            if (z.isRegExp(n)) return n.test(e)
          }
        }
        class wt {
          constructor(t) {
            t && this.set(t)
          }
          set(t, e, r) {
            const n = this;

            function i(t, e, r) {
              const i = yt(e);
              if (!i) throw Error("header name must be a non-empty string");
              const o = z.findKey(n, i);
              (!o || void 0 === n[o] || !0 === r || void 0 === r && !1 !== n[o]) && (n[o || e] = gt(t))
            }
            const o = (t, e) => z.forEach(t, (t, r) => i(t, r, e));
            if (z.isPlainObject(t) || t instanceof this.constructor) o(t, e);
            else if (z.isString(t) && (t = t.trim()) && !(t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()))(t)) o((t => {
              const e = {};
              let r, n, i;
              return t && t.split("\n").forEach(function(t) {
                i = t.indexOf(":"), r = t.substring(0, i).trim().toLowerCase(), n = t.substring(i + 1).trim(), !(!r || e[r] && bt[r]) && ("set-cookie" === r ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n)
              }), e
            })(t), e);
            else if (z.isObject(t) && z.isIterable(t)) {
              let r, n, i = {};
              for (const e of t) {
                if (!z.isArray(e)) throw TypeError("Object iterator must return a key-value pair");
                i[n = e[0]] = (r = i[n]) ? z.isArray(r) ? [...r, e[1]] : [r, e[1]] : e[1]
              }
              o(i, e)
            } else null != t && i(e, t, r);
            return this
          }
          get(t, e) {
            if (t = yt(t)) {
              const r = z.findKey(this, t);
              if (r) {
                const t = this[r];
                if (!e) return t;
                if (!0 === e) return function(t) {
                  const e = Object.create(null),
                    r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
                  let n;
                  for (; n = r.exec(t);) e[n[1]] = n[2];
                  return e
                }(t);
                if (z.isFunction(e)) return e.call(this, t, r);
                if (z.isRegExp(e)) return e.exec(t);
                throw new TypeError("parser must be boolean|regexp|function")
              }
            }
          }
          has(t, e) {
            if (t = yt(t)) {
              const r = z.findKey(this, t);
              return !(!r || void 0 === this[r] || e && !vt(0, this[r], r, e))
            }
            return !1
          }
          delete(t, e) {
            const r = this;
            let n = !1;

            function i(t) {
              if (t = yt(t)) {
                const i = z.findKey(r, t);
                i && (!e || vt(0, r[i], i, e)) && (delete r[i], n = !0)
              }
            }
            return z.isArray(t) ? t.forEach(i) : i(t), n
          }
          clear(t) {
            const e = Object.keys(this);
            let r = e.length,
              n = !1;
            for (; r--;) {
              const i = e[r];
              (!t || vt(0, this[i], i, t, !0)) && (delete this[i], n = !0)
            }
            return n
          }
          normalize(t) {
            const e = this,
              r = {};
            return z.forEach(this, (n, i) => {
              const o = z.findKey(r, i);
              if (o) return e[o] = gt(n), void delete e[i];
              const s = t ? function(t) {
                return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, e, r) => e.toUpperCase() + r)
              }(i) : (i + "").trim();
              s !== i && delete e[i], e[s] = gt(n), r[s] = !0
            }), this
          }
          concat(...t) {
            return this.constructor.concat(this, ...t)
          }
          toJSON(t) {
            const e = Object.create(null);
            return z.forEach(this, (r, n) => {
              null != r && !1 !== r && (e[n] = t && z.isArray(r) ? r.join(", ") : r)
            }), e
          } [Symbol.iterator]() {
            return Object.entries(this.toJSON())[Symbol.iterator]()
          }
          toString() {
            return Object.entries(this.toJSON()).map(([t, e]) => t + ": " + e).join("\n")
          }
          getSetCookie() {
            return this.get("set-cookie") || []
          }
          get[Symbol.toStringTag]() {
            return "AxiosHeaders"
          }
          static from(t) {
            return t instanceof this ? t : new this(t)
          }
          static concat(t, ...e) {
            const r = new this(t);
            return e.forEach(t => r.set(t)), r
          }
          static accessor(t) {
            const e = (this[mt] = this[mt] = {
                accessors: {}
              }).accessors,
              r = this.prototype;

            function n(t) {
              const n = yt(t);
              e[n] || (function(t, e) {
                const r = z.toCamelCase(" " + e);
                ["get", "set", "has"].forEach(n => {
                  Object.defineProperty(t, n + r, {
                    value: function(t, r, i) {
                      return this[n].call(this, e, t, r, i)
                    },
                    configurable: !0
                  })
                })
              }(r, t), e[n] = !0)
            }
            return z.isArray(t) ? t.forEach(n) : n(t), this
          }
        }
        wt.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), z.reduceDescriptors(wt.prototype, ({
          value: t
        }, e) => {
          let r = e[0].toUpperCase() + e.slice(1);
          return {
            get: () => t,
            set(t) {
              this[r] = t
            }
          }
        }), z.freezeMethods(wt);
        var At = wt;

        function Tt(t, e) {
          const r = this || pt,
            n = e || r,
            i = At.from(n.headers);
          let o = n.data;
          return z.forEach(t, function(t) {
            o = t.call(r, o, i.normalize(), e ? e.status : void 0)
          }), i.normalize(), o
        }

        function Et(t) {
          return !(!t || !t.Un)
        }

        function Pt(t, e, r) {
          H.call(this, t ?? "canceled", H.ERR_CANCELED, e, r), this.name = "CanceledError"
        }

        function kt(t, e, r) {
          const n = r.config.validateStatus;
          r.status && n && !n(r.status) ? e(new H("Request failed with status code " + r.status, [H.ERR_BAD_REQUEST, H.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : t(r)
        }
        z.inherits(Pt, H, {
          Un: !0
        });
        const xt = (t, e, r = 3) => {
            let n = 0;
            const i = function(t, e) {
              const r = Array(t = t || 10),
                n = Array(t);
              let i, o = 0,
                s = 0;
              return e = void 0 !== e ? e : 1e3,
                function(a) {
                  const u = Date.now(),
                    c = n[s];
                  i || (i = u), r[o] = a, n[o] = u;
                  let f = s,
                    l = 0;
                  for (; f !== o;) l += r[f++], f %= t;
                  if (o = (o + 1) % t, o === s && (s = (s + 1) % t), e > u - i) return;
                  const h = c && u - c;
                  return h ? Math.round(1e3 * l / h) : void 0
                }
            }(50, 250);
            return function(t, e) {
              let r, n, i = 0,
                o = 1e3 / e;
              const s = (e, o = Date.now()) => {
                i = o, r = null, n && (clearTimeout(n), n = null), t.apply(null, e)
              };
              return [(...t) => {
                const e = Date.now(),
                  a = e - i;
                o > a ? (r = t, n || (n = setTimeout(() => {
                  n = null, s(r)
                }, o - a))) : s(t, e)
              }, () => r && s(r)]
            }(r => {
              const o = r.loaded,
                s = r.lengthComputable ? r.total : void 0,
                a = o - n,
                u = i(a);
              n = o, t({
                loaded: o,
                total: s,
                progress: s ? o / s : void 0,
                bytes: a,
                rate: u || void 0,
                estimated: u && s && s >= o ? (s - o) / u : void 0,
                event: r,
                lengthComputable: null != s,
                [e ? "download" : "upload"]: !0
              })
            }, r)
          },
          It = (t, e) => {
            const r = null != t;
            return [n => e[0]({
              lengthComputable: r,
              total: t,
              loaded: n
            }), e[1]]
          },
          St = t => (...e) => z.asap(() => t(...e));
        var Ot = lt.hasStandardBrowserEnv ? ((t, e) => r => (r = new URL(r, lt.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(new URL(lt.origin), lt.navigator && /(msie|trident)/i.test(lt.navigator.userAgent)) : () => !0,
          Bt = lt.hasStandardBrowserEnv ? {
            write(t, e, r, n, i, o) {
              const s = [t + "=" + encodeURIComponent(e)];
              z.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), z.isString(n) && s.push("path=" + n), z.isString(i) && s.push("domain=" + i), !0 === o && s.push("secure"), document.cookie = s.join("; ")
            },
            read(t) {
              const e = document.cookie.match(RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
              return e ? decodeURIComponent(e[3]) : null
            },
            remove(t) {
              this.write(t, "", Date.now() - 864e5)
            }
          } : {
            write() {},
            read: () => null,
            remove() {}
          };

        function Wt(t, e, r) {
          let n = ! function(t) {
            return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
          }(e);
          return t && (n || 0 == r) ? function(t, e) {
            return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t
          }(t, e) : e
        }
        const Mt = t => t instanceof At ? {
          ...t
        } : t;

        function Ct(t, e) {
          e = e || {};
          const r = {};

          function n(t, e, r, n) {
            return z.isPlainObject(t) && z.isPlainObject(e) ? z.merge.call({
              caseless: n
            }, t, e) : z.isPlainObject(e) ? z.merge({}, e) : z.isArray(e) ? e.slice() : e
          }

          function i(t, e, r, i) {
            return z.isUndefined(e) ? z.isUndefined(t) ? void 0 : n(void 0, t, 0, i) : n(t, e, 0, i)
          }

          function o(t, e) {
            if (!z.isUndefined(e)) return n(void 0, e)
          }

          function s(t, e) {
            return z.isUndefined(e) ? z.isUndefined(t) ? void 0 : n(void 0, t) : n(void 0, e)
          }

          function a(r, i, o) {
            return o in e ? n(r, i) : o in t ? n(void 0, r) : void 0
          }
          const u = {
            url: o,
            method: o,
            data: o,
            baseURL: s,
            transformRequest: s,
            transformResponse: s,
            paramsSerializer: s,
            timeout: s,
            timeoutMessage: s,
            withCredentials: s,
            withXSRFToken: s,
            adapter: s,
            responseType: s,
            xsrfCookieName: s,
            xsrfHeaderName: s,
            onUploadProgress: s,
            onDownloadProgress: s,
            decompress: s,
            maxContentLength: s,
            maxBodyLength: s,
            beforeRedirect: s,
            transport: s,
            httpAgent: s,
            httpsAgent: s,
            cancelToken: s,
            socketPath: s,
            responseEncoding: s,
            validateStatus: a,
            headers: (t, e, r) => i(Mt(t), Mt(e), 0, !0)
          };
          return z.forEach(Object.keys(Object.assign({}, t, e)), function(n) {
            const o = u[n] || i,
              s = o(t[n], e[n], n);
            z.isUndefined(s) && o !== a || (r[n] = s)
          }), r
        }
        var Rt = t => {
            const e = Ct({}, t);
            let r, {
              data: n,
              withXSRFToken: i,
              xsrfHeaderName: o,
              xsrfCookieName: s,
              headers: a,
              auth: u
            } = e;
            if (e.headers = a = At.from(a), e.url = rt(Wt(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), u && a.set("Authorization", "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))), z.isFormData(n))
              if (lt.hasStandardBrowserEnv || lt.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0);
              else if (!1 !== (r = a.getContentType())) {
              const [t, ...e] = r ? r.split(";").map(t => t.trim()).filter(Boolean) : [];
              a.setContentType([t || "multipart/form-data", ...e].join("; "))
            }
            if (lt.hasStandardBrowserEnv && (i && z.isFunction(i) && (i = i(e)), i || !1 !== i && Ot(e.url))) {
              const t = o && s && Bt.read(s);
              t && a.set(o, t)
            }
            return e
          },
          Nt = "u" > typeof XMLHttpRequest && function(t) {
            return new Promise(function(e, r) {
              const n = Rt(t);
              let i = n.data;
              const o = At.from(n.headers).normalize();
              let s, a, u, c, f, {
                responseType: l,
                onUploadProgress: h,
                onDownloadProgress: d
              } = n;

              function p() {
                c && c(), f && f(), n.cancelToken && n.cancelToken.unsubscribe(s), n.signal && n.signal.removeEventListener("abort", s)
              }
              let b = new XMLHttpRequest;

              function m() {
                if (!b) return;
                const n = At.from("getAllResponseHeaders" in b && b.getAllResponseHeaders());
                kt(function(t) {
                  e(t), p()
                }, function(t) {
                  r(t), p()
                }, {
                  data: l && "text" !== l && "json" !== l ? b.response : b.responseText,
                  status: b.status,
                  statusText: b.statusText,
                  headers: n,
                  config: t,
                  request: b
                }), b = null
              }
              b.open(n.method.toUpperCase(), n.url, !0), b.timeout = n.timeout, "onloadend" in b ? b.onloadend = m : b.onreadystatechange = function() {
                !b || 4 !== b.readyState || 0 === b.status && (!b.responseURL || 0 !== b.responseURL.indexOf("file:")) || setTimeout(m)
              }, b.onabort = function() {
                b && (r(new H("Request aborted", H.ECONNABORTED, t, b)), b = null)
              }, b.onerror = function() {
                r(new H("Network Error", H.ERR_NETWORK, t, b)), b = null
              }, b.ontimeout = function() {
                let e = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
                const i = n.transitional || it;
                n.timeoutErrorMessage && (e = n.timeoutErrorMessage), r(new H(e, i.clarifyTimeoutError ? H.ETIMEDOUT : H.ECONNABORTED, t, b)), b = null
              }, void 0 === i && o.setContentType(null), "setRequestHeader" in b && z.forEach(o.toJSON(), function(t, e) {
                b.setRequestHeader(e, t)
              }), z.isUndefined(n.withCredentials) || (b.withCredentials = !!n.withCredentials), l && "json" !== l && (b.responseType = n.responseType), d && ([u, f] = xt(d, !0), b.addEventListener("progress", u)), h && b.upload && ([a, c] = xt(h), b.upload.addEventListener("progress", a), b.upload.addEventListener("loadend", c)), (n.cancelToken || n.signal) && (s = e => {
                b && (r(!e || e.type ? new Pt(null, t, b) : e), b.abort(), b = null)
              }, n.cancelToken && n.cancelToken.subscribe(s), n.signal && (n.signal.aborted ? s() : n.signal.addEventListener("abort", s)));
              const y = function(t) {
                const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
                return e && e[1] || ""
              }(n.url);
              y && -1 === lt.protocols.indexOf(y) ? r(new H("Unsupported protocol " + y + ":", H.ERR_BAD_REQUEST, t)) : b.send(i || null)
            })
          },
          jt = (t, e) => {
            const {
              length: r
            } = t = t ? t.filter(Boolean) : [];
            if (e || r) {
              let r, n = new AbortController;
              const i = function(t) {
                if (!r) {
                  r = !0, s();
                  const e = t instanceof Error ? t : this.reason;
                  n.abort(e instanceof H ? e : new Pt(e instanceof Error ? e.message : e))
                }
              };
              let o = e && setTimeout(() => {
                o = null, i(new H(`timeout ${e} of ms exceeded`, H.ETIMEDOUT))
              }, e);
              const s = () => {
                t && (o && clearTimeout(o), o = null, t.forEach(t => {
                  t.unsubscribe ? t.unsubscribe(i) : t.removeEventListener("abort", i)
                }), t = null)
              };
              t.forEach(t => t.addEventListener("abort", i));
              const {
                signal: a
              } = n;
              return a.unsubscribe = () => z.asap(s), a
            }
          };
        const _t = function*(t, e) {
            let r = t.byteLength;
            if (!e || e > r) return void(yield t);
            let n, i = 0;
            for (; r > i;) n = i + e, yield t.slice(i, n), i = n
          },
          Dt = (t, e, r, n) => {
            const i = async function*(t, e) {
              for await (const r of async function*(t) {
                if (t[Symbol.asyncIterator]) return void(yield* t);
                const e = t.getReader();
                try {
                  for (;;) {
                    const {
                      done: t,
                      value: r
                    } = await e.read();
                    if (t) break;
                    yield r
                  }
                } finally {
                  await e.cancel()
                }
              }(t)) yield* _t(r, e)
            }(t, e);
            let o, s = 0,
              a = t => {
                o || (o = !0, n && n(t))
              };
            return new ReadableStream({
              async pull(t) {
                try {
                  const {
                    done: e,
                    value: n
                  } = await i.next();
                  if (e) return a(), void t.close();
                  let o = n.byteLength;
                  if (r) {
                    let t = s += o;
                    r(t)
                  }
                  t.enqueue(new Uint8Array(n))
                } catch (t) {
                  throw a(t), t
                }
              },
              cancel: t => (a(t), i.return())
            }, {
              highWaterMark: 2
            })
          },
          Ut = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response,
          Lt = Ut && "function" == typeof ReadableStream,
          Ft = Ut && ("function" == typeof TextEncoder ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
          $t = (t, ...e) => {
            try {
              return !!t(...e)
            } catch {
              return !1
            }
          },
          zt = Lt && $t(() => {
            let t = !1;
            const e = new Request(lt.origin, {
              body: new ReadableStream,
              method: "POST",
              get duplex() {
                return t = !0, "half"
              }
            }).headers.has("Content-Type");
            return t && !e
          }),
          Ht = Lt && $t(() => z.isReadableStream(new Response("").body)),
          Gt = {
            stream: Ht && (t => t.body)
          };
        Ut && (t => {
          ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
            !Gt[e] && (Gt[e] = z.isFunction(t[e]) ? t => t[e]() : (t, r) => {
              throw new H(`Response type '${e}' is not supported`, H.ERR_NOT_SUPPORT, r)
            })
          })
        })(new Response);
        var Kt = Ut && (async t => {
          let {
            url: e,
            method: r,
            data: n,
            signal: i,
            cancelToken: o,
            timeout: s,
            onDownloadProgress: a,
            onUploadProgress: u,
            responseType: c,
            headers: f,
            withCredentials: l = "same-origin",
            fetchOptions: h
          } = Rt(t);
          c = c ? (c + "").toLowerCase() : "text";
          let d, p = jt([i, o && o.toAbortSignal()], s);
          const b = p && p.unsubscribe && (() => {
            p.unsubscribe()
          });
          let m;
          try {
            if (u && zt && "get" !== r && "head" !== r && 0 !== (m = await (async (t, e) => z.toFiniteNumber(t.getContentLength()) ?? (async t => null == t ? 0 : z.isBlob(t) ? t.size : z.isSpecCompliantForm(t) ? (await new Request(lt.origin, {
                method: "POST",
                body: t
              }).arrayBuffer()).byteLength : z.isArrayBufferView(t) || z.isArrayBuffer(t) ? t.byteLength : (z.isURLSearchParams(t) && (t += ""), z.isString(t) ? (await Ft(t)).byteLength : void 0))(e))(f, n))) {
              let t, r = new Request(e, {
                method: "POST",
                body: n,
                duplex: "half"
              });
              if (z.isFormData(n) && (t = r.headers.get("content-type")) && f.setContentType(t), r.body) {
                const [t, e] = It(m, xt(St(u)));
                n = Dt(r.body, 65536, t, e)
              }
            }
            z.isString(l) || (l = l ? "include" : "omit");
            const i = "credentials" in Request.prototype;
            d = new Request(e, {
              ...h,
              signal: p,
              method: r.toUpperCase(),
              headers: f.normalize().toJSON(),
              body: n,
              duplex: "half",
              credentials: i ? l : void 0
            });
            let o = await fetch(d, h);
            const s = Ht && ("stream" === c || "response" === c);
            if (Ht && (a || s && b)) {
              const t = {};
              ["status", "statusText", "headers"].forEach(e => {
                t[e] = o[e]
              });
              const e = z.toFiniteNumber(o.headers.get("content-length")),
                [r, n] = a && It(e, xt(St(a), !0)) || [];
              o = new Response(Dt(o.body, 65536, r, () => {
                n && n(), b && b()
              }), t)
            }
            c = c || "text";
            let y = await Gt[z.findKey(Gt, c) || "text"](o, t);
            return !s && b && b(), await new Promise((e, r) => {
              kt(e, r, {
                data: y,
                headers: At.from(o.headers),
                status: o.status,
                statusText: o.statusText,
                config: t,
                request: d
              })
            })
          } catch (e) {
            throw b && b(), e && "TypeError" === e.name && /Load failed|fetch/i.test(e.message) ? Object.assign(new H("Network Error", H.ERR_NETWORK, t, d), {
              cause: e.cause || e
            }) : H.from(e, e && e.code, t, d)
          }
        });
        const Vt = {
          http: null,
          xhr: Nt,
          fetch: Kt
        };
        z.forEach(Vt, (t, e) => {
          if (t) {
            try {
              Object.defineProperty(t, "name", {
                value: e
              })
            } catch {}
            Object.defineProperty(t, "adapterName", {
              value: e
            })
          }
        });
        const Zt = t => "- " + t,
          qt = t => z.isFunction(t) || null === t || !1 === t;
        var Jt = t => {
          t = z.isArray(t) ? t : [t];
          const {
            length: e
          } = t;
          let r, n;
          const i = {};
          for (let o = 0; e > o; o++) {
            let e;
            if (r = t[o], n = r, !qt(r) && (n = Vt[(e = r + "").toLowerCase()], void 0 === n)) throw new H(`Unknown adapter '${e}'`);
            if (n) break;
            i[e || "#" + o] = n
          }
          if (!n) {
            const t = Object.entries(i).map(([t, e]) => `adapter ${t} ` + (!1 === e ? "is not supported by the environment" : "is not available in the build"));
            throw new H("There is no suitable adapter to dispatch the request " + (e ? t.length > 1 ? "since :\n" + t.map(Zt).join("\n") : " " + Zt(t[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT")
          }
          return n
        };

        function Yt(t) {
          if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new Pt(null, t)
        }

        function Qt(t) {
          return Yt(t), t.headers = At.from(t.headers), t.data = Tt.call(t, t.transformRequest), -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1), Jt(t.adapter || pt.adapter)(t).then(function(e) {
            return Yt(t), e.data = Tt.call(t, t.transformResponse, e), e.headers = At.from(e.headers), e
          }, function(e) {
            return Et(e) || (Yt(t), e && e.response && (e.response.data = Tt.call(t, t.transformResponse, e.response), e.response.headers = At.from(e.response.headers))), Promise.reject(e)
          })
        }
        const Xt = "1.10.0",
          te = {};
        ["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
          te[t] = function(r) {
            return typeof r === t || "a" + (1 > e ? "n " : " ") + t
          }
        });
        const ee = {};
        te.transitional = function(t, e, r) {
          function n(t, e) {
            return "[Axios v" + Xt + "] Transitional option '" + t + "'" + e + (r ? ". " + r : "")
          }
          return (r, i, o) => {
            if (!1 === t) throw new H(n(i, " has been removed" + (e ? " in " + e : "")), H.ERR_DEPRECATED);
            return e && !ee[i] && (ee[i] = !0, console.warn(n(i, " has been deprecated since v" + e + " and will be removed in the near future"))), !t || t(r, i, o)
          }
        }, te.spelling = function(t) {
          return (e, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0)
        };
        var re = {
          assertOptions: function(t, e, r) {
            if ("object" != typeof t) throw new H("options must be an object", H.ERR_BAD_OPTION_VALUE);
            const n = Object.keys(t);
            let i = n.length;
            for (; i-- > 0;) {
              const o = n[i],
                s = e[o];
              if (s) {
                const e = t[o],
                  r = void 0 === e || s(e, o, t);
                if (!0 !== r) throw new H("option " + o + " must be " + r, H.ERR_BAD_OPTION_VALUE);
                continue
              }
              if (!0 !== r) throw new H("Unknown option " + o, H.ERR_BAD_OPTION)
            }
          },
          validators: te
        };
        const ne = re.validators;
        class ie {
          constructor(t) {
            this.defaults = t || {}, this.interceptors = {
              request: new nt,
              response: new nt
            }
          }
          async request(t, e) {
            try {
              return await this.Ln(t, e)
            } catch (t) {
              if (t instanceof Error) {
                let e = {};
                Error.captureStackTrace ? Error.captureStackTrace(e) : e = Error();
                const r = e.stack ? e.stack.replace(/^.+\n/, "") : "";
                try {
                  t.stack ? r && !(t.stack + "").endsWith(r.replace(/^.+\n.+\n/, "")) && (t.stack += "\n" + r) : t.stack = r
                } catch {}
              }
              throw t
            }
          }
          Ln(t, e) {
            "string" == typeof t ? (e = e || {}).url = t : e = t || {}, e = Ct(this.defaults, e);
            const {
              transitional: r,
              paramsSerializer: n,
              headers: i
            } = e;
            void 0 !== r && re.assertOptions(r, {
              silentJSONParsing: ne.transitional(ne.boolean),
              forcedJSONParsing: ne.transitional(ne.boolean),
              clarifyTimeoutError: ne.transitional(ne.boolean)
            }, !1), null != n && (z.isFunction(n) ? e.paramsSerializer = {
              serialize: n
            } : re.assertOptions(n, {
              encode: ne.function,
              serialize: ne.function
            }, !0)), void 0 !== e.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? e.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : e.allowAbsoluteUrls = !0), re.assertOptions(e, {
              baseUrl: ne.spelling("baseURL"),
              withXsrfToken: ne.spelling("withXSRFToken")
            }, !0), e.method = (e.method || this.defaults.method || "get").toLowerCase();
            let o = i && z.merge(i.common, i[e.method]);
            i && z.forEach(["delete", "get", "head", "post", "put", "patch", "common"], t => {
              delete i[t]
            }), e.headers = At.concat(o, i);
            const s = [];
            let a = !0;
            this.interceptors.request.forEach(function(t) {
              "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous, s.unshift(t.fulfilled, t.rejected))
            });
            const u = [];
            this.interceptors.response.forEach(function(t) {
              u.push(t.fulfilled, t.rejected)
            });
            let c, f, l = 0;
            if (!a) {
              const t = [Qt.bind(this), void 0];
              for (t.unshift.apply(t, s), t.push.apply(t, u), f = t.length, c = Promise.resolve(e); f > l;) c = c.then(t[l++], t[l++]);
              return c
            }
            f = s.length;
            let h = e;
            for (l = 0; f > l;) {
              const t = s[l++],
                e = s[l++];
              try {
                h = t(h)
              } catch (t) {
                e.call(this, t);
                break
              }
            }
            try {
              c = Qt(h)
            } catch (t) {
              return Promise.reject(t)
            }
            for (l = 0, f = u.length; f > l;) c = c.then(u[l++], u[l++]);
            return c
          }
          getUri(t) {
            return rt(Wt((t = Ct(this.defaults, t)).baseURL, t.url, t.allowAbsoluteUrls), t.params, t.paramsSerializer)
          }
        }
        z.forEach(["delete", "get", "head", "options"], function(t) {
          ie.prototype[t] = function(e, r) {
            return this.request(Ct(r || {}, {
              method: t,
              url: e,
              data: (r || {}).data
            }))
          }
        }), z.forEach(["post", "put", "patch"], function(t) {
          function e(e) {
            return function(r, n, i) {
              return this.request(Ct(i || {}, {
                method: t,
                headers: e ? {
                  "Content-Type": "multipart/form-data"
                } : {},
                url: r,
                data: n
              }))
            }
          }
          ie.prototype[t] = e(), ie.prototype[t + "Form"] = e(!0)
        });
        var oe = ie;
        class se {
          constructor(t) {
            if ("function" != typeof t) throw new TypeError("executor must be a function.");
            let e;
            this.promise = new Promise(function(t) {
              e = t
            });
            const r = this;
            this.promise.then(t => {
              if (!r.$n) return;
              let e = r.$n.length;
              for (; e-- > 0;) r.$n[e](t);
              r.$n = null
            }), this.promise.then = t => {
              let e;
              const n = new Promise(t => {
                r.subscribe(t), e = t
              }).then(t);
              return n.cancel = function() {
                r.unsubscribe(e)
              }, n
            }, t(function(t, n, i) {
              r.reason || (r.reason = new Pt(t, n, i), e(r.reason))
            })
          }
          throwIfRequested() {
            if (this.reason) throw this.reason
          }
          subscribe(t) {
            this.reason ? t(this.reason) : this.$n ? this.$n.push(t) : this.$n = [t]
          }
          unsubscribe(t) {
            if (!this.$n) return;
            const e = this.$n.indexOf(t); - 1 !== e && this.$n.splice(e, 1)
          }
          toAbortSignal() {
            const t = new AbortController,
              e = e => {
                t.abort(e)
              };
            return this.subscribe(e), t.signal.unsubscribe = () => this.unsubscribe(e), t.signal
          }
          static source() {
            let t;
            return {
              token: new se(function(e) {
                t = e
              }),
              cancel: t
            }
          }
        }
        var ae = se;
        const ue = {
          Continue: 100,
          SwitchingProtocols: 101,
          Processing: 102,
          EarlyHints: 103,
          Ok: 200,
          Created: 201,
          Accepted: 202,
          NonAuthoritativeInformation: 203,
          NoContent: 204,
          ResetContent: 205,
          PartialContent: 206,
          MultiStatus: 207,
          AlreadyReported: 208,
          ImUsed: 226,
          MultipleChoices: 300,
          MovedPermanently: 301,
          Found: 302,
          SeeOther: 303,
          NotModified: 304,
          UseProxy: 305,
          Unused: 306,
          TemporaryRedirect: 307,
          PermanentRedirect: 308,
          BadRequest: 400,
          Unauthorized: 401,
          PaymentRequired: 402,
          Forbidden: 403,
          NotFound: 404,
          MethodNotAllowed: 405,
          NotAcceptable: 406,
          ProxyAuthenticationRequired: 407,
          RequestTimeout: 408,
          Conflict: 409,
          Gone: 410,
          LengthRequired: 411,
          PreconditionFailed: 412,
          PayloadTooLarge: 413,
          UriTooLong: 414,
          UnsupportedMediaType: 415,
          RangeNotSatisfiable: 416,
          ExpectationFailed: 417,
          ImATeapot: 418,
          MisdirectedRequest: 421,
          UnprocessableEntity: 422,
          Locked: 423,
          FailedDependency: 424,
          TooEarly: 425,
          UpgradeRequired: 426,
          PreconditionRequired: 428,
          TooManyRequests: 429,
          RequestHeaderFieldsTooLarge: 431,
          UnavailableForLegalReasons: 451,
          InternalServerError: 500,
          NotImplemented: 501,
          BadGateway: 502,
          ServiceUnavailable: 503,
          GatewayTimeout: 504,
          HttpVersionNotSupported: 505,
          VariantAlsoNegotiates: 506,
          InsufficientStorage: 507,
          LoopDetected: 508,
          NotExtended: 510,
          NetworkAuthenticationRequired: 511
        };
        Object.entries(ue).forEach(([t, e]) => {
          ue[e] = t
        });
        var ce = ue;
        const fe = function t(e) {
          const r = new oe(e),
            n = o(oe.prototype.request, r);
          return z.extend(n, oe.prototype, r, {
            allOwnKeys: !0
          }), z.extend(n, r, null, {
            allOwnKeys: !0
          }), n.create = function(r) {
            return t(Ct(e, r))
          }, n
        }(pt);
        fe.Axios = oe, fe.CanceledError = Pt, fe.CancelToken = ae, fe.isCancel = Et, fe.VERSION = Xt, fe.toFormData = Y, fe.AxiosError = H, fe.Cancel = fe.CanceledError, fe.all = function(t) {
          return Promise.all(t)
        }, fe.spread = function(t) {
          return function(e) {
            return t.apply(null, e)
          }
        }, fe.isAxiosError = function(t) {
          return z.isObject(t) && !0 === t.isAxiosError
        }, fe.mergeConfig = Ct, fe.AxiosHeaders = At, fe.formToJSON = t => ht(z.isHTMLForm(t) ? new FormData(t) : t), fe.getAdapter = Jt, fe.HttpStatusCode = ce, fe.default = fe, t.exports = fe
      },
      86727: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Address = void 0;
        const i = r(16284),
          o = r(77312);
        class s {
          constructor(t) {
            if (20 !== t.length) throw Error("Invalid address length");
            this.buf = t
          }
          static zero() {
            return new s((0, o.zeros)(20))
          }
          static fromString(t) {
            if (!(0, i.isValidAddress)(t)) throw Error("Invalid address");
            return new s((0, o.toBuffer)(t))
          }
          static fromPublicKey(t) {
            if (!n.isBuffer(t)) throw Error("Public key should be Buffer");
            const e = (0, i.pubToAddress)(t);
            return new s(e)
          }
          static fromPrivateKey(t) {
            if (!n.isBuffer(t)) throw Error("Private key should be Buffer");
            const e = (0, i.privateToAddress)(t);
            return new s(e)
          }
          static generate(t, e) {
            if ("bigint" != typeof e) throw Error("Expected nonce to be a bigint");
            return new s((0, i.generateAddress)(t.buf, (0, o.bigIntToBuffer)(e)))
          }
          static generate2(t, e, r) {
            if (!n.isBuffer(e)) throw Error("Expected salt to be a Buffer");
            if (!n.isBuffer(r)) throw Error("Expected initCode to be a Buffer");
            return new s((0, i.generateAddress2)(t.buf, e, r))
          }
          equals(t) {
            return this.buf.equals(t.buf)
          }
          isZero() {
            return this.equals(s.zero())
          }
          isPrecompileOrSystemAddress() {
            const t = (0, o.bufferToBigInt)(this.buf),
              e = BigInt(0),
              r = BigInt("0xffff");
            return t >= e && r >= t
          }
          toString() {
            return "0x" + this.buf.toString("hex")
          }
          toBuffer() {
            return n.from(this.buf)
          }
        }
        e.Address = s
      },
      86866: t => {
        t.exports = {
          100: "Continue",
          101: "Switching Protocols",
          102: "Processing",
          200: "OK",
          201: "Created",
          202: "Accepted",
          203: "Non-Authoritative Information",
          204: "No Content",
          205: "Reset Content",
          206: "Partial Content",
          207: "Multi-Status",
          208: "Already Reported",
          226: "IM Used",
          300: "Multiple Choices",
          301: "Moved Permanently",
          302: "Found",
          303: "See Other",
          304: "Not Modified",
          305: "Use Proxy",
          307: "Temporary Redirect",
          308: "Permanent Redirect",
          400: "Bad Request",
          401: "Unauthorized",
          402: "Payment Required",
          403: "Forbidden",
          404: "Not Found",
          405: "Method Not Allowed",
          406: "Not Acceptable",
          407: "Proxy Authentication Required",
          408: "Request Timeout",
          409: "Conflict",
          410: "Gone",
          411: "Length Required",
          412: "Precondition Failed",
          413: "Payload Too Large",
          414: "URI Too Long",
          415: "Unsupported Media Type",
          416: "Range Not Satisfiable",
          417: "Expectation Failed",
          418: "I'm a teapot",
          421: "Misdirected Request",
          422: "Unprocessable Entity",
          423: "Locked",
          424: "Failed Dependency",
          425: "Unordered Collection",
          426: "Upgrade Required",
          428: "Precondition Required",
          429: "Too Many Requests",
          431: "Request Header Fields Too Large",
          451: "Unavailable For Legal Reasons",
          500: "Internal Server Error",
          501: "Not Implemented",
          502: "Bad Gateway",
          503: "Service Unavailable",
          504: "Gateway Timeout",
          505: "HTTP Version Not Supported",
          506: "Variant Also Negotiates",
          507: "Insufficient Storage",
          508: "Loop Detected",
          509: "Bandwidth Limit Exceeded",
          510: "Not Extended",
          511: "Network Authentication Required"
        }
      },
      86910: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      87676: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeAccountStatus = e.loadAccountStatus = void 0, e.loadAccountStatus = function(t) {
          const e = t.loadUint(2);
          if (0 === e) return "uninitialized";
          if (1 === e) return "frozen";
          if (2 === e) return "active";
          if (3 === e) return "non-existing";
          throw Error("Invalid data")
        }, e.storeAccountStatus = function(t) {
          return e => {
            if ("uninitialized" === t) e.storeUint(0, 2);
            else if ("frozen" === t) e.storeUint(1, 2);
            else if ("active" === t) e.storeUint(2, 2);
            else {
              if ("non-existing" !== t) throw Error("Invalid data");
              e.storeUint(3, 2)
            }
            return e
          }
        }
      },
      87677: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), t.replace(/&quot;/g, '"').replace(/&#x27;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&#x2F;/g, "/").replace(/&#x5C;/g, "\\").replace(/&#96;/g, "`").replace(/&amp;/g, "&")
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      88310: (t, e, r) => {
        t.exports = i;
        var n = r(37007).EventEmitter;

        function i() {
          n.call(this)
        }
        r(56698)(i, n), i.Readable = r(45412), i.Writable = r(16708), i.Duplex = r(25382), i.Transform = r(74610), i.PassThrough = r(63600), i.finished = r(86238), i.pipeline = r(57758), i.Stream = i, i.prototype.pipe = function(t, e) {
          var r = this;

          function i(e) {
            t.writable && !1 === t.write(e) && r.pause && r.pause()
          }

          function o() {
            r.readable && r.resume && r.resume()
          }
          r.on("data", i), t.on("drain", o), !t.zn && (!e || !1 !== e.end) && (r.on("end", a), r.on("close", u));
          var s = !1;

          function a() {
            s || (s = !0, t.end())
          }

          function u() {
            s || (s = !0, "function" == typeof t.destroy && t.destroy())
          }

          function c(t) {
            if (f(), 0 === n.listenerCount(this, "error")) throw t
          }

          function f() {
            r.removeListener("data", i), t.removeListener("drain", o), r.removeListener("end", a), r.removeListener("close", u), r.removeListener("error", c), t.removeListener("error", c), r.removeListener("end", f), r.removeListener("close", f), t.removeListener("close", f)
          }
          return r.on("error", c), t.on("error", c), r.on("end", f), r.on("close", f), t.on("close", f), t.emit("pipe", r), t
        }
      },
      88342: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.has(t.toUpperCase())
        }, e.CurrencyCodes = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = new Set(["AED", "AFN", "ALL", "AMD", "ANG", "AOA", "ARS", "AUD", "AWG", "AZN", "BAM", "BBD", "BDT", "BGN", "BHD", "BIF", "BMD", "BND", "BOB", "BOV", "BRL", "BSD", "BTN", "BWP", "BYN", "BZD", "CAD", "CDF", "CHE", "CHF", "CHW", "CLF", "CLP", "CNY", "COP", "COU", "CRC", "CUC", "CUP", "CVE", "CZK", "DJF", "DKK", "DOP", "DZD", "EGP", "ERN", "ETB", "EUR", "FJD", "FKP", "GBP", "GEL", "GHS", "GIP", "GMD", "GNF", "GTQ", "GYD", "HKD", "HNL", "HRK", "HTG", "HUF", "IDR", "ILS", "INR", "IQD", "IRR", "ISK", "JMD", "JOD", "JPY", "KES", "KGS", "KHR", "KMF", "KPW", "KRW", "KWD", "KYD", "KZT", "LAK", "LBP", "LKR", "LRD", "LSL", "LYD", "MAD", "MDL", "MGA", "MKD", "MMK", "MNT", "MOP", "MRU", "MUR", "MVR", "MWK", "MXN", "MXV", "MYR", "MZN", "NAD", "NGN", "NIO", "NOK", "NPR", "NZD", "OMR", "PAB", "PEN", "PGK", "PHP", "PKR", "PLN", "PYG", "QAR", "RON", "RSD", "RUB", "RWF", "SAR", "SBD", "SCR", "SDG", "SEK", "SGD", "SHP", "SLL", "SOS", "SRD", "SSP", "STN", "SVC", "SYP", "SZL", "THB", "TJS", "TMT", "TND", "TOP", "TRY", "TTD", "TWD", "TZS", "UAH", "UGX", "USD", "USN", "UYI", "UYU", "UYW", "UZS", "VES", "VND", "VUV", "WST", "XAF", "XAG", "XAU", "XBA", "XBB", "XBC", "XBD", "XCD", "XDR", "XOF", "XPD", "XPF", "XPT", "XSU", "XTS", "XUA", "XXX", "YER", "ZAR", "ZMW", "ZWL"]),
          s = o;
        e.CurrencyCodes = s
      },
      88447: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.has(t.toUpperCase())
        }, e.CountryCodes = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = new Set(["AD", "AE", "AF", "AG", "AI", "AL", "AM", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ", "BL", "BM", "BN", "BO", "BQ", "BR", "BS", "BT", "BV", "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", "CU", "CV", "CW", "CX", "CY", "CZ", "DE", "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR", "SS", "ST", "SV", "SX", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW"]),
          s = o;
        e.CountryCodes = s
      },
      88835: (t, e, r) => {
        "use strict";
        var n = r(61270);

        function i() {
          this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
        }
        var o = /^([a-z0-9.+-]+:)/i,
          s = /:[0-9]*$/,
          a = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/,
          u = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "\t"]),
          c = ["'"].concat(u),
          f = ["%", "/", "?", ";", "#"].concat(c),
          l = ["/", "?", "#"],
          h = /^[+a-z0-9A-Z_-]{0,63}$/,
          d = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
          p = {
            javascript: !0,
            "javascript:": !0
          },
          b = {
            javascript: !0,
            "javascript:": !0
          },
          m = {
            http: !0,
            https: !0,
            ftp: !0,
            gopher: !0,
            file: !0,
            "http:": !0,
            "https:": !0,
            "ftp:": !0,
            "gopher:": !0,
            "file:": !0
          },
          y = r(55373);

        function g(t, e, r) {
          if (t && "object" == typeof t && t instanceof i) return t;
          var n = new i;
          return n.parse(t, e, r), n
        }
        i.prototype.parse = function(t, e, r) {
          if ("string" != typeof t) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
          var i = t.indexOf("?"),
            s = -1 !== i && i < t.indexOf("#") ? "?" : "#",
            u = t.split(s);
          u[0] = u[0].replace(/\\/g, "/");
          var g = t = u.join(s);
          if (g = g.trim(), !r && 1 === t.split("#").length) {
            var v = a.exec(g);
            if (v) return this.path = g, this.href = g, this.pathname = v[1], v[2] ? (this.search = v[2], this.query = e ? y.parse(this.search.substr(1)) : this.search.substr(1)) : e && (this.search = "", this.query = {}), this
          }
          var w = o.exec(g);
          if (w) {
            var A = (w = w[0]).toLowerCase();
            this.protocol = A, g = g.substr(w.length)
          }
          if (r || w || g.match(/^\/\/[^@/]+@[^@/]+/)) {
            var T = "//" === g.substr(0, 2);
            T && (!w || !b[w]) && (g = g.substr(2), this.slashes = !0)
          }
          if (!b[w] && (T || w && !m[w])) {
            for (var E = -1, P = 0; l.length > P; P++) - 1 !== (I = g.indexOf(l[P])) && (-1 === E || E > I) && (E = I);
            var k, x;
            for (-1 !== (x = -1 === E ? g.lastIndexOf("@") : g.lastIndexOf("@", E)) && (k = g.slice(0, x), g = g.slice(x + 1), this.auth = decodeURIComponent(k)), E = -1, P = 0; P < f.length; P++) {
              var I; - 1 !== (I = g.indexOf(f[P])) && (-1 === E || E > I) && (E = I)
            } - 1 === E && (E = g.length), this.host = g.slice(0, E), g = g.slice(E), this.parseHost(), this.hostname = this.hostname || "";
            var S = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
            if (!S)
              for (var O = this.hostname.split(/\./), B = (P = 0, O.length); B > P; P++) {
                var W = O[P];
                if (W && !W.match(h)) {
                  for (var M = "", C = 0, R = W.length; R > C; C++) W.charCodeAt(C) > 127 ? M += "x" : M += W[C];
                  if (!M.match(h)) {
                    var N = O.slice(0, P),
                      j = O.slice(P + 1),
                      _ = W.match(d);
                    _ && (N.push(_[1]), j.unshift(_[2])), j.length && (g = "/" + j.join(".") + g), this.hostname = N.join(".");
                    break
                  }
                }
              }
            this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), S || (this.hostname = n.toASCII(this.hostname));
            var D = this.port ? ":" + this.port : "",
              U = this.hostname || "";
            this.host = U + D, this.href += this.host, S && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== g[0] && (g = "/" + g))
          }
          if (!p[A])
            for (P = 0, B = c.length; B > P; P++) {
              var L = c[P];
              if (-1 !== g.indexOf(L)) {
                var F = encodeURIComponent(L);
                F === L && (F = escape(L)), g = g.split(L).join(F)
              }
            }
          var $ = g.indexOf("#"); - 1 !== $ && (this.hash = g.substr($), g = g.slice(0, $));
          var z = g.indexOf("?");
          if (-1 !== z ? (this.search = g.substr(z), this.query = g.substr(z + 1), e && (this.query = y.parse(this.query)), g = g.slice(0, z)) : e && (this.search = "", this.query = {}), g && (this.pathname = g), m[A] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
            D = this.pathname || "";
            var H = this.search || "";
            this.path = D + H
          }
          return this.href = this.format(), this
        }, i.prototype.format = function() {
          var t = this.auth || "";
          t && (t = (t = encodeURIComponent(t)).replace(/%3A/i, ":"), t += "@");
          var e = this.protocol || "",
            r = this.pathname || "",
            n = this.hash || "",
            i = !1,
            o = "";
          this.host ? i = t + this.host : this.hostname && (i = t + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (i += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (o = y.stringify(this.query, {
            arrayFormat: "repeat",
            addQueryPrefix: !1
          }));
          var s = this.search || o && "?" + o || "";
          return e && ":" !== e.substr(-1) && (e += ":"), this.slashes || (!e || m[e]) && !1 !== i ? (i = "//" + (i || ""), r && "/" !== r.charAt(0) && (r = "/" + r)) : i || (i = ""), n && "#" !== n.charAt(0) && (n = "#" + n), s && "?" !== s.charAt(0) && (s = "?" + s), e + i + (r = r.replace(/[?#]/g, function(t) {
            return encodeURIComponent(t)
          })) + (s = s.replace("#", "%23")) + n
        }, i.prototype.resolve = function(t) {
          return this.resolveObject(g(t, !1, !0)).format()
        }, i.prototype.resolveObject = function(t) {
          if ("string" == typeof t) {
            var e = new i;
            e.parse(t, !1, !0), t = e
          }
          for (var r = new i, n = Object.keys(this), o = 0; o < n.length; o++) {
            var s = n[o];
            r[s] = this[s]
          }
          if (r.hash = t.hash, "" === t.href) return r.href = r.format(), r;
          if (t.slashes && !t.protocol) {
            for (var a = Object.keys(t), u = 0; u < a.length; u++) {
              var c = a[u];
              "protocol" !== c && (r[c] = t[c])
            }
            return m[r.protocol] && r.hostname && !r.pathname && (r.pathname = "/", r.path = r.pathname), r.href = r.format(), r
          }
          if (t.protocol && t.protocol !== r.protocol) {
            if (!m[t.protocol]) {
              for (var f = Object.keys(t), l = 0; l < f.length; l++) {
                var h = f[l];
                r[h] = t[h]
              }
              return r.href = r.format(), r
            }
            if (r.protocol = t.protocol, t.host || b[t.protocol]) r.pathname = t.pathname;
            else {
              for (var d = (t.pathname || "").split("/"); d.length && !(t.host = d.shift()););
              t.host || (t.host = ""), t.hostname || (t.hostname = ""), "" !== d[0] && d.unshift(""), 2 > d.length && d.unshift(""), r.pathname = d.join("/")
            }
            if (r.search = t.search, r.query = t.query, r.host = t.host || "", r.auth = t.auth, r.hostname = t.hostname || t.host, r.port = t.port, r.pathname || r.search) {
              var p = r.pathname || "",
                y = r.search || "";
              r.path = p + y
            }
            return r.slashes = r.slashes || t.slashes, r.href = r.format(), r
          }
          var g = r.pathname && "/" === r.pathname.charAt(0),
            v = t.host || t.pathname && "/" === t.pathname.charAt(0),
            w = v || g || r.host && t.pathname,
            A = w,
            T = r.pathname && r.pathname.split("/") || [],
            E = (d = t.pathname && t.pathname.split("/") || [], r.protocol && !m[r.protocol]);
          if (E && (r.hostname = "", r.port = null, r.host && ("" === T[0] ? T[0] = r.host : T.unshift(r.host)), r.host = "", t.protocol && (t.hostname = null, t.port = null, t.host && ("" === d[0] ? d[0] = t.host : d.unshift(t.host)), t.host = null), w = w && ("" === d[0] || "" === T[0])), v) r.host = t.host || "" === t.host ? t.host : r.host, r.hostname = t.hostname || "" === t.hostname ? t.hostname : r.hostname, r.search = t.search, r.query = t.query, T = d;
          else if (d.length) T || (T = []), T.pop(), T = T.concat(d), r.search = t.search, r.query = t.query;
          else if (null != t.search) return E && (r.host = T.shift(), r.hostname = r.host, (S = !(!r.host || 0 >= r.host.indexOf("@")) && r.host.split("@")) && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname)), r.search = t.search, r.query = t.query, (null !== r.pathname || null !== r.search) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.href = r.format(), r;
          if (!T.length) return r.pathname = null, r.search ? r.path = "/" + r.search : r.path = null, r.href = r.format(), r;
          for (var P = T.slice(-1)[0], k = (r.host || t.host || T.length > 1) && ("." === P || ".." === P) || "" === P, x = 0, I = T.length; I >= 0; I--) "." === (P = T[I]) ? T.splice(I, 1) : ".." === P ? (T.splice(I, 1), x++) : x && (T.splice(I, 1), x--);
          if (!w && !A)
            for (; x--; x) T.unshift("..");
          w && "" !== T[0] && (!T[0] || "/" !== T[0].charAt(0)) && T.unshift(""), k && "/" !== T.join("/").substr(-1) && T.push("");
          var S, O = "" === T[0] || T[0] && "/" === T[0].charAt(0);
          return E && (r.hostname = O ? "" : T.length ? T.shift() : "", r.host = r.hostname, (S = !(!r.host || 0 >= r.host.indexOf("@")) && r.host.split("@")) && (r.auth = S.shift(), r.hostname = S.shift(), r.host = r.hostname)), (w = w || r.host && T.length) && !O && T.unshift(""), T.length > 0 ? r.pathname = T.join("/") : (r.pathname = null, r.path = null), (null !== r.pathname || null !== r.search) && (r.path = (r.pathname ? r.pathname : "") + (r.search ? r.search : "")), r.auth = t.auth || r.auth, r.slashes = r.slashes || t.slashes, r.href = r.format(), r
        }, i.prototype.parseHost = function() {
          var t = this.host,
            e = s.exec(t);
          e && (":" !== (e = e[0]) && (this.port = e.substr(1)), t = t.substr(0, t.length - e.length)), t && (this.hostname = t)
        }, e.parse = g, e.resolve = function(t, e) {
          return g(t, !1, !0).resolve(e)
        }, e.resolveObject = function(t, e) {
          return t ? g(t, !1, !0).resolveObject(e) : e
        }, e.format = function(t) {
          return "string" == typeof t && (t = g(t)), t instanceof i ? t.format() : i.prototype.format.call(t)
        }, e.Url = i
      },
      88947: (t, e, r) => {
        ! function(t) {
          "use strict";
          var e = function(t) {
              var e, r = new Float64Array(16);
              if (t)
                for (e = 0; e < t.length; e++) r[e] = t[e];
              return r
            },
            n = function() {
              throw Error("no PRNG")
            },
            i = new Uint8Array(16),
            o = new Uint8Array(32);
          o[0] = 9;
          var s = e(),
            a = e([1]),
            u = e([56129, 1]),
            c = e([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]),
            f = e([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]),
            l = e([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]),
            h = e([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]),
            d = e([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);

          function p(t, e, r, n) {
            t[e] = r >> 24 & 255, t[e + 1] = r >> 16 & 255, t[e + 2] = r >> 8 & 255, t[e + 3] = 255 & r, t[e + 4] = n >> 24 & 255, t[e + 5] = n >> 16 & 255, t[e + 6] = n >> 8 & 255, t[e + 7] = 255 & n
          }

          function b(t, e, r, n, i) {
            var o, s = 0;
            for (o = 0; i > o; o++) s |= t[e + o] ^ r[n + o];
            return (1 & s - 1 >>> 8) - 1
          }

          function m(t, e, r, n) {
            return b(t, e, r, n, 16)
          }

          function y(t, e, r, n) {
            return b(t, e, r, n, 32)
          }

          function g(t, e, r, n) {
            ! function(t, e, r, n) {
              for (var i, o = 255 & n[0] | (255 & n[1]) << 8 | (255 & n[2]) << 16 | (255 & n[3]) << 24, s = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, a = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, u = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, c = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, f = 255 & n[4] | (255 & n[5]) << 8 | (255 & n[6]) << 16 | (255 & n[7]) << 24, l = 255 & e[0] | (255 & e[1]) << 8 | (255 & e[2]) << 16 | (255 & e[3]) << 24, h = 255 & e[4] | (255 & e[5]) << 8 | (255 & e[6]) << 16 | (255 & e[7]) << 24, d = 255 & e[8] | (255 & e[9]) << 8 | (255 & e[10]) << 16 | (255 & e[11]) << 24, p = 255 & e[12] | (255 & e[13]) << 8 | (255 & e[14]) << 16 | (255 & e[15]) << 24, b = 255 & n[8] | (255 & n[9]) << 8 | (255 & n[10]) << 16 | (255 & n[11]) << 24, m = 255 & r[16] | (255 & r[17]) << 8 | (255 & r[18]) << 16 | (255 & r[19]) << 24, y = 255 & r[20] | (255 & r[21]) << 8 | (255 & r[22]) << 16 | (255 & r[23]) << 24, g = 255 & r[24] | (255 & r[25]) << 8 | (255 & r[26]) << 16 | (255 & r[27]) << 24, v = 255 & r[28] | (255 & r[29]) << 8 | (255 & r[30]) << 16 | (255 & r[31]) << 24, w = 255 & n[12] | (255 & n[13]) << 8 | (255 & n[14]) << 16 | (255 & n[15]) << 24, A = o, T = s, E = a, P = u, k = c, x = f, I = l, S = h, O = d, B = p, W = b, M = m, C = y, R = g, N = v, j = w, _ = 0; 20 > _; _ += 2) A ^= (i = (C ^= (i = (O ^= (i = (k ^= (i = A + C | 0) << 7 | i >>> 25) + A | 0) << 9 | i >>> 23) + k | 0) << 13 | i >>> 19) + O | 0) << 18 | i >>> 14, x ^= (i = (T ^= (i = (R ^= (i = (B ^= (i = x + T | 0) << 7 | i >>> 25) + x | 0) << 9 | i >>> 23) + B | 0) << 13 | i >>> 19) + R | 0) << 18 | i >>> 14, W ^= (i = (I ^= (i = (E ^= (i = (N ^= (i = W + I | 0) << 7 | i >>> 25) + W | 0) << 9 | i >>> 23) + N | 0) << 13 | i >>> 19) + E | 0) << 18 | i >>> 14, j ^= (i = (M ^= (i = (S ^= (i = (P ^= (i = j + M | 0) << 7 | i >>> 25) + j | 0) << 9 | i >>> 23) + P | 0) << 13 | i >>> 19) + S | 0) << 18 | i >>> 14, A ^= (i = (P ^= (i = (E ^= (i = (T ^= (i = A + P | 0) << 7 | i >>> 25) + A | 0) << 9 | i >>> 23) + T | 0) << 13 | i >>> 19) + E | 0) << 18 | i >>> 14, x ^= (i = (k ^= (i = (S ^= (i = (I ^= (i = x + k | 0) << 7 | i >>> 25) + x | 0) << 9 | i >>> 23) + I | 0) << 13 | i >>> 19) + S | 0) << 18 | i >>> 14, W ^= (i = (B ^= (i = (O ^= (i = (M ^= (i = W + B | 0) << 7 | i >>> 25) + W | 0) << 9 | i >>> 23) + M | 0) << 13 | i >>> 19) + O | 0) << 18 | i >>> 14, j ^= (i = (N ^= (i = (R ^= (i = (C ^= (i = j + N | 0) << 7 | i >>> 25) + j | 0) << 9 | i >>> 23) + C | 0) << 13 | i >>> 19) + R | 0) << 18 | i >>> 14;
              A = A + o | 0, T = T + s | 0, E = E + a | 0, P = P + u | 0, k = k + c | 0, x = x + f | 0, I = I + l | 0, S = S + h | 0, O = O + d | 0, B = B + p | 0, W = W + b | 0, M = M + m | 0, C = C + y | 0, R = R + g | 0, N = N + v | 0, j = j + w | 0, t[0] = A >>> 0 & 255, t[1] = A >>> 8 & 255, t[2] = A >>> 16 & 255, t[3] = A >>> 24 & 255, t[4] = T >>> 0 & 255, t[5] = T >>> 8 & 255, t[6] = T >>> 16 & 255, t[7] = T >>> 24 & 255, t[8] = E >>> 0 & 255, t[9] = E >>> 8 & 255, t[10] = E >>> 16 & 255, t[11] = E >>> 24 & 255, t[12] = P >>> 0 & 255, t[13] = P >>> 8 & 255, t[14] = P >>> 16 & 255, t[15] = P >>> 24 & 255, t[16] = k >>> 0 & 255, t[17] = k >>> 8 & 255, t[18] = k >>> 16 & 255, t[19] = k >>> 24 & 255, t[20] = x >>> 0 & 255, t[21] = x >>> 8 & 255, t[22] = x >>> 16 & 255, t[23] = x >>> 24 & 255, t[24] = I >>> 0 & 255, t[25] = I >>> 8 & 255, t[26] = I >>> 16 & 255, t[27] = I >>> 24 & 255, t[28] = S >>> 0 & 255, t[29] = S >>> 8 & 255, t[30] = S >>> 16 & 255, t[31] = S >>> 24 & 255, t[32] = O >>> 0 & 255, t[33] = O >>> 8 & 255, t[34] = O >>> 16 & 255, t[35] = O >>> 24 & 255, t[36] = B >>> 0 & 255, t[37] = B >>> 8 & 255, t[38] = B >>> 16 & 255, t[39] = B >>> 24 & 255, t[40] = W >>> 0 & 255, t[41] = W >>> 8 & 255, t[42] = W >>> 16 & 255, t[43] = W >>> 24 & 255, t[44] = M >>> 0 & 255, t[45] = M >>> 8 & 255, t[46] = M >>> 16 & 255, t[47] = M >>> 24 & 255, t[48] = C >>> 0 & 255, t[49] = C >>> 8 & 255, t[50] = C >>> 16 & 255, t[51] = C >>> 24 & 255, t[52] = R >>> 0 & 255, t[53] = R >>> 8 & 255, t[54] = R >>> 16 & 255, t[55] = R >>> 24 & 255, t[56] = N >>> 0 & 255, t[57] = N >>> 8 & 255, t[58] = N >>> 16 & 255, t[59] = N >>> 24 & 255, t[60] = j >>> 0 & 255, t[61] = j >>> 8 & 255, t[62] = j >>> 16 & 255, t[63] = j >>> 24 & 255
            }(t, e, r, n)
          }

          function v(t, e, r, n) {
            ! function(t, e, r, n) {
              for (var i, o = 255 & n[0] | (255 & n[1]) << 8 | (255 & n[2]) << 16 | (255 & n[3]) << 24, s = 255 & r[0] | (255 & r[1]) << 8 | (255 & r[2]) << 16 | (255 & r[3]) << 24, a = 255 & r[4] | (255 & r[5]) << 8 | (255 & r[6]) << 16 | (255 & r[7]) << 24, u = 255 & r[8] | (255 & r[9]) << 8 | (255 & r[10]) << 16 | (255 & r[11]) << 24, c = 255 & r[12] | (255 & r[13]) << 8 | (255 & r[14]) << 16 | (255 & r[15]) << 24, f = 255 & n[4] | (255 & n[5]) << 8 | (255 & n[6]) << 16 | (255 & n[7]) << 24, l = 255 & e[0] | (255 & e[1]) << 8 | (255 & e[2]) << 16 | (255 & e[3]) << 24, h = 255 & e[4] | (255 & e[5]) << 8 | (255 & e[6]) << 16 | (255 & e[7]) << 24, d = 255 & e[8] | (255 & e[9]) << 8 | (255 & e[10]) << 16 | (255 & e[11]) << 24, p = 255 & e[12] | (255 & e[13]) << 8 | (255 & e[14]) << 16 | (255 & e[15]) << 24, b = 255 & n[8] | (255 & n[9]) << 8 | (255 & n[10]) << 16 | (255 & n[11]) << 24, m = 255 & r[16] | (255 & r[17]) << 8 | (255 & r[18]) << 16 | (255 & r[19]) << 24, y = 255 & r[20] | (255 & r[21]) << 8 | (255 & r[22]) << 16 | (255 & r[23]) << 24, g = 255 & r[24] | (255 & r[25]) << 8 | (255 & r[26]) << 16 | (255 & r[27]) << 24, v = 255 & r[28] | (255 & r[29]) << 8 | (255 & r[30]) << 16 | (255 & r[31]) << 24, w = 255 & n[12] | (255 & n[13]) << 8 | (255 & n[14]) << 16 | (255 & n[15]) << 24, A = 0; 20 > A; A += 2) o ^= (i = (y ^= (i = (d ^= (i = (c ^= (i = o + y | 0) << 7 | i >>> 25) + o | 0) << 9 | i >>> 23) + c | 0) << 13 | i >>> 19) + d | 0) << 18 | i >>> 14, f ^= (i = (s ^= (i = (g ^= (i = (p ^= (i = f + s | 0) << 7 | i >>> 25) + f | 0) << 9 | i >>> 23) + p | 0) << 13 | i >>> 19) + g | 0) << 18 | i >>> 14, b ^= (i = (l ^= (i = (a ^= (i = (v ^= (i = b + l | 0) << 7 | i >>> 25) + b | 0) << 9 | i >>> 23) + v | 0) << 13 | i >>> 19) + a | 0) << 18 | i >>> 14, w ^= (i = (m ^= (i = (h ^= (i = (u ^= (i = w + m | 0) << 7 | i >>> 25) + w | 0) << 9 | i >>> 23) + u | 0) << 13 | i >>> 19) + h | 0) << 18 | i >>> 14, o ^= (i = (u ^= (i = (a ^= (i = (s ^= (i = o + u | 0) << 7 | i >>> 25) + o | 0) << 9 | i >>> 23) + s | 0) << 13 | i >>> 19) + a | 0) << 18 | i >>> 14, f ^= (i = (c ^= (i = (h ^= (i = (l ^= (i = f + c | 0) << 7 | i >>> 25) + f | 0) << 9 | i >>> 23) + l | 0) << 13 | i >>> 19) + h | 0) << 18 | i >>> 14, b ^= (i = (p ^= (i = (d ^= (i = (m ^= (i = b + p | 0) << 7 | i >>> 25) + b | 0) << 9 | i >>> 23) + m | 0) << 13 | i >>> 19) + d | 0) << 18 | i >>> 14, w ^= (i = (v ^= (i = (g ^= (i = (y ^= (i = w + v | 0) << 7 | i >>> 25) + w | 0) << 9 | i >>> 23) + y | 0) << 13 | i >>> 19) + g | 0) << 18 | i >>> 14;
              t[0] = o >>> 0 & 255, t[1] = o >>> 8 & 255, t[2] = o >>> 16 & 255, t[3] = o >>> 24 & 255, t[4] = f >>> 0 & 255, t[5] = f >>> 8 & 255, t[6] = f >>> 16 & 255, t[7] = f >>> 24 & 255, t[8] = b >>> 0 & 255, t[9] = b >>> 8 & 255, t[10] = b >>> 16 & 255, t[11] = b >>> 24 & 255, t[12] = w >>> 0 & 255, t[13] = w >>> 8 & 255, t[14] = w >>> 16 & 255, t[15] = w >>> 24 & 255, t[16] = l >>> 0 & 255, t[17] = l >>> 8 & 255, t[18] = l >>> 16 & 255, t[19] = l >>> 24 & 255, t[20] = h >>> 0 & 255, t[21] = h >>> 8 & 255, t[22] = h >>> 16 & 255, t[23] = h >>> 24 & 255, t[24] = d >>> 0 & 255, t[25] = d >>> 8 & 255, t[26] = d >>> 16 & 255, t[27] = d >>> 24 & 255, t[28] = p >>> 0 & 255, t[29] = p >>> 8 & 255, t[30] = p >>> 16 & 255, t[31] = p >>> 24 & 255
            }(t, e, r, n)
          }
          var w = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);

          function A(t, e, r, n, i, o, s) {
            var a, u, c = new Uint8Array(16),
              f = new Uint8Array(64);
            for (u = 0; 16 > u; u++) c[u] = 0;
            for (u = 0; 8 > u; u++) c[u] = o[u];
            for (; i >= 64;) {
              for (g(f, c, s, w), u = 0; 64 > u; u++) t[e + u] = r[n + u] ^ f[u];
              for (a = 1, u = 8; 16 > u; u++) a = a + (255 & c[u]) | 0, c[u] = 255 & a, a >>>= 8;
              i -= 64, e += 64, n += 64
            }
            if (i > 0)
              for (g(f, c, s, w), u = 0; i > u; u++) t[e + u] = r[n + u] ^ f[u];
            return 0
          }

          function T(t, e, r, n, i) {
            var o, s, a = new Uint8Array(16),
              u = new Uint8Array(64);
            for (s = 0; 16 > s; s++) a[s] = 0;
            for (s = 0; 8 > s; s++) a[s] = n[s];
            for (; r >= 64;) {
              for (g(u, a, i, w), s = 0; 64 > s; s++) t[e + s] = u[s];
              for (o = 1, s = 8; 16 > s; s++) o = o + (255 & a[s]) | 0, a[s] = 255 & o, o >>>= 8;
              r -= 64, e += 64
            }
            if (r > 0)
              for (g(u, a, i, w), s = 0; r > s; s++) t[e + s] = u[s];
            return 0
          }

          function E(t, e, r, n, i) {
            var o = new Uint8Array(32);
            v(o, n, i, w);
            for (var s = new Uint8Array(8), a = 0; 8 > a; a++) s[a] = n[a + 16];
            return T(t, e, r, s, o)
          }

          function P(t, e, r, n, i, o, s) {
            var a = new Uint8Array(32);
            v(a, o, s, w);
            for (var u = new Uint8Array(8), c = 0; 8 > c; c++) u[c] = o[c + 16];
            return A(t, e, r, n, i, u, a)
          }
          var k = function(t) {
            var e, r, n, i, o, s, a, u;
            this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0, e = 255 & t[0] | (255 & t[1]) << 8, this.r[0] = 8191 & e, r = 255 & t[2] | (255 & t[3]) << 8, this.r[1] = 8191 & (e >>> 13 | r << 3), n = 255 & t[4] | (255 & t[5]) << 8, this.r[2] = 7939 & (r >>> 10 | n << 6), i = 255 & t[6] | (255 & t[7]) << 8, this.r[3] = 8191 & (n >>> 7 | i << 9), o = 255 & t[8] | (255 & t[9]) << 8, this.r[4] = 255 & (i >>> 4 | o << 12), this.r[5] = o >>> 1 & 8190, s = 255 & t[10] | (255 & t[11]) << 8, this.r[6] = 8191 & (o >>> 14 | s << 2), a = 255 & t[12] | (255 & t[13]) << 8, this.r[7] = 8065 & (s >>> 11 | a << 5), u = 255 & t[14] | (255 & t[15]) << 8, this.r[8] = 8191 & (a >>> 8 | u << 8), this.r[9] = u >>> 5 & 127, this.pad[0] = 255 & t[16] | (255 & t[17]) << 8, this.pad[1] = 255 & t[18] | (255 & t[19]) << 8, this.pad[2] = 255 & t[20] | (255 & t[21]) << 8, this.pad[3] = 255 & t[22] | (255 & t[23]) << 8, this.pad[4] = 255 & t[24] | (255 & t[25]) << 8, this.pad[5] = 255 & t[26] | (255 & t[27]) << 8, this.pad[6] = 255 & t[28] | (255 & t[29]) << 8, this.pad[7] = 255 & t[30] | (255 & t[31]) << 8
          };

          function x(t, e, r, n, i, o) {
            var s = new k(o);
            return s.update(r, n, i), s.finish(t, e), 0
          }

          function I(t, e, r, n, i, o) {
            var s = new Uint8Array(16);
            return x(s, 0, r, n, i, o), m(t, e, s, 0)
          }

          function S(t, e, r, n, i) {
            var o;
            if (32 > r) return -1;
            for (P(t, 0, e, 0, r, n, i), x(t, 16, t, 32, r - 32, t), o = 0; 16 > o; o++) t[o] = 0;
            return 0
          }

          function O(t, e, r, n, i) {
            var o, s = new Uint8Array(32);
            if (32 > r || (E(s, 0, 32, n, i), 0 !== I(e, 16, e, 32, r - 32, s))) return -1;
            for (P(t, 0, e, 0, r, n, i), o = 0; 32 > o; o++) t[o] = 0;
            return 0
          }

          function B(t, e) {
            var r;
            for (r = 0; 16 > r; r++) t[r] = 0 | e[r]
          }

          function W(t) {
            var e, r, n = 1;
            for (e = 0; 16 > e; e++) r = t[e] + n + 65535, n = Math.floor(r / 65536), t[e] = r - 65536 * n;
            t[0] += n - 1 + 37 * (n - 1)
          }

          function M(t, e, r) {
            for (var n, i = ~(r - 1), o = 0; 16 > o; o++) n = i & (t[o] ^ e[o]), t[o] ^= n, e[o] ^= n
          }

          function C(t, r) {
            var n, i, o, s = e(),
              a = e();
            for (n = 0; 16 > n; n++) a[n] = r[n];
            for (W(a), W(a), W(a), i = 0; 2 > i; i++) {
              for (s[0] = a[0] - 65517, n = 1; 15 > n; n++) s[n] = a[n] - 65535 - (s[n - 1] >> 16 & 1), s[n - 1] &= 65535;
              s[15] = a[15] - 32767 - (s[14] >> 16 & 1), o = s[15] >> 16 & 1, s[14] &= 65535, M(a, s, 1 - o)
            }
            for (n = 0; 16 > n; n++) t[2 * n] = 255 & a[n], t[2 * n + 1] = a[n] >> 8
          }

          function R(t, e) {
            var r = new Uint8Array(32),
              n = new Uint8Array(32);
            return C(r, t), C(n, e), y(r, 0, n, 0)
          }

          function N(t) {
            var e = new Uint8Array(32);
            return C(e, t), 1 & e[0]
          }

          function j(t, e) {
            var r;
            for (r = 0; 16 > r; r++) t[r] = e[2 * r] + (e[2 * r + 1] << 8);
            t[15] &= 32767
          }

          function _(t, e, r) {
            for (var n = 0; 16 > n; n++) t[n] = e[n] + r[n]
          }

          function D(t, e, r) {
            for (var n = 0; 16 > n; n++) t[n] = e[n] - r[n]
          }

          function U(t, e, r) {
            var n, i, o = 0,
              s = 0,
              a = 0,
              u = 0,
              c = 0,
              f = 0,
              l = 0,
              h = 0,
              d = 0,
              p = 0,
              b = 0,
              m = 0,
              y = 0,
              g = 0,
              v = 0,
              w = 0,
              A = 0,
              T = 0,
              E = 0,
              P = 0,
              k = 0,
              x = 0,
              I = 0,
              S = 0,
              O = 0,
              B = 0,
              W = 0,
              M = 0,
              C = 0,
              R = 0,
              N = 0,
              j = r[0],
              _ = r[1],
              D = r[2],
              U = r[3],
              L = r[4],
              F = r[5],
              $ = r[6],
              z = r[7],
              H = r[8],
              G = r[9],
              K = r[10],
              V = r[11],
              Z = r[12],
              q = r[13],
              J = r[14],
              Y = r[15];
            o += (n = e[0]) * j, s += n * _, a += n * D, u += n * U, c += n * L, f += n * F, l += n * $, h += n * z, d += n * H, p += n * G, b += n * K, m += n * V, y += n * Z, g += n * q, v += n * J, w += n * Y, s += (n = e[1]) * j, a += n * _, u += n * D, c += n * U, f += n * L, l += n * F, h += n * $, d += n * z, p += n * H, b += n * G, m += n * K, y += n * V, g += n * Z, v += n * q, w += n * J, A += n * Y, a += (n = e[2]) * j, u += n * _, c += n * D, f += n * U, l += n * L, h += n * F, d += n * $, p += n * z, b += n * H, m += n * G, y += n * K, g += n * V, v += n * Z, w += n * q, A += n * J, T += n * Y, u += (n = e[3]) * j, c += n * _, f += n * D, l += n * U, h += n * L, d += n * F, p += n * $, b += n * z, m += n * H, y += n * G, g += n * K, v += n * V, w += n * Z, A += n * q, T += n * J, E += n * Y, c += (n = e[4]) * j, f += n * _, l += n * D, h += n * U, d += n * L, p += n * F, b += n * $, m += n * z, y += n * H, g += n * G, v += n * K, w += n * V, A += n * Z, T += n * q, E += n * J, P += n * Y, f += (n = e[5]) * j, l += n * _, h += n * D, d += n * U, p += n * L, b += n * F, m += n * $, y += n * z, g += n * H, v += n * G, w += n * K, A += n * V, T += n * Z, E += n * q, P += n * J, k += n * Y, l += (n = e[6]) * j, h += n * _, d += n * D, p += n * U, b += n * L, m += n * F, y += n * $, g += n * z, v += n * H, w += n * G, A += n * K, T += n * V, E += n * Z, P += n * q, k += n * J, x += n * Y, h += (n = e[7]) * j, d += n * _, p += n * D, b += n * U, m += n * L, y += n * F, g += n * $, v += n * z, w += n * H, A += n * G, T += n * K, E += n * V, P += n * Z, k += n * q, x += n * J, I += n * Y, d += (n = e[8]) * j, p += n * _, b += n * D, m += n * U, y += n * L, g += n * F, v += n * $, w += n * z, A += n * H, T += n * G, E += n * K, P += n * V, k += n * Z, x += n * q, I += n * J, S += n * Y, p += (n = e[9]) * j, b += n * _, m += n * D, y += n * U, g += n * L, v += n * F, w += n * $, A += n * z, T += n * H, E += n * G, P += n * K, k += n * V, x += n * Z, I += n * q, S += n * J, O += n * Y, b += (n = e[10]) * j, m += n * _, y += n * D, g += n * U, v += n * L, w += n * F, A += n * $, T += n * z, E += n * H, P += n * G, k += n * K, x += n * V, I += n * Z, S += n * q, O += n * J, B += n * Y, m += (n = e[11]) * j, y += n * _, g += n * D, v += n * U, w += n * L, A += n * F, T += n * $, E += n * z, P += n * H, k += n * G, x += n * K, I += n * V, S += n * Z, O += n * q, B += n * J, W += n * Y, y += (n = e[12]) * j, g += n * _, v += n * D, w += n * U, A += n * L, T += n * F, E += n * $, P += n * z, k += n * H, x += n * G, I += n * K, S += n * V, O += n * Z, B += n * q, W += n * J, M += n * Y, g += (n = e[13]) * j, v += n * _, w += n * D, A += n * U, T += n * L, E += n * F, P += n * $, k += n * z, x += n * H, I += n * G, S += n * K, O += n * V, B += n * Z, W += n * q, M += n * J, C += n * Y, v += (n = e[14]) * j, w += n * _, A += n * D, T += n * U, E += n * L, P += n * F, k += n * $, x += n * z, I += n * H, S += n * G, O += n * K, B += n * V, W += n * Z, M += n * q, C += n * J, R += n * Y, w += (n = e[15]) * j, s += 38 * (T += n * D), a += 38 * (E += n * U), u += 38 * (P += n * L), c += 38 * (k += n * F), f += 38 * (x += n * $), l += 38 * (I += n * z), h += 38 * (S += n * H), d += 38 * (O += n * G), p += 38 * (B += n * K), b += 38 * (W += n * V), m += 38 * (M += n * Z), y += 38 * (C += n * q), g += 38 * (R += n * J), v += 38 * (N += n * Y), o = (n = (o += 38 * (A += n * _)) + (i = 1) + 65535) - 65536 * (i = Math.floor(n / 65536)), s = (n = s + i + 65535) - 65536 * (i = Math.floor(n / 65536)), a = (n = a + i + 65535) - 65536 * (i = Math.floor(n / 65536)), u = (n = u + i + 65535) - 65536 * (i = Math.floor(n / 65536)), c = (n = c + i + 65535) - 65536 * (i = Math.floor(n / 65536)), f = (n = f + i + 65535) - 65536 * (i = Math.floor(n / 65536)), l = (n = l + i + 65535) - 65536 * (i = Math.floor(n / 65536)), h = (n = h + i + 65535) - 65536 * (i = Math.floor(n / 65536)), d = (n = d + i + 65535) - 65536 * (i = Math.floor(n / 65536)), p = (n = p + i + 65535) - 65536 * (i = Math.floor(n / 65536)), b = (n = b + i + 65535) - 65536 * (i = Math.floor(n / 65536)), m = (n = m + i + 65535) - 65536 * (i = Math.floor(n / 65536)), y = (n = y + i + 65535) - 65536 * (i = Math.floor(n / 65536)), g = (n = g + i + 65535) - 65536 * (i = Math.floor(n / 65536)), v = (n = v + i + 65535) - 65536 * (i = Math.floor(n / 65536)), w = (n = w + i + 65535) - 65536 * (i = Math.floor(n / 65536)), o = (n = (o += i - 1 + 37 * (i - 1)) + (i = 1) + 65535) - 65536 * (i = Math.floor(n / 65536)), s = (n = s + i + 65535) - 65536 * (i = Math.floor(n / 65536)), a = (n = a + i + 65535) - 65536 * (i = Math.floor(n / 65536)), u = (n = u + i + 65535) - 65536 * (i = Math.floor(n / 65536)), c = (n = c + i + 65535) - 65536 * (i = Math.floor(n / 65536)), f = (n = f + i + 65535) - 65536 * (i = Math.floor(n / 65536)), l = (n = l + i + 65535) - 65536 * (i = Math.floor(n / 65536)), h = (n = h + i + 65535) - 65536 * (i = Math.floor(n / 65536)), d = (n = d + i + 65535) - 65536 * (i = Math.floor(n / 65536)), p = (n = p + i + 65535) - 65536 * (i = Math.floor(n / 65536)), b = (n = b + i + 65535) - 65536 * (i = Math.floor(n / 65536)), m = (n = m + i + 65535) - 65536 * (i = Math.floor(n / 65536)), y = (n = y + i + 65535) - 65536 * (i = Math.floor(n / 65536)), g = (n = g + i + 65535) - 65536 * (i = Math.floor(n / 65536)), v = (n = v + i + 65535) - 65536 * (i = Math.floor(n / 65536)), w = (n = w + i + 65535) - 65536 * (i = Math.floor(n / 65536)), o += i - 1 + 37 * (i - 1), t[0] = o, t[1] = s, t[2] = a, t[3] = u, t[4] = c, t[5] = f, t[6] = l, t[7] = h, t[8] = d, t[9] = p, t[10] = b, t[11] = m, t[12] = y, t[13] = g, t[14] = v, t[15] = w
          }

          function L(t, e) {
            U(t, e, e)
          }

          function F(t, r) {
            var n, i = e();
            for (n = 0; 16 > n; n++) i[n] = r[n];
            for (n = 253; n >= 0; n--) L(i, i), 2 !== n && 4 !== n && U(i, i, r);
            for (n = 0; 16 > n; n++) t[n] = i[n]
          }

          function $(t, r) {
            var n, i = e();
            for (n = 0; 16 > n; n++) i[n] = r[n];
            for (n = 250; n >= 0; n--) L(i, i), 1 !== n && U(i, i, r);
            for (n = 0; 16 > n; n++) t[n] = i[n]
          }

          function z(t, r, n) {
            var i, o, s = new Uint8Array(32),
              a = new Float64Array(80),
              c = e(),
              f = e(),
              l = e(),
              h = e(),
              d = e(),
              p = e();
            for (o = 0; 31 > o; o++) s[o] = r[o];
            for (s[31] = 127 & r[31] | 64, s[0] &= 248, j(a, n), o = 0; 16 > o; o++) f[o] = a[o], h[o] = c[o] = l[o] = 0;
            for (c[0] = h[0] = 1, o = 254; o >= 0; --o) M(c, f, i = s[o >>> 3] >>> (7 & o) & 1), M(l, h, i), _(d, c, l), D(c, c, l), _(l, f, h), D(f, f, h), L(h, d), L(p, c), U(c, l, c), U(l, f, d), _(d, c, l), D(c, c, l), L(f, c), D(l, h, p), U(c, l, u), _(c, c, h), U(l, l, c), U(c, h, p), U(h, f, a), L(f, d), M(c, f, i), M(l, h, i);
            for (o = 0; 16 > o; o++) a[o + 16] = c[o], a[o + 32] = l[o], a[o + 48] = f[o], a[o + 64] = h[o];
            var b = a.subarray(32),
              m = a.subarray(16);
            return F(b, b), U(m, m, b), C(t, m), 0
          }

          function H(t, e) {
            return z(t, e, o)
          }

          function G(t, e) {
            return n(e, 32), H(t, e)
          }

          function K(t, e, r) {
            var n = new Uint8Array(32);
            return z(n, r, e), v(t, i, n, w)
          }
          k.prototype.blocks = function(t, e, r) {
            for (var n, i, o, s, a, u, c, f, l, h, d, p, b, m, y, g, v, w, A, T = this.fin ? 0 : 2048, E = this.h[0], P = this.h[1], k = this.h[2], x = this.h[3], I = this.h[4], S = this.h[5], O = this.h[6], B = this.h[7], W = this.h[8], M = this.h[9], C = this.r[0], R = this.r[1], N = this.r[2], j = this.r[3], _ = this.r[4], D = this.r[5], U = this.r[6], L = this.r[7], F = this.r[8], $ = this.r[9]; r >= 16;) h = l = 0, h += (E += 8191 & (n = 255 & t[e + 0] | (255 & t[e + 1]) << 8)) * C, h += 5 * (P += 8191 & (n >>> 13 | (i = 255 & t[e + 2] | (255 & t[e + 3]) << 8) << 3)) * $, h += 5 * (k += 8191 & (i >>> 10 | (o = 255 & t[e + 4] | (255 & t[e + 5]) << 8) << 6)) * F, h += 5 * (x += 8191 & (o >>> 7 | (s = 255 & t[e + 6] | (255 & t[e + 7]) << 8) << 9)) * L, l = (h += 5 * (I += 8191 & (s >>> 4 | (a = 255 & t[e + 8] | (255 & t[e + 9]) << 8) << 12)) * U) >>> 13, h &= 8191, h += 5 * (S += a >>> 1 & 8191) * D, h += 5 * (O += 8191 & (a >>> 14 | (u = 255 & t[e + 10] | (255 & t[e + 11]) << 8) << 2)) * _, h += 5 * (B += 8191 & (u >>> 11 | (c = 255 & t[e + 12] | (255 & t[e + 13]) << 8) << 5)) * j, h += 5 * (W += 8191 & (c >>> 8 | (f = 255 & t[e + 14] | (255 & t[e + 15]) << 8) << 8)) * N, d = l += (h += 5 * (M += f >>> 5 | T) * R) >>> 13, d += E * R, d += P * C, d += 5 * k * $, d += 5 * x * F, l = (d += 5 * I * L) >>> 13, d &= 8191, d += 5 * S * U, d += 5 * O * D, d += 5 * B * _, d += 5 * W * j, l += (d += 5 * M * N) >>> 13, d &= 8191, p = l, p += E * N, p += P * R, p += k * C, p += 5 * x * $, l = (p += 5 * I * F) >>> 13, p &= 8191, p += 5 * S * L, p += 5 * O * U, p += 5 * B * D, p += 5 * W * _, b = l += (p += 5 * M * j) >>> 13, b += E * j, b += P * N, b += k * R, b += x * C, l = (b += 5 * I * $) >>> 13, b &= 8191, b += 5 * S * F, b += 5 * O * L, b += 5 * B * U, b += 5 * W * D, m = l += (b += 5 * M * _) >>> 13, m += E * _, m += P * j, m += k * N, m += x * R, l = (m += I * C) >>> 13, m &= 8191, m += 5 * S * $, m += 5 * O * F, m += 5 * B * L, m += 5 * W * U, y = l += (m += 5 * M * D) >>> 13, y += E * D, y += P * _, y += k * j, y += x * N, l = (y += I * R) >>> 13, y &= 8191, y += S * C, y += 5 * O * $, y += 5 * B * F, y += 5 * W * L, g = l += (y += 5 * M * U) >>> 13, g += E * U, g += P * D, g += k * _, g += x * j, l = (g += I * N) >>> 13, g &= 8191, g += S * R, g += O * C, g += 5 * B * $, g += 5 * W * F, v = l += (g += 5 * M * L) >>> 13, v += E * L, v += P * U, v += k * D, v += x * _, l = (v += I * j) >>> 13, v &= 8191, v += S * N, v += O * R, v += B * C, v += 5 * W * $, w = l += (v += 5 * M * F) >>> 13, w += E * F, w += P * L, w += k * U, w += x * D, l = (w += I * _) >>> 13, w &= 8191, w += S * j, w += O * N, w += B * R, w += W * C, A = l += (w += 5 * M * $) >>> 13, A += E * $, A += P * F, A += k * L, A += x * U, l = (A += I * D) >>> 13, A &= 8191, A += S * _, A += O * j, A += B * N, A += W * R, E = h = 8191 & (l = (l = ((l += (A += M * C) >>> 13) << 2) + l | 0) + (h &= 8191) | 0), P = d += l >>>= 13, k = p &= 8191, x = b &= 8191, I = m &= 8191, S = y &= 8191, O = g &= 8191, B = v &= 8191, W = w &= 8191, M = A &= 8191, e += 16, r -= 16;
            this.h[0] = E, this.h[1] = P, this.h[2] = k, this.h[3] = x, this.h[4] = I, this.h[5] = S, this.h[6] = O, this.h[7] = B, this.h[8] = W, this.h[9] = M
          }, k.prototype.finish = function(t, e) {
            var r, n, i, o, s = new Uint16Array(10);
            if (this.leftover) {
              for (o = this.leftover, this.buffer[o++] = 1; 16 > o; o++) this.buffer[o] = 0;
              this.fin = 1, this.blocks(this.buffer, 0, 16)
            }
            for (r = this.h[1] >>> 13, this.h[1] &= 8191, o = 2; 10 > o; o++) this.h[o] += r, r = this.h[o] >>> 13, this.h[o] &= 8191;
            for (this.h[0] += 5 * r, r = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += r, r = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += r, s[0] = this.h[0] + 5, r = s[0] >>> 13, s[0] &= 8191, o = 1; 10 > o; o++) s[o] = this.h[o] + r, r = s[o] >>> 13, s[o] &= 8191;
            for (s[9] -= 8192, n = (1 ^ r) - 1, o = 0; 10 > o; o++) s[o] &= n;
            for (n = ~n, o = 0; 10 > o; o++) this.h[o] = this.h[o] & n | s[o];
            for (this.h[0] = 65535 & (this.h[0] | this.h[1] << 13), this.h[1] = 65535 & (this.h[1] >>> 3 | this.h[2] << 10), this.h[2] = 65535 & (this.h[2] >>> 6 | this.h[3] << 7), this.h[3] = 65535 & (this.h[3] >>> 9 | this.h[4] << 4), this.h[4] = 65535 & (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14), this.h[5] = 65535 & (this.h[6] >>> 2 | this.h[7] << 11), this.h[6] = 65535 & (this.h[7] >>> 5 | this.h[8] << 8), this.h[7] = 65535 & (this.h[8] >>> 8 | this.h[9] << 5), i = this.h[0] + this.pad[0], this.h[0] = 65535 & i, o = 1; 8 > o; o++) i = (this.h[o] + this.pad[o] | 0) + (i >>> 16) | 0, this.h[o] = 65535 & i;
            t[e + 0] = this.h[0] >>> 0 & 255, t[e + 1] = this.h[0] >>> 8 & 255, t[e + 2] = this.h[1] >>> 0 & 255, t[e + 3] = this.h[1] >>> 8 & 255, t[e + 4] = this.h[2] >>> 0 & 255, t[e + 5] = this.h[2] >>> 8 & 255, t[e + 6] = this.h[3] >>> 0 & 255, t[e + 7] = this.h[3] >>> 8 & 255, t[e + 8] = this.h[4] >>> 0 & 255, t[e + 9] = this.h[4] >>> 8 & 255, t[e + 10] = this.h[5] >>> 0 & 255, t[e + 11] = this.h[5] >>> 8 & 255, t[e + 12] = this.h[6] >>> 0 & 255, t[e + 13] = this.h[6] >>> 8 & 255, t[e + 14] = this.h[7] >>> 0 & 255, t[e + 15] = this.h[7] >>> 8 & 255
          }, k.prototype.update = function(t, e, r) {
            var n, i;
            if (this.leftover) {
              for ((i = 16 - this.leftover) > r && (i = r), n = 0; i > n; n++) this.buffer[this.leftover + n] = t[e + n];
              if (r -= i, e += i, this.leftover += i, 16 > this.leftover) return;
              this.blocks(this.buffer, 0, 16), this.leftover = 0
            }
            if (r >= 16 && (i = r - r % 16, this.blocks(t, e, i), e += i, r -= i), r) {
              for (n = 0; r > n; n++) this.buffer[this.leftover + n] = t[e + n];
              this.leftover += r
            }
          };
          var V = S,
            Z = O,
            q = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

          function J(t, e, r, n) {
            for (var i, o, s, a, u, c, f, l, h, d, p, b, m, y, g, v, w, A, T, E, P, k, x, I, S, O, B = new Int32Array(16), W = new Int32Array(16), M = t[0], C = t[1], R = t[2], N = t[3], j = t[4], _ = t[5], D = t[6], U = t[7], L = e[0], F = e[1], $ = e[2], z = e[3], H = e[4], G = e[5], K = e[6], V = e[7], Z = 0; n >= 128;) {
              for (T = 0; 16 > T; T++) E = 8 * T + Z, B[T] = r[E + 0] << 24 | r[E + 1] << 16 | r[E + 2] << 8 | r[E + 3], W[T] = r[E + 4] << 24 | r[E + 5] << 16 | r[E + 6] << 8 | r[E + 7];
              for (T = 0; 80 > T; T++)
                if (i = M, o = C, s = R, a = N, u = j, c = _, f = D, h = L, d = F, p = $, b = z, m = H, y = G, g = K, x = 65535 & (k = V), I = k >>> 16, S = 65535 & (P = U), O = P >>> 16, x += 65535 & (k = (H >>> 14 | j << 18) ^ (H >>> 18 | j << 14) ^ (j >>> 9 | H << 23)), I += k >>> 16, S += 65535 & (P = (j >>> 14 | H << 18) ^ (j >>> 18 | H << 14) ^ (H >>> 9 | j << 23)), O += P >>> 16, x += 65535 & (k = H & G ^ ~H & K), I += k >>> 16, S += 65535 & (P = j & _ ^ ~j & D), O += P >>> 16, x += 65535 & (k = q[2 * T + 1]), I += k >>> 16, S += 65535 & (P = q[2 * T]), O += P >>> 16, P = B[T % 16], I += (k = W[T % 16]) >>> 16, S += 65535 & P, O += P >>> 16, S += (I += (x += 65535 & k) >>> 16) >>> 16, x = 65535 & (k = A = 65535 & x | I << 16), I = k >>> 16, S = 65535 & (P = w = 65535 & S | (O += S >>> 16) << 16), O = P >>> 16, x += 65535 & (k = (L >>> 28 | M << 4) ^ (M >>> 2 | L << 30) ^ (M >>> 7 | L << 25)), I += k >>> 16, S += 65535 & (P = (M >>> 28 | L << 4) ^ (L >>> 2 | M << 30) ^ (L >>> 7 | M << 25)), O += P >>> 16, I += (k = L & F ^ L & $ ^ F & $) >>> 16, S += 65535 & (P = M & C ^ M & R ^ C & R), O += P >>> 16, l = 65535 & (S += (I += (x += 65535 & k) >>> 16) >>> 16) | (O += S >>> 16) << 16, v = 65535 & x | I << 16, x = 65535 & (k = b), I = k >>> 16, S = 65535 & (P = a), O = P >>> 16, I += (k = A) >>> 16, S += 65535 & (P = w), O += P >>> 16, C = i, R = o, N = s, j = a = 65535 & (S += (I += (x += 65535 & k) >>> 16) >>> 16) | (O += S >>> 16) << 16, _ = u, D = c, U = f, M = l, F = h, $ = d, z = p, H = b = 65535 & x | I << 16, G = m, K = y, V = g, L = v, T % 16 == 15)
                  for (E = 0; 16 > E; E++) P = B[E], x = 65535 & (k = W[E]), I = k >>> 16, S = 65535 & P, O = P >>> 16, P = B[(E + 9) % 16], x += 65535 & (k = W[(E + 9) % 16]), I += k >>> 16, S += 65535 & P, O += P >>> 16, w = B[(E + 1) % 16], x += 65535 & (k = ((A = W[(E + 1) % 16]) >>> 1 | w << 31) ^ (A >>> 8 | w << 24) ^ (A >>> 7 | w << 25)), I += k >>> 16, S += 65535 & (P = (w >>> 1 | A << 31) ^ (w >>> 8 | A << 24) ^ w >>> 7), O += P >>> 16, w = B[(E + 14) % 16], I += (k = ((A = W[(E + 14) % 16]) >>> 19 | w << 13) ^ (w >>> 29 | A << 3) ^ (A >>> 6 | w << 26)) >>> 16, S += 65535 & (P = (w >>> 19 | A << 13) ^ (A >>> 29 | w << 3) ^ w >>> 6), O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, B[E] = 65535 & S | O << 16, W[E] = 65535 & x | I << 16;
              x = 65535 & (k = L), I = k >>> 16, S = 65535 & (P = M), O = P >>> 16, P = t[0], I += (k = e[0]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[0] = M = 65535 & S | O << 16, e[0] = L = 65535 & x | I << 16, x = 65535 & (k = F), I = k >>> 16, S = 65535 & (P = C), O = P >>> 16, P = t[1], I += (k = e[1]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[1] = C = 65535 & S | O << 16, e[1] = F = 65535 & x | I << 16, x = 65535 & (k = $), I = k >>> 16, S = 65535 & (P = R), O = P >>> 16, P = t[2], I += (k = e[2]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[2] = R = 65535 & S | O << 16, e[2] = $ = 65535 & x | I << 16, x = 65535 & (k = z), I = k >>> 16, S = 65535 & (P = N), O = P >>> 16, P = t[3], I += (k = e[3]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[3] = N = 65535 & S | O << 16, e[3] = z = 65535 & x | I << 16, x = 65535 & (k = H), I = k >>> 16, S = 65535 & (P = j), O = P >>> 16, P = t[4], I += (k = e[4]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[4] = j = 65535 & S | O << 16, e[4] = H = 65535 & x | I << 16, x = 65535 & (k = G), I = k >>> 16, S = 65535 & (P = _), O = P >>> 16, P = t[5], I += (k = e[5]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[5] = _ = 65535 & S | O << 16, e[5] = G = 65535 & x | I << 16, x = 65535 & (k = K), I = k >>> 16, S = 65535 & (P = D), O = P >>> 16, P = t[6], I += (k = e[6]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[6] = D = 65535 & S | O << 16, e[6] = K = 65535 & x | I << 16, x = 65535 & (k = V), I = k >>> 16, S = 65535 & (P = U), O = P >>> 16, P = t[7], I += (k = e[7]) >>> 16, S += 65535 & P, O += P >>> 16, O += (S += (I += (x += 65535 & k) >>> 16) >>> 16) >>> 16, t[7] = U = 65535 & S | O << 16, e[7] = V = 65535 & x | I << 16, Z += 128, n -= 128
            }
            return n
          }

          function Y(t, e, r) {
            var n, i = new Int32Array(8),
              o = new Int32Array(8),
              s = new Uint8Array(256),
              a = r;
            for (i[0] = 1779033703, i[1] = 3144134277, i[2] = 1013904242, i[3] = 2773480762, i[4] = 1359893119, i[5] = 2600822924, i[6] = 528734635, i[7] = 1541459225, o[0] = 4089235720, o[1] = 2227873595, o[2] = 4271175723, o[3] = 1595750129, o[4] = 2917565137, o[5] = 725511199, o[6] = 4215389547, o[7] = 327033209, J(i, o, e, r), r %= 128, n = 0; r > n; n++) s[n] = e[a - r + n];
            for (s[r] = 128, s[(r = 256 - 128 * (112 > r ? 1 : 0)) - 9] = 0, p(s, r - 8, a / 536870912 | 0, a << 3), J(i, o, s, r), n = 0; 8 > n; n++) p(t, 8 * n, i[n], o[n]);
            return 0
          }

          function Q(t, r) {
            var n = e(),
              i = e(),
              o = e(),
              s = e(),
              a = e(),
              u = e(),
              c = e(),
              l = e(),
              h = e();
            D(n, t[1], t[0]), D(h, r[1], r[0]), U(n, n, h), _(i, t[0], t[1]), _(h, r[0], r[1]), U(i, i, h), U(o, t[3], r[3]), U(o, o, f), U(s, t[2], r[2]), _(s, s, s), D(a, i, n), D(u, s, o), _(c, s, o), _(l, i, n), U(t[0], a, u), U(t[1], l, c), U(t[2], c, u), U(t[3], a, l)
          }

          function X(t, e, r) {
            var n;
            for (n = 0; 4 > n; n++) M(t[n], e[n], r)
          }

          function tt(t, r) {
            var n = e(),
              i = e(),
              o = e();
            F(o, r[2]), U(n, r[0], o), U(i, r[1], o), C(t, i), t[31] ^= N(n) << 7
          }

          function et(t, e, r) {
            var n, i;
            for (B(t[0], s), B(t[1], a), B(t[2], a), B(t[3], s), i = 255; i >= 0; --i) X(t, e, n = r[i / 8 | 0] >> (7 & i) & 1), Q(e, t), Q(t, t), X(t, e, n)
          }

          function rt(t, r) {
            var n = [e(), e(), e(), e()];
            B(n[0], l), B(n[1], h), B(n[2], a), U(n[3], l, h), et(t, n, r)
          }

          function nt(t, r, i) {
            var o, s = new Uint8Array(64),
              a = [e(), e(), e(), e()];
            for (i || n(r, 32), Y(s, r, 32), s[0] &= 248, s[31] &= 127, s[31] |= 64, rt(a, s), tt(t, a), o = 0; 32 > o; o++) r[o + 32] = t[o];
            return 0
          }
          var it = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);

          function ot(t, e) {
            var r, n, i, o;
            for (n = 63; n >= 32; --n) {
              for (r = 0, i = n - 32, o = n - 12; o > i; ++i) e[i] += r - 16 * e[n] * it[i - (n - 32)], r = Math.floor((e[i] + 128) / 256), e[i] -= 256 * r;
              e[i] += r, e[n] = 0
            }
            for (r = 0, i = 0; 32 > i; i++) e[i] += r - (e[31] >> 4) * it[i], r = e[i] >> 8, e[i] &= 255;
            for (i = 0; 32 > i; i++) e[i] -= r * it[i];
            for (n = 0; 32 > n; n++) e[n + 1] += e[n] >> 8, t[n] = 255 & e[n]
          }

          function st(t) {
            var e, r = new Float64Array(64);
            for (e = 0; 64 > e; e++) r[e] = t[e];
            for (e = 0; 64 > e; e++) t[e] = 0;
            ot(t, r)
          }

          function at(t, r, n, i) {
            var o, s, a = new Uint8Array(64),
              u = new Uint8Array(64),
              c = new Uint8Array(64),
              f = new Float64Array(64),
              l = [e(), e(), e(), e()];
            Y(a, i, 32), a[0] &= 248, a[31] &= 127, a[31] |= 64;
            var h = n + 64;
            for (o = 0; n > o; o++) t[64 + o] = r[o];
            for (o = 0; 32 > o; o++) t[32 + o] = a[32 + o];
            for (Y(c, t.subarray(32), n + 32), st(c), rt(l, c), tt(t, l), o = 32; 64 > o; o++) t[o] = i[o];
            for (Y(u, t, n + 64), st(u), o = 0; 64 > o; o++) f[o] = 0;
            for (o = 0; 32 > o; o++) f[o] = c[o];
            for (o = 0; 32 > o; o++)
              for (s = 0; 32 > s; s++) f[o + s] += u[o] * a[s];
            return ot(t.subarray(32), f), h
          }

          function ut(t, r, n, i) {
            var o, u = new Uint8Array(32),
              f = new Uint8Array(64),
              l = [e(), e(), e(), e()],
              h = [e(), e(), e(), e()];
            if (64 > n || function(t, r) {
                var n = e(),
                  i = e(),
                  o = e(),
                  u = e(),
                  f = e(),
                  l = e(),
                  h = e();
                return B(t[2], a), j(t[1], r), L(o, t[1]), U(u, o, c), D(o, o, t[2]), _(u, t[2], u), L(f, u), L(l, f), U(h, l, f), U(n, h, o), U(n, n, u), $(n, n), U(n, n, o), U(n, n, u), U(n, n, u), U(t[0], n, u), L(i, t[0]), U(i, i, u), R(i, o) && U(t[0], t[0], d), L(i, t[0]), U(i, i, u), R(i, o) ? -1 : (N(t[0]) === r[31] >> 7 && D(t[0], s, t[0]), U(t[3], t[0], t[1]), 0)
              }(h, i)) return -1;
            for (o = 0; n > o; o++) t[o] = r[o];
            for (o = 0; 32 > o; o++) t[o + 32] = i[o];
            if (Y(f, t, n), st(f), et(l, h, f), rt(h, r.subarray(32)), Q(l, h), tt(u, l), n -= 64, y(r, 0, u, 0)) {
              for (o = 0; n > o; o++) t[o] = 0;
              return -1
            }
            for (o = 0; n > o; o++) t[o] = r[o + 64];
            return n
          }
          var ct, ft = 64,
            lt = 32,
            ht = 64;

          function dt(t, e) {
            if (32 !== t.length) throw Error("bad key size");
            if (24 !== e.length) throw Error("bad nonce size")
          }

          function pt() {
            for (var t = 0; arguments.length > t; t++)
              if (!(arguments[t] instanceof Uint8Array)) throw new TypeError("unexpected type, use Uint8Array")
          }

          function bt(t) {
            for (var e = 0; e < t.length; e++) t[e] = 0
          }
          t.lowlevel = {
            crypto_core_hsalsa20: v,
            crypto_stream_xor: P,
            crypto_stream: E,
            crypto_stream_salsa20_xor: A,
            crypto_stream_salsa20: T,
            crypto_onetimeauth: x,
            crypto_onetimeauth_verify: I,
            crypto_verify_16: m,
            crypto_verify_32: y,
            crypto_secretbox: S,
            crypto_secretbox_open: O,
            crypto_scalarmult: z,
            crypto_scalarmult_base: H,
            crypto_box_beforenm: K,
            crypto_box_afternm: V,
            crypto_box: function(t, e, r, n, i, o) {
              var s = new Uint8Array(32);
              return K(s, i, o), V(t, e, r, n, s)
            },
            crypto_box_open: function(t, e, r, n, i, o) {
              var s = new Uint8Array(32);
              return K(s, i, o), Z(t, e, r, n, s)
            },
            crypto_box_keypair: G,
            crypto_hash: Y,
            crypto_sign: at,
            crypto_sign_keypair: nt,
            crypto_sign_open: ut,
            crypto_secretbox_KEYBYTES: 32,
            crypto_secretbox_NONCEBYTES: 24,
            crypto_secretbox_ZEROBYTES: 32,
            crypto_secretbox_BOXZEROBYTES: 16,
            crypto_scalarmult_BYTES: 32,
            crypto_scalarmult_SCALARBYTES: 32,
            crypto_box_PUBLICKEYBYTES: 32,
            crypto_box_SECRETKEYBYTES: 32,
            crypto_box_BEFORENMBYTES: 32,
            crypto_box_NONCEBYTES: 24,
            crypto_box_ZEROBYTES: 32,
            crypto_box_BOXZEROBYTES: 16,
            crypto_sign_BYTES: ft,
            crypto_sign_PUBLICKEYBYTES: lt,
            crypto_sign_SECRETKEYBYTES: ht,
            crypto_sign_SEEDBYTES: 32,
            crypto_hash_BYTES: 64,
            gf: e,
            D: c,
            L: it,
            pack25519: C,
            unpack25519: j,
            M: U,
            A: _,
            S: L,
            Z: D,
            pow2523: $,
            add: Q,
            set25519: B,
            modL: ot,
            scalarmult: et,
            scalarbase: rt
          }, t.randomBytes = function(t) {
            var e = new Uint8Array(t);
            return n(e, t), e
          }, t.secretbox = function(t, e, r) {
            pt(t, e, r), dt(r, e);
            for (var n = new Uint8Array(32 + t.length), i = new Uint8Array(n.length), o = 0; o < t.length; o++) n[o + 32] = t[o];
            return S(i, n, n.length, e, r), i.subarray(16)
          }, t.secretbox.open = function(t, e, r) {
            pt(t, e, r), dt(r, e);
            for (var n = new Uint8Array(16 + t.length), i = new Uint8Array(n.length), o = 0; o < t.length; o++) n[o + 16] = t[o];
            return 32 > n.length || 0 !== O(i, n, n.length, e, r) ? null : i.subarray(32)
          }, t.secretbox.keyLength = 32, t.secretbox.nonceLength = 24, t.secretbox.overheadLength = 16, t.scalarMult = function(t, e) {
            if (pt(t, e), 32 !== t.length) throw Error("bad n size");
            if (32 !== e.length) throw Error("bad p size");
            var r = new Uint8Array(32);
            return z(r, t, e), r
          }, t.scalarMult.base = function(t) {
            if (pt(t), 32 !== t.length) throw Error("bad n size");
            var e = new Uint8Array(32);
            return H(e, t), e
          }, t.scalarMult.scalarLength = 32, t.scalarMult.groupElementLength = 32, t.box = function(e, r, n, i) {
            var o = t.box.before(n, i);
            return t.secretbox(e, r, o)
          }, t.box.before = function(t, e) {
            pt(t, e),
              function(t, e) {
                if (32 !== t.length) throw Error("bad public key size");
                if (32 !== e.length) throw Error("bad secret key size")
              }(t, e);
            var r = new Uint8Array(32);
            return K(r, t, e), r
          }, t.box.after = t.secretbox, t.box.open = function(e, r, n, i) {
            var o = t.box.before(n, i);
            return t.secretbox.open(e, r, o)
          }, t.box.open.after = t.secretbox.open, t.box.keyPair = function() {
            var t = new Uint8Array(32),
              e = new Uint8Array(32);
            return G(t, e), {
              publicKey: t,
              secretKey: e
            }
          }, t.box.keyPair.fromSecretKey = function(t) {
            if (pt(t), 32 !== t.length) throw Error("bad secret key size");
            var e = new Uint8Array(32);
            return H(e, t), {
              publicKey: e,
              secretKey: new Uint8Array(t)
            }
          }, t.box.publicKeyLength = 32, t.box.secretKeyLength = 32, t.box.sharedKeyLength = 32, t.box.nonceLength = 24, t.box.overheadLength = t.secretbox.overheadLength, t.sign = function(t, e) {
            if (pt(t, e), e.length !== ht) throw Error("bad secret key size");
            var r = new Uint8Array(ft + t.length);
            return at(r, t, t.length, e), r
          }, t.sign.open = function(t, e) {
            if (pt(t, e), e.length !== lt) throw Error("bad public key size");
            var r = new Uint8Array(t.length),
              n = ut(r, t, t.length, e);
            if (0 > n) return null;
            for (var i = new Uint8Array(n), o = 0; o < i.length; o++) i[o] = r[o];
            return i
          }, t.sign.detached = function(e, r) {
            for (var n = t.sign(e, r), i = new Uint8Array(ft), o = 0; o < i.length; o++) i[o] = n[o];
            return i
          }, t.sign.detached.verify = function(t, e, r) {
            if (pt(t, e, r), e.length !== ft) throw Error("bad signature size");
            if (r.length !== lt) throw Error("bad public key size");
            var n, i = new Uint8Array(ft + t.length),
              o = new Uint8Array(ft + t.length);
            for (n = 0; ft > n; n++) i[n] = e[n];
            for (n = 0; n < t.length; n++) i[n + ft] = t[n];
            return ut(o, i, i.length, r) >= 0
          }, t.sign.keyPair = function() {
            var t = new Uint8Array(lt),
              e = new Uint8Array(ht);
            return nt(t, e), {
              publicKey: t,
              secretKey: e
            }
          }, t.sign.keyPair.fromSecretKey = function(t) {
            if (pt(t), t.length !== ht) throw Error("bad secret key size");
            for (var e = new Uint8Array(lt), r = 0; r < e.length; r++) e[r] = t[32 + r];
            return {
              publicKey: e,
              secretKey: new Uint8Array(t)
            }
          }, t.sign.keyPair.fromSeed = function(t) {
            if (pt(t), 32 !== t.length) throw Error("bad seed size");
            for (var e = new Uint8Array(lt), r = new Uint8Array(ht), n = 0; 32 > n; n++) r[n] = t[n];
            return nt(e, r, !0), {
              publicKey: e,
              secretKey: r
            }
          }, t.sign.publicKeyLength = lt, t.sign.secretKeyLength = ht, t.sign.seedLength = 32, t.sign.signatureLength = ft, t.hash = function(t) {
            pt(t);
            var e = new Uint8Array(64);
            return Y(e, t, t.length), e
          }, t.hash.hashLength = 64, t.verify = function(t, e) {
            return pt(t, e), 0 !== t.length && 0 !== e.length && t.length === e.length && 0 === b(t, 0, e, 0, t.length)
          }, t.setPRNG = function(t) {
            n = t
          }, (ct = "u" > typeof self ? self.crypto || self.msCrypto : null) && ct.getRandomValues ? t.setPRNG(function(t, e) {
            var r, n = new Uint8Array(e);
            for (r = 0; e > r; r += 65536) ct.getRandomValues(n.subarray(r, r + Math.min(e - r, 65536)));
            for (r = 0; e > r; r++) t[r] = n[r];
            bt(n)
          }) : (ct = r(71281)) && ct.randomBytes && t.setPRNG(function(t, e) {
            var r, n = ct.randomBytes(e);
            for (r = 0; e > r; r++) t[r] = n[r];
            bt(n)
          })
        }(t.exports ? t.exports : self.nacl = self.nacl || {})
      },
      88986: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.contractAddress = void 0;
        const n = r(65871),
          i = r(22738),
          o = r(3512);
        e.contractAddress = function(t, e) {
          let r = (0, n.beginCell)().store((0, i.storeStateInit)(e)).endCell().hash();
          return new o.Address(t, r)
        }
      },
      89015: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isNegativeLE = void 0, e.mod = l, e.pow = h, e.pow2 = function(t, e, r) {
          let n = t;
          for (; e-- > i;) n *= n, n %= r;
          return n
        }, e.invert = d, e.tonelliShanks = p, e.FpSqrt = b, e.validateField = function(t) {
          const e = m.reduce((t, e) => (t[e] = "function", t), {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "isSafeInteger",
            BITS: "isSafeInteger"
          });
          return (0, n.validateObject)(t, e)
        }, e.FpPow = y, e.FpInvertBatch = g, e.FpDiv = function(t, e, r) {
          return t.mul(e, "bigint" == typeof r ? d(r, t.ORDER) : t.inv(r))
        }, e.FpIsSquare = function(t) {
          const e = (t.ORDER - o) / s;
          return r => {
            const n = t.pow(r, e);
            return t.eql(n, t.ZERO) || t.eql(n, t.ONE)
          }
        }, e.nLength = v, e.Field = function(t, e, r = !1, s = {}) {
          if (i >= t) throw Error("Expected Field ORDER > 0, got " + t);
          const {
            nBitLength: a,
            nByteLength: u
          } = v(t, e);
          if (u > 2048) throw Error("Field lengths over 2048 bytes are not supported");
          const c = b(t),
            f = Object.freeze({
              ORDER: t,
              BITS: a,
              BYTES: u,
              MASK: (0, n.bitMask)(a),
              ZERO: i,
              ONE: o,
              create: e => l(e, t),
              isValid: e => {
                if ("bigint" != typeof e) throw Error("Invalid field element: expected bigint, got " + typeof e);
                return e >= i && t > e
              },
              is0: t => t === i,
              isOdd: t => (t & o) === o,
              neg: e => l(-e, t),
              eql: (t, e) => t === e,
              sqr: e => l(e * e, t),
              add: (e, r) => l(e + r, t),
              sub: (e, r) => l(e - r, t),
              mul: (e, r) => l(e * r, t),
              pow: (t, e) => y(f, t, e),
              div: (e, r) => l(e * d(r, t), t),
              sqrN: t => t * t,
              addN: (t, e) => t + e,
              subN: (t, e) => t - e,
              mulN: (t, e) => t * e,
              inv: e => d(e, t),
              sqrt: s.sqrt || (t => c(f, t)),
              invertBatch: t => g(f, t),
              cmov: (t, e, r) => r ? e : t,
              toBytes: t => r ? (0, n.numberToBytesLE)(t, u) : (0, n.numberToBytesBE)(t, u),
              fromBytes: t => {
                if (t.length !== u) throw Error(`Fp.fromBytes: expected ${u}, got ${t.length}`);
                return r ? (0, n.bytesToNumberLE)(t) : (0, n.bytesToNumberBE)(t)
              }
            });
          return Object.freeze(f)
        }, e.FpSqrtOdd = function(t, e) {
          if (!t.isOdd) throw Error("Field doesn't have isOdd");
          const r = t.sqrt(e);
          return t.isOdd(r) ? r : t.neg(r)
        }, e.FpSqrtEven = function(t, e) {
          if (!t.isOdd) throw Error("Field doesn't have isOdd");
          const r = t.sqrt(e);
          return t.isOdd(r) ? t.neg(r) : r
        }, e.hashToPrivateScalar = function(t, e, r = !1) {
          const i = (t = (0, n.ensureBytes)("privateHash", t)).length,
            s = v(e).nByteLength + 8;
          if (24 > s || s > i || i > 1024) throw Error(`hashToPrivateScalar: expected ${s}-1024 bytes of input, got ${i}`);
          return l(r ? (0, n.bytesToNumberLE)(t) : (0, n.bytesToNumberBE)(t), e - o) + o
        }, e.getFieldBytesLength = w, e.getMinHashLength = A, e.mapHashToField = function(t, e, r = !1) {
          const i = t.length,
            s = w(e),
            a = A(e);
          if (16 > i || a > i || i > 1024) throw Error(`expected ${a}-1024 bytes of input, got ${i}`);
          const u = l(r ? (0, n.bytesToNumberBE)(t) : (0, n.bytesToNumberLE)(t), e - o) + o;
          return r ? (0, n.numberToBytesLE)(u, s) : (0, n.numberToBytesBE)(u, s)
        };
        const n = r(19372),
          i = BigInt(0),
          o = BigInt(1),
          s = BigInt(2),
          a = BigInt(3),
          u = BigInt(4),
          c = BigInt(5),
          f = BigInt(8);

        function l(t, e) {
          const r = t % e;
          return i > r ? e + r : r
        }

        function h(t, e, r) {
          if (i >= r || i > e) throw Error("Expected power/modulo > 0");
          if (r === o) return i;
          let n = o;
          for (; e > i;) e & o && (n = n * t % r), t = t * t % r, e >>= o;
          return n
        }

        function d(t, e) {
          if (t === i || i >= e) throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);
          let r = l(t, e),
            n = e,
            s = i,
            a = o,
            u = o,
            c = i;
          for (; r !== i;) {
            const t = n / r,
              e = n % r,
              i = s - u * t,
              o = a - c * t;
            n = r, r = e, s = u, a = c, u = i, c = o
          }
          if (n !== o) throw Error("invert: does not exist");
          return l(s, e)
        }

        function p(t) {
          const e = (t - o) / s;
          let r, n, a;
          for (r = t - o, n = 0; r % s === i; r /= s, n++);
          for (a = s; t > a && h(a, e, t) !== t - o; a++);
          if (1 === n) {
            const e = (t + o) / u;
            return function(t, r) {
              const n = t.pow(r, e);
              if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
              return n
            }
          }
          const c = (r + o) / s;
          return function(t, i) {
            if (t.pow(i, e) === t.neg(t.ONE)) throw Error("Cannot find square root");
            let s = n,
              u = t.pow(t.mul(t.ONE, a), r),
              f = t.pow(i, c),
              l = t.pow(i, r);
            for (; !t.eql(l, t.ONE);) {
              if (t.eql(l, t.ZERO)) return t.ZERO;
              let e = 1;
              for (let r = t.sqr(l); s > e && !t.eql(r, t.ONE); e++) r = t.sqr(r);
              const r = t.pow(u, o << BigInt(s - e - 1));
              u = t.sqr(r), f = t.mul(f, r), l = t.mul(l, u), s = e
            }
            return f
          }
        }

        function b(t) {
          if (t % u === a) {
            const e = (t + o) / u;
            return function(t, r) {
              const n = t.pow(r, e);
              if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
              return n
            }
          }
          if (t % f === c) {
            const e = (t - c) / f;
            return function(t, r) {
              const n = t.mul(r, s),
                i = t.pow(n, e),
                o = t.mul(r, i),
                a = t.mul(t.mul(o, s), i),
                u = t.mul(o, t.sub(a, t.ONE));
              if (!t.eql(t.sqr(u), r)) throw Error("Cannot find square root");
              return u
            }
          }
          return p(t)
        }
        BigInt(9), BigInt(16), e.isNegativeLE = (t, e) => (l(t, e) & o) === o;
        const m = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

        function y(t, e, r) {
          if (i > r) throw Error("Expected power > 0");
          if (r === i) return t.ONE;
          if (r === o) return e;
          let n = t.ONE,
            s = e;
          for (; r > i;) r & o && (n = t.mul(n, s)), s = t.sqr(s), r >>= o;
          return n
        }

        function g(t, e) {
          const r = Array(e.length),
            n = e.reduce((e, n, i) => t.is0(n) ? e : (r[i] = e, t.mul(e, n)), t.ONE),
            i = t.inv(n);
          return e.reduceRight((e, n, i) => t.is0(n) ? e : (r[i] = t.mul(e, r[i]), t.mul(e, n)), i), r
        }

        function v(t, e) {
          const r = void 0 !== e ? e : t.toString(2).length;
          return {
            nBitLength: r,
            nByteLength: Math.ceil(r / 8)
          }
        }

        function w(t) {
          if ("bigint" != typeof t) throw Error("field order must be bigint");
          const e = t.toString(2).length;
          return Math.ceil(e / 8)
        }

        function A(t) {
          const e = w(t);
          return e + Math.ceil(e / 2)
        }
      },
      89211: t => {
        "use strict";
        var e = function(t) {
          return t != t
        };
        t.exports = function(t, r) {
          return 0 === t && 0 === r ? 1 / t == 1 / r : !!(t === r || e(t) && e(r))
        }
      },
      89353: t => {
        "use strict";
        var e = {}.toString,
          r = Math.max,
          n = function(t, e) {
            for (var r = [], n = 0; n < t.length; n += 1) r[n] = t[n];
            for (var i = 0; i < e.length; i += 1) r[i + t.length] = e[i];
            return r
          };
        t.exports = function(t) {
          var i = this;
          if ("function" != typeof i || "[object Function]" !== e.apply(i)) throw new TypeError("Function.prototype.bind called on incompatible " + i);
          for (var o, s = function(t) {
              for (var e = [], r = 1, n = 0; t.length > r; r += 1, n += 1) e[n] = t[r];
              return e
            }(arguments), a = r(0, i.length - s.length), u = [], c = 0; a > c; c++) u[c] = "$" + c;
          if (o = Function("binder", "return function (" + function(t) {
              for (var e = "", r = 0; r < t.length; r += 1) e += t[r], r + 1 < t.length && (e += ",");
              return e
            }(u) + "){ return binder.apply(this,arguments); }")(function() {
              if (this instanceof o) {
                var e = i.apply(this, n(s, arguments));
                return Object(e) === e ? e : this
              }
              return i.apply(t, n(s, arguments))
            }), i.prototype) {
            var f = function() {};
            f.prototype = i.prototype, o.prototype = new f, f.prototype = null
          }
          return o
        }
      },
      89838: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.MAX_WITHDRAWALS_PER_PAYLOAD = e.RLP_EMPTY_STRING = e.KECCAK256_RLP = e.KECCAK256_RLP_S = e.KECCAK256_RLP_ARRAY = e.KECCAK256_RLP_ARRAY_S = e.KECCAK256_NULL = e.KECCAK256_NULL_S = e.TWO_POW256 = e.SECP256K1_ORDER_DIV_2 = e.SECP256K1_ORDER = e.MAX_INTEGER_BIGINT = e.MAX_INTEGER = e.MAX_UINT64 = void 0;
        const n = r(48287),
          i = r(26513);
        e.MAX_UINT64 = BigInt("0xffffffffffffffff"), e.MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), e.MAX_INTEGER_BIGINT = BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"), e.SECP256K1_ORDER = i.secp256k1.CURVE.n, e.SECP256K1_ORDER_DIV_2 = i.secp256k1.CURVE.n / BigInt(2), e.TWO_POW256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"), e.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470", e.KECCAK256_NULL = n.Buffer.from(e.KECCAK256_NULL_S, "hex"), e.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347", e.KECCAK256_RLP_ARRAY = n.Buffer.from(e.KECCAK256_RLP_ARRAY_S, "hex"), e.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421", e.KECCAK256_RLP = n.Buffer.from(e.KECCAK256_RLP_S, "hex"), e.RLP_EMPTY_STRING = n.Buffer.from([128]), e.MAX_WITHDRAWALS_PER_PAYLOAD = 16
      },
      90109: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.safeSignVerify = e.safeSign = void 0;
        const i = r(75269);

        function o(t, e) {
          let r = n.from(e);
          if (r.length > 64) throw Error("Seed can\t be longer than 64 bytes");
          if (8 > r.length) throw Error("Seed must be at least 8 bytes");
          return (0, i.sha256_sync)(n.concat([n.from([255, 255]), r, t.hash()]))
        }
        e.safeSign = function(t, e, r = "ton-safe-sign-magic") {
          return (0, i.sign)(o(t, r), e)
        }, e.safeSignVerify = function(t, e, r, n = "ton-safe-sign-magic") {
          return (0, i.signVerify)(o(t, n), e, r)
        }
      },
      90251: function(t, e, r) {
        var n, i;
        n = function(t) {
          "use strict";
          var e, r, n = {
              template: "[%t] %l:",
              levelFormatter: function(t) {
                return t.toUpperCase()
              },
              nameFormatter: function(t) {
                return t || "root"
              },
              timestampFormatter: function(t) {
                return t.toTimeString().replace(/.*(\d{2}:\d{2}:\d{2}).*/, "$1")
              },
              format: void 0
            },
            i = {},
            o = {
              reg: function(t) {
                if (!t || !t.getLogger) throw new TypeError("Argument is not a root logger");
                e = t
              },
              apply: function(t, r) {
                if (!t || !t.setLevel) throw new TypeError("Argument is not a logger");
                var o = t.methodFactory,
                  s = t.name || "",
                  a = i[s] || i[""] || n;
                return i[s] || (t.methodFactory = function(t, e, r) {
                  var n = o(t, e, r),
                    a = i[r] || i[""],
                    u = -1 !== a.template.indexOf("%t"),
                    c = -1 !== a.template.indexOf("%l"),
                    f = -1 !== a.template.indexOf("%n");
                  return function() {
                    for (var e = "", o = arguments.length, l = Array(o), h = 0; o > h; h++) l[h] = arguments[h];
                    if (s || !i[r]) {
                      var d = a.timestampFormatter(new Date),
                        p = a.levelFormatter(t),
                        b = a.nameFormatter(r);
                      a.format ? e += a.format(p, b, d) : (e += a.template, u && (e = e.replace(/%t/, d)), c && (e = e.replace(/%l/, p)), f && (e = e.replace(/%n/, b))), l.length && "string" == typeof l[0] ? l[0] = e + " " + l[0] : l.unshift(e)
                    }
                    n.apply(void 0, l)
                  }
                }), (r = r || {}).template && (r.format = void 0), i[s] = function(t) {
                  for (var e, r = 1, n = arguments.length; n > r; r++)
                    for (e in arguments[r])({}).hasOwnProperty.call(arguments[r], e) && (t[e] = arguments[r][e]);
                  return t
                }({}, a, r), t.setLevel(t.getLevel()), e || t.warn("It is necessary to call the function reg() of loglevel-plugin-prefix before calling apply. From the next release, it will throw an error. See more: https://github.com/kutuluk/loglevel-plugin-prefix/blob/master/README.md"), t
              }
            };
          return t && (r = t.prefix, o.noConflict = function() {
            return t.prefix === o && (t.prefix = r), o
          }), o
        }, void 0 !== (i = n(r)) && (t.exports = i)
      },
      90629: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          for (var r = t.length - 1; r >= 0; r--)
            if (-1 === e.indexOf(t[r])) return !1;
          return !0
        };
        var n, i = (n = r(83399)) && n._ ? n : {
          default: n
        };
        t.exports = e.default, t.exports.default = e.default
      },
      90746: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV1R2 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey)
          }
          constructor(t, e) {
            this.workchain = t, this.publicKey = e;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEAUwAAov8AIN0gggFMl7qXMO1E0NcLH+Ck8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVNDieG8=", "base64"))[0],
              o = (0, i.beginCell)().storeUint(0, 32).storeBuffer(e).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(t, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            let e = i.SendMode.PAY_GAS_SEPARATELY;
            return null !== t.sendMode && void 0 !== t.sendMode && (e = t.sendMode), (0, o.createWalletTransferV1)({
              seqno: t.seqno,
              sendMode: e,
              secretKey: t.secretKey,
              message: t.message
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    message: (0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV1R2 = s
      },
      90819: function(t, e, r) {
        "use strict";
        var n = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.isAsync = e.isValid = e.isDirty = e.isAborted = e.OK = e.DIRTY = e.INVALID = e.ParseStatus = e.EMPTY_PATH = e.makeIssue = void 0, e.addIssueToContext = function(t, r) {
          const n = (0, i.getErrorMap)(),
            s = (0, e.makeIssue)({
              issueData: r,
              data: t.data,
              path: t.path,
              errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, n, n === o.default ? void 0 : o.default].filter(t => !!t)
            });
          t.common.issues.push(s)
        };
        const i = r(99317),
          o = n(r(75653));
        e.makeIssue = t => {
          const {
            data: e,
            path: r,
            errorMaps: n,
            issueData: i
          } = t, o = [...r, ...i.path || []], s = {
            ...i,
            path: o
          };
          if (void 0 !== i.message) return {
            ...i,
            path: o,
            message: i.message
          };
          let a = "";
          const u = n.filter(t => !!t).slice().reverse();
          for (const t of u) a = t(s, {
            data: e,
            defaultError: a
          }).message;
          return {
            ...i,
            path: o,
            message: a
          }
        }, e.EMPTY_PATH = [];
        class s {
          constructor() {
            this.value = "valid"
          }
          dirty() {
            "valid" === this.value && (this.value = "dirty")
          }
          abort() {
            "aborted" !== this.value && (this.value = "aborted")
          }
          static mergeArray(t, r) {
            const n = [];
            for (const i of r) {
              if ("aborted" === i.status) return e.INVALID;
              "dirty" === i.status && t.dirty(), n.push(i.value)
            }
            return {
              status: t.value,
              value: n
            }
          }
          static async mergeObjectAsync(t, e) {
            const r = [];
            for (const t of e) {
              const e = await t.key,
                n = await t.value;
              r.push({
                key: e,
                value: n
              })
            }
            return s.mergeObjectSync(t, r)
          }
          static mergeObjectSync(t, r) {
            const n = {};
            for (const i of r) {
              const {
                key: r,
                value: o
              } = i;
              if ("aborted" === r.status || "aborted" === o.status) return e.INVALID;
              "dirty" === r.status && t.dirty(), "dirty" === o.status && t.dirty(), "__proto__" !== r.value && ("u" > typeof o.value || i.alwaysSet) && (n[r.value] = o.value)
            }
            return {
              status: t.value,
              value: n
            }
          }
        }
        e.ParseStatus = s, e.INVALID = Object.freeze({
          status: "aborted"
        }), e.DIRTY = t => ({
          status: "dirty",
          value: t
        }), e.OK = t => ({
          status: "valid",
          value: t
        }), e.isAborted = t => "aborted" === t.status, e.isDirty = t => "dirty" === t.status, e.isValid = t => "valid" === t.status, e.isAsync = t => "u" > typeof Promise && t instanceof Promise
      },
      91408: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.exoticMerkleUpdate = void 0;
        const n = r(53528);
        e.exoticMerkleUpdate = function(t, e) {
          const r = new n.BitReader(t);
          if (552 !== t.length) throw Error(`Merkle Update cell must have exactly (8 + (2 * (256 + 16))) bits, got "${t.length}"`);
          if (2 !== e.length) throw Error(`Merkle Update cell must have exactly 2 refs, got "${e.length}"`);
          let i = r.loadUint(8);
          if (4 !== i) throw Error(`Merkle Update cell type must be exactly 4, got "${i}"`);
          const o = r.loadBuffer(32),
            s = r.loadBuffer(32),
            a = r.loadUint(16),
            u = r.loadUint(16);
          if (a !== e[0].depth(0)) throw Error(`Merkle Update cell ref depth must be exactly "${a}", got "${e[0].depth(0)}"`);
          if (!o.equals(e[0].hash(0))) throw Error(`Merkle Update cell ref hash must be exactly "${o.toString("hex")}", got "${e[0].hash(0).toString("hex")}"`);
          if (u !== e[1].depth(0)) throw Error(`Merkle Update cell ref depth must be exactly "${u}", got "${e[1].depth(0)}"`);
          if (!s.equals(e[1].hash(0))) throw Error(`Merkle Update cell ref hash must be exactly "${s.toString("hex")}", got "${e[1].hash(0).toString("hex")}"`);
          return {
            proofDepth1: a,
            proofDepth2: u,
            proofHash1: o,
            proofHash2: s
          }
        }
      },
      91704: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.trimmed = e.defaulted = e.coerce = void 0;
        const n = r(99067),
          i = r(70639),
          o = r(67792);

        function s(t, e, r) {
          return new n.Struct({
            ...t,
            coercer: (i, o) => (0, n.is)(i, e) ? t.coercer(r(i, o), o) : t.coercer(i, o)
          })
        }
        e.coerce = s, e.defaulted = function(t, e, r = {}) {
          return s(t, (0, o.unknown)(), t => {
            const n = "function" == typeof e ? e() : e;
            if (void 0 === t) return n;
            if (!r.strict && (0, i.isPlainObject)(t) && (0, i.isPlainObject)(n)) {
              const e = {
                ...t
              };
              let r = !1;
              for (const t in n) void 0 === e[t] && (e[t] = n[t], r = !0);
              if (r) return e
            }
            return t
          })
        }, e.trimmed = function(t) {
          return s(t, (0, o.string)(), t => t.trim())
        }
      },
      92034: (t, e) => {
        "use strict";
        var r, n, i;
        Object.defineProperty(e, "_", {
            value: !0
          }), e.getParsedType = e.ZodParsedType = e.objectUtil = e.util = void 0, (n = r || (e.util = r = {})).assertEqual = t => {}, n.assertIs = function(t) {}, n.assertNever = function(t) {
            throw Error()
          }, n.arrayToEnum = t => {
            const e = {};
            for (const r of t) e[r] = r;
            return e
          }, n.getValidEnumValues = t => {
            const e = n.objectKeys(t).filter(e => "number" != typeof t[t[e]]),
              r = {};
            for (const n of e) r[n] = t[n];
            return n.objectValues(r)
          }, n.objectValues = t => n.objectKeys(t).map(function(e) {
            return t[e]
          }), n.objectKeys = "function" == typeof Object.keys ? t => Object.keys(t) : t => {
            const e = [];
            for (const r in t)({}).hasOwnProperty.call(t, r) && e.push(r);
            return e
          }, n.find = (t, e) => {
            for (const r of t)
              if (e(r)) return r
          }, n.isInteger = "function" == typeof Number.isInteger ? t => Number.isInteger(t) : t => "number" == typeof t && Number.isFinite(t) && Math.floor(t) === t, n.joinValues = function(t, e = " | ") {
            return t.map(t => "string" == typeof t ? `'${t}'` : t).join(e)
          }, n.jsonStringifyReplacer = (t, e) => "bigint" == typeof e ? e.toString() : e,
          function(t) {
            t.mergeShapes = (t, e) => ({
              ...t,
              ...e
            })
          }(i || (e.objectUtil = i = {})), e.ZodParsedType = r.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), e.getParsedType = t => {
            switch (typeof t) {
              case "undefined":
                return e.ZodParsedType.undefined;
              case "string":
                return e.ZodParsedType.string;
              case "number":
                return Number.isNaN(t) ? e.ZodParsedType.nan : e.ZodParsedType.number;
              case "boolean":
                return e.ZodParsedType.boolean;
              case "function":
                return e.ZodParsedType.function;
              case "bigint":
                return e.ZodParsedType.bigint;
              case "symbol":
                return e.ZodParsedType.symbol;
              case "object":
                return Array.isArray(t) ? e.ZodParsedType.array : null === t ? e.ZodParsedType.null : t.then && "function" == typeof t.then && t.catch && "function" == typeof t.catch ? e.ZodParsedType.promise : "u" > typeof Map && t instanceof Map ? e.ZodParsedType.map : "u" > typeof Set && t instanceof Set ? e.ZodParsedType.set : "u" > typeof Date && t instanceof Date ? e.ZodParsedType.date : e.ZodParsedType.object;
              default:
                return e.ZodParsedType.unknown
            }
          }
      },
      92133: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.hashPersonalMessage = e.isValidSignature = e.fromRpcSig = e.toCompactSig = e.toRpcSig = e.ecrecover = e.ecsign = void 0;
        const i = r(32019),
          o = r(26513),
          s = r(77312),
          a = r(89838),
          u = r(35546);

        function c(t, e) {
          return t === BigInt(0) || t === BigInt(1) ? t : void 0 === e ? t - BigInt(27) : t - (e * BigInt(2) + BigInt(35))
        }

        function f(t) {
          return t === BigInt(0) || t === BigInt(1)
        }
        e.ecsign = function(t, e, r) {
          const i = o.secp256k1.sign(t, e),
            s = i.toCompactRawBytes();
          return {
            r: n.from(s.slice(0, 32)),
            s: n.from(s.slice(32, 64)),
            v: void 0 === r ? BigInt(i.recovery + 27) : BigInt(i.recovery + 35) + BigInt(r) * BigInt(2)
          }
        }, e.ecrecover = function(t, e, r, i, a) {
          const u = n.concat([(0, s.setLengthLeft)(r, 32), (0, s.setLengthLeft)(i, 32)], 64),
            l = c(e, a);
          if (!f(l)) throw Error("Invalid signature v value");
          const h = o.secp256k1.Signature.fromCompact(u).addRecoveryBit(+l).recoverPublicKey(t);
          return n.from(h.toRawBytes(!1).slice(1))
        }, e.toRpcSig = function(t, e, r, i) {
          if (!f(c(t, i))) throw Error("Invalid signature v value");
          return (0, s.bufferToHex)(n.concat([(0, s.setLengthLeft)(e, 32), (0, s.setLengthLeft)(r, 32), (0, s.toBuffer)(t)]))
        }, e.toCompactSig = function(t, e, r, i) {
          if (!f(c(t, i))) throw Error("Invalid signature v value");
          let o = r;
          return (t > BigInt(28) && t % BigInt(2) === BigInt(1) || t === BigInt(1) || t === BigInt(28)) && (o = n.from(r), o[0] |= 128), (0, s.bufferToHex)(n.concat([(0, s.setLengthLeft)(e, 32), (0, s.setLengthLeft)(o, 32)]))
        }, e.fromRpcSig = function(t) {
          const e = (0, s.toBuffer)(t);
          let r, n, i;
          if (65 > e.length) {
            if (64 !== e.length) throw Error("Invalid signature length");
            r = e.slice(0, 32), n = e.slice(32, 64), i = BigInt((0, s.bufferToInt)(e.slice(32, 33)) >> 7), n[0] &= 127
          } else r = e.slice(0, 32), n = e.slice(32, 64), i = (0, s.bufferToBigInt)(e.slice(64));
          return 27 > i && (i += BigInt(27)), {
            v: i,
            r: r,
            s: n
          }
        }, e.isValidSignature = function(t, e, r, n = !0, i) {
          if (32 !== e.length || 32 !== r.length || !f(c(t, i))) return !1;
          const o = (0, s.bufferToBigInt)(e),
            u = (0, s.bufferToBigInt)(r);
          return !(o === BigInt(0) || o >= a.SECP256K1_ORDER || u === BigInt(0) || u >= a.SECP256K1_ORDER || n && u >= a.SECP256K1_ORDER_DIV_2)
        }, e.hashPersonalMessage = function(t) {
          (0, u.assertIsBuffer)(t);
          const e = n.from("Ethereum Signed Message:\n" + t.length, "utf-8");
          return n.from((0, i.keccak256)(n.concat([e, t])))
        }
      },
      92234: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeCommonMessageInfoRelaxed = e.loadCommonMessageInfoRelaxed = void 0;
        const n = r(10574);
        e.loadCommonMessageInfoRelaxed = function(t) {
          if (!t.loadBit()) return {
            type: "internal",
            ihrDisabled: t.loadBit(),
            bounce: t.loadBit(),
            bounced: t.loadBit(),
            src: t.loadMaybeAddress(),
            dest: t.loadAddress(),
            value: (0, n.loadCurrencyCollection)(t),
            ihrFee: t.loadCoins(),
            forwardFee: t.loadCoins(),
            createdLt: t.loadUintBig(64),
            createdAt: t.loadUint(32)
          };
          if (!t.loadBit()) throw Error("External In message is not possible for CommonMessageInfoRelaxed");
          return {
            type: "external-out",
            src: t.loadMaybeAddress(),
            dest: t.loadMaybeExternalAddress(),
            createdLt: t.loadUintBig(64),
            createdAt: t.loadUint(32)
          }
        }, e.storeCommonMessageInfoRelaxed = function(t) {
          return e => {
            if ("internal" === t.type) e.storeBit(0), e.storeBit(t.ihrDisabled), e.storeBit(t.bounce), e.storeBit(t.bounced), e.storeAddress(t.src), e.storeAddress(t.dest), e.store((0, n.storeCurrencyCollection)(t.value)), e.storeCoins(t.ihrFee), e.storeCoins(t.forwardFee), e.storeUint(t.createdLt, 64), e.storeUint(t.createdAt, 32);
            else {
              if ("external-out" !== t.type) throw Error("Unknown CommonMessageInfo type");
              e.storeBit(1), e.storeBit(1), e.storeAddress(t.src), e.storeAddress(t.dest), e.storeUint(t.createdLt, 64), e.storeUint(t.createdAt, 32)
            }
          }
        }
      },
      92443: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wrapError = e.getErrorMessage = e.isErrorWithStack = e.isErrorWithMessage = e.isErrorWithCode = void 0;
        const n = r(71843),
          i = r(15354);

        function o(t) {
          return "object" == typeof t && null !== t && "code" in t
        }

        function s(t) {
          return "object" == typeof t && null !== t && "message" in t
        }
        e.isErrorWithCode = o, e.isErrorWithMessage = s, e.isErrorWithStack = function(t) {
          return "object" == typeof t && null !== t && "stack" in t
        }, e.getErrorMessage = function(t) {
          return s(t) && "string" == typeof t.message ? t.message : (0, i.isNullOrUndefined)(t) ? "" : t + ""
        }, e.wrapError = function(t, e) {
          if (function(t) {
              return t instanceof Error || (0, i.isObject)(t) && "Error" === t.constructor.name
            }(t)) {
            let r;
            return r = 2 === Error.length ? Error(e, {
              cause: t
            }) : new n.ErrorWithCause(e, {
              cause: t
            }), o(t) && (r.code = t.code), r
          }
          return e.length > 0 ? Error(`${t+""}: ${e}`) : Error(t + "")
        }
      },
      92464: (t, e, r) => {
        "use strict";
        var n = r(38452),
          i = r(76642);
        t.exports = function() {
          var t = i();
          return n(Number, {
            isNaN: t
          }, {
            isNaN: function() {
              return Number.isNaN !== t
            }
          }), t
        }
      },
      92577: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeStorageUsed = e.loadStorageUsed = void 0, e.loadStorageUsed = function(t) {
          return {
            cells: t.loadVarUintBig(3),
            bits: t.loadVarUintBig(3)
          }
        }, e.storeStorageUsed = function(t) {
          return e => {
            e.storeVarUint(t.cells, 3), e.storeVarUint(t.bits, 3)
          }
        }
      },
      92678: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          if ((0, i.default)(t), !o.test(t)) return !1;
          for (var e = !0, r = 0, n = t.length - 2; n >= 0; n--)
            if ("A" > t[n] || t[n] > "Z") {
              var s = t[n].charCodeAt(0) - 48;
              r += e ? 5 > s ? 2 * s : 1 + 2 * (s - 5) : s, e = !e
            } else
              for (var a = t[n].charCodeAt(0) - 55, u = 0, c = [a % 10, Math.trunc(a / 10)]; c.length > u; u++) {
                var f = c[u];
                r += e ? 5 > f ? 2 * f : 1 + 2 * (f - 5) : f, e = !e
              }
          var l = 10 * Math.trunc((r + 9) / 10) - r;
          return +t[t.length - 1] === l
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^[A-Z]{2}[0-9A-Z]{9}[0-9]$/;
        t.exports = e.default, t.exports.default = e.default
      },
      92755: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.q || (Object.create ? function(t, e, r, n) {
            void 0 === n && (n = r), Object.defineProperty(t, n, {
              enumerable: !0,
              get: function() {
                return e[r]
              }
            })
          } : function(t, e, r, n) {
            void 0 === n && (n = r), t[n] = e[r]
          }),
          o = this && this.St || (Object.create ? function(t, e) {
            Object.defineProperty(t, "default", {
              enumerable: !0,
              value: e
            })
          } : function(t, e) {
            t.default = e
          }),
          s = this && this.Hn || function(t, e, r, n) {
            var i, o = arguments.length,
              s = 3 > o ? e : null === n ? n = Object.getOwnPropertyDescriptor(e, r) : n;
            if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) s = Reflect.decorate(t, e, r, n);
            else
              for (var a = t.length - 1; a >= 0; a--)(i = t[a]) && (s = (3 > o ? i(s) : o > 3 ? i(e, r, s) : i(e, r)) || s);
            return o > 3 && s && Object.defineProperty(e, r, s), s
          },
          a = this && this.Ot || function(t) {
            if (t && t._) return t;
            var e = {};
            if (null != t)
              for (var r in t) "default" !== r && Object.hasOwnProperty.call(t, r) && i(e, t, r);
            return o(e, t), e
          },
          u = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.deserializeUnchecked = e.deserialize = e.serialize = e.BinaryReader = e.BinaryWriter = e.BorshError = e.baseDecode = e.baseEncode = void 0;
        const c = u(r(39404)),
          f = u(r(16763)),
          l = a(r(44281)),
          h = new("function" != typeof TextDecoder ? l.TextDecoder : TextDecoder)("utf-8", {
            fatal: !0
          });
        e.baseEncode = function(t) {
          return "string" == typeof t && (t = n.from(t, "utf8")), f.default.encode(n.from(t))
        }, e.baseDecode = function(t) {
          return n.from(f.default.decode(t))
        };
        const d = 1024;
        class p extends Error {
          constructor(t) {
            super(t), this.fieldPath = [], this.originalMessage = t
          }
          addToFieldPath(t) {
            this.fieldPath.splice(0, 0, t), this.message = this.originalMessage + ": " + this.fieldPath.join(".")
          }
        }
        e.BorshError = p;
        class b {
          constructor() {
            this.buf = n.alloc(d), this.length = 0
          }
          maybeResize() {
            this.buf.length < 16 + this.length && (this.buf = n.concat([this.buf, n.alloc(d)]))
          }
          writeU8(t) {
            this.maybeResize(), this.buf.writeUInt8(t, this.length), this.length += 1
          }
          writeU16(t) {
            this.maybeResize(), this.buf.writeUInt16LE(t, this.length), this.length += 2
          }
          writeU32(t) {
            this.maybeResize(), this.buf.writeUInt32LE(t, this.length), this.length += 4
          }
          writeU64(t) {
            this.maybeResize(), this.writeBuffer(n.from(new c.default(t).toArray("le", 8)))
          }
          writeU128(t) {
            this.maybeResize(), this.writeBuffer(n.from(new c.default(t).toArray("le", 16)))
          }
          writeU256(t) {
            this.maybeResize(), this.writeBuffer(n.from(new c.default(t).toArray("le", 32)))
          }
          writeU512(t) {
            this.maybeResize(), this.writeBuffer(n.from(new c.default(t).toArray("le", 64)))
          }
          writeBuffer(t) {
            this.buf = n.concat([n.from(this.buf.subarray(0, this.length)), t, n.alloc(d)]), this.length += t.length
          }
          writeString(t) {
            this.maybeResize();
            const e = n.from(t, "utf8");
            this.writeU32(e.length), this.writeBuffer(e)
          }
          writeFixedArray(t) {
            this.writeBuffer(n.from(t))
          }
          writeArray(t, e) {
            this.maybeResize(), this.writeU32(t.length);
            for (const r of t) this.maybeResize(), e(r)
          }
          toArray() {
            return this.buf.subarray(0, this.length)
          }
        }

        function m(t, e, r) {
          const n = r.value;
          r.value = function(...t) {
            try {
              return n.apply(this, t)
            } catch (t) {
              if (t instanceof RangeError) {
                const e = t.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(e) >= 0) throw new p("Reached the end of buffer when deserializing")
              }
              throw t
            }
          }
        }
        e.BinaryWriter = b;
        class y {
          constructor(t) {
            this.buf = t, this.offset = 0
          }
          readU8() {
            const t = this.buf.readUInt8(this.offset);
            return this.offset += 1, t
          }
          readU16() {
            const t = this.buf.readUInt16LE(this.offset);
            return this.offset += 2, t
          }
          readU32() {
            const t = this.buf.readUInt32LE(this.offset);
            return this.offset += 4, t
          }
          readU64() {
            const t = this.readBuffer(8);
            return new c.default(t, "le")
          }
          readU128() {
            const t = this.readBuffer(16);
            return new c.default(t, "le")
          }
          readU256() {
            const t = this.readBuffer(32);
            return new c.default(t, "le")
          }
          readU512() {
            const t = this.readBuffer(64);
            return new c.default(t, "le")
          }
          readBuffer(t) {
            if (this.offset + t > this.buf.length) throw new p(`Expected buffer length ${t} isn't within bounds`);
            const e = this.buf.slice(this.offset, this.offset + t);
            return this.offset += t, e
          }
          readString() {
            const t = this.readU32(),
              e = this.readBuffer(t);
            try {
              return h.decode(e)
            } catch (t) {
              throw new p("Error decoding UTF-8 string: " + t)
            }
          }
          readFixedArray(t) {
            return new Uint8Array(this.readBuffer(t))
          }
          readArray(t) {
            const e = this.readU32(),
              r = [];
            for (let n = 0; e > n; ++n) r.push(t());
            return r
          }
        }

        function g(t) {
          return t.charAt(0).toUpperCase() + t.slice(1)
        }

        function v(t, e, r, n, i) {
          try {
            if ("string" == typeof n) i["write" + g(n)](r);
            else if (n instanceof Array)
              if ("number" == typeof n[0]) {
                if (r.length !== n[0]) throw new p(`Expecting byte array of length ${n[0]}, but got ${r.length} bytes`);
                i.writeFixedArray(r)
              } else if (2 === n.length && "number" == typeof n[1]) {
              if (r.length !== n[1]) throw new p(`Expecting byte array of length ${n[1]}, but got ${r.length} bytes`);
              for (let e = 0; e < n[1]; e++) v(t, null, r[e], n[0], i)
            } else i.writeArray(r, r => {
              v(t, e, r, n[0], i)
            });
            else if (void 0 !== n.kind) switch (n.kind) {
              case "option":
                null == r ? i.writeU8(0) : (i.writeU8(1), v(t, e, r, n.type, i));
                break;
              case "map":
                i.writeU32(r.size), r.forEach((r, o) => {
                  v(t, e, o, n.key, i), v(t, e, r, n.value, i)
                });
                break;
              default:
                throw new p(`FieldType ${n} unrecognized`)
            } else w(t, r, i)
          } catch (t) {
            throw t instanceof p && t.addToFieldPath(e), t
          }
        }

        function w(t, e, r) {
          if ("function" == typeof e.borshSerialize) return void e.borshSerialize(r);
          const n = t.get(e.constructor);
          if (!n) throw new p(`Class ${e.constructor.name} is missing in schema`);
          if ("struct" === n.kind) n.fields.map(([n, i]) => {
            v(t, n, e[n], i, r)
          });
          else {
            if ("enum" !== n.kind) throw new p(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`);
            {
              const i = e[n.field];
              for (let o = 0; o < n.values.length; ++o) {
                const [s, a] = n.values[o];
                if (s === i) {
                  r.writeU8(o), v(t, s, e[s], a, r);
                  break
                }
              }
            }
          }
        }

        function A(t, e, r, n) {
          try {
            if ("string" == typeof r) return n["read" + g(r)]();
            if (r instanceof Array) {
              if ("number" == typeof r[0]) return n.readFixedArray(r[0]);
              if ("number" == typeof r[1]) {
                const e = [];
                for (let i = 0; i < r[1]; i++) e.push(A(t, null, r[0], n));
                return e
              }
              return n.readArray(() => A(t, e, r[0], n))
            }
            if ("option" === r.kind) return n.readU8() ? A(t, e, r.type, n) : void 0;
            if ("map" === r.kind) {
              let i = new Map;
              const o = n.readU32();
              for (let s = 0; o > s; s++) {
                const o = A(t, e, r.key, n),
                  s = A(t, e, r.value, n);
                i.set(o, s)
              }
              return i
            }
            return T(t, r, n)
          } catch (t) {
            throw t instanceof p && t.addToFieldPath(e), t
          }
        }

        function T(t, e, r) {
          if ("function" == typeof e.borshDeserialize) return e.borshDeserialize(r);
          const n = t.get(e);
          if (!n) throw new p(`Class ${e.name} is missing in schema`);
          if ("struct" === n.kind) {
            const n = {};
            for (const [i, o] of t.get(e).fields) n[i] = A(t, i, o, r);
            return new e(n)
          }
          if ("enum" === n.kind) {
            const i = r.readU8();
            if (i >= n.values.length) throw new p(`Enum index: ${i} is out of range`);
            const [o, s] = n.values[i], a = A(t, o, s, r);
            return new e({
              [o]: a
            })
          }
          throw new p(`Unexpected schema kind: ${n.kind} for ${e.constructor.name}`)
        }
        s([m], y.prototype, "readU8", null), s([m], y.prototype, "readU16", null), s([m], y.prototype, "readU32", null), s([m], y.prototype, "readU64", null), s([m], y.prototype, "readU128", null), s([m], y.prototype, "readU256", null), s([m], y.prototype, "readU512", null), s([m], y.prototype, "readString", null), s([m], y.prototype, "readFixedArray", null), s([m], y.prototype, "readArray", null), e.BinaryReader = y, e.serialize = function(t, e, r = b) {
          const n = new r;
          return w(t, e, n), n.toArray()
        }, e.deserialize = function(t, e, r, n = y) {
          const i = new n(r),
            o = T(t, e, i);
          if (i.offset < r.length) throw new p(`Unexpected ${r.length-i.offset} bytes after deserialized data`);
          return o
        }, e.deserializeUnchecked = function(t, e, r, n = y) {
          return T(t, e, new n(r))
        }
      },
      92861: (t, e, r) => {
        var n = r(48287),
          i = n.Buffer;

        function o(t, e) {
          for (var r in t) e[r] = t[r]
        }

        function s(t, e, r) {
          return i(t, e, r)
        }
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t.exports = n : (o(n, e), e.Buffer = s), s.prototype = Object.create(i.prototype), o(i, s), s.from = function(t, e, r) {
          if ("number" == typeof t) throw new TypeError("Argument must not be a number");
          return i(t, e, r)
        }, s.alloc = function(t, e, r) {
          if ("number" != typeof t) throw new TypeError("Argument must be a number");
          var n = i(t);
          return void 0 !== e ? "string" == typeof r ? n.fill(e, r) : n.fill(e) : n.fill(0), n
        }, s.allocUnsafe = function(t) {
          if ("number" != typeof t) throw new TypeError("Argument must be a number");
          return i(t)
        }, s.allocUnsafeSlow = function(t) {
          if ("number" != typeof t) throw new TypeError("Argument must be a number");
          return n.SlowBuffer(t)
        }
      },
      92960: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.crc16 = void 0, e.crc16 = function(t) {
          let e = 0;
          const r = n.alloc(t.length + 2);
          r.set(t);
          for (let t of r) {
            let r = 128;
            for (; r > 0;) e <<= 1, t & r && (e += 1), r >>= 1, e > 65535 && (e &= 65535, e ^= 4129)
          }
          return n.from([Math.floor(e / 256), e % 256])
        }
      },
      93007: (t, e, r) => {
        const n = r(53908);
        t.exports = (t, e, r, i, o) => {
          "string" == typeof r && (o = i, i = r, r = void 0);
          try {
            return new n(t instanceof n ? t.version : t, r).inc(e, i, o).version
          } catch {
            return null
          }
        }
      },
      93442: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, i.default)(t);
          var r = t.replace(/\s/g, "").toUpperCase();
          return e.toUpperCase() in o && o[e].test(r)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            AM: /^[A-Z]{2}\d{7}$/,
            AR: /^[A-Z]{3}\d{6}$/,
            AT: /^[A-Z]\d{7}$/,
            AU: /^[A-Z]\d{7}$/,
            AZ: /^[A-Z]{2,3}\d{7,8}$/,
            BE: /^[A-Z]{2}\d{6}$/,
            BG: /^\d{9}$/,
            BR: /^[A-Z]{2}\d{6}$/,
            BY: /^[A-Z]{2}\d{7}$/,
            CA: /^[A-Z]{2}\d{6}$/,
            CH: /^[A-Z]\d{7}$/,
            CN: /^G\d{8}$|^E(?![IO])[A-Z0-9]\d{7}$/,
            CY: /^[A-Z](\d{6}|\d{8})$/,
            CZ: /^\d{8}$/,
            DE: /^[CFGHJKLMNPRTVWXYZ0-9]{9}$/,
            DK: /^\d{9}$/,
            DZ: /^\d{9}$/,
            EE: /^([A-Z]\d{7}|[A-Z]{2}\d{7})$/,
            ES: /^[A-Z0-9]{2}([A-Z0-9]?)\d{6}$/,
            FI: /^[A-Z]{2}\d{7}$/,
            FR: /^\d{2}[A-Z]{2}\d{5}$/,
            GB: /^\d{9}$/,
            GR: /^[A-Z]{2}\d{7}$/,
            HR: /^\d{9}$/,
            HU: /^[A-Z]{2}(\d{6}|\d{7})$/,
            IE: /^[A-Z0-9]{2}\d{7}$/,
            IN: /^[A-Z]{1}-?\d{7}$/,
            ID: /^[A-C]\d{7}$/,
            IR: /^[A-Z]\d{8}$/,
            IS: /^(A)\d{7}$/,
            IT: /^[A-Z0-9]{2}\d{7}$/,
            JM: /^[Aa]\d{7}$/,
            JP: /^[A-Z]{2}\d{7}$/,
            KR: /^[MS]\d{8}$/,
            KZ: /^[a-zA-Z]\d{7}$/,
            LI: /^[a-zA-Z]\d{5}$/,
            LT: /^[A-Z0-9]{8}$/,
            LU: /^[A-Z0-9]{8}$/,
            LV: /^[A-Z0-9]{2}\d{7}$/,
            LY: /^[A-Z0-9]{8}$/,
            MT: /^\d{7}$/,
            MZ: /^([A-Z]{2}\d{7})|(\d{2}[A-Z]{2}\d{5})$/,
            MY: /^[AHK]\d{8}$/,
            MX: /^\d{10,11}$/,
            NL: /^[A-Z]{2}[A-Z0-9]{6}\d$/,
            NZ: /^([Ll]([Aa]|[Dd]|[Ff]|[Hh])|[Ee]([Aa]|[Pp])|[Nn])\d{6}$/,
            PH: /^([A-Z](\d{6}|\d{7}[A-Z]))|([A-Z]{2}(\d{6}|\d{7}))$/,
            PK: /^[A-Z]{2}\d{7}$/,
            PL: /^[A-Z]{2}\d{7}$/,
            PT: /^[A-Z]\d{6}$/,
            RO: /^\d{8,9}$/,
            RU: /^\d{9}$/,
            SE: /^\d{8}$/,
            SL: /^(P)[A-Z]\d{7}$/,
            SK: /^[0-9A-Z]\d{7}$/,
            TH: /^[A-Z]{1,2}\d{6,7}$/,
            TR: /^[A-Z]\d{8}$/,
            UA: /^[A-Z]{2}\d{6}$/,
            US: /^\d{9}$/
          };
        t.exports = e.default, t.exports.default = e.default
      },
      93471: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeComputeSkipReason = e.loadComputeSkipReason = void 0, e.loadComputeSkipReason = function(t) {
          let e = t.loadUint(2);
          if (0 === e) return "no-state";
          if (1 === e) return "bad-state";
          if (2 === e) return "no-gas";
          throw Error("Unknown ComputeSkipReason: " + e)
        }, e.storeComputeSkipReason = function(t) {
          return e => {
            if ("no-state" === t) e.storeUint(0, 2);
            else if ("bad-state" === t) e.storeUint(1, 2);
            else {
              if ("no-gas" !== t) throw Error("Unknown ComputeSkipReason: " + t);
              e.storeUint(2, 2)
            }
          }
        }
      },
      93628: (t, e, r) => {
        "use strict";
        var n = r(48648),
          i = r(71064),
          o = r(7176);
        t.exports = n ? function(t) {
          return n(t)
        } : i ? function(t) {
          if (!t || "object" != typeof t && "function" != typeof t) throw new TypeError("getProto: not an object");
          return i(t)
        } : o ? function(t) {
          return o(t)
        } : null
      },
      93904: (t, e, r) => {
        const n = Symbol("SemVer ANY");
        class i {
          static get ANY() {
            return n
          }
          constructor(t, e) {
            if (e = o(e), t instanceof i) {
              if (t.loose === !!e.loose) return t;
              t = t.value
            }
            t = t.trim().split(/\s+/).join(" "), c("comparator", t, e), this.options = e, this.loose = !!e.loose, this.parse(t), this.semver === n ? this.value = "" : this.value = this.operator + this.semver.version, c("comp", this)
          }
          parse(t) {
            const e = this.options.loose ? s[a.COMPARATORLOOSE] : s[a.COMPARATOR],
              r = t.match(e);
            if (!r) throw new TypeError("Invalid comparator: " + t);
            this.operator = void 0 !== r[1] ? r[1] : "", "=" === this.operator && (this.operator = ""), r[2] ? this.semver = new f(r[2], this.options.loose) : this.semver = n
          }
          toString() {
            return this.value
          }
          test(t) {
            if (c("Comparator.test", t, this.options.loose), this.semver === n || t === n) return !0;
            if ("string" == typeof t) try {
              t = new f(t, this.options)
            } catch {
              return !1
            }
            return u(t, this.operator, this.semver, this.options)
          }
          intersects(t, e) {
            if (!(t instanceof i)) throw new TypeError("a Comparator is required");
            return "" === this.operator ? "" === this.value || new l(t.value, e).test(this.value) : "" === t.operator ? "" === t.value || new l(this.value, e).test(t.semver) : !((e = o(e)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === t.value) || !e.includePrerelease && (this.value.startsWith("<0.0.0") || t.value.startsWith("<0.0.0")) || !(this.operator.startsWith(">") && t.operator.startsWith(">") || this.operator.startsWith("<") && t.operator.startsWith("<") || this.semver.version === t.semver.version && this.operator.includes("=") && t.operator.includes("=") || u(this.semver, "<", t.semver, e) && this.operator.startsWith(">") && t.operator.startsWith("<") || u(this.semver, ">", t.semver, e) && this.operator.startsWith("<") && t.operator.startsWith(">")))
          }
        }
        t.exports = i;
        const o = r(98587),
          {
            safeRe: s,
            t: a
          } = r(99718),
          u = r(72111),
          c = r(57272),
          f = r(53908),
          l = r(78311)
      },
      93939: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if ((0, i.default)(t), e in c) return c[e].test(t);
          if ("any" === e) {
            for (var r in c)
              if (c.hasOwnProperty(r) && c[r].test(t)) return !0;
            return !1
          }
          throw Error("Invalid locale '".concat(e, "'"))
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^\d{3}$/,
          s = /^\d{4}$/,
          a = /^\d{5}$/,
          u = /^\d{6}$/,
          c = {
            AD: /^AD\d{3}$/,
            AT: s,
            AU: s,
            AZ: /^AZ\d{4}$/,
            BA: /^([7-8]\d{4}$)/,
            BE: s,
            BG: s,
            BR: /^\d{5}-\d{3}$/,
            BY: /^2[1-4]\d{4}$/,
            CA: /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJ-NPRSTV-Z][\s\-]?\d[ABCEGHJ-NPRSTV-Z]\d$/i,
            CH: s,
            CN: /^(0[1-7]|1[012356]|2[0-7]|3[0-6]|4[0-7]|5[1-7]|6[1-7]|7[1-5]|8[1345]|9[09])\d{4}$/,
            CZ: /^\d{3}\s?\d{2}$/,
            DE: a,
            DK: s,
            DO: a,
            DZ: a,
            EE: a,
            ES: /^(5[0-2]{1}|[0-4]{1}\d{1})\d{3}$/,
            FI: a,
            FR: /^\d{2}\s?\d{3}$/,
            GB: /^(gir\s?0aa|[a-z]{1,2}\d[\da-z]?\s?(\d[a-z]{2})?)$/i,
            GR: /^\d{3}\s?\d{2}$/,
            HR: /^([1-5]\d{4}$)/,
            HT: /^HT\d{4}$/,
            HU: s,
            ID: a,
            IE: /^(?!.*(?:o))[A-Za-z]\d[\dw]\s\w{4}$/i,
            IL: /^(\d{5}|\d{7})$/,
            IN: /^((?!10|29|35|54|55|65|66|86|87|88|89)[1-9][0-9]{5})$/,
            IR: /^(?!(\d)\1{3})[13-9]{4}[1346-9][013-9]{5}$/,
            IS: o,
            IT: a,
            JP: /^\d{3}\-\d{4}$/,
            KE: a,
            KR: /^(\d{5}|\d{6})$/,
            LI: /^(948[5-9]|949[0-7])$/,
            LT: /^LT\-\d{5}$/,
            LU: s,
            LV: /^LV\-\d{4}$/,
            LK: a,
            MG: o,
            MX: a,
            MT: /^[A-Za-z]{3}\s{0,1}\d{4}$/,
            MY: a,
            NL: /^\d{4}\s?[a-z]{2}$/i,
            NO: s,
            NP: /^(10|21|22|32|33|34|44|45|56|57)\d{3}$|^(977)$/i,
            NZ: s,
            PL: /^\d{2}\-\d{3}$/,
            PR: /^00[679]\d{2}([ -]\d{4})?$/,
            PT: /^\d{4}\-\d{3}?$/,
            RO: u,
            RU: u,
            SA: a,
            SE: /^[1-9]\d{2}\s?\d{2}$/,
            SG: u,
            SI: s,
            SK: /^\d{3}\s?\d{2}$/,
            TH: a,
            TN: s,
            TW: /^\d{3}(\d{2})?$/,
            UA: a,
            US: /^\d{5}(-\d{4})?$/,
            ZA: s,
            ZM: a
          },
          f = Object.keys(c);
        e.locales = f
      },
      94107: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.base64 = void 0;
        const n = r(35620),
          i = r(74772);
        e.base64 = (t, e = {}) => {
          const r = e.paddingRequired ?? !1,
            o = e.characterSet ?? "base64";
          let s, a;
          return "base64" === o ? s = String.raw`[A-Za-z0-9+\/]` : ((0, i.assert)("base64url" === o), s = String.raw`[-_A-Za-z0-9]`), a = RegExp(r ? `^(?:${s}{4})*(?:${s}{3}=|${s}{2}==)?$` : `^(?:${s}{4})*(?:${s}{2,3}|${s}{3}=|${s}{2}==)?$`, "u"), (0, n.pattern)(t, a)
        }
      },
      94148: (t, e, r) => {
        "use strict";
        var n = r(65606);

        function i(t) {
          return (i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
            return typeof t
          } : function(t) {
            return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
          })(t)
        }
        var o, s, a = r(69597).codes,
          u = a.ERR_AMBIGUOUS_ARGUMENT,
          c = a.ERR_INVALID_ARG_TYPE,
          f = a.ERR_INVALID_ARG_VALUE,
          l = a.ERR_INVALID_RETURN_VALUE,
          h = a.ERR_MISSING_ARGS,
          d = r(3918),
          p = r(40537).inspect,
          b = r(40537).types,
          m = b.isPromise,
          y = b.isRegExp,
          g = r(11514)(),
          v = r(9394)(),
          w = r(38075)("RegExp.prototype.test");

        function A() {
          var t = r(82299);
          o = t.isDeepEqual, s = t.isDeepStrictEqual
        }
        new Map;
        var T = !1,
          E = t.exports = I,
          P = {};

        function k(t) {
          throw t.message instanceof Error ? t.message : new d(t)
        }

        function x(t, e, r, n) {
          if (!r) {
            var i = !1;
            if (0 === e) i = !0, n = "No value argument passed to `assert.ok()`";
            else if (n instanceof Error) throw n;
            var o = new d({
              actual: r,
              expected: !0,
              message: n,
              operator: "==",
              stackStartFn: t
            });
            throw o.generatedMessage = i, o
          }
        }

        function I() {
          for (var t = arguments.length, e = Array(t), r = 0; t > r; r++) e[r] = arguments[r];
          x.apply(void 0, [I, e.length].concat(e))
        }
        E.fail = function t(e, r, i, o, s) {
          var a, u = arguments.length;
          if (0 === u ? a = "Failed" : 1 === u ? (i = e, e = void 0) : (!1 === T && (T = !0, (n.emitWarning ? n.emitWarning : console.warn.bind(console))("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094")), 2 === u && (o = "!=")), i instanceof Error) throw i;
          var c = {
            actual: e,
            expected: r,
            operator: void 0 === o ? "fail" : o,
            stackStartFn: s || t
          };
          void 0 !== i && (c.message = i);
          var f = new d(c);
          throw a && (f.message = a, f.generatedMessage = !0), f
        }, E.AssertionError = d, E.ok = I, E.equal = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          e != r && k({
            actual: e,
            expected: r,
            message: n,
            operator: "==",
            stackStartFn: t
          })
        }, E.notEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          e == r && k({
            actual: e,
            expected: r,
            message: n,
            operator: "!=",
            stackStartFn: t
          })
        }, E.deepEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          void 0 === o && A(), o(e, r) || k({
            actual: e,
            expected: r,
            message: n,
            operator: "deepEqual",
            stackStartFn: t
          })
        }, E.notDeepEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          void 0 === o && A(), o(e, r) && k({
            actual: e,
            expected: r,
            message: n,
            operator: "notDeepEqual",
            stackStartFn: t
          })
        }, E.deepStrictEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          void 0 === o && A(), s(e, r) || k({
            actual: e,
            expected: r,
            message: n,
            operator: "deepStrictEqual",
            stackStartFn: t
          })
        }, E.notDeepStrictEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          void 0 === o && A(), s(e, r) && k({
            actual: e,
            expected: r,
            message: n,
            operator: "notDeepStrictEqual",
            stackStartFn: t
          })
        }, E.strictEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          v(e, r) || k({
            actual: e,
            expected: r,
            message: n,
            operator: "strictEqual",
            stackStartFn: t
          })
        }, E.notStrictEqual = function t(e, r, n) {
          if (2 > arguments.length) throw new h("actual", "expected");
          v(e, r) && k({
            actual: e,
            expected: r,
            message: n,
            operator: "notStrictEqual",
            stackStartFn: t
          })
        };
        var S, O = (Object.defineProperty(S = function t(e, r, n) {
          var i = this;
          (function(t, e) {
            if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
          })(this, t), r.forEach(function(t) {
            t in e && (void 0 !== n && "string" == typeof n[t] && y(e[t]) && w(e[t], n[t]) ? i[t] = n[t] : i[t] = e[t])
          })
        }, "prototype", {
          writable: !1
        }), S);

        function B(t, e, r, n) {
          if ("function" != typeof e) {
            if (y(e)) return w(e, t);
            if (2 === arguments.length) throw new c("expected", ["Function", "RegExp"], e);
            if ("object" !== i(t) || null === t) {
              var a = new d({
                actual: t,
                expected: e,
                message: r,
                operator: "deepStrictEqual",
                stackStartFn: n
              });
              throw a.operator = n.name, a
            }
            var u = Object.keys(e);
            if (e instanceof Error) u.push("name", "message");
            else if (0 === u.length) throw new f("error", e, "may not be an empty object");
            return void 0 === o && A(), u.forEach(function(i) {
              "string" == typeof t[i] && y(e[i]) && w(e[i], t[i]) || function(t, e, r, n, i, o) {
                if (!(r in t) || !s(t[r], e[r])) {
                  if (!n) {
                    var a = new O(t, i),
                      u = new O(e, i, t),
                      c = new d({
                        actual: a,
                        expected: u,
                        operator: "deepStrictEqual",
                        stackStartFn: o
                      });
                    throw c.actual = t, c.expected = e, c.operator = o.name, c
                  }
                  k({
                    actual: t,
                    expected: e,
                    message: n,
                    operator: o.name,
                    stackStartFn: o
                  })
                }
              }(t, e, i, r, u, n)
            }), !0
          }
          return void 0 !== e.prototype && t instanceof e || !Error.isPrototypeOf(e) && !0 === e.call({}, t)
        }

        function W(t) {
          if ("function" != typeof t) throw new c("fn", "Function", t);
          try {
            t()
          } catch (t) {
            return t
          }
          return P
        }

        function M(t) {
          return m(t) || null !== t && "object" === i(t) && "function" == typeof t.then && "function" == typeof t.catch
        }

        function C(t) {
          return Promise.resolve().then(function() {
            var e;
            if ("function" == typeof t) {
              if (!M(e = t())) throw new l("instance of Promise", "promiseFn", e)
            } else {
              if (!M(t)) throw new c("promiseFn", ["Function", "Promise"], t);
              e = t
            }
            return Promise.resolve().then(function() {
              return e
            }).then(function() {
              return P
            }).catch(function(t) {
              return t
            })
          })
        }

        function R(t, e, r, n) {
          if ("string" == typeof r) {
            if (4 === arguments.length) throw new c("error", ["Object", "Error", "Function", "RegExp"], r);
            if ("object" === i(e) && null !== e) {
              if (e.message === r) throw new u("error/message", 'The error message "'.concat(e.message, '" is identical to the message.'))
            } else if (e === r) throw new u("error/message", 'The error "'.concat(e, '" is identical to the message.'));
            n = r, r = void 0
          } else if (null != r && "object" !== i(r) && "function" != typeof r) throw new c("error", ["Object", "Error", "Function", "RegExp"], r);
          if (e === P) {
            var o = "";
            r && r.name && (o += " (".concat(r.name, ")")), o += n ? ": ".concat(n) : ".";
            var s = "rejects" === t.name ? "rejection" : "exception";
            k({
              actual: void 0,
              expected: r,
              operator: t.name,
              message: "Missing expected ".concat(s).concat(o),
              stackStartFn: t
            })
          }
          if (r && !B(e, r, n, t)) throw e
        }

        function N(t, e, r, n) {
          if (e !== P) {
            if ("string" == typeof r && (n = r, r = void 0), !r || B(e, r)) {
              var i = n ? ": ".concat(n) : ".",
                o = "doesNotReject" === t.name ? "rejection" : "exception";
              k({
                actual: e,
                expected: r,
                operator: t.name,
                message: "Got unwanted ".concat(o).concat(i, "\n") + 'Actual message: "'.concat(e && e.message, '"'),
                stackStartFn: t
              })
            }
            throw e
          }
        }

        function j(t, e, r, n, o) {
          if (!y(e)) throw new c("regexp", "RegExp", e);
          var s = "match" === o;
          if ("string" != typeof t || w(e, t) !== s) {
            if (r instanceof Error) throw r;
            var a = !r;
            r = r || ("string" != typeof t ? 'The "string" argument must be of type string. Received type ' + "".concat(i(t), " (").concat(p(t), ")") : (s ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(p(e), ". Input:\n\n").concat(p(t), "\n"));
            var u = new d({
              actual: t,
              expected: e,
              message: r,
              operator: o,
              stackStartFn: n
            });
            throw u.generatedMessage = a, u
          }
        }

        function _() {
          for (var t = arguments.length, e = Array(t), r = 0; t > r; r++) e[r] = arguments[r];
          x.apply(void 0, [_, e.length].concat(e))
        }
        E.throws = function t(e) {
          for (var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), i = 1; r > i; i++) n[i - 1] = arguments[i];
          R.apply(void 0, [t, W(e)].concat(n))
        }, E.rejects = function t(e) {
          for (var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), i = 1; r > i; i++) n[i - 1] = arguments[i];
          return C(e).then(function(e) {
            return R.apply(void 0, [t, e].concat(n))
          })
        }, E.doesNotThrow = function t(e) {
          for (var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), i = 1; r > i; i++) n[i - 1] = arguments[i];
          N.apply(void 0, [t, W(e)].concat(n))
        }, E.doesNotReject = function t(e) {
          for (var r = arguments.length, n = Array(r > 1 ? r - 1 : 0), i = 1; r > i; i++) n[i - 1] = arguments[i];
          return C(e).then(function(e) {
            return N.apply(void 0, [t, e].concat(n))
          })
        }, E.ifError = function t(e) {
          if (null != e) {
            var r = "ifError got unwanted exception: ";
            "object" === i(e) && "string" == typeof e.message ? 0 === e.message.length && e.constructor ? r += e.constructor.name : r += e.message : r += p(e);
            var n = new d({
                actual: e,
                expected: null,
                operator: "ifError",
                message: r,
                stackStartFn: t
              }),
              o = e.stack;
            if ("string" == typeof o) {
              var s = o.split("\n");
              s.shift();
              for (var a = n.stack.split("\n"), u = 0; u < s.length; u++) {
                var c = a.indexOf(s[u]);
                if (-1 !== c) {
                  a = a.slice(0, c);
                  break
                }
              }
              n.stack = "".concat(a.join("\n"), "\n").concat(s.join("\n"))
            }
            throw n
          }
        }, E.match = function t(e, r, n) {
          j(e, r, n, t, "match")
        }, E.doesNotMatch = function t(e, r, n) {
          j(e, r, n, t, "doesNotMatch")
        }, E.strict = g(_, E, {
          equal: E.strictEqual,
          deepEqual: E.deepStrictEqual,
          notEqual: E.notStrictEqual,
          notDeepEqual: E.notDeepStrictEqual
        }), E.strict.strict = E.strict
      },
      94306: t => {
        "use strict";
        const e = t => {
            if (t && "object" == typeof t && "cause" in t) {
              if ("function" == typeof t.cause) {
                const e = t.cause();
                return e instanceof Error ? e : void 0
              }
              return t.cause instanceof Error ? t.cause : void 0
            }
          },
          r = (t, n) => {
            if (!(t instanceof Error)) return "";
            const i = t.stack || "";
            if (n.has(t)) return i + "\ncauses have become circular...";
            const o = e(t);
            return o ? (n.add(t), i + "\ncaused by: " + r(o, n)) : i
          },
          n = (t, r, i) => {
            if (!(t instanceof Error)) return "";
            const o = i ? "" : t.message || "";
            if (r.has(t)) return o + ": ...";
            const s = e(t);
            if (s) {
              r.add(t);
              const e = "cause" in t && "function" == typeof t.cause;
              return o + (e ? "" : ": ") + n(s, r, e)
            }
            return o
          };
        t.exports = {
          findCauseByReference: (t, r) => {
            if (!(t && r && t instanceof Error && (r.prototype instanceof Error || r === Error))) return;
            const n = new Set;
            let i = t;
            for (; i && !n.has(i);) {
              if (n.add(i), i instanceof r) return i;
              i = e(i)
            }
          },
          getErrorCause: e,
          stackWithCauses: t => r(t, new Set),
          messageWithCauses: t => n(t, new Set)
        }
      },
      94459: t => {
        "use strict";
        t.exports = Number.isNaN || function(t) {
          return t != t
        }
      },
      94471: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV1R1 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey)
          }
          constructor(t, e) {
            this.workchain = t, this.publicKey = e;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEARAAAhP8AIN2k8mCBAgDXGCDXCx/tRNDTH9P/0VESuvKhIvkBVBBE+RDyovgAAdMfMSDXSpbTB9QC+wDe0aTIyx/L/8ntVEH98Ik=", "base64"))[0],
              o = (0, i.beginCell)().storeUint(0, 32).storeBuffer(e).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(t, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            let e = await t.getState();
            return "active" === e.state.type ? i.Cell.fromBoc(e.state.data)[0].beginParse().loadUint(32) : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            let e = i.SendMode.PAY_GAS_SEPARATELY;
            return null !== t.sendMode && void 0 !== t.sendMode && (e = t.sendMode), (0, o.createWalletTransferV1)({
              seqno: t.seqno,
              sendMode: e,
              secretKey: t.secretKey,
              message: t.message
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    message: (0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV1R1 = s
      },
      94641: (t, e, r) => {
        const n = r(50560);
        t.exports = (t, e, r) => 0 === n(t, e, r)
      },
      94643: (t, e, r) => {
        function n(t) {
          try {
            if (!r.g.localStorage) return !1
          } catch {
            return !1
          }
          var e = r.g.localStorage[t];
          return null != e && "true" === (e + "").toLowerCase()
        }
        t.exports = function(t, e) {
          if (n("noDeprecation")) return t;
          var r = !1;
          return function() {
            if (!r) {
              if (n("throwDeprecation")) throw Error(e);
              n("traceDeprecation") ? console.trace(e) : console.warn(e), r = !0
            }
            return t.apply(this, arguments)
          }
        }
      },
      95251: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e, r) {
          if ((0, i.default)(t), r && r.strictMode && !t.startsWith("+")) return !1;
          if (Array.isArray(e)) return e.some(function(e) {
            return !(!o.hasOwnProperty(e) || !o[e].test(t))
          });
          if (e in o) return o[e].test(t);
          if (!e || "any" === e) {
            for (var n in o)
              if (o.hasOwnProperty(n) && o[n].test(t)) return !0;
            return !1
          }
          throw Error("Invalid locale '".concat(e, "'"))
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = {
            "am-AM": /^(\+?374|0)((10|[9|7][0-9])\d{6}$|[2-4]\d{7}$)/,
            "ar-AE": /^((\+?971)|0)?5[024568]\d{7}$/,
            "ar-BH": /^(\+?973)?(3|6)\d{7}$/,
            "ar-DZ": /^(\+?213|0)(5|6|7)\d{8}$/,
            "ar-LB": /^(\+?961)?((3|81)\d{6}|7\d{7})$/,
            "ar-EG": /^((\+?20)|0)?1[0125]\d{8}$/,
            "ar-IQ": /^(\+?964|0)?7[0-9]\d{8}$/,
            "ar-JO": /^(\+?962|0)?7[789]\d{7}$/,
            "ar-KW": /^(\+?965)([569]\d{7}|41\d{6})$/,
            "ar-LY": /^((\+?218)|0)?(9[1-6]\d{7}|[1-8]\d{7,9})$/,
            "ar-MA": /^(?:(?:\+|00)212|0)[5-7]\d{8}$/,
            "ar-OM": /^((\+|00)968)?(9[1-9])\d{6}$/,
            "ar-PS": /^(\+?970|0)5[6|9](\d{7})$/,
            "ar-SA": /^(!?(\+?966)|0)?5\d{8}$/,
            "ar-SD": /^((\+?249)|0)?(9[012369]|1[012])\d{7}$/,
            "ar-SY": /^(!?(\+?963)|0)?9\d{8}$/,
            "ar-TN": /^(\+?216)?[2459]\d{7}$/,
            "az-AZ": /^(\+994|0)(10|5[015]|7[07]|99)\d{7}$/,
            "bs-BA": /^((((\+|00)3876)|06))((([0-3]|[5-6])\d{6})|(4\d{7}))$/,
            "be-BY": /^(\+?375)?(24|25|29|33|44)\d{7}$/,
            "bg-BG": /^(\+?359|0)?8[789]\d{7}$/,
            "bn-BD": /^(\+?880|0)1[13456789][0-9]{8}$/,
            "ca-AD": /^(\+376)?[346]\d{5}$/,
            "cs-CZ": /^(\+?420)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            "da-DK": /^(\+?45)?\s?\d{2}\s?\d{2}\s?\d{2}\s?\d{2}$/,
            "de-DE": /^((\+49|0)1)(5[0-25-9]\d|6([23]|0\d?)|7([0-57-9]|6\d))\d{7,9}$/,
            "de-AT": /^(\+43|0)\d{1,4}\d{3,12}$/,
            "de-CH": /^(\+41|0)([1-9])\d{1,9}$/,
            "de-LU": /^(\+352)?((6\d1)\d{6})$/,
            "dv-MV": /^(\+?960)?(7[2-9]|9[1-9])\d{5}$/,
            "el-GR": /^(\+?30|0)?6(8[5-9]|9(?![26])[0-9])\d{7}$/,
            "el-CY": /^(\+?357?)?(9(9|6)\d{6})$/,
            "en-AI": /^(\+?1|0)264(?:2(35|92)|4(?:6[1-2]|76|97)|5(?:3[6-9]|8[1-4])|7(?:2(4|9)|72))\d{4}$/,
            "en-AU": /^(\+?61|0)4\d{8}$/,
            "en-AG": /^(?:\+1|1)268(?:464|7(?:1[3-9]|[28]\d|3[0246]|64|7[0-689]))\d{4}$/,
            "en-BM": /^(\+?1)?441(((3|7)\d{6}$)|(5[0-3][0-9]\d{4}$)|(59\d{5}$))/,
            "en-BS": /^(\+?1[-\s]?|0)?\(?242\)?[-\s]?\d{3}[-\s]?\d{4}$/,
            "en-GB": /^(\+?44|0)7\d{9}$/,
            "en-GG": /^(\+?44|0)1481\d{6}$/,
            "en-GH": /^(\+233|0)(20|50|24|54|27|57|26|56|23|28|55|59)\d{7}$/,
            "en-GY": /^(\+592|0)6\d{6}$/,
            "en-HK": /^(\+?852[-\s]?)?[456789]\d{3}[-\s]?\d{4}$/,
            "en-MO": /^(\+?853[-\s]?)?[6]\d{3}[-\s]?\d{4}$/,
            "en-IE": /^(\+?353|0)8[356789]\d{7}$/,
            "en-IN": /^(\+?91|0)?[6789]\d{9}$/,
            "en-JM": /^(\+?876)?\d{7}$/,
            "en-KE": /^(\+?254|0)(7|1)\d{8}$/,
            "fr-CF": /^(\+?236| ?)(70|75|77|72|21|22)\d{6}$/,
            "en-SS": /^(\+?211|0)(9[1257])\d{7}$/,
            "en-KI": /^((\+686|686)?)?( )?((6|7)(2|3|8)[0-9]{6})$/,
            "en-KN": /^(?:\+1|1)869(?:46\d|48[89]|55[6-8]|66\d|76[02-7])\d{4}$/,
            "en-LS": /^(\+?266)(22|28|57|58|59|27|52)\d{6}$/,
            "en-MT": /^(\+?356|0)?(99|79|77|21|27|22|25)[0-9]{6}$/,
            "en-MU": /^(\+?230|0)?\d{8}$/,
            "en-NA": /^(\+?264|0)(6|8)\d{7}$/,
            "en-NG": /^(\+?234|0)?[789]\d{9}$/,
            "en-NZ": /^(\+?64|0)[28]\d{7,9}$/,
            "en-PG": /^(\+?675|0)?(7\d|8[18])\d{6}$/,
            "en-PK": /^((00|\+)?92|0)3[0-6]\d{8}$/,
            "en-PH": /^(09|\+639)\d{9}$/,
            "en-RW": /^(\+?250|0)?[7]\d{8}$/,
            "en-SG": /^(\+65)?[3689]\d{7}$/,
            "en-SL": /^(\+?232|0)\d{8}$/,
            "en-TZ": /^(\+?255|0)?[67]\d{8}$/,
            "en-UG": /^(\+?256|0)?[7]\d{8}$/,
            "en-US": /^((\+1|1)?( |-)?)?(\([2-9][0-9]{2}\)|[2-9][0-9]{2})( |-)?([2-9][0-9]{2}( |-)?[0-9]{4})$/,
            "en-ZA": /^(\+?27|0)\d{9}$/,
            "en-ZM": /^(\+?26)?09[567]\d{7}$/,
            "en-ZW": /^(\+263)[0-9]{9}$/,
            "en-BW": /^(\+?267)?(7[1-8]{1})\d{6}$/,
            "es-AR": /^\+?549(11|[2368]\d)\d{8}$/,
            "es-BO": /^(\+?591)?(6|7)\d{7}$/,
            "es-CO": /^(\+?57)?3(0(0|1|2|4|5)|1\d|2[0-4]|5(0|1))\d{7}$/,
            "es-CL": /^(\+?56|0)[2-9]\d{1}\d{7}$/,
            "es-CR": /^(\+506)?[2-8]\d{7}$/,
            "es-CU": /^(\+53|0053)?5\d{7}$/,
            "es-DO": /^(\+?1)?8[024]9\d{7}$/,
            "es-HN": /^(\+?504)?[9|8|3|2]\d{7}$/,
            "es-EC": /^(\+?593|0)([2-7]|9[2-9])\d{7}$/,
            "es-ES": /^(\+?34)?[6|7]\d{8}$/,
            "es-PE": /^(\+?51)?9\d{8}$/,
            "es-MX": /^(\+?52)?(1|01)?\d{10,11}$/,
            "es-NI": /^(\+?505)\d{7,8}$/,
            "es-PA": /^(\+?507)\d{7,8}$/,
            "es-PY": /^(\+?595|0)9[9876]\d{7}$/,
            "es-SV": /^(\+?503)?[67]\d{7}$/,
            "es-UY": /^(\+598|0)9[1-9][\d]{6}$/,
            "es-VE": /^(\+?58)?(2|4)\d{9}$/,
            "et-EE": /^(\+?372)?\s?(5|8[1-4])\s?([0-9]\s?){6,7}$/,
            "fa-IR": /^(\+?98[\-\s]?|0)9[0-39]\d[\-\s]?\d{3}[\-\s]?\d{4}$/,
            "fi-FI": /^(\+?358|0)\s?(4[0-6]|50)\s?(\d\s?){4,8}$/,
            "fj-FJ": /^(\+?679)?\s?\d{3}\s?\d{4}$/,
            "fo-FO": /^(\+?298)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
            "fr-BF": /^(\+226|0)[67]\d{7}$/,
            "fr-BJ": /^(\+229)\d{8}$/,
            "fr-CD": /^(\+?243|0)?(8|9)\d{8}$/,
            "fr-CM": /^(\+?237)6[0-9]{8}$/,
            "fr-FR": /^(\+?33|0)[67]\d{8}$/,
            "fr-GF": /^(\+?594|0|00594)[67]\d{8}$/,
            "fr-GP": /^(\+?590|0|00590)[67]\d{8}$/,
            "fr-MQ": /^(\+?596|0|00596)[67]\d{8}$/,
            "fr-PF": /^(\+?689)?8[789]\d{6}$/,
            "fr-RE": /^(\+?262|0|00262)[67]\d{8}$/,
            "fr-WF": /^(\+681)?\d{6}$/,
            "he-IL": /^(\+972|0)([23489]|5[012345689]|77)[1-9]\d{6}$/,
            "hu-HU": /^(\+?36|06)(20|30|31|50|70)\d{7}$/,
            "id-ID": /^(\+?62|0)8(1[123456789]|2[1238]|3[1238]|5[12356789]|7[78]|9[56789]|8[123456789])([\s?|\d]{5,11})$/,
            "ir-IR": /^(\+98|0)?9\d{9}$/,
            "it-IT": /^(\+?39)?\s?3\d{2} ?\d{6,7}$/,
            "it-SM": /^((\+378)|(0549)|(\+390549)|(\+3780549))?6\d{5,9}$/,
            "ja-JP": /^(\+81[ \-]?(\(0\))?|0)[6789]0[ \-]?\d{4}[ \-]?\d{4}$/,
            "ka-GE": /^(\+?995)?(79\d{7}|5\d{8})$/,
            "kk-KZ": /^(\+?7|8)?7\d{9}$/,
            "kl-GL": /^(\+?299)?\s?\d{2}\s?\d{2}\s?\d{2}$/,
            "ko-KR": /^((\+?82)[ \-]?)?0?1([0|1|6|7|8|9]{1})[ \-]?\d{3,4}[ \-]?\d{4}$/,
            "ky-KG": /^(\+?7\s?\+?7|0)\s?\d{2}\s?\d{3}\s?\d{4}$/,
            "lt-LT": /^(\+370|8)\d{8}$/,
            "lv-LV": /^(\+?371)2\d{7}$/,
            "mg-MG": /^((\+?261|0)(2|3)\d)?\d{7}$/,
            "mn-MN": /^(\+|00|011)?976(77|81|88|91|94|95|96|99)\d{6}$/,
            "my-MM": /^(\+?959|09|9)(2[5-7]|3[1-2]|4[0-5]|6[6-9]|7[5-9]|9[6-9])[0-9]{7}$/,
            "ms-MY": /^(\+?60|0)1(([0145](-|\s)?\d{7,8})|([236-9](-|\s)?\d{7}))$/,
            "mz-MZ": /^(\+?258)?8[234567]\d{7}$/,
            "nb-NO": /^(\+?47)?[49]\d{7}$/,
            "ne-NP": /^(\+?977)?9[78]\d{8}$/,
            "nl-BE": /^(\+?32|0)4\d{8}$/,
            "nl-NL": /^(((\+|00)?31\(0\))|((\+|00)?31)|0)6{1}\d{8}$/,
            "nl-AW": /^(\+)?297(56|59|64|73|74|99)\d{5}$/,
            "nn-NO": /^(\+?47)?[49]\d{7}$/,
            "pl-PL": /^(\+?48)? ?([5-8]\d|45) ?\d{3} ?\d{2} ?\d{2}$/,
            "pt-BR": /^((\+?55\ ?[1-9]{2}\ ?)|(\+?55\ ?\([1-9]{2}\)\ ?)|(0[1-9]{2}\ ?)|(\([1-9]{2}\)\ ?)|([1-9]{2}\ ?))((\d{4}\-?\d{4})|(9[1-9]{1}\d{3}\-?\d{4}))$/,
            "pt-PT": /^(\+?351)?9[1236]\d{7}$/,
            "pt-AO": /^(\+244)\d{9}$/,
            "ro-MD": /^(\+?373|0)((6(0|1|2|6|7|8|9))|(7(6|7|8|9)))\d{6}$/,
            "ro-RO": /^(\+?40|0)\s?7\d{2}(\/|\s|\.|-)?\d{3}(\s|\.|-)?\d{3}$/,
            "ru-RU": /^(\+?7|8)?9\d{9}$/,
            "si-LK": /^(?:0|94|\+94)?(7(0|1|2|4|5|6|7|8)( |-)?)\d{7}$/,
            "sl-SI": /^(\+386\s?|0)(\d{1}\s?\d{3}\s?\d{2}\s?\d{2}|\d{2}\s?\d{3}\s?\d{3})$/,
            "sk-SK": /^(\+?421)? ?[1-9][0-9]{2} ?[0-9]{3} ?[0-9]{3}$/,
            "so-SO": /^(\+?252|0)((6[0-9])\d{7}|(7[1-9])\d{7})$/,
            "sq-AL": /^(\+355|0)6[789]\d{6}$/,
            "sr-RS": /^(\+3816|06)[- \d]{5,9}$/,
            "sv-SE": /^(\+?46|0)[\s\-]?7[\s\-]?[02369]([\s\-]?\d){7}$/,
            "tg-TJ": /^(\+?992)?[5][5]\d{7}$/,
            "th-TH": /^(\+66|66|0)\d{9}$/,
            "tr-TR": /^(\+?90|0)?5\d{9}$/,
            "tk-TM": /^(\+993|993|8)\d{8}$/,
            "uk-UA": /^(\+?38|8)?0\d{9}$/,
            "uz-UZ": /^(\+?998)?(6[125-79]|7[1-69]|88|9\d)\d{7}$/,
            "vi-VN": /^((\+?84)|0)((3([2-9]))|(5([25689]))|(7([0|6-9]))|(8([1-9]))|(9([0-9])))([0-9]{7})$/,
            "zh-CN": /^((\+|00)86)?(1[3-9]|9[28])\d{9}$/,
            "zh-TW": /^(\+?886\-?|0)?9\d{8}$/,
            "dz-BT": /^(\+?975|0)?(17|16|77|02)\d{6}$/,
            "ar-YE": /^(((\+|00)9677|0?7)[0137]\d{7}|((\+|00)967|0)[1-7]\d{6})$/,
            "ar-EH": /^(\+?212|0)[\s\-]?(5288|5289)[\s\-]?\d{5}$/,
            "fa-AF": /^(\+93|0)?(2{1}[0-8]{1}|[3-5]{1}[0-4]{1})(\d{7})$/
          };
        o["en-CA"] = o["en-US"], o["fr-CA"] = o["en-CA"], o["fr-BE"] = o["nl-BE"], o["zh-HK"] = o["en-HK"], o["zh-MO"] = o["en-MO"], o["ga-IE"] = o["en-IE"], o["fr-CH"] = o["de-CH"], o["it-CH"] = o["fr-CH"];
        var s = Object.keys(o);
        e.locales = s
      },
      95255: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      95364: (t, e, r) => {
        "use strict";
        var n = r(92861).Buffer;
        t.exports = function(t) {
          if (t.length >= 255) throw new TypeError("Alphabet too long");
          for (var e = new Uint8Array(256), r = 0; r < e.length; r++) e[r] = 255;
          for (var i = 0; i < t.length; i++) {
            var o = t.charAt(i),
              s = o.charCodeAt(0);
            if (255 !== e[s]) throw new TypeError(o + " is ambiguous");
            e[s] = i
          }
          var a = t.length,
            u = t.charAt(0),
            c = Math.log(a) / Math.log(256),
            f = Math.log(256) / Math.log(a);

          function l(t) {
            if ("string" != typeof t) throw new TypeError("Expected String");
            if (0 === t.length) return n.alloc(0);
            for (var r = 0, i = 0, o = 0; t[r] === u;) i++, r++;
            for (var s = (t.length - r) * c + 1 >>> 0, f = new Uint8Array(s); r < t.length;) {
              var l = t.charCodeAt(r);
              if (l > 255) return;
              var h = e[l];
              if (255 === h) return;
              for (var d = 0, p = s - 1;
                (0 !== h || o > d) && -1 !== p; p--, d++) h += a * f[p] >>> 0, f[p] = h % 256 >>> 0, h = h / 256 >>> 0;
              if (0 !== h) throw Error("Non-zero carry");
              o = d, r++
            }
            for (var b = s - o; b !== s && 0 === f[b];) b++;
            var m = n.allocUnsafe(i + (s - b));
            m.fill(0, 0, i);
            for (var y = i; b !== s;) m[y++] = f[b++];
            return m
          }
          return {
            encode: function(e) {
              if ((Array.isArray(e) || e instanceof Uint8Array) && (e = n.from(e)), !n.isBuffer(e)) throw new TypeError("Expected Buffer");
              if (0 === e.length) return "";
              for (var r = 0, i = 0, o = 0, s = e.length; o !== s && 0 === e[o];) o++, r++;
              for (var c = (s - o) * f + 1 >>> 0, l = new Uint8Array(c); o !== s;) {
                for (var h = e[o], d = 0, p = c - 1;
                  (0 !== h || i > d) && -1 !== p; p--, d++) h += 256 * l[p] >>> 0, l[p] = h % a >>> 0, h = h / a >>> 0;
                if (0 !== h) throw Error("Non-zero carry");
                i = d, o++
              }
              for (var b = c - i; b !== c && 0 === l[b];) b++;
              for (var m = u.repeat(r); c > b; ++b) m += t.charAt(l[b]);
              return m
            },
            decodeUnsafe: l,
            decode: function(t) {
              var e = l(t);
              if (e) return e;
              throw Error("Non-base" + a + " character")
            }
          }
        }
      },
      95415: function(t, e, r) {
        "use strict";
        var n = r(48287).Buffer,
          i = this && this.nt || function(t) {
            return t && t._ ? t : {
              default: t
            }
          };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.openBox = e.sealBox = e.signVerify = e.sign = e.keyPairFromSeed = e.keyPairFromSecretKey = void 0;
        const o = i(r(88947));
        e.keyPairFromSecretKey = function(t) {
          let e = o.default.sign.keyPair.fromSecretKey(new Uint8Array(t));
          return {
            publicKey: n.from(e.publicKey),
            secretKey: n.from(e.secretKey)
          }
        }, e.keyPairFromSeed = function(t) {
          let e = o.default.sign.keyPair.fromSeed(new Uint8Array(t));
          return {
            publicKey: n.from(e.publicKey),
            secretKey: n.from(e.secretKey)
          }
        }, e.sign = function(t, e) {
          return n.from(o.default.sign.detached(new Uint8Array(t), new Uint8Array(e)))
        }, e.signVerify = function(t, e, r) {
          return o.default.sign.detached.verify(new Uint8Array(t), new Uint8Array(e), new Uint8Array(r))
        }, e.sealBox = function(t, e, r) {
          return n.from(o.default.secretbox(t, e, r))
        }, e.openBox = function(t, e, r) {
          let i = o.default.secretbox.open(t, e, r);
          return i ? n.from(i) : null
        }
      },
      96286: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.add5L = e.add5H = e.add4H = e.add4L = e.add3H = e.add3L = e.add = e.rotlBL = e.rotlBH = e.rotlSL = e.rotlSH = e.rotr32L = e.rotr32H = e.rotrBL = e.rotrBH = e.rotrSL = e.rotrSH = e.shrSL = e.shrSH = e.toBig = e.split = e.fromBig = void 0;
        const r = BigInt(2 ** 32 - 1),
          n = BigInt(32);

        function i(t, e = !1) {
          return e ? {
            h: +(t & r),
            l: +(t >> n & r)
          } : {
            h: 0 | +(t >> n & r),
            l: 0 | +(t & r)
          }
        }

        function o(t, e = !1) {
          let r = new Uint32Array(t.length),
            n = new Uint32Array(t.length);
          for (let o = 0; o < t.length; o++) {
            const {
              h: s,
              l: a
            } = i(t[o], e);
            [r[o], n[o]] = [s, a]
          }
          return [r, n]
        }
        e.fromBig = i, e.split = o;
        const s = (t, e) => BigInt(t >>> 0) << n | BigInt(e >>> 0);
        e.toBig = s;
        const a = (t, e, r) => t >>> r;
        e.shrSH = a;
        const u = (t, e, r) => t << 32 - r | e >>> r;
        e.shrSL = u;
        const c = (t, e, r) => t >>> r | e << 32 - r;
        e.rotrSH = c;
        const f = (t, e, r) => t << 32 - r | e >>> r;
        e.rotrSL = f;
        const l = (t, e, r) => t << 64 - r | e >>> r - 32;
        e.rotrBH = l;
        const h = (t, e, r) => t >>> r - 32 | e << 64 - r;
        e.rotrBL = h;
        const d = (t, e) => e;
        e.rotr32H = d;
        const p = (t, e) => t;
        e.rotr32L = p;
        const b = (t, e, r) => t << r | e >>> 32 - r;
        e.rotlSH = b;
        const m = (t, e, r) => e << r | t >>> 32 - r;
        e.rotlSL = m;
        const y = (t, e, r) => e << r - 32 | t >>> 64 - r;
        e.rotlBH = y;
        const g = (t, e, r) => t << r - 32 | e >>> 64 - r;

        function v(t, e, r, n) {
          const i = (e >>> 0) + (n >>> 0);
          return {
            h: t + r + (i / 4294967296 | 0) | 0,
            l: 0 | i
          }
        }
        e.rotlBL = g, e.add = v;
        const w = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0);
        e.add3L = w;
        const A = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0;
        e.add3H = A;
        const T = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0);
        e.add4L = T;
        const E = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0;
        e.add4H = E;
        const P = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0);
        e.add5L = P;
        const k = (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0;
        e.add5H = k;
        const x = {
          fromBig: i,
          split: o,
          toBig: s,
          shrSH: a,
          shrSL: u,
          rotrSH: c,
          rotrSL: f,
          rotrBH: l,
          rotrBL: h,
          rotr32H: d,
          rotr32L: p,
          rotlSH: b,
          rotlSL: m,
          rotlBH: y,
          rotlBL: g,
          add: v,
          add3L: w,
          add3H: A,
          add4L: T,
          add4H: E,
          add5H: k,
          add5L: P
        };
        e.default = x
      },
      96305: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeTransaction = e.loadTransaction = void 0;
        const n = r(65871),
          i = r(97590),
          o = r(87676),
          s = r(10574),
          a = r(14660),
          u = r(48178),
          c = r(13543);
        e.loadTransaction = function(t) {
          let e = t.asCell();
          if (7 !== t.loadUint(4)) throw Error("Invalid data");
          let r = t.loadUintBig(256),
            n = t.loadUintBig(64),
            f = t.loadUintBig(256),
            l = t.loadUintBig(64),
            h = t.loadUint(32),
            d = t.loadUint(15),
            p = (0, o.loadAccountStatus)(t),
            b = (0, o.loadAccountStatus)(t),
            m = t.loadRef().beginParse(),
            y = m.loadBit() ? (0, u.loadMessage)(m.loadRef().beginParse()) : void 0,
            g = m.loadDict(i.Dictionary.Keys.Uint(15), u.MessageValue);
          return m.endParse(), {
            address: r,
            lt: n,
            prevTransactionHash: f,
            prevTransactionLt: l,
            now: h,
            outMessagesCount: d,
            oldStatus: p,
            endStatus: b,
            inMessage: y,
            outMessages: g,
            totalFees: (0, s.loadCurrencyCollection)(t),
            stateUpdate: (0, a.loadHashUpdate)(t.loadRef().beginParse()),
            description: (0, c.loadTransactionDescription)(t.loadRef().beginParse()),
            raw: e,
            hash: () => e.hash()
          }
        }, e.storeTransaction = function(t) {
          return e => {
            e.storeUint(7, 4), e.storeUint(t.address, 256), e.storeUint(t.lt, 64), e.storeUint(t.prevTransactionHash, 256), e.storeUint(t.prevTransactionLt, 64), e.storeUint(t.now, 32), e.storeUint(t.outMessagesCount, 15), e.store((0, o.storeAccountStatus)(t.oldStatus)), e.store((0, o.storeAccountStatus)(t.endStatus));
            let r = (0, n.beginCell)();
            t.inMessage ? (r.storeBit(!0), r.storeRef((0, n.beginCell)().store((0, u.storeMessage)(t.inMessage)))) : r.storeBit(!1), r.storeDict(t.outMessages), e.storeRef(r), e.store((0, s.storeCurrencyCollection)(t.totalFees)), e.storeRef((0, n.beginCell)().store((0, a.storeHashUpdate)(t.stateUpdate))), e.storeRef((0, n.beginCell)().store((0, c.storeTransactionDescription)(t.description)))
          }
        }
      },
      96370: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        })
      },
      96760: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")();
        i.exportSymbol("TronWebProto.ProposalApproveContract", null, o), i.exportSymbol("TronWebProto.ProposalCreateContract", null, o), i.exportSymbol("TronWebProto.ProposalDeleteContract", null, o), TronWebProto.ProposalApproveContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ProposalApproveContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ProposalApproveContract.displayName = "TronWebProto.ProposalApproveContract"), TronWebProto.ProposalCreateContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ProposalCreateContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ProposalCreateContract.displayName = "TronWebProto.ProposalCreateContract"), TronWebProto.ProposalDeleteContract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.ProposalDeleteContract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.ProposalDeleteContract.displayName = "TronWebProto.ProposalDeleteContract"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalApproveContract.prototype.toObject = function(t) {
          return TronWebProto.ProposalApproveContract.toObject(t, this)
        }, TronWebProto.ProposalApproveContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            proposalId: n.Message.getFieldWithDefault(e, 2, 0),
            isAddApproval: n.Message.getBooleanFieldWithDefault(e, 3, !1)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ProposalApproveContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ProposalApproveContract;
          return TronWebProto.ProposalApproveContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ProposalApproveContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setProposalId(r);
              break;
            case 3:
              r = e.readBool(), t.setIsAddApproval(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ProposalApproveContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ProposalApproveContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ProposalApproveContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getProposalId()) && e.writeInt64(2, r), (r = t.getIsAddApproval()) && e.writeBool(3, r)
        }, TronWebProto.ProposalApproveContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ProposalApproveContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ProposalApproveContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ProposalApproveContract.prototype.getProposalId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ProposalApproveContract.prototype.setProposalId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.ProposalApproveContract.prototype.getIsAddApproval = function() {
          return n.Message.getBooleanFieldWithDefault(this, 3, !1)
        }, TronWebProto.ProposalApproveContract.prototype.setIsAddApproval = function(t) {
          return n.Message.setProto3BooleanField(this, 3, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalCreateContract.prototype.toObject = function(t) {
          return TronWebProto.ProposalCreateContract.toObject(t, this)
        }, TronWebProto.ProposalCreateContract.toObject = function(t, e) {
          var r, n = {
            ownerAddress: e.getOwnerAddress_asB64(),
            parametersMap: (r = e.getParametersMap()) ? r.toObject(t, void 0) : []
          };
          return t && (n.$jspbMessageInstance = e), n
        }), TronWebProto.ProposalCreateContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ProposalCreateContract;
          return TronWebProto.ProposalCreateContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ProposalCreateContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = t.getParametersMap(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readInt64, n.BinaryReader.prototype.readInt64, null, 0, 0)
              });
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ProposalCreateContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ProposalCreateContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ProposalCreateContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getParametersMap(!0)) && r.getLength() > 0 && r.serializeBinary(2, e, n.BinaryWriter.prototype.writeInt64, n.BinaryWriter.prototype.writeInt64)
        }, TronWebProto.ProposalCreateContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ProposalCreateContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ProposalCreateContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ProposalCreateContract.prototype.getParametersMap = function(t) {
          return n.Message.getMapField(this, 2, t, null)
        }, TronWebProto.ProposalCreateContract.prototype.clearParametersMap = function() {
          return this.getParametersMap().clear(), this
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.ProposalDeleteContract.prototype.toObject = function(t) {
          return TronWebProto.ProposalDeleteContract.toObject(t, this)
        }, TronWebProto.ProposalDeleteContract.toObject = function(t, e) {
          var r = {
            ownerAddress: e.getOwnerAddress_asB64(),
            proposalId: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.ProposalDeleteContract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.ProposalDeleteContract;
          return TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.ProposalDeleteContract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setOwnerAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setProposalId(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.ProposalDeleteContract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.ProposalDeleteContract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.ProposalDeleteContract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getOwnerAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getProposalId()) && e.writeInt64(2, r)
        }, TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getOwnerAddress())
        }, TronWebProto.ProposalDeleteContract.prototype.getOwnerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getOwnerAddress())
        }, TronWebProto.ProposalDeleteContract.prototype.setOwnerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.ProposalDeleteContract.prototype.getProposalId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.ProposalDeleteContract.prototype.setProposalId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, i.object.extend(e, TronWebProto)
      },
      96815: function(t, e) {
        var r, n;
        "u" > typeof globalThis ? globalThis : "u" > typeof self && self, void 0 !== (n = "function" == typeof(r = function(t) {
          "use strict";
          if (!globalThis.chrome?.runtime?.id) throw Error("This script should only be loaded in a browser extension.");
          if (typeof globalThis.browser > "u" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
            const e = "The message port closed before a response was received.",
              r = t => {
                const r = {
                  alarms: {
                    clear: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    clearAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    get: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    getAll: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  bookmarks: {
                    create: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    get: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getChildren: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getRecent: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getSubTree: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getTree: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    move: {
                      minArgs: 2,
                      maxArgs: 2
                    },
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeTree: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    search: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    update: {
                      minArgs: 2,
                      maxArgs: 2
                    }
                  },
                  browserAction: {
                    disable: {
                      minArgs: 0,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    enable: {
                      minArgs: 0,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    getBadgeBackgroundColor: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getBadgeText: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getPopup: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getTitle: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    openPopup: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    setBadgeBackgroundColor: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    setBadgeText: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    setIcon: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    setPopup: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    setTitle: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    }
                  },
                  browsingData: {
                    remove: {
                      minArgs: 2,
                      maxArgs: 2
                    },
                    removeCache: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeCookies: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeDownloads: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeFormData: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeHistory: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeLocalStorage: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removePasswords: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removePluginData: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    settings: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  commands: {
                    getAll: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  contextMenus: {
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    update: {
                      minArgs: 2,
                      maxArgs: 2
                    }
                  },
                  cookies: {
                    get: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getAll: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getAllCookieStores: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    set: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  devtools: {
                    inspectedWindow: {
                      eval: {
                        minArgs: 1,
                        maxArgs: 2,
                        singleCallbackArg: !1
                      }
                    },
                    panels: {
                      create: {
                        minArgs: 3,
                        maxArgs: 3,
                        singleCallbackArg: !0
                      },
                      elements: {
                        createSidebarPane: {
                          minArgs: 1,
                          maxArgs: 1
                        }
                      }
                    }
                  },
                  downloads: {
                    cancel: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    download: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    erase: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getFileIcon: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    open: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    pause: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeFile: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    resume: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    search: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    show: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    }
                  },
                  extension: {
                    isAllowedFileSchemeAccess: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    isAllowedIncognitoAccess: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  history: {
                    addUrl: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    deleteAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    deleteRange: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    deleteUrl: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getVisits: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    search: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  i18n: {
                    detectLanguage: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getAcceptLanguages: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  identity: {
                    launchWebAuthFlow: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  idle: {
                    queryState: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  management: {
                    get: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    getSelf: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    setEnabled: {
                      minArgs: 2,
                      maxArgs: 2
                    },
                    uninstallSelf: {
                      minArgs: 0,
                      maxArgs: 1
                    }
                  },
                  notifications: {
                    clear: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    create: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    getAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    getPermissionLevel: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    update: {
                      minArgs: 2,
                      maxArgs: 2
                    }
                  },
                  pageAction: {
                    getPopup: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getTitle: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    hide: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    setIcon: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    setPopup: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    setTitle: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    },
                    show: {
                      minArgs: 1,
                      maxArgs: 1,
                      fallbackToNoCallback: !0
                    }
                  },
                  permissions: {
                    contains: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getAll: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    request: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  runtime: {
                    getBackgroundPage: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    getPlatformInfo: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    openOptionsPage: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    requestUpdateCheck: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    sendMessage: {
                      minArgs: 1,
                      maxArgs: 3
                    },
                    sendNativeMessage: {
                      minArgs: 2,
                      maxArgs: 2
                    },
                    setUninstallURL: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  sessions: {
                    getDevices: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    getRecentlyClosed: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    restore: {
                      minArgs: 0,
                      maxArgs: 1
                    }
                  },
                  storage: {
                    local: {
                      clear: {
                        minArgs: 0,
                        maxArgs: 0
                      },
                      get: {
                        minArgs: 0,
                        maxArgs: 1
                      },
                      getBytesInUse: {
                        minArgs: 0,
                        maxArgs: 1
                      },
                      remove: {
                        minArgs: 1,
                        maxArgs: 1
                      },
                      set: {
                        minArgs: 1,
                        maxArgs: 1
                      }
                    },
                    managed: {
                      get: {
                        minArgs: 0,
                        maxArgs: 1
                      },
                      getBytesInUse: {
                        minArgs: 0,
                        maxArgs: 1
                      }
                    },
                    sync: {
                      clear: {
                        minArgs: 0,
                        maxArgs: 0
                      },
                      get: {
                        minArgs: 0,
                        maxArgs: 1
                      },
                      getBytesInUse: {
                        minArgs: 0,
                        maxArgs: 1
                      },
                      remove: {
                        minArgs: 1,
                        maxArgs: 1
                      },
                      set: {
                        minArgs: 1,
                        maxArgs: 1
                      }
                    }
                  },
                  tabs: {
                    captureVisibleTab: {
                      minArgs: 0,
                      maxArgs: 2
                    },
                    create: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    detectLanguage: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    discard: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    duplicate: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    executeScript: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    get: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getCurrent: {
                      minArgs: 0,
                      maxArgs: 0
                    },
                    getZoom: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    getZoomSettings: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    goBack: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    goForward: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    highlight: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    insertCSS: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    move: {
                      minArgs: 2,
                      maxArgs: 2
                    },
                    query: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    reload: {
                      minArgs: 0,
                      maxArgs: 2
                    },
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    removeCSS: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    sendMessage: {
                      minArgs: 2,
                      maxArgs: 3
                    },
                    setZoom: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    setZoomSettings: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    update: {
                      minArgs: 1,
                      maxArgs: 2
                    }
                  },
                  topSites: {
                    get: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  webNavigation: {
                    getAllFrames: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    getFrame: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  },
                  webRequest: {
                    handlerBehaviorChanged: {
                      minArgs: 0,
                      maxArgs: 0
                    }
                  },
                  windows: {
                    create: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    get: {
                      minArgs: 1,
                      maxArgs: 2
                    },
                    getAll: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    getCurrent: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    getLastFocused: {
                      minArgs: 0,
                      maxArgs: 1
                    },
                    remove: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    update: {
                      minArgs: 2,
                      maxArgs: 2
                    }
                  }
                };
                if (0 === Object.keys(r).length) throw Error("api-metadata.json has not been included in browser-polyfill");
                class n extends WeakMap {
                  constructor(t, e = void 0) {
                    super(e), this.createItem = t
                  }
                  get(t) {
                    return this.has(t) || this.set(t, this.createItem(t)), super.get(t)
                  }
                }
                const i = (e, r) => (...n) => {
                    t.runtime.lastError ? e.reject(Error(t.runtime.lastError.message)) : r.singleCallbackArg || 1 >= n.length && !1 !== r.singleCallbackArg ? e.resolve(n[0]) : e.resolve(n)
                  },
                  o = t => 1 == t ? "argument" : "arguments",
                  s = (t, e, r) => new Proxy(e, {
                    apply: (e, n, i) => r.call(n, t, ...i)
                  });
                let a = Function.call.bind({}.hasOwnProperty);
                const u = (t, e = {}, r = {}) => {
                    let n = Object.create(null),
                      c = {
                        has: (e, r) => r in t || r in n,
                        get(c, f, l) {
                          if (f in n) return n[f];
                          if (!(f in t)) return;
                          let h = t[f];
                          if ("function" == typeof h)
                            if ("function" == typeof e[f]) h = s(t, t[f], e[f]);
                            else if (a(r, f)) {
                            let e = ((t, e) => function(r, ...n) {
                              if (n.length < e.minArgs) throw Error(`Expected at least ${e.minArgs} ${o(e.minArgs)} for ${t}(), got ${n.length}`);
                              if (n.length > e.maxArgs) throw Error(`Expected at most ${e.maxArgs} ${o(e.maxArgs)} for ${t}(), got ${n.length}`);
                              return new Promise((o, s) => {
                                if (e.fallbackToNoCallback) try {
                                  r[t](...n, i({
                                    resolve: o,
                                    reject: s
                                  }, e))
                                } catch (i) {
                                  console.warn(t + " API method doesn't seem to support the callback parameter, falling back to call it without a callback: ", i), r[t](...n), e.fallbackToNoCallback = !1, e.noCallback = !0, o()
                                } else e.noCallback ? (r[t](...n), o()) : r[t](...n, i({
                                  resolve: o,
                                  reject: s
                                }, e))
                              })
                            })(f, r[f]);
                            h = s(t, t[f], e)
                          } else h = h.bind(t);
                          else if ("object" == typeof h && null !== h && (a(e, f) || a(r, f))) h = u(h, e[f], r[f]);
                          else {
                            if (!a(r, "*")) return Object.defineProperty(n, f, {
                              configurable: !0,
                              enumerable: !0,
                              get: () => t[f],
                              set(e) {
                                t[f] = e
                              }
                            }), h;
                            h = u(h, e[f], r["*"])
                          }
                          return n[f] = h, h
                        },
                        set: (e, r, i, o) => (r in n ? n[r] = i : t[r] = i, !0),
                        defineProperty: (t, e, r) => Reflect.defineProperty(n, e, r),
                        deleteProperty: (t, e) => Reflect.deleteProperty(n, e)
                      };
                    return new Proxy(Object.create(t), c)
                  },
                  c = t => ({
                    addListener(e, r, ...n) {
                      e.addListener(t.get(r), ...n)
                    },
                    hasListener: (e, r) => e.hasListener(t.get(r)),
                    removeListener(e, r) {
                      e.removeListener(t.get(r))
                    }
                  }),
                  f = new n(t => "function" != typeof t ? t : function(e) {
                    const r = u(e, {}, {
                      getContent: {
                        minArgs: 0,
                        maxArgs: 0
                      }
                    });
                    t(r)
                  }),
                  l = new n(t => "function" != typeof t ? t : function(e, r, n) {
                    let i, o, s = !1,
                      a = new Promise(t => {
                        i = function(e) {
                          s = !0, t(e)
                        }
                      });
                    try {
                      o = t(e, r, i)
                    } catch (t) {
                      o = Promise.reject(t)
                    }
                    const u = !0 !== o && (t => t && "object" == typeof t && "function" == typeof t.then)(o);
                    return !(!0 !== o && !u && !s || ((u ? o : a).then(t => {
                      n(t)
                    }, t => {
                      let e;
                      e = t && (t instanceof Error || "string" == typeof t.message) ? t.message : "An unexpected error occurred", n({
                        Gn: !0,
                        message: e
                      })
                    }).catch(t => {
                      console.error("Failed to send onMessage rejected reply", t)
                    }), 0))
                  }),
                  h = ({
                    reject: r,
                    resolve: n
                  }, i) => {
                    t.runtime.lastError ? t.runtime.lastError.message === e ? n() : r(Error(t.runtime.lastError.message)) : i && i.Gn ? r(Error(i.message)) : n(i)
                  },
                  d = (t, e, r, ...n) => {
                    if (n.length < e.minArgs) throw Error(`Expected at least ${e.minArgs} ${o(e.minArgs)} for ${t}(), got ${n.length}`);
                    if (n.length > e.maxArgs) throw Error(`Expected at most ${e.maxArgs} ${o(e.maxArgs)} for ${t}(), got ${n.length}`);
                    return new Promise((t, e) => {
                      const i = h.bind(null, {
                        resolve: t,
                        reject: e
                      });
                      n.push(i), r.sendMessage(...n)
                    })
                  },
                  p = {
                    devtools: {
                      network: {
                        onRequestFinished: c(f)
                      }
                    },
                    runtime: {
                      onMessage: c(l),
                      onMessageExternal: c(l),
                      sendMessage: d.bind(null, "sendMessage", {
                        minArgs: 1,
                        maxArgs: 3
                      })
                    },
                    tabs: {
                      sendMessage: d.bind(null, "sendMessage", {
                        minArgs: 2,
                        maxArgs: 3
                      })
                    }
                  },
                  b = {
                    clear: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    get: {
                      minArgs: 1,
                      maxArgs: 1
                    },
                    set: {
                      minArgs: 1,
                      maxArgs: 1
                    }
                  };
                return r.privacy = {
                  network: {
                    "*": b
                  },
                  services: {
                    "*": b
                  },
                  websites: {
                    "*": b
                  }
                }, u(t, p, r)
              };
            t.exports = r(chrome)
          } else t.exports = globalThis.browser
        }) ? r(t) : r) && (t.exports = n)
      },
      96897: (t, e, r) => {
        "use strict";
        var n = r(70453),
          i = r(30041),
          o = r(30592)(),
          s = r(75795),
          a = r(69675),
          u = n("%Math.floor%");
        t.exports = function(t, e) {
          if ("function" != typeof t) throw new a("`fn` is not a function");
          if ("number" != typeof e || 0 > e || e > 4294967295 || u(e) !== e) throw new a("`length` must be a positive 32-bit integer");
          var r = arguments.length > 2 && !!arguments[2],
            n = !0,
            c = !0;
          if ("length" in t && s) {
            var f = s(t, "length");
            f && !f.configurable && (n = !1), f && !f.writable && (c = !1)
          }
          return (n || c || !r) && (o ? i(t, "length", e, !0, !0) : i(t, "length", e)), t
        }
      },
      97070: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.fromNano = e.toNano = void 0, e.toNano = function(t) {
          if ("bigint" == typeof t) return 1000000000n * t;
          {
            if ("number" == typeof t) {
              if (!Number.isFinite(t)) throw Error("Invalid number");
              if (Math.log10(t) > 6) {
                if (t - Math.trunc(t) !== 0) throw Error("Not enough precision for a number value. Use string value instead");
                t = t.toLocaleString("en", {
                  maximumFractionDigits: 0,
                  useGrouping: !1
                })
              } else t = t.toLocaleString("en", {
                minimumFractionDigits: 9,
                useGrouping: !1
              })
            }
            let e = !1;
            for (; t.startsWith("-");) e = !e, t = t.slice(1);
            if ("." === t) throw Error("Invalid number");
            let r = t.split(".");
            if (r.length > 2) throw Error("Invalid number");
            let n = r[0],
              i = r[1];
            if (n || (n = "0"), i || (i = "0"), i.length > 9) throw Error("Invalid number");
            for (; 9 > i.length;) i += "0";
            let o = 1000000000n * BigInt(n) + BigInt(i);
            return e && (o = -o), o
          }
        }, e.fromNano = function(t) {
          let e = BigInt(t),
            r = !1;
          0 > e && (r = !0, e = -e);
          let n = "" + e % 1000000000n;
          for (; 9 > n.length;) n = "0" + n;
          n = n.match(/^([0-9]*[1-9]|0)(0*)/)[1];
          let i = `${""+e/1000000000n}${"0"===n?"":"."+n}`;
          return r && (i = "-" + i), i
        }
      },
      97075: (t, e, r) => {
        const n = r(53908),
          i = r(93904),
          {
            ANY: o
          } = i,
          s = r(78311),
          a = r(97638),
          u = r(35580),
          c = r(7059),
          f = r(25200),
          l = r(54089);
        t.exports = (t, e, r, h) => {
          let d, p, b, m, y;
          switch (t = new n(t, h), e = new s(e, h), r) {
            case ">":
              d = u, p = f, b = c, m = ">", y = ">=";
              break;
            case "<":
              d = c, p = l, b = u, m = "<", y = "<=";
              break;
            default:
              throw new TypeError('Must provide a hilo val of "<" or ">"')
          }
          if (a(t, e, h)) return !1;
          for (let r = 0; r < e.set.length; ++r) {
            const n = e.set[r];
            let s = null,
              a = null;
            if (n.forEach(t => {
                t.semver === o && (t = new i(">=0.0.0")), s = s || t, a = a || t, d(t.semver, s.semver, h) ? s = t : b(t.semver, a.semver, h) && (a = t)
              }), s.operator === m || s.operator === y || (!a.operator || a.operator === m) && p(t, a.semver)) return !1;
            if (a.operator === y && b(t, a.semver)) return !1
          }
          return !0
        }
      },
      97590: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.Dictionary = void 0;
        const i = r(3512),
          o = r(65871),
          s = r(66902),
          a = r(62386),
          u = r(78981),
          c = r(42230),
          f = r(22979),
          l = r(33910),
          h = r(26278);
        class d {
          static empty(t, e) {
            return t && e ? new d(new Map, t, e) : new d(new Map, null, null)
          }
          static load(t, e, r) {
            let n;
            if (r instanceof s.Cell) {
              if (r.isExotic) return d.empty(t, e);
              n = r.beginParse()
            } else n = r;
            let i = n.loadMaybeRef();
            return i && !i.isExotic ? d.loadDirect(t, e, i.beginParse()) : d.empty(t, e)
          }
          static loadDirect(t, e, r) {
            if (!r) return d.empty(t, e);
            let n;
            n = r instanceof s.Cell ? r.beginParse() : r;
            let i = (0, f.parseDict)(n, t.bits, e.parse),
              o = new Map;
            for (let [e, r] of i) o.set((0, h.serializeInternalKey)(t.parse(e)), r);
            return new d(o, t, e)
          }
          constructor(t, e, r) {
            this.An = e, this.Kn = r, this.Vn = t
          }
          get size() {
            return this.Vn.size
          }
          get(t) {
            return this.Vn.get((0, h.serializeInternalKey)(t))
          }
          has(t) {
            return this.Vn.has((0, h.serializeInternalKey)(t))
          }
          set(t, e) {
            return this.Vn.set((0, h.serializeInternalKey)(t), e), this
          }
          delete(t) {
            const e = (0, h.serializeInternalKey)(t);
            return this.Vn.delete(e)
          }
          clear() {
            this.Vn.clear()
          }*[Symbol.iterator]() {
            for (const [t, e] of this.Vn) yield [(0, h.deserializeInternalKey)(t), e]
          }
          keys() {
            return Array.from(this.Vn.keys()).map(t => (0, h.deserializeInternalKey)(t))
          }
          values() {
            return Array.from(this.Vn.values())
          }
          store(t, e, r) {
            if (0 === this.Vn.size) t.storeBit(0);
            else {
              let n = this.An;
              null != e && (n = e);
              let i = this.Kn;
              if (null != r && (i = r), !n) throw Error("Key serializer is not defined");
              if (!i) throw Error("Value serializer is not defined");
              let s = new Map;
              for (const [t, e] of this.Vn) s.set(n.serialize((0, h.deserializeInternalKey)(t)), e);
              t.storeBit(1);
              let a = (0, o.beginCell)();
              (0, l.serializeDict)(s, n.bits, i.serialize, a), t.storeRef(a.endCell())
            }
          }
          storeDirect(t, e, r) {
            if (0 === this.Vn.size) throw Error("Cannot store empty dictionary directly");
            let n = this.An;
            null != e && (n = e);
            let i = this.Kn;
            if (null != r && (i = r), !n) throw Error("Key serializer is not defined");
            if (!i) throw Error("Value serializer is not defined");
            let o = new Map;
            for (const [t, e] of this.Vn) o.set(n.serialize((0, h.deserializeInternalKey)(t)), e);
            (0, l.serializeDict)(o, n.bits, i.serialize, t)
          }
          generateMerkleProof(t) {
            return (0, u.generateMerkleProof)(this, t, this.An)
          }
          generateMerkleProofDirect(t) {
            return (0, u.generateMerkleProofDirect)(this, t, this.An)
          }
          generateMerkleUpdate(t, e) {
            return (0, c.generateMerkleUpdate)(this, t, this.An, e)
          }
        }
        e.Dictionary = d, d.Keys = {
          Address: () => ({
            bits: 267,
            serialize: t => {
              if (!i.Address.isAddress(t)) throw Error("Key is not an address");
              return (0, o.beginCell)().storeAddress(t).endCell().beginParse().preloadUintBig(267)
            },
            parse: t => (0, o.beginCell)().storeUint(t, 267).endCell().beginParse().loadAddress()
          }),
          BigInt: t => function(t) {
            return {
              bits: t,
              serialize: e => {
                if ("bigint" != typeof e) throw Error("Key is not a bigint");
                return (0, o.beginCell)().storeInt(e, t).endCell().beginParse().loadUintBig(t)
              },
              parse: e => (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadIntBig(t)
            }
          }(t),
          Int: t => function(t) {
            return {
              bits: t,
              serialize: e => {
                if ("number" != typeof e) throw Error("Key is not a number");
                if (!Number.isSafeInteger(e)) throw Error("Key is not a safe integer: " + e);
                return (0, o.beginCell)().storeInt(e, t).endCell().beginParse().loadUintBig(t)
              },
              parse: e => (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadInt(t)
            }
          }(t),
          BigUint: t => function(t) {
            return {
              bits: t,
              serialize: e => {
                if ("bigint" != typeof e) throw Error("Key is not a bigint");
                if (0 > e) throw Error("Key is negative: " + e);
                return (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadUintBig(t)
              },
              parse: e => (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadUintBig(t)
            }
          }(t),
          Uint: t => function(t) {
            return {
              bits: t,
              serialize: e => {
                if ("number" != typeof e) throw Error("Key is not a number");
                if (!Number.isSafeInteger(e)) throw Error("Key is not a safe integer: " + e);
                if (0 > e) throw Error("Key is negative: " + e);
                return (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadUintBig(t)
              },
              parse: e => +(0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadUint(t)
            }
          }(t),
          Buffer: t => function(t) {
            return {
              bits: 8 * t,
              serialize: e => {
                if (!n.isBuffer(e)) throw Error("Key is not a buffer");
                return (0, o.beginCell)().storeBuffer(e).endCell().beginParse().loadUintBig(8 * t)
              },
              parse: e => (0, o.beginCell)().storeUint(e, 8 * t).endCell().beginParse().loadBuffer(t)
            }
          }(t),
          BitString: t => function(t) {
            return {
              bits: t,
              serialize: e => {
                if (!a.BitString.isBitString(e)) throw Error("Key is not a BitString");
                return (0, o.beginCell)().storeBits(e).endCell().beginParse().loadUintBig(t)
              },
              parse: e => (0, o.beginCell)().storeUint(e, t).endCell().beginParse().loadBits(t)
            }
          }(t)
        }, d.Values = {
          BigInt: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeInt(e, t)
              },
              parse: e => {
                let r = e.loadIntBig(t);
                return e.endParse(), r
              }
            }
          }(t),
          Int: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeInt(e, t)
              },
              parse: e => {
                let r = e.loadInt(t);
                return e.endParse(), r
              }
            }
          }(t),
          BigVarInt: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeVarInt(e, t)
              },
              parse: e => {
                let r = e.loadVarIntBig(t);
                return e.endParse(), r
              }
            }
          }(t),
          BigUint: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeUint(e, t)
              },
              parse: e => {
                let r = e.loadUintBig(t);
                return e.endParse(), r
              }
            }
          }(t),
          Uint: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeUint(e, t)
              },
              parse: e => {
                let r = e.loadUint(t);
                return e.endParse(), r
              }
            }
          }(t),
          BigVarUint: t => function(t) {
            return {
              serialize: (e, r) => {
                r.storeVarUint(e, t)
              },
              parse: e => {
                let r = e.loadVarUintBig(t);
                return e.endParse(), r
              }
            }
          }(t),
          Bool: () => ({
            serialize: (t, e) => {
              e.storeBit(t)
            },
            parse: t => {
              let e = t.loadBit();
              return t.endParse(), e
            }
          }),
          Address: () => ({
            serialize: (t, e) => {
              e.storeAddress(t)
            },
            parse: t => {
              let e = t.loadAddress();
              return t.endParse(), e
            }
          }),
          Cell: () => ({
            serialize: (t, e) => {
              e.storeRef(t)
            },
            parse: t => {
              let e = t.loadRef();
              return t.endParse(), e
            }
          }),
          Buffer: t => function(t) {
            return {
              serialize: (e, r) => {
                if (e.length !== t) throw Error("Invalid buffer size");
                r.storeBuffer(e)
              },
              parse: e => {
                let r = e.loadBuffer(t);
                return e.endParse(), r
              }
            }
          }(t),
          BitString: t => function(t) {
            return {
              serialize: (e, r) => {
                if (e.length !== t) throw Error("Invalid BitString size");
                r.storeBits(e)
              },
              parse: e => {
                let r = e.loadBits(t);
                return e.endParse(), r
              }
            }
          }(t),
          Dictionary: (t, e) => function(t, e) {
            return {
              serialize: (t, e) => {
                t.store(e)
              },
              parse: r => {
                let n = d.load(t, e, r);
                return r.endParse(), n
              }
            }
          }(t, e)
        }
      },
      97638: (t, e, r) => {
        const n = r(78311);
        t.exports = (t, e, r) => {
          try {
            e = new n(e, r)
          } catch {
            return !1
          }
          return e.test(t)
        }
      },
      98274: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          (0, n.default)(t), e = (0, i.default)(e, u);
          var r = t.length;
          if (e.urlSafe) return a.test(t);
          if (r % 4 != 0 || s.test(t)) return !1;
          var o = t.indexOf("=");
          return -1 === o || o === r - 1 || o === r - 2 && "=" === t[r - 1]
        };
        var n = o(r(83399)),
          i = o(r(71229));

        function o(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var s = /[^A-Z0-9+\/=]/i,
          a = /^[A-Z0-9_\-]*$/i,
          u = {
            urlSafe: !1
          };
        t.exports = e.default, t.exports.default = e.default
      },
      98421: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.AsyncEventEmitter = void 0;
        const n = r(37007);
        class i extends n.EventEmitter {
          emit(t, ...e) {
            let [r, n] = e;
            const i = this;
            let o = i.ye[t] ?? [];
            return void 0 === n && "function" == typeof r && (n = r, r = void 0), ("newListener" === t || "removeListener" === t) && (r = {
              event: r,
              fn: n
            }, n = void 0), o = Array.isArray(o) ? o : [o], async function(t, e, r) {
              let n;
              for await (const i of e) try {
                2 > i.length ? i.call(t, r) : await new Promise((e, n) => {
                  i.call(t, r, t => {
                    t ? n(t) : e()
                  })
                })
              } catch (t) {
                n = t
              }
              if (n) throw n
            }(i, o.slice(), r).then(n).catch(n), i.listenerCount(t) > 0
          }
          once(t, e) {
            const r = this;
            let n;
            if ("function" != typeof e) throw new TypeError("listener must be a function");
            return n = 2 > e.length ? function(i) {
              r.removeListener(t, n), e(i, n)
            } : function(i, o) {
              r.removeListener(t, n), e(i, o)
            }, r.on(t, n), r
          }
          first(t, e) {
            let r = this.ye[t] ?? [];
            if ("function" != typeof e) throw new TypeError("listener must be a function");
            return Array.isArray(r) || (this.ye[t] = r = [r]), r.unshift(e), this
          }
          before(t, e, r) {
            return this.beforeOrAfter(t, e, r)
          }
          after(t, e, r) {
            return this.beforeOrAfter(t, e, r, "after")
          }
          beforeOrAfter(t, e, r, n) {
            let i, o, s = this.ye[t] ?? [];
            const a = "after" === n ? 1 : 0;
            if ("function" != typeof r) throw new TypeError("listener must be a function");
            if ("function" != typeof e) throw new TypeError("target must be a function");
            for (Array.isArray(s) || (this.ye[t] = s = [s]), o = s.length, i = s.length; i--;)
              if (s[i] === e) {
                o = i + a;
                break
              } return s.splice(o, 0, r), this
          }
          on(t, e) {
            return super.on(t, e)
          }
          addListener(t, e) {
            return super.addListener(t, e)
          }
          prependListener(t, e) {
            return super.prependListener(t, e)
          }
          prependOnceListener(t, e) {
            return super.prependOnceListener(t, e)
          }
          removeAllListeners(t) {
            return super.removeAllListeners(t)
          }
          removeListener(t, e) {
            return super.removeListener(t, e)
          }
          eventNames() {
            return super.eventNames()
          }
          listeners(t) {
            return super.listeners(t)
          }
          listenerCount(t) {
            return super.listenerCount(t)
          }
          getMaxListeners() {
            return super.getMaxListeners()
          }
          setMaxListeners(t) {
            return super.setMaxListeners(t)
          }
        }
        e.AsyncEventEmitter = i
      },
      98587: t => {
        const e = Object.freeze({
            loose: !0
          }),
          r = Object.freeze({});
        t.exports = t => t ? "object" != typeof t ? e : t : r
      },
      98636: (t, e, r) => {
        "use strict";
        var n = r(920),
          i = r(37720),
          o = r(74765),
          s = {}.hasOwnProperty,
          a = {
            brackets: function(t) {
              return t + "[]"
            },
            comma: "comma",
            indices: function(t, e) {
              return t + "[" + e + "]"
            },
            repeat: function(t) {
              return t
            }
          },
          u = Array.isArray,
          c = [].push,
          f = function(t, e) {
            c.apply(t, u(e) ? e : [e])
          },
          l = Date.prototype.toISOString,
          h = o.default,
          d = {
            addQueryPrefix: !1,
            allowDots: !1,
            allowEmptyArrays: !1,
            arrayFormat: "indices",
            charset: "utf-8",
            charsetSentinel: !1,
            commaRoundTrip: !1,
            delimiter: "&",
            encode: !0,
            encodeDotInKeys: !1,
            encoder: i.encode,
            encodeValuesOnly: !1,
            filter: void 0,
            format: h,
            formatter: o.formatters[h],
            indices: !1,
            serializeDate: function(t) {
              return l.call(t)
            },
            skipNulls: !1,
            strictNullHandling: !1
          },
          p = {},
          b = function t(e, r, o, s, a, c, l, h, b, m, y, g, v, w, A, T, E, P) {
            for (var k = e, x = P, I = 0, S = !1; void 0 !== (x = x.get(p)) && !S;) {
              var O = x.get(e);
              if (I += 1, "u" > typeof O) {
                if (O === I) throw new RangeError("Cyclic object value");
                S = !0
              }
              typeof x.get(p) > "u" && (I = 0)
            }
            if ("function" == typeof m ? k = m(r, k) : k instanceof Date ? k = v(k) : "comma" === o && u(k) && (k = i.maybeMap(k, function(t) {
                return t instanceof Date ? v(t) : t
              })), null === k) {
              if (c) return b && !T ? b(r, d.encoder, E, "key", w) : r;
              k = ""
            }
            if (function(t) {
                return "string" == typeof t || "number" == typeof t || "boolean" == typeof t || "symbol" == typeof t || "bigint" == typeof t
              }(k) || i.isBuffer(k)) return b ? [A(T ? r : b(r, d.encoder, E, "key", w)) + "=" + A(b(k, d.encoder, E, "value", w))] : [A(r) + "=" + A(k + "")];
            var B, W = [];
            if (typeof k > "u") return W;
            if ("comma" === o && u(k)) T && b && (k = i.maybeMap(k, b)), B = [{
              value: k.length > 0 ? k.join(",") || null : void 0
            }];
            else if (u(m)) B = m;
            else {
              var M = Object.keys(k);
              B = y ? M.sort(y) : M
            }
            var C = h ? (r + "").replace(/\./g, "%2E") : r + "",
              R = s && u(k) && 1 === k.length ? C + "[]" : C;
            if (a && u(k) && 0 === k.length) return R + "[]";
            for (var N = 0; N < B.length; ++N) {
              var j = B[N],
                _ = "object" == typeof j && j && "u" > typeof j.value ? j.value : k[j];
              if (!l || null !== _) {
                var D = g && h ? (j + "").replace(/\./g, "%2E") : j + "",
                  U = u(k) ? "function" == typeof o ? o(R, D) : R : R + (g ? "." + D : "[" + D + "]");
                P.set(e, I);
                var L = n();
                L.set(p, P), f(W, t(_, U, o, s, a, c, l, h, "comma" === o && T && u(k) ? null : b, m, y, g, v, w, A, T, E, L))
              }
            }
            return W
          };
        t.exports = function(t, e) {
          var r, i = t,
            c = function(t) {
              if (!t) return d;
              if ("u" > typeof t.allowEmptyArrays && "boolean" != typeof t.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
              if ("u" > typeof t.encodeDotInKeys && "boolean" != typeof t.encodeDotInKeys) throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
              if (null !== t.encoder && "u" > typeof t.encoder && "function" != typeof t.encoder) throw new TypeError("Encoder has to be a function.");
              var e = t.charset || d.charset;
              if ("u" > typeof t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
              var r = o.default;
              if ("u" > typeof t.format) {
                if (!s.call(o.formatters, t.format)) throw new TypeError("Unknown format option provided.");
                r = t.format
              }
              var n, i = o.formatters[r],
                c = d.filter;
              if (("function" == typeof t.filter || u(t.filter)) && (c = t.filter), n = t.arrayFormat in a ? t.arrayFormat : "indices" in t ? t.indices ? "indices" : "repeat" : d.arrayFormat, "commaRoundTrip" in t && "boolean" != typeof t.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
              var f = typeof t.allowDots > "u" ? !0 === t.encodeDotInKeys || d.allowDots : !!t.allowDots;
              return {
                addQueryPrefix: "boolean" == typeof t.addQueryPrefix ? t.addQueryPrefix : d.addQueryPrefix,
                allowDots: f,
                allowEmptyArrays: "boolean" == typeof t.allowEmptyArrays ? !!t.allowEmptyArrays : d.allowEmptyArrays,
                arrayFormat: n,
                charset: e,
                charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : d.charsetSentinel,
                commaRoundTrip: !!t.commaRoundTrip,
                delimiter: typeof t.delimiter > "u" ? d.delimiter : t.delimiter,
                encode: "boolean" == typeof t.encode ? t.encode : d.encode,
                encodeDotInKeys: "boolean" == typeof t.encodeDotInKeys ? t.encodeDotInKeys : d.encodeDotInKeys,
                encoder: "function" == typeof t.encoder ? t.encoder : d.encoder,
                encodeValuesOnly: "boolean" == typeof t.encodeValuesOnly ? t.encodeValuesOnly : d.encodeValuesOnly,
                filter: c,
                format: r,
                formatter: i,
                serializeDate: "function" == typeof t.serializeDate ? t.serializeDate : d.serializeDate,
                skipNulls: "boolean" == typeof t.skipNulls ? t.skipNulls : d.skipNulls,
                sort: "function" == typeof t.sort ? t.sort : null,
                strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : d.strictNullHandling
              }
            }(e);
          "function" == typeof c.filter ? i = (0, c.filter)("", i) : u(c.filter) && (r = c.filter);
          var l = [];
          if ("object" != typeof i || null === i) return "";
          var h = a[c.arrayFormat],
            p = "comma" === h && c.commaRoundTrip;
          r || (r = Object.keys(i)), c.sort && r.sort(c.sort);
          for (var m = n(), y = 0; y < r.length; ++y) {
            var g = r[y],
              v = i[g];
            c.skipNulls && null === v || f(l, b(v, g, h, p, c.allowEmptyArrays, c.strictNullHandling, c.skipNulls, c.encodeDotInKeys, c.encode ? c.encoder : null, c.filter, c.sort, c.allowDots, c.serializeDate, c.format, c.formatter, c.encodeValuesOnly, c.charset, m))
          }
          var w = l.join(c.delimiter),
            A = !0 === c.addQueryPrefix ? "?" : "";
          return c.charsetSentinel && ("iso-8859-1" === c.charset ? A += "utf8=%26%2310003%3B&" : A += "utf8=%E2%9C%93&"), w.length > 0 ? A + w : ""
        }
      },
      98737: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.TonClient = void 0;
        const i = r(41972),
          o = r(1307);

        function s(t) {
          const e = t["@type"];
          switch (e) {
            case "tvm.list":
            case "tvm.tuple":
              return t.elements.map(s);
            case "tvm.cell":
            case "tvm.slice":
              return o.Cell.fromBoc(n.from(t.bytes, "base64"))[0];
            case "tvm.stackEntryCell":
              return s(t.cell);
            case "tvm.stackEntrySlice":
              return s(t.slice);
            case "tvm.stackEntryTuple":
              return s(t.tuple);
            case "tvm.stackEntryList":
              return s(t.list);
            case "tvm.stackEntryNumber":
              return s(t.number);
            case "tvm.numberDecimal":
              return BigInt(t.number);
            default:
              throw Error("Unsupported item type: " + e)
          }
        }

        function a(t) {
          if ("num" === t[0]) {
            let e = t[1];
            return e.startsWith("-") ? {
              type: "int",
              value: -BigInt(e.slice(1))
            } : {
              type: "int",
              value: BigInt(e)
            }
          }
          if ("null" === t[0]) return {
            type: "null"
          };
          if ("cell" === t[0]) return {
            type: "cell",
            cell: o.Cell.fromBoc(n.from(t[1].bytes, "base64"))[0]
          };
          if ("slice" === t[0]) return {
            type: "slice",
            cell: o.Cell.fromBoc(n.from(t[1].bytes, "base64"))[0]
          };
          if ("builder" === t[0]) return {
            type: "builder",
            cell: o.Cell.fromBoc(n.from(t[1].bytes, "base64"))[0]
          };
          if ("tuple" === t[0] || "list" === t[0]) return 0 === t[1].elements.length ? {
            type: "null"
          } : {
            type: "tuple",
            items: t[1].elements.map(s)
          };
          throw Error("Unsupported stack item type: " + t[0])
        }

        function u(t) {
          let e = [];
          for (let r of t) e.push(a(r));
          return new o.TupleReader(e)
        }

        function c(t, e, r) {
          return {
            async getState() {
              let r, i = await t.getContractState(e),
                o = i.balance,
                s = i.lastTransaction ? {
                  lt: BigInt(i.lastTransaction.lt),
                  hash: n.from(i.lastTransaction.hash, "base64")
                } : null;
              if ("active" === i.state) r = {
                type: "active",
                code: i.code ? i.code : null,
                data: i.data ? i.data : null
              };
              else if ("uninitialized" === i.state) r = {
                type: "uninit"
              };
              else {
                if ("frozen" !== i.state) throw Error("Unsupported state");
                r = {
                  type: "frozen",
                  stateHash: n.alloc(0)
                }
              }
              return {
                balance: o,
                last: s,
                state: r
              }
            },
            async get(r, n) {
              if ("string" != typeof r) throw Error("Method name must be a string for TonClient provider");
              return {
                stack: (await t.runMethod(e, r, n)).stack
              }
            },
            async external(n) {
              let i = null;
              r && !await t.isContractDeployed(e) && (i = r);
              const s = (0, o.external)({
                to: e,
                init: i,
                body: n
              });
              let a = (0, o.beginCell)().store((0, o.storeMessage)(s)).endCell().toBoc();
              await t.sendFile(a)
            },
            async internal(n, i) {
              let s = null;
              r && !await t.isContractDeployed(e) && (s = r);
              let a, u = !0;
              null !== i.bounce && void 0 !== i.bounce && (u = i.bounce), a = "string" == typeof i.value ? (0, o.toNano)(i.value) : i.value;
              let c = null;
              "string" == typeof i.body ? c = (0, o.comment)(i.body) : i.body && (c = i.body), await n.send({
                to: e,
                value: a,
                bounce: u,
                sendMode: i.sendMode,
                init: s,
                body: c
              })
            },
            open: e => (0, o.openContract)(e, e => c(t, e.address, e.init ?? null)),
            getTransactions: (e, r, n, i) => t.getTransactions(e, {
              limit: i ?? 100,
              lt: r.toString(),
              hash: n.toString("base64"),
              inclusive: !0
            })
          }
        }
        e.TonClient = class {
          constructor(t) {
            this.parameters = {
              endpoint: t.endpoint
            }, this.api = new i.HttpApi(this.parameters.endpoint, {
              timeout: t.timeout,
              apiKey: t.apiKey,
              adapter: t.httpAdapter
            })
          }
          async getBalance(t) {
            return (await this.getContractState(t)).balance
          }
          async runMethod(t, e, r = []) {
            let n = await this.api.callGetMethod(t, e, r);
            if (0 !== n.exit_code) throw Error("Unable to execute get method. Got exit_code: " + n.exit_code);
            return {
              gas_used: n.gas_used,
              stack: u(n.stack)
            }
          }
          async callGetMethod(t, e, r = []) {
            return this.runMethod(t, e, r)
          }
          async runMethodWithError(t, e, r = []) {
            let n = await this.api.callGetMethod(t, e, r);
            return {
              gas_used: n.gas_used,
              stack: u(n.stack),
              exit_code: n.exit_code
            }
          }
          async callGetMethodWithError(t, e, r = []) {
            return this.runMethodWithError(t, e, r)
          }
          async getTransactions(t, e) {
            let r = await this.api.getTransactions(t, e),
              i = [];
            for (let t of r) i.push((0, o.loadTransaction)(o.Cell.fromBoc(n.from(t.data, "base64"))[0].beginParse()));
            return i
          }
          async getTransaction(t, e, r) {
            let i = await this.api.getTransaction(t, e, r);
            return i ? (0, o.loadTransaction)(o.Cell.fromBoc(n.from(i.data, "base64"))[0].beginParse()) : null
          }
          async tryLocateResultTx(t, e, r) {
            let n = await this.api.tryLocateResultTx(t, e, r);
            return (0, o.loadTransaction)(o.Cell.fromBase64(n.data).beginParse())
          }
          async tryLocateSourceTx(t, e, r) {
            let n = await this.api.tryLocateSourceTx(t, e, r);
            return (0, o.loadTransaction)(o.Cell.fromBase64(n.data).beginParse())
          }
          async getMasterchainInfo() {
            let t = await this.api.getMasterchainInfo();
            return {
              workchain: t.init.workchain,
              shard: t.last.shard,
              initSeqno: t.init.seqno,
              latestSeqno: t.last.seqno
            }
          }
          async getWorkchainShards(t) {
            return (await this.api.getShards(t)).map(t => ({
              workchain: t.workchain,
              shard: t.shard,
              seqno: t.seqno
            }))
          }
          async getShardTransactions(t, e, r) {
            let n = await this.api.getBlockTransactions(t, e, r);
            if (n.incomplete) throw Error("Unsupported");
            return n.transactions.map(t => ({
              account: o.Address.parseRaw(t.account),
              lt: t.lt,
              hash: t.hash
            }))
          }
          async sendMessage(t) {
            const e = (0, o.beginCell)().store((0, o.storeMessage)(t)).endCell().toBoc();
            await this.api.sendBoc(e)
          }
          async sendFile(t) {
            await this.api.sendBoc(t)
          }
          async estimateExternalMessageFee(t, e) {
            return await this.api.estimateFee(t, {
              body: e.body,
              initCode: e.initCode,
              initData: e.initData,
              ignoreSignature: e.ignoreSignature
            })
          }
          async sendExternalMessage(t, e) {
            if (await this.isContractDeployed(t.address) || !t.init) {
              const r = (0, o.external)({
                to: t.address,
                body: e
              });
              await this.sendMessage(r)
            } else {
              const r = (0, o.external)({
                to: t.address,
                init: t.init,
                body: e
              });
              await this.sendMessage(r)
            }
          }
          async isContractDeployed(t) {
            return "active" === (await this.getContractState(t)).state
          }
          async getContractState(t) {
            let e = await this.api.getAddressInformation(t);
            return {
              balance: BigInt(e.balance),
              state: e.state,
              code: "" !== e.code ? n.from(e.code, "base64") : null,
              data: "" !== e.data ? n.from(e.data, "base64") : null,
              lastTransaction: "0" !== e.last_transaction_id.lt ? {
                lt: e.last_transaction_id.lt,
                hash: e.last_transaction_id.hash
              } : null,
              blockId: {
                workchain: e.block_id.workchain,
                shard: e.block_id.shard,
                seqno: e.block_id.seqno
              },
              timestampt: e.sync_utime
            }
          }
          open(t) {
            return (0, o.openContract)(t, t => c(this, t.address, t.init))
          }
          provider(t, e) {
            return c(this, t, e ?? null)
          }
        }
      },
      98986: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "en-US",
            r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
          (0, i.default)(t);
          var n = t,
            s = r.ignore;
          if (s)
            if (s instanceof RegExp) n = n.replace(s, "");
            else {
              if ("string" != typeof s) throw Error("ignore should be instance of a String or RegExp");
              n = n.replace(RegExp("[".concat(s.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&"), "]"), "g"), "")
            } if (e in o.alphanumeric) return o.alphanumeric[e].test(n);
          throw Error("Invalid locale '".concat(e, "'"))
        }, e.locales = void 0;
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = r(13237),
          s = Object.keys(o.alphanumeric);
        e.locales = s
      },
      99013: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t, e) {
          if (e = "string" == typeof e ? (0, i.default)({
              format: e
            }, u) : (0, i.default)(e, u), "string" == typeof t && function(t) {
              return /(^(y{4}|y{2})[.\/-](m{1,2})[.\/-](d{1,2})$)|(^(m{1,2})[.\/-](d{1,2})[.\/-]((y{4}|y{2})$))|(^(d{1,2})[.\/-](m{1,2})[.\/-]((y{4}|y{2})$))/gi.test(t)
            }(e.format)) {
            var r, n = e.delimiters.find(function(t) {
                return -1 !== e.format.indexOf(t)
              }),
              a = e.strictMode ? n : e.delimiters.find(function(e) {
                return -1 !== t.indexOf(e)
              }),
              c = function(t, e) {
                for (var r = [], n = Math.min(t.length, e.length), i = 0; n > i; i++) r.push([t[i], e[i]]);
                return r
              }(t.split(a), e.format.toLowerCase().split(n)),
              f = {},
              l = function(t) {
                var e;
                if (typeof Symbol > "u" || null == t[Symbol.iterator]) {
                  if (Array.isArray(t) || (e = s(t))) {
                    e && (t = e);
                    var r = 0,
                      n = function() {};
                    return {
                      s: n,
                      n: function() {
                        return r < t.length ? {
                          done: !1,
                          value: t[r++]
                        } : {
                          done: !0
                        }
                      },
                      e: function(t) {
                        throw t
                      },
                      f: n
                    }
                  }
                  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                }
                var i, o = !0,
                  a = !1;
                return {
                  s: function() {
                    e = t[Symbol.iterator]()
                  },
                  n: function() {
                    var t = e.next();
                    return o = t.done, t
                  },
                  e: function(t) {
                    a = !0, i = t
                  },
                  f: function() {
                    try {
                      !o && null != e.return && e.return()
                    } finally {
                      if (a) throw i
                    }
                  }
                }
              }(c);
            try {
              for (l.s(); !(r = l.n()).done;) {
                var h = o(r.value, 2),
                  d = h[0],
                  p = h[1];
                if (d.length !== p.length) return !1;
                f[p.charAt(0)] = d
              }
            } catch (t) {
              l.e(t)
            } finally {
              l.f()
            }
            var b = f.y;
            if (2 === f.y.length) {
              var m = parseInt(f.y, 10);
              if (isNaN(m)) return !1;
              b = (new Date).getFullYear() % 100 > m ? "20".concat(f.y) : "19".concat(f.y)
            }
            return new Date("".concat(b, "-").concat(f.m, "-").concat(f.d)).getDate() === +f.d
          }
          return !e.strictMode && "[object Date]" === {}.toString.call(t) && isFinite(t)
        };
        var n, i = (n = r(71229)) && n._ ? n : {
          default: n
        };

        function o(t, e) {
          return function(t) {
            if (Array.isArray(t)) return t
          }(t) || function(t, e) {
            if ("u" >= typeof Symbol && Symbol.iterator in Object(t)) {
              var r = [],
                n = !0,
                i = !1,
                o = void 0;
              try {
                for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (r.push(s.value), !e || r.length !== e); n = !0);
              } catch (t) {
                i = !0, o = t
              } finally {
                try {
                  !n && null != a.return && a.return()
                } finally {
                  if (i) throw o
                }
              }
              return r
            }
          }(t, e) || s(t, e) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
          }()
        }

        function s(t, e) {
          if (t) {
            if ("string" == typeof t) return a(t, e);
            var r = {}.toString.call(t).slice(8, -1);
            if ("Object" === r && t.constructor && (r = t.constructor.name), "Map" === r || "Set" === r) return Array.from(t);
            if ("Arguments" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)) return a(t, e)
          }
        }

        function a(t, e) {
          (null == e || e > t.length) && (e = t.length);
          for (var r = 0, n = Array(e); e > r; r++) n[r] = t[r];
          return n
        }
        var u = {
          format: "YYYY/MM/DD",
          delimiters: ["/", "-"],
          strictMode: !1
        };
        t.exports = e.default, t.exports.default = e.default
      },
      99067: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.validate = e.is = e.mask = e.create = e.assert = e.ExactOptionalStruct = e.Struct = void 0;
        const n = r(27754),
          i = r(70639);
        class o {
          constructor(t) {
            const {
              type: e,
              schema: r,
              validator: n,
              refiner: o,
              coercer: s = t => t,
              entries: a = function*() {}
            } = t;
            this.type = e, this.schema = r, this.entries = a, this.coercer = s, this.validator = n ? (t, e) => {
              const r = n(t, e);
              return (0, i.toFailures)(r, e, this, t)
            } : () => [], this.refiner = o ? (t, e) => {
              const r = o(t, e);
              return (0, i.toFailures)(r, e, this, t)
            } : () => []
          }
          assert(t, e) {
            return a(t, this, e)
          }
          create(t, e) {
            return u(t, this, e)
          }
          is(t) {
            return f(t, this)
          }
          mask(t, e) {
            return c(t, this, e)
          }
          validate(t, e = {}) {
            return l(t, this, e)
          }
        }
        e.Struct = o;
        const s = "EXACT_OPTIONAL";

        function a(t, e, r) {
          const n = l(t, e, {
            message: r
          });
          if (n[0]) throw n[0]
        }

        function u(t, e, r) {
          const n = l(t, e, {
            coerce: !0,
            message: r
          });
          if (n[0]) throw n[0];
          return n[1]
        }

        function c(t, e, r) {
          const n = l(t, e, {
            coerce: !0,
            mask: !0,
            message: r
          });
          if (n[0]) throw n[0];
          return n[1]
        }

        function f(t, e) {
          return !l(t, e)[0]
        }

        function l(t, e, r = {}) {
          const o = (0, i.run)(t, e, r),
            s = (0, i.shiftIterator)(o);
          return s[0] ? [new n.StructError(s[0], function*() {
            for (const t of o) t[0] && (yield t[0])
          }), void 0] : [void 0, s[1]]
        }
        e.ExactOptionalStruct = class extends o {
          constructor(t) {
            super({
              ...t,
              type: "exact optional " + t.type
            }), this.brand = s
          }
          static isExactOptional(t) {
            return (0, i.isObject)(t) && "brand" in t && t.brand === s
          }
        }, e.assert = a, e.create = u, e.mask = c, e.is = f, e.validate = l
      },
      99100: (t, e) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.storeStorageExtraInfo = e.loadStorageExtraInfo = void 0, e.loadStorageExtraInfo = function(t) {
          let e = t.loadUint(3);
          if (0 === e) return null;
          if (1 === e) return {
            dictHash: t.loadUintBig(256)
          };
          throw Error("Invalid storage extra info header: " + e)
        }, e.storeStorageExtraInfo = function(t) {
          return e => {
            null === t ? e.storeUint(0, 3) : (e.storeUint(1, 3), e.storeUint(t.dictHash, 256))
          }
        }
      },
      99135: (t, e, r) => {
        var n = r(65339),
          i = n,
          o = "u" > typeof globalThis && globalThis || "u" > typeof window && window || "u" > typeof o && o || "u" > typeof self && self || function() {
            return this
          }.call(null) || Function("return this")(),
          s = r(41653);
        i.object.extend(proto, s), i.exportSymbol("TronWebProto.Account", null, o), i.exportSymbol("TronWebProto.Account.AccountResource", null, o), i.exportSymbol("TronWebProto.Account.Frozen", null, o), i.exportSymbol("TronWebProto.AccountId", null, o), i.exportSymbol("TronWebProto.AccountType", null, o), i.exportSymbol("TronWebProto.DelegatedResource", null, o), i.exportSymbol("TronWebProto.Exchange", null, o), i.exportSymbol("TronWebProto.Key", null, o), i.exportSymbol("TronWebProto.MarketOrderDetail", null, o), i.exportSymbol("TronWebProto.Permission", null, o), i.exportSymbol("TronWebProto.Permission.PermissionType", null, o), i.exportSymbol("TronWebProto.Proposal", null, o), i.exportSymbol("TronWebProto.Proposal.State", null, o), i.exportSymbol("TronWebProto.Transaction", null, o), i.exportSymbol("TronWebProto.Transaction.Contract", null, o), i.exportSymbol("TronWebProto.Transaction.Contract.ContractType", null, o), i.exportSymbol("TronWebProto.Transaction.Result", null, o), i.exportSymbol("TronWebProto.Transaction.Result.code", null, o), i.exportSymbol("TronWebProto.Transaction.Result.contractResult", null, o), i.exportSymbol("TronWebProto.Transaction.raw", null, o), i.exportSymbol("TronWebProto.Vote", null, o), i.exportSymbol("TronWebProto.Votes", null, o), i.exportSymbol("TronWebProto.Witness", null, o), i.exportSymbol("TronWebProto.authority", null, o), TronWebProto.AccountId = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.AccountId, n.Message), i.DEBUG && !COMPILED && (TronWebProto.AccountId.displayName = "TronWebProto.AccountId"), TronWebProto.Vote = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Vote, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Vote.displayName = "TronWebProto.Vote"), TronWebProto.Proposal = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Proposal.repeatedFields_, null)
        }, i.inherits(TronWebProto.Proposal, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Proposal.displayName = "TronWebProto.Proposal"), TronWebProto.Exchange = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Exchange, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Exchange.displayName = "TronWebProto.Exchange"), TronWebProto.Account = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Account.repeatedFields_, null)
        }, i.inherits(TronWebProto.Account, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Account.displayName = "TronWebProto.Account"), TronWebProto.Account.Frozen = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Account.Frozen, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Account.Frozen.displayName = "TronWebProto.Account.Frozen"), TronWebProto.Account.AccountResource = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Account.AccountResource, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Account.AccountResource.displayName = "TronWebProto.Account.AccountResource"), TronWebProto.Key = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Key, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Key.displayName = "TronWebProto.Key"), TronWebProto.DelegatedResource = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.DelegatedResource, n.Message), i.DEBUG && !COMPILED && (TronWebProto.DelegatedResource.displayName = "TronWebProto.DelegatedResource"), TronWebProto.authority = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.authority, n.Message), i.DEBUG && !COMPILED && (TronWebProto.authority.displayName = "TronWebProto.authority"), TronWebProto.Permission = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Permission.repeatedFields_, null)
        }, i.inherits(TronWebProto.Permission, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Permission.displayName = "TronWebProto.Permission"), TronWebProto.Witness = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Witness, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Witness.displayName = "TronWebProto.Witness"), TronWebProto.Votes = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Votes.repeatedFields_, null)
        }, i.inherits(TronWebProto.Votes, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Votes.displayName = "TronWebProto.Votes"), TronWebProto.MarketOrderDetail = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.MarketOrderDetail, n.Message), i.DEBUG && !COMPILED && (TronWebProto.MarketOrderDetail.displayName = "TronWebProto.MarketOrderDetail"), TronWebProto.Transaction = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Transaction.repeatedFields_, null)
        }, i.inherits(TronWebProto.Transaction, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Transaction.displayName = "TronWebProto.Transaction"), TronWebProto.Transaction.Contract = function(t) {
          n.Message.initialize(this, t, 0, -1, null, null)
        }, i.inherits(TronWebProto.Transaction.Contract, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Transaction.Contract.displayName = "TronWebProto.Transaction.Contract"), TronWebProto.Transaction.Result = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Transaction.Result.repeatedFields_, null)
        }, i.inherits(TronWebProto.Transaction.Result, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Transaction.Result.displayName = "TronWebProto.Transaction.Result"), TronWebProto.Transaction.raw = function(t) {
          n.Message.initialize(this, t, 0, -1, TronWebProto.Transaction.raw.repeatedFields_, null)
        }, i.inherits(TronWebProto.Transaction.raw, n.Message), i.DEBUG && !COMPILED && (TronWebProto.Transaction.raw.displayName = "TronWebProto.Transaction.raw"), n.Message.GENERATE_TO_OBJECT && (TronWebProto.AccountId.prototype.toObject = function(t) {
          return TronWebProto.AccountId.toObject(t, this)
        }, TronWebProto.AccountId.toObject = function(t, e) {
          var r = {
            name: e.getName_asB64(),
            address: e.getAddress_asB64()
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.AccountId.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.AccountId;
          return TronWebProto.AccountId.deserializeBinaryFromReader(r, e)
        }, TronWebProto.AccountId.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setName(r);
              break;
            case 2:
              r = e.readBytes(), t.setAddress(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.AccountId.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.AccountId.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.AccountId.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getName_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getAddress_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.AccountId.prototype.getName = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.AccountId.prototype.getName_asB64 = function() {
          return n.Message.bytesAsB64(this.getName())
        }, TronWebProto.AccountId.prototype.getName_asU8 = function() {
          return n.Message.bytesAsU8(this.getName())
        }, TronWebProto.AccountId.prototype.setName = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.AccountId.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.AccountId.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.AccountId.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.AccountId.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Vote.prototype.toObject = function(t) {
          return TronWebProto.Vote.toObject(t, this)
        }, TronWebProto.Vote.toObject = function(t, e) {
          var r = {
            voteAddress: e.getVoteAddress_asB64(),
            voteCount: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Vote.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Vote;
          return TronWebProto.Vote.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Vote.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setVoteAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setVoteCount(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Vote.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Vote.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Vote.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getVoteAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getVoteCount()) && e.writeInt64(2, r)
        }, TronWebProto.Vote.prototype.getVoteAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Vote.prototype.getVoteAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getVoteAddress())
        }, TronWebProto.Vote.prototype.getVoteAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getVoteAddress())
        }, TronWebProto.Vote.prototype.setVoteAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Vote.prototype.getVoteCount = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Vote.prototype.setVoteCount = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.Proposal.repeatedFields_ = [6], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Proposal.prototype.toObject = function(t) {
          return TronWebProto.Proposal.toObject(t, this)
        }, TronWebProto.Proposal.toObject = function(t, e) {
          var r, i = {
            proposalId: n.Message.getFieldWithDefault(e, 1, 0),
            proposerAddress: e.getProposerAddress_asB64(),
            parametersMap: (r = e.getParametersMap()) ? r.toObject(t, void 0) : [],
            expirationTime: n.Message.getFieldWithDefault(e, 4, 0),
            createTime: n.Message.getFieldWithDefault(e, 5, 0),
            approvalsList: e.getApprovalsList_asB64(),
            state: n.Message.getFieldWithDefault(e, 7, 0)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.Proposal.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Proposal;
          return TronWebProto.Proposal.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Proposal.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setProposalId(r);
              break;
            case 2:
              r = e.readBytes(), t.setProposerAddress(r);
              break;
            case 3:
              r = t.getParametersMap(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readInt64, n.BinaryReader.prototype.readInt64, null, 0, 0)
              });
              break;
            case 4:
              r = e.readInt64(), t.setExpirationTime(r);
              break;
            case 5:
              r = e.readInt64(), t.setCreateTime(r);
              break;
            case 6:
              r = e.readBytes(), t.addApprovals(r);
              break;
            case 7:
              r = e.readEnum(), t.setState(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Proposal.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Proposal.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Proposal.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getProposalId()) && e.writeInt64(1, r), (r = t.getProposerAddress_asU8()).length > 0 && e.writeBytes(2, r), (r = t.getParametersMap(!0)) && r.getLength() > 0 && r.serializeBinary(3, e, n.BinaryWriter.prototype.writeInt64, n.BinaryWriter.prototype.writeInt64), 0 !== (r = t.getExpirationTime()) && e.writeInt64(4, r), 0 !== (r = t.getCreateTime()) && e.writeInt64(5, r), (r = t.getApprovalsList_asU8()).length > 0 && e.writeRepeatedBytes(6, r), 0 !== (r = t.getState()) && e.writeEnum(7, r)
        }, TronWebProto.Proposal.State = {
          PENDING: 0,
          DISAPPROVED: 1,
          APPROVED: 2,
          CANCELED: 3
        }, TronWebProto.Proposal.prototype.getProposalId = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Proposal.prototype.setProposalId = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.Proposal.prototype.getProposerAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.Proposal.prototype.getProposerAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getProposerAddress())
        }, TronWebProto.Proposal.prototype.getProposerAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getProposerAddress())
        }, TronWebProto.Proposal.prototype.setProposerAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.Proposal.prototype.getParametersMap = function(t) {
          return n.Message.getMapField(this, 3, t, null)
        }, TronWebProto.Proposal.prototype.clearParametersMap = function() {
          return this.getParametersMap().clear(), this
        }, TronWebProto.Proposal.prototype.getExpirationTime = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.Proposal.prototype.setExpirationTime = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.Proposal.prototype.getCreateTime = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.Proposal.prototype.setCreateTime = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.Proposal.prototype.getApprovalsList = function() {
          return n.Message.getRepeatedField(this, 6)
        }, TronWebProto.Proposal.prototype.getApprovalsList_asB64 = function() {
          return n.Message.bytesListAsB64(this.getApprovalsList())
        }, TronWebProto.Proposal.prototype.getApprovalsList_asU8 = function() {
          return n.Message.bytesListAsU8(this.getApprovalsList())
        }, TronWebProto.Proposal.prototype.setApprovalsList = function(t) {
          return n.Message.setField(this, 6, t || [])
        }, TronWebProto.Proposal.prototype.addApprovals = function(t, e) {
          return n.Message.addToRepeatedField(this, 6, t, e)
        }, TronWebProto.Proposal.prototype.clearApprovalsList = function() {
          return this.setApprovalsList([])
        }, TronWebProto.Proposal.prototype.getState = function() {
          return n.Message.getFieldWithDefault(this, 7, 0)
        }, TronWebProto.Proposal.prototype.setState = function(t) {
          return n.Message.setProto3EnumField(this, 7, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Exchange.prototype.toObject = function(t) {
          return TronWebProto.Exchange.toObject(t, this)
        }, TronWebProto.Exchange.toObject = function(t, e) {
          var r = {
            exchangeId: n.Message.getFieldWithDefault(e, 1, 0),
            creatorAddress: e.getCreatorAddress_asB64(),
            createTime: n.Message.getFieldWithDefault(e, 3, 0),
            firstTokenId: e.getFirstTokenId_asB64(),
            firstTokenBalance: n.Message.getFieldWithDefault(e, 7, 0),
            secondTokenId: e.getSecondTokenId_asB64(),
            secondTokenBalance: n.Message.getFieldWithDefault(e, 9, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Exchange.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Exchange;
          return TronWebProto.Exchange.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Exchange.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setExchangeId(r);
              break;
            case 2:
              r = e.readBytes(), t.setCreatorAddress(r);
              break;
            case 3:
              r = e.readInt64(), t.setCreateTime(r);
              break;
            case 6:
              r = e.readBytes(), t.setFirstTokenId(r);
              break;
            case 7:
              r = e.readInt64(), t.setFirstTokenBalance(r);
              break;
            case 8:
              r = e.readBytes(), t.setSecondTokenId(r);
              break;
            case 9:
              r = e.readInt64(), t.setSecondTokenBalance(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Exchange.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Exchange.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Exchange.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getExchangeId()) && e.writeInt64(1, r), (r = t.getCreatorAddress_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getCreateTime()) && e.writeInt64(3, r), (r = t.getFirstTokenId_asU8()).length > 0 && e.writeBytes(6, r), 0 !== (r = t.getFirstTokenBalance()) && e.writeInt64(7, r), (r = t.getSecondTokenId_asU8()).length > 0 && e.writeBytes(8, r), 0 !== (r = t.getSecondTokenBalance()) && e.writeInt64(9, r)
        }, TronWebProto.Exchange.prototype.getExchangeId = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Exchange.prototype.setExchangeId = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.Exchange.prototype.getCreatorAddress = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.Exchange.prototype.getCreatorAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getCreatorAddress())
        }, TronWebProto.Exchange.prototype.getCreatorAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getCreatorAddress())
        }, TronWebProto.Exchange.prototype.setCreatorAddress = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.Exchange.prototype.getCreateTime = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.Exchange.prototype.setCreateTime = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.Exchange.prototype.getFirstTokenId = function() {
          return n.Message.getFieldWithDefault(this, 6, "")
        }, TronWebProto.Exchange.prototype.getFirstTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getFirstTokenId())
        }, TronWebProto.Exchange.prototype.getFirstTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getFirstTokenId())
        }, TronWebProto.Exchange.prototype.setFirstTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 6, t)
        }, TronWebProto.Exchange.prototype.getFirstTokenBalance = function() {
          return n.Message.getFieldWithDefault(this, 7, 0)
        }, TronWebProto.Exchange.prototype.setFirstTokenBalance = function(t) {
          return n.Message.setProto3IntField(this, 7, t)
        }, TronWebProto.Exchange.prototype.getSecondTokenId = function() {
          return n.Message.getFieldWithDefault(this, 8, "")
        }, TronWebProto.Exchange.prototype.getSecondTokenId_asB64 = function() {
          return n.Message.bytesAsB64(this.getSecondTokenId())
        }, TronWebProto.Exchange.prototype.getSecondTokenId_asU8 = function() {
          return n.Message.bytesAsU8(this.getSecondTokenId())
        }, TronWebProto.Exchange.prototype.setSecondTokenId = function(t) {
          return n.Message.setProto3BytesField(this, 8, t)
        }, TronWebProto.Exchange.prototype.getSecondTokenBalance = function() {
          return n.Message.getFieldWithDefault(this, 9, 0)
        }, TronWebProto.Exchange.prototype.setSecondTokenBalance = function(t) {
          return n.Message.setProto3IntField(this, 9, t)
        }, TronWebProto.Account.repeatedFields_ = [5, 7, 16, 33], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.prototype.toObject = function(t) {
          return TronWebProto.Account.toObject(t, this)
        }, TronWebProto.Account.toObject = function(t, e) {
          var r, i = {
            accountName: e.getAccountName_asB64(),
            type: n.Message.getFieldWithDefault(e, 2, 0),
            address: e.getAddress_asB64(),
            balance: n.Message.getFieldWithDefault(e, 4, 0),
            votesList: n.Message.toObjectList(e.getVotesList(), TronWebProto.Vote.toObject, t),
            assetMap: (r = e.getAssetMap()) ? r.toObject(t, void 0) : [],
            assetv2Map: (r = e.getAssetv2Map()) ? r.toObject(t, void 0) : [],
            frozenList: n.Message.toObjectList(e.getFrozenList(), TronWebProto.Account.Frozen.toObject, t),
            netUsage: n.Message.getFieldWithDefault(e, 8, 0),
            acquiredDelegatedFrozenBalanceForBandwidth: n.Message.getFieldWithDefault(e, 41, 0),
            delegatedFrozenBalanceForBandwidth: n.Message.getFieldWithDefault(e, 42, 0),
            oldTronPower: n.Message.getFieldWithDefault(e, 46, 0),
            tronPower: (r = e.getTronPower()) && TronWebProto.Account.Frozen.toObject(t, r),
            assetOptimized: n.Message.getBooleanFieldWithDefault(e, 60, !1),
            createTime: n.Message.getFieldWithDefault(e, 9, 0),
            latestOprationTime: n.Message.getFieldWithDefault(e, 10, 0),
            allowance: n.Message.getFieldWithDefault(e, 11, 0),
            latestWithdrawTime: n.Message.getFieldWithDefault(e, 12, 0),
            code: e.getCode_asB64(),
            isWitness: n.Message.getBooleanFieldWithDefault(e, 14, !1),
            isCommittee: n.Message.getBooleanFieldWithDefault(e, 15, !1),
            frozenSupplyList: n.Message.toObjectList(e.getFrozenSupplyList(), TronWebProto.Account.Frozen.toObject, t),
            assetIssuedName: e.getAssetIssuedName_asB64(),
            assetIssuedId: e.getAssetIssuedId_asB64(),
            latestAssetOperationTimeMap: (r = e.getLatestAssetOperationTimeMap()) ? r.toObject(t, void 0) : [],
            latestAssetOperationTimev2Map: (r = e.getLatestAssetOperationTimev2Map()) ? r.toObject(t, void 0) : [],
            freeNetUsage: n.Message.getFieldWithDefault(e, 19, 0),
            freeAssetNetUsageMap: (r = e.getFreeAssetNetUsageMap()) ? r.toObject(t, void 0) : [],
            freeAssetNetUsagev2Map: (r = e.getFreeAssetNetUsagev2Map()) ? r.toObject(t, void 0) : [],
            latestConsumeTime: n.Message.getFieldWithDefault(e, 21, 0),
            latestConsumeFreeTime: n.Message.getFieldWithDefault(e, 22, 0),
            accountId: e.getAccountId_asB64(),
            accountResource: (r = e.getAccountResource()) && TronWebProto.Account.AccountResource.toObject(t, r),
            codehash: e.getCodehash_asB64(),
            ownerPermission: (r = e.getOwnerPermission()) && TronWebProto.Permission.toObject(t, r),
            witnessPermission: (r = e.getWitnessPermission()) && TronWebProto.Permission.toObject(t, r),
            activePermissionList: n.Message.toObjectList(e.getActivePermissionList(), TronWebProto.Permission.toObject, t)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.Account.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Account;
          return TronWebProto.Account.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Account.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAccountName(r);
              break;
            case 2:
              r = e.readEnum(), t.setType(r);
              break;
            case 3:
              r = e.readBytes(), t.setAddress(r);
              break;
            case 4:
              r = e.readInt64(), t.setBalance(r);
              break;
            case 5:
              r = new TronWebProto.Vote, e.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader), t.addVotes(r);
              break;
            case 6:
              r = t.getAssetMap(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 56:
              r = t.getAssetv2Map(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 7:
              r = new TronWebProto.Account.Frozen, e.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader), t.addFrozen(r);
              break;
            case 8:
              r = e.readInt64(), t.setNetUsage(r);
              break;
            case 41:
              r = e.readInt64(), t.setAcquiredDelegatedFrozenBalanceForBandwidth(r);
              break;
            case 42:
              r = e.readInt64(), t.setDelegatedFrozenBalanceForBandwidth(r);
              break;
            case 46:
              r = e.readInt64(), t.setOldTronPower(r);
              break;
            case 47:
              r = new TronWebProto.Account.Frozen, e.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader), t.setTronPower(r);
              break;
            case 60:
              r = e.readBool(), t.setAssetOptimized(r);
              break;
            case 9:
              r = e.readInt64(), t.setCreateTime(r);
              break;
            case 10:
              r = e.readInt64(), t.setLatestOprationTime(r);
              break;
            case 11:
              r = e.readInt64(), t.setAllowance(r);
              break;
            case 12:
              r = e.readInt64(), t.setLatestWithdrawTime(r);
              break;
            case 13:
              r = e.readBytes(), t.setCode(r);
              break;
            case 14:
              r = e.readBool(), t.setIsWitness(r);
              break;
            case 15:
              r = e.readBool(), t.setIsCommittee(r);
              break;
            case 16:
              r = new TronWebProto.Account.Frozen, e.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader), t.addFrozenSupply(r);
              break;
            case 17:
              r = e.readBytes(), t.setAssetIssuedName(r);
              break;
            case 57:
              r = e.readBytes(), t.setAssetIssuedId(r);
              break;
            case 18:
              r = t.getLatestAssetOperationTimeMap(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 58:
              r = t.getLatestAssetOperationTimev2Map(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 19:
              r = e.readInt64(), t.setFreeNetUsage(r);
              break;
            case 20:
              r = t.getFreeAssetNetUsageMap(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 59:
              r = t.getFreeAssetNetUsagev2Map(), e.readMessage(r, function(t, e) {
                n.Map.deserializeBinary(t, e, n.BinaryReader.prototype.readString, n.BinaryReader.prototype.readInt64, null, "", 0)
              });
              break;
            case 21:
              r = e.readInt64(), t.setLatestConsumeTime(r);
              break;
            case 22:
              r = e.readInt64(), t.setLatestConsumeFreeTime(r);
              break;
            case 23:
              r = e.readBytes(), t.setAccountId(r);
              break;
            case 26:
              r = new TronWebProto.Account.AccountResource, e.readMessage(r, TronWebProto.Account.AccountResource.deserializeBinaryFromReader), t.setAccountResource(r);
              break;
            case 30:
              r = e.readBytes(), t.setCodehash(r);
              break;
            case 31:
              r = new TronWebProto.Permission, e.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader), t.setOwnerPermission(r);
              break;
            case 32:
              r = new TronWebProto.Permission, e.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader), t.setWitnessPermission(r);
              break;
            case 33:
              r = new TronWebProto.Permission, e.readMessage(r, TronWebProto.Permission.deserializeBinaryFromReader), t.addActivePermission(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Account.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Account.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Account.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAccountName_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getType()) && e.writeEnum(2, r), (r = t.getAddress_asU8()).length > 0 && e.writeBytes(3, r), 0 !== (r = t.getBalance()) && e.writeInt64(4, r), (r = t.getVotesList()).length > 0 && e.writeRepeatedMessage(5, r, TronWebProto.Vote.serializeBinaryToWriter), (r = t.getAssetMap(!0)) && r.getLength() > 0 && r.serializeBinary(6, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), (r = t.getAssetv2Map(!0)) && r.getLength() > 0 && r.serializeBinary(56, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), (r = t.getFrozenList()).length > 0 && e.writeRepeatedMessage(7, r, TronWebProto.Account.Frozen.serializeBinaryToWriter), 0 !== (r = t.getNetUsage()) && e.writeInt64(8, r), 0 !== (r = t.getAcquiredDelegatedFrozenBalanceForBandwidth()) && e.writeInt64(41, r), 0 !== (r = t.getDelegatedFrozenBalanceForBandwidth()) && e.writeInt64(42, r), 0 !== (r = t.getOldTronPower()) && e.writeInt64(46, r), null != (r = t.getTronPower()) && e.writeMessage(47, r, TronWebProto.Account.Frozen.serializeBinaryToWriter), (r = t.getAssetOptimized()) && e.writeBool(60, r), 0 !== (r = t.getCreateTime()) && e.writeInt64(9, r), 0 !== (r = t.getLatestOprationTime()) && e.writeInt64(10, r), 0 !== (r = t.getAllowance()) && e.writeInt64(11, r), 0 !== (r = t.getLatestWithdrawTime()) && e.writeInt64(12, r), (r = t.getCode_asU8()).length > 0 && e.writeBytes(13, r), (r = t.getIsWitness()) && e.writeBool(14, r), (r = t.getIsCommittee()) && e.writeBool(15, r), (r = t.getFrozenSupplyList()).length > 0 && e.writeRepeatedMessage(16, r, TronWebProto.Account.Frozen.serializeBinaryToWriter), (r = t.getAssetIssuedName_asU8()).length > 0 && e.writeBytes(17, r), (r = t.getAssetIssuedId_asU8()).length > 0 && e.writeBytes(57, r), (r = t.getLatestAssetOperationTimeMap(!0)) && r.getLength() > 0 && r.serializeBinary(18, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), (r = t.getLatestAssetOperationTimev2Map(!0)) && r.getLength() > 0 && r.serializeBinary(58, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), 0 !== (r = t.getFreeNetUsage()) && e.writeInt64(19, r), (r = t.getFreeAssetNetUsageMap(!0)) && r.getLength() > 0 && r.serializeBinary(20, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), (r = t.getFreeAssetNetUsagev2Map(!0)) && r.getLength() > 0 && r.serializeBinary(59, e, n.BinaryWriter.prototype.writeString, n.BinaryWriter.prototype.writeInt64), 0 !== (r = t.getLatestConsumeTime()) && e.writeInt64(21, r), 0 !== (r = t.getLatestConsumeFreeTime()) && e.writeInt64(22, r), (r = t.getAccountId_asU8()).length > 0 && e.writeBytes(23, r), null != (r = t.getAccountResource()) && e.writeMessage(26, r, TronWebProto.Account.AccountResource.serializeBinaryToWriter), (r = t.getCodehash_asU8()).length > 0 && e.writeBytes(30, r), null != (r = t.getOwnerPermission()) && e.writeMessage(31, r, TronWebProto.Permission.serializeBinaryToWriter), null != (r = t.getWitnessPermission()) && e.writeMessage(32, r, TronWebProto.Permission.serializeBinaryToWriter), (r = t.getActivePermissionList()).length > 0 && e.writeRepeatedMessage(33, r, TronWebProto.Permission.serializeBinaryToWriter)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.Frozen.prototype.toObject = function(t) {
          return TronWebProto.Account.Frozen.toObject(t, this)
        }, TronWebProto.Account.Frozen.toObject = function(t, e) {
          var r = {
            frozenBalance: n.Message.getFieldWithDefault(e, 1, 0),
            expireTime: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Account.Frozen.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Account.Frozen;
          return TronWebProto.Account.Frozen.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Account.Frozen.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setFrozenBalance(r);
              break;
            case 2:
              r = e.readInt64(), t.setExpireTime(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Account.Frozen.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Account.Frozen.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Account.Frozen.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getFrozenBalance()) && e.writeInt64(1, r), 0 !== (r = t.getExpireTime()) && e.writeInt64(2, r)
        }, TronWebProto.Account.Frozen.prototype.getFrozenBalance = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Account.Frozen.prototype.setFrozenBalance = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.Account.Frozen.prototype.getExpireTime = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Account.Frozen.prototype.setExpireTime = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Account.AccountResource.prototype.toObject = function(t) {
          return TronWebProto.Account.AccountResource.toObject(t, this)
        }, TronWebProto.Account.AccountResource.toObject = function(t, e) {
          var r, i = {
            energyUsage: n.Message.getFieldWithDefault(e, 1, 0),
            frozenBalanceForEnergy: (r = e.getFrozenBalanceForEnergy()) && TronWebProto.Account.Frozen.toObject(t, r),
            latestConsumeTimeForEnergy: n.Message.getFieldWithDefault(e, 3, 0),
            acquiredDelegatedFrozenBalanceForEnergy: n.Message.getFieldWithDefault(e, 4, 0),
            delegatedFrozenBalanceForEnergy: n.Message.getFieldWithDefault(e, 5, 0),
            storageLimit: n.Message.getFieldWithDefault(e, 6, 0),
            storageUsage: n.Message.getFieldWithDefault(e, 7, 0),
            latestExchangeStorageTime: n.Message.getFieldWithDefault(e, 8, 0)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.Account.AccountResource.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Account.AccountResource;
          return TronWebProto.Account.AccountResource.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Account.AccountResource.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setEnergyUsage(r);
              break;
            case 2:
              r = new TronWebProto.Account.Frozen, e.readMessage(r, TronWebProto.Account.Frozen.deserializeBinaryFromReader), t.setFrozenBalanceForEnergy(r);
              break;
            case 3:
              r = e.readInt64(), t.setLatestConsumeTimeForEnergy(r);
              break;
            case 4:
              r = e.readInt64(), t.setAcquiredDelegatedFrozenBalanceForEnergy(r);
              break;
            case 5:
              r = e.readInt64(), t.setDelegatedFrozenBalanceForEnergy(r);
              break;
            case 6:
              r = e.readInt64(), t.setStorageLimit(r);
              break;
            case 7:
              r = e.readInt64(), t.setStorageUsage(r);
              break;
            case 8:
              r = e.readInt64(), t.setLatestExchangeStorageTime(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Account.AccountResource.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Account.AccountResource.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Account.AccountResource.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getEnergyUsage()) && e.writeInt64(1, r), null != (r = t.getFrozenBalanceForEnergy()) && e.writeMessage(2, r, TronWebProto.Account.Frozen.serializeBinaryToWriter), 0 !== (r = t.getLatestConsumeTimeForEnergy()) && e.writeInt64(3, r), 0 !== (r = t.getAcquiredDelegatedFrozenBalanceForEnergy()) && e.writeInt64(4, r), 0 !== (r = t.getDelegatedFrozenBalanceForEnergy()) && e.writeInt64(5, r), 0 !== (r = t.getStorageLimit()) && e.writeInt64(6, r), 0 !== (r = t.getStorageUsage()) && e.writeInt64(7, r), 0 !== (r = t.getLatestExchangeStorageTime()) && e.writeInt64(8, r)
        }, TronWebProto.Account.AccountResource.prototype.getEnergyUsage = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Account.AccountResource.prototype.setEnergyUsage = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.Account.AccountResource.prototype.getFrozenBalanceForEnergy = function() {
          return n.Message.getWrapperField(this, TronWebProto.Account.Frozen, 2)
        }, TronWebProto.Account.AccountResource.prototype.setFrozenBalanceForEnergy = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.Account.AccountResource.prototype.clearFrozenBalanceForEnergy = function() {
          return this.setFrozenBalanceForEnergy(void 0)
        }, TronWebProto.Account.AccountResource.prototype.hasFrozenBalanceForEnergy = function() {
          return null != n.Message.getField(this, 2)
        }, TronWebProto.Account.AccountResource.prototype.getLatestConsumeTimeForEnergy = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.Account.AccountResource.prototype.setLatestConsumeTimeForEnergy = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.Account.AccountResource.prototype.getAcquiredDelegatedFrozenBalanceForEnergy = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.Account.AccountResource.prototype.setAcquiredDelegatedFrozenBalanceForEnergy = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.Account.AccountResource.prototype.getDelegatedFrozenBalanceForEnergy = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.Account.AccountResource.prototype.setDelegatedFrozenBalanceForEnergy = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.Account.AccountResource.prototype.getStorageLimit = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.Account.AccountResource.prototype.setStorageLimit = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, TronWebProto.Account.AccountResource.prototype.getStorageUsage = function() {
          return n.Message.getFieldWithDefault(this, 7, 0)
        }, TronWebProto.Account.AccountResource.prototype.setStorageUsage = function(t) {
          return n.Message.setProto3IntField(this, 7, t)
        }, TronWebProto.Account.AccountResource.prototype.getLatestExchangeStorageTime = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.Account.AccountResource.prototype.setLatestExchangeStorageTime = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.Account.prototype.getAccountName = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Account.prototype.getAccountName_asB64 = function() {
          return n.Message.bytesAsB64(this.getAccountName())
        }, TronWebProto.Account.prototype.getAccountName_asU8 = function() {
          return n.Message.bytesAsU8(this.getAccountName())
        }, TronWebProto.Account.prototype.setAccountName = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Account.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Account.prototype.setType = function(t) {
          return n.Message.setProto3EnumField(this, 2, t)
        }, TronWebProto.Account.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.Account.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.Account.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.Account.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.Account.prototype.getBalance = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.Account.prototype.setBalance = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.Account.prototype.getVotesList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 5)
        }, TronWebProto.Account.prototype.setVotesList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 5, t)
        }, TronWebProto.Account.prototype.addVotes = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 5, t, TronWebProto.Vote, e)
        }, TronWebProto.Account.prototype.clearVotesList = function() {
          return this.setVotesList([])
        }, TronWebProto.Account.prototype.getAssetMap = function(t) {
          return n.Message.getMapField(this, 6, t, null)
        }, TronWebProto.Account.prototype.clearAssetMap = function() {
          return this.getAssetMap().clear(), this
        }, TronWebProto.Account.prototype.getAssetv2Map = function(t) {
          return n.Message.getMapField(this, 56, t, null)
        }, TronWebProto.Account.prototype.clearAssetv2Map = function() {
          return this.getAssetv2Map().clear(), this
        }, TronWebProto.Account.prototype.getFrozenList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 7)
        }, TronWebProto.Account.prototype.setFrozenList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 7, t)
        }, TronWebProto.Account.prototype.addFrozen = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 7, t, TronWebProto.Account.Frozen, e)
        }, TronWebProto.Account.prototype.clearFrozenList = function() {
          return this.setFrozenList([])
        }, TronWebProto.Account.prototype.getNetUsage = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.Account.prototype.setNetUsage = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.Account.prototype.getAcquiredDelegatedFrozenBalanceForBandwidth = function() {
          return n.Message.getFieldWithDefault(this, 41, 0)
        }, TronWebProto.Account.prototype.setAcquiredDelegatedFrozenBalanceForBandwidth = function(t) {
          return n.Message.setProto3IntField(this, 41, t)
        }, TronWebProto.Account.prototype.getDelegatedFrozenBalanceForBandwidth = function() {
          return n.Message.getFieldWithDefault(this, 42, 0)
        }, TronWebProto.Account.prototype.setDelegatedFrozenBalanceForBandwidth = function(t) {
          return n.Message.setProto3IntField(this, 42, t)
        }, TronWebProto.Account.prototype.getOldTronPower = function() {
          return n.Message.getFieldWithDefault(this, 46, 0)
        }, TronWebProto.Account.prototype.setOldTronPower = function(t) {
          return n.Message.setProto3IntField(this, 46, t)
        }, TronWebProto.Account.prototype.getTronPower = function() {
          return n.Message.getWrapperField(this, TronWebProto.Account.Frozen, 47)
        }, TronWebProto.Account.prototype.setTronPower = function(t) {
          return n.Message.setWrapperField(this, 47, t)
        }, TronWebProto.Account.prototype.clearTronPower = function() {
          return this.setTronPower(void 0)
        }, TronWebProto.Account.prototype.hasTronPower = function() {
          return null != n.Message.getField(this, 47)
        }, TronWebProto.Account.prototype.getAssetOptimized = function() {
          return n.Message.getBooleanFieldWithDefault(this, 60, !1)
        }, TronWebProto.Account.prototype.setAssetOptimized = function(t) {
          return n.Message.setProto3BooleanField(this, 60, t)
        }, TronWebProto.Account.prototype.getCreateTime = function() {
          return n.Message.getFieldWithDefault(this, 9, 0)
        }, TronWebProto.Account.prototype.setCreateTime = function(t) {
          return n.Message.setProto3IntField(this, 9, t)
        }, TronWebProto.Account.prototype.getLatestOprationTime = function() {
          return n.Message.getFieldWithDefault(this, 10, 0)
        }, TronWebProto.Account.prototype.setLatestOprationTime = function(t) {
          return n.Message.setProto3IntField(this, 10, t)
        }, TronWebProto.Account.prototype.getAllowance = function() {
          return n.Message.getFieldWithDefault(this, 11, 0)
        }, TronWebProto.Account.prototype.setAllowance = function(t) {
          return n.Message.setProto3IntField(this, 11, t)
        }, TronWebProto.Account.prototype.getLatestWithdrawTime = function() {
          return n.Message.getFieldWithDefault(this, 12, 0)
        }, TronWebProto.Account.prototype.setLatestWithdrawTime = function(t) {
          return n.Message.setProto3IntField(this, 12, t)
        }, TronWebProto.Account.prototype.getCode = function() {
          return n.Message.getFieldWithDefault(this, 13, "")
        }, TronWebProto.Account.prototype.getCode_asB64 = function() {
          return n.Message.bytesAsB64(this.getCode())
        }, TronWebProto.Account.prototype.getCode_asU8 = function() {
          return n.Message.bytesAsU8(this.getCode())
        }, TronWebProto.Account.prototype.setCode = function(t) {
          return n.Message.setProto3BytesField(this, 13, t)
        }, TronWebProto.Account.prototype.getIsWitness = function() {
          return n.Message.getBooleanFieldWithDefault(this, 14, !1)
        }, TronWebProto.Account.prototype.setIsWitness = function(t) {
          return n.Message.setProto3BooleanField(this, 14, t)
        }, TronWebProto.Account.prototype.getIsCommittee = function() {
          return n.Message.getBooleanFieldWithDefault(this, 15, !1)
        }, TronWebProto.Account.prototype.setIsCommittee = function(t) {
          return n.Message.setProto3BooleanField(this, 15, t)
        }, TronWebProto.Account.prototype.getFrozenSupplyList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Account.Frozen, 16)
        }, TronWebProto.Account.prototype.setFrozenSupplyList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 16, t)
        }, TronWebProto.Account.prototype.addFrozenSupply = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 16, t, TronWebProto.Account.Frozen, e)
        }, TronWebProto.Account.prototype.clearFrozenSupplyList = function() {
          return this.setFrozenSupplyList([])
        }, TronWebProto.Account.prototype.getAssetIssuedName = function() {
          return n.Message.getFieldWithDefault(this, 17, "")
        }, TronWebProto.Account.prototype.getAssetIssuedName_asB64 = function() {
          return n.Message.bytesAsB64(this.getAssetIssuedName())
        }, TronWebProto.Account.prototype.getAssetIssuedName_asU8 = function() {
          return n.Message.bytesAsU8(this.getAssetIssuedName())
        }, TronWebProto.Account.prototype.setAssetIssuedName = function(t) {
          return n.Message.setProto3BytesField(this, 17, t)
        }, TronWebProto.Account.prototype.getAssetIssuedId = function() {
          return n.Message.getFieldWithDefault(this, 57, "")
        }, TronWebProto.Account.prototype.getAssetIssuedId_asB64 = function() {
          return n.Message.bytesAsB64(this.getAssetIssuedId())
        }, TronWebProto.Account.prototype.getAssetIssuedId_asU8 = function() {
          return n.Message.bytesAsU8(this.getAssetIssuedId())
        }, TronWebProto.Account.prototype.setAssetIssuedId = function(t) {
          return n.Message.setProto3BytesField(this, 57, t)
        }, TronWebProto.Account.prototype.getLatestAssetOperationTimeMap = function(t) {
          return n.Message.getMapField(this, 18, t, null)
        }, TronWebProto.Account.prototype.clearLatestAssetOperationTimeMap = function() {
          return this.getLatestAssetOperationTimeMap().clear(), this
        }, TronWebProto.Account.prototype.getLatestAssetOperationTimev2Map = function(t) {
          return n.Message.getMapField(this, 58, t, null)
        }, TronWebProto.Account.prototype.clearLatestAssetOperationTimev2Map = function() {
          return this.getLatestAssetOperationTimev2Map().clear(), this
        }, TronWebProto.Account.prototype.getFreeNetUsage = function() {
          return n.Message.getFieldWithDefault(this, 19, 0)
        }, TronWebProto.Account.prototype.setFreeNetUsage = function(t) {
          return n.Message.setProto3IntField(this, 19, t)
        }, TronWebProto.Account.prototype.getFreeAssetNetUsageMap = function(t) {
          return n.Message.getMapField(this, 20, t, null)
        }, TronWebProto.Account.prototype.clearFreeAssetNetUsageMap = function() {
          return this.getFreeAssetNetUsageMap().clear(), this
        }, TronWebProto.Account.prototype.getFreeAssetNetUsagev2Map = function(t) {
          return n.Message.getMapField(this, 59, t, null)
        }, TronWebProto.Account.prototype.clearFreeAssetNetUsagev2Map = function() {
          return this.getFreeAssetNetUsagev2Map().clear(), this
        }, TronWebProto.Account.prototype.getLatestConsumeTime = function() {
          return n.Message.getFieldWithDefault(this, 21, 0)
        }, TronWebProto.Account.prototype.setLatestConsumeTime = function(t) {
          return n.Message.setProto3IntField(this, 21, t)
        }, TronWebProto.Account.prototype.getLatestConsumeFreeTime = function() {
          return n.Message.getFieldWithDefault(this, 22, 0)
        }, TronWebProto.Account.prototype.setLatestConsumeFreeTime = function(t) {
          return n.Message.setProto3IntField(this, 22, t)
        }, TronWebProto.Account.prototype.getAccountId = function() {
          return n.Message.getFieldWithDefault(this, 23, "")
        }, TronWebProto.Account.prototype.getAccountId_asB64 = function() {
          return n.Message.bytesAsB64(this.getAccountId())
        }, TronWebProto.Account.prototype.getAccountId_asU8 = function() {
          return n.Message.bytesAsU8(this.getAccountId())
        }, TronWebProto.Account.prototype.setAccountId = function(t) {
          return n.Message.setProto3BytesField(this, 23, t)
        }, TronWebProto.Account.prototype.getAccountResource = function() {
          return n.Message.getWrapperField(this, TronWebProto.Account.AccountResource, 26)
        }, TronWebProto.Account.prototype.setAccountResource = function(t) {
          return n.Message.setWrapperField(this, 26, t)
        }, TronWebProto.Account.prototype.clearAccountResource = function() {
          return this.setAccountResource(void 0)
        }, TronWebProto.Account.prototype.hasAccountResource = function() {
          return null != n.Message.getField(this, 26)
        }, TronWebProto.Account.prototype.getCodehash = function() {
          return n.Message.getFieldWithDefault(this, 30, "")
        }, TronWebProto.Account.prototype.getCodehash_asB64 = function() {
          return n.Message.bytesAsB64(this.getCodehash())
        }, TronWebProto.Account.prototype.getCodehash_asU8 = function() {
          return n.Message.bytesAsU8(this.getCodehash())
        }, TronWebProto.Account.prototype.setCodehash = function(t) {
          return n.Message.setProto3BytesField(this, 30, t)
        }, TronWebProto.Account.prototype.getOwnerPermission = function() {
          return n.Message.getWrapperField(this, TronWebProto.Permission, 31)
        }, TronWebProto.Account.prototype.setOwnerPermission = function(t) {
          return n.Message.setWrapperField(this, 31, t)
        }, TronWebProto.Account.prototype.clearOwnerPermission = function() {
          return this.setOwnerPermission(void 0)
        }, TronWebProto.Account.prototype.hasOwnerPermission = function() {
          return null != n.Message.getField(this, 31)
        }, TronWebProto.Account.prototype.getWitnessPermission = function() {
          return n.Message.getWrapperField(this, TronWebProto.Permission, 32)
        }, TronWebProto.Account.prototype.setWitnessPermission = function(t) {
          return n.Message.setWrapperField(this, 32, t)
        }, TronWebProto.Account.prototype.clearWitnessPermission = function() {
          return this.setWitnessPermission(void 0)
        }, TronWebProto.Account.prototype.hasWitnessPermission = function() {
          return null != n.Message.getField(this, 32)
        }, TronWebProto.Account.prototype.getActivePermissionList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Permission, 33)
        }, TronWebProto.Account.prototype.setActivePermissionList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 33, t)
        }, TronWebProto.Account.prototype.addActivePermission = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 33, t, TronWebProto.Permission, e)
        }, TronWebProto.Account.prototype.clearActivePermissionList = function() {
          return this.setActivePermissionList([])
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Key.prototype.toObject = function(t) {
          return TronWebProto.Key.toObject(t, this)
        }, TronWebProto.Key.toObject = function(t, e) {
          var r = {
            address: e.getAddress_asB64(),
            weight: n.Message.getFieldWithDefault(e, 2, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Key.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Key;
          return TronWebProto.Key.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Key.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setWeight(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Key.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Key.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Key.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getWeight()) && e.writeInt64(2, r)
        }, TronWebProto.Key.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Key.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.Key.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.Key.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Key.prototype.getWeight = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Key.prototype.setWeight = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.DelegatedResource.prototype.toObject = function(t) {
          return TronWebProto.DelegatedResource.toObject(t, this)
        }, TronWebProto.DelegatedResource.toObject = function(t, e) {
          var r = {
            from: e.getFrom_asB64(),
            to: e.getTo_asB64(),
            frozenBalanceForBandwidth: n.Message.getFieldWithDefault(e, 3, 0),
            frozenBalanceForEnergy: n.Message.getFieldWithDefault(e, 4, 0),
            expireTimeForBandwidth: n.Message.getFieldWithDefault(e, 5, 0),
            expireTimeForEnergy: n.Message.getFieldWithDefault(e, 6, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.DelegatedResource.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.DelegatedResource;
          return TronWebProto.DelegatedResource.deserializeBinaryFromReader(r, e)
        }, TronWebProto.DelegatedResource.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setFrom(r);
              break;
            case 2:
              r = e.readBytes(), t.setTo(r);
              break;
            case 3:
              r = e.readInt64(), t.setFrozenBalanceForBandwidth(r);
              break;
            case 4:
              r = e.readInt64(), t.setFrozenBalanceForEnergy(r);
              break;
            case 5:
              r = e.readInt64(), t.setExpireTimeForBandwidth(r);
              break;
            case 6:
              r = e.readInt64(), t.setExpireTimeForEnergy(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.DelegatedResource.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.DelegatedResource.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.DelegatedResource.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getFrom_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getTo_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getFrozenBalanceForBandwidth()) && e.writeInt64(3, r), 0 !== (r = t.getFrozenBalanceForEnergy()) && e.writeInt64(4, r), 0 !== (r = t.getExpireTimeForBandwidth()) && e.writeInt64(5, r), 0 !== (r = t.getExpireTimeForEnergy()) && e.writeInt64(6, r)
        }, TronWebProto.DelegatedResource.prototype.getFrom = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.DelegatedResource.prototype.getFrom_asB64 = function() {
          return n.Message.bytesAsB64(this.getFrom())
        }, TronWebProto.DelegatedResource.prototype.getFrom_asU8 = function() {
          return n.Message.bytesAsU8(this.getFrom())
        }, TronWebProto.DelegatedResource.prototype.setFrom = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.DelegatedResource.prototype.getTo = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.DelegatedResource.prototype.getTo_asB64 = function() {
          return n.Message.bytesAsB64(this.getTo())
        }, TronWebProto.DelegatedResource.prototype.getTo_asU8 = function() {
          return n.Message.bytesAsU8(this.getTo())
        }, TronWebProto.DelegatedResource.prototype.setTo = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.DelegatedResource.prototype.getFrozenBalanceForBandwidth = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.DelegatedResource.prototype.setFrozenBalanceForBandwidth = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.DelegatedResource.prototype.getFrozenBalanceForEnergy = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.DelegatedResource.prototype.setFrozenBalanceForEnergy = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.DelegatedResource.prototype.getExpireTimeForBandwidth = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.DelegatedResource.prototype.setExpireTimeForBandwidth = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.DelegatedResource.prototype.getExpireTimeForEnergy = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.DelegatedResource.prototype.setExpireTimeForEnergy = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.authority.prototype.toObject = function(t) {
          return TronWebProto.authority.toObject(t, this)
        }, TronWebProto.authority.toObject = function(t, e) {
          var r, n = {
            account: (r = e.getAccount()) && TronWebProto.AccountId.toObject(t, r),
            permissionName: e.getPermissionName_asB64()
          };
          return t && (n.$jspbMessageInstance = e), n
        }), TronWebProto.authority.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.authority;
          return TronWebProto.authority.deserializeBinaryFromReader(r, e)
        }, TronWebProto.authority.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = new TronWebProto.AccountId;
              e.readMessage(r, TronWebProto.AccountId.deserializeBinaryFromReader), t.setAccount(r);
              break;
            case 2:
              r = e.readBytes(), t.setPermissionName(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.authority.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.authority.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.authority.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          null != (r = t.getAccount()) && e.writeMessage(1, r, TronWebProto.AccountId.serializeBinaryToWriter), (r = t.getPermissionName_asU8()).length > 0 && e.writeBytes(2, r)
        }, TronWebProto.authority.prototype.getAccount = function() {
          return n.Message.getWrapperField(this, TronWebProto.AccountId, 1)
        }, TronWebProto.authority.prototype.setAccount = function(t) {
          return n.Message.setWrapperField(this, 1, t)
        }, TronWebProto.authority.prototype.clearAccount = function() {
          return this.setAccount(void 0)
        }, TronWebProto.authority.prototype.hasAccount = function() {
          return null != n.Message.getField(this, 1)
        }, TronWebProto.authority.prototype.getPermissionName = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.authority.prototype.getPermissionName_asB64 = function() {
          return n.Message.bytesAsB64(this.getPermissionName())
        }, TronWebProto.authority.prototype.getPermissionName_asU8 = function() {
          return n.Message.bytesAsU8(this.getPermissionName())
        }, TronWebProto.authority.prototype.setPermissionName = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.Permission.repeatedFields_ = [7], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Permission.prototype.toObject = function(t) {
          return TronWebProto.Permission.toObject(t, this)
        }, TronWebProto.Permission.toObject = function(t, e) {
          var r = {
            type: n.Message.getFieldWithDefault(e, 1, 0),
            id: n.Message.getFieldWithDefault(e, 2, 0),
            permissionName: n.Message.getFieldWithDefault(e, 3, ""),
            threshold: n.Message.getFieldWithDefault(e, 4, 0),
            parentId: n.Message.getFieldWithDefault(e, 5, 0),
            operations: e.getOperations_asB64(),
            keysList: n.Message.toObjectList(e.getKeysList(), TronWebProto.Key.toObject, t)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Permission.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Permission;
          return TronWebProto.Permission.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Permission.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readEnum();
              t.setType(r);
              break;
            case 2:
              r = e.readInt32(), t.setId(r);
              break;
            case 3:
              r = e.readString(), t.setPermissionName(r);
              break;
            case 4:
              r = e.readInt64(), t.setThreshold(r);
              break;
            case 5:
              r = e.readInt32(), t.setParentId(r);
              break;
            case 6:
              r = e.readBytes(), t.setOperations(r);
              break;
            case 7:
              r = new TronWebProto.Key, e.readMessage(r, TronWebProto.Key.deserializeBinaryFromReader), t.addKeys(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Permission.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Permission.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Permission.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getType()) && e.writeEnum(1, r), 0 !== (r = t.getId()) && e.writeInt32(2, r), (r = t.getPermissionName()).length > 0 && e.writeString(3, r), 0 !== (r = t.getThreshold()) && e.writeInt64(4, r), 0 !== (r = t.getParentId()) && e.writeInt32(5, r), (r = t.getOperations_asU8()).length > 0 && e.writeBytes(6, r), (r = t.getKeysList()).length > 0 && e.writeRepeatedMessage(7, r, TronWebProto.Key.serializeBinaryToWriter)
        }, TronWebProto.Permission.PermissionType = {
          OWNER: 0,
          WITNESS: 1,
          ACTIVE: 2
        }, TronWebProto.Permission.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Permission.prototype.setType = function(t) {
          return n.Message.setProto3EnumField(this, 1, t)
        }, TronWebProto.Permission.prototype.getId = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Permission.prototype.setId = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.Permission.prototype.getPermissionName = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.Permission.prototype.setPermissionName = function(t) {
          return n.Message.setProto3StringField(this, 3, t)
        }, TronWebProto.Permission.prototype.getThreshold = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.Permission.prototype.setThreshold = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.Permission.prototype.getParentId = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.Permission.prototype.setParentId = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.Permission.prototype.getOperations = function() {
          return n.Message.getFieldWithDefault(this, 6, "")
        }, TronWebProto.Permission.prototype.getOperations_asB64 = function() {
          return n.Message.bytesAsB64(this.getOperations())
        }, TronWebProto.Permission.prototype.getOperations_asU8 = function() {
          return n.Message.bytesAsU8(this.getOperations())
        }, TronWebProto.Permission.prototype.setOperations = function(t) {
          return n.Message.setProto3BytesField(this, 6, t)
        }, TronWebProto.Permission.prototype.getKeysList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Key, 7)
        }, TronWebProto.Permission.prototype.setKeysList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 7, t)
        }, TronWebProto.Permission.prototype.addKeys = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 7, t, TronWebProto.Key, e)
        }, TronWebProto.Permission.prototype.clearKeysList = function() {
          return this.setKeysList([])
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Witness.prototype.toObject = function(t) {
          return TronWebProto.Witness.toObject(t, this)
        }, TronWebProto.Witness.toObject = function(t, e) {
          var r = {
            address: e.getAddress_asB64(),
            votecount: n.Message.getFieldWithDefault(e, 2, 0),
            pubkey: e.getPubkey_asB64(),
            url: n.Message.getFieldWithDefault(e, 4, ""),
            totalproduced: n.Message.getFieldWithDefault(e, 5, 0),
            totalmissed: n.Message.getFieldWithDefault(e, 6, 0),
            latestblocknum: n.Message.getFieldWithDefault(e, 7, 0),
            latestslotnum: n.Message.getFieldWithDefault(e, 8, 0),
            isjobs: n.Message.getBooleanFieldWithDefault(e, 9, !1)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Witness.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Witness;
          return TronWebProto.Witness.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Witness.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAddress(r);
              break;
            case 2:
              r = e.readInt64(), t.setVotecount(r);
              break;
            case 3:
              r = e.readBytes(), t.setPubkey(r);
              break;
            case 4:
              r = e.readString(), t.setUrl(r);
              break;
            case 5:
              r = e.readInt64(), t.setTotalproduced(r);
              break;
            case 6:
              r = e.readInt64(), t.setTotalmissed(r);
              break;
            case 7:
              r = e.readInt64(), t.setLatestblocknum(r);
              break;
            case 8:
              r = e.readInt64(), t.setLatestslotnum(r);
              break;
            case 9:
              r = e.readBool(), t.setIsjobs(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Witness.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Witness.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Witness.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAddress_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getVotecount()) && e.writeInt64(2, r), (r = t.getPubkey_asU8()).length > 0 && e.writeBytes(3, r), (r = t.getUrl()).length > 0 && e.writeString(4, r), 0 !== (r = t.getTotalproduced()) && e.writeInt64(5, r), 0 !== (r = t.getTotalmissed()) && e.writeInt64(6, r), 0 !== (r = t.getLatestblocknum()) && e.writeInt64(7, r), 0 !== (r = t.getLatestslotnum()) && e.writeInt64(8, r), (r = t.getIsjobs()) && e.writeBool(9, r)
        }, TronWebProto.Witness.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Witness.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.Witness.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.Witness.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Witness.prototype.getVotecount = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Witness.prototype.setVotecount = function(t) {
          return n.Message.setProto3IntField(this, 2, t)
        }, TronWebProto.Witness.prototype.getPubkey = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.Witness.prototype.getPubkey_asB64 = function() {
          return n.Message.bytesAsB64(this.getPubkey())
        }, TronWebProto.Witness.prototype.getPubkey_asU8 = function() {
          return n.Message.bytesAsU8(this.getPubkey())
        }, TronWebProto.Witness.prototype.setPubkey = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.Witness.prototype.getUrl = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.Witness.prototype.setUrl = function(t) {
          return n.Message.setProto3StringField(this, 4, t)
        }, TronWebProto.Witness.prototype.getTotalproduced = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.Witness.prototype.setTotalproduced = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.Witness.prototype.getTotalmissed = function() {
          return n.Message.getFieldWithDefault(this, 6, 0)
        }, TronWebProto.Witness.prototype.setTotalmissed = function(t) {
          return n.Message.setProto3IntField(this, 6, t)
        }, TronWebProto.Witness.prototype.getLatestblocknum = function() {
          return n.Message.getFieldWithDefault(this, 7, 0)
        }, TronWebProto.Witness.prototype.setLatestblocknum = function(t) {
          return n.Message.setProto3IntField(this, 7, t)
        }, TronWebProto.Witness.prototype.getLatestslotnum = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.Witness.prototype.setLatestslotnum = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.Witness.prototype.getIsjobs = function() {
          return n.Message.getBooleanFieldWithDefault(this, 9, !1)
        }, TronWebProto.Witness.prototype.setIsjobs = function(t) {
          return n.Message.setProto3BooleanField(this, 9, t)
        }, TronWebProto.Votes.repeatedFields_ = [2, 3], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Votes.prototype.toObject = function(t) {
          return TronWebProto.Votes.toObject(t, this)
        }, TronWebProto.Votes.toObject = function(t, e) {
          var r = {
            address: e.getAddress_asB64(),
            oldVotesList: n.Message.toObjectList(e.getOldVotesList(), TronWebProto.Vote.toObject, t),
            newVotesList: n.Message.toObjectList(e.getNewVotesList(), TronWebProto.Vote.toObject, t)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Votes.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Votes;
          return TronWebProto.Votes.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Votes.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setAddress(r);
              break;
            case 2:
              r = new TronWebProto.Vote, e.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader), t.addOldVotes(r);
              break;
            case 3:
              r = new TronWebProto.Vote, e.readMessage(r, TronWebProto.Vote.deserializeBinaryFromReader), t.addNewVotes(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Votes.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Votes.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Votes.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getAddress_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getOldVotesList()).length > 0 && e.writeRepeatedMessage(2, r, TronWebProto.Vote.serializeBinaryToWriter), (r = t.getNewVotesList()).length > 0 && e.writeRepeatedMessage(3, r, TronWebProto.Vote.serializeBinaryToWriter)
        }, TronWebProto.Votes.prototype.getAddress = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Votes.prototype.getAddress_asB64 = function() {
          return n.Message.bytesAsB64(this.getAddress())
        }, TronWebProto.Votes.prototype.getAddress_asU8 = function() {
          return n.Message.bytesAsU8(this.getAddress())
        }, TronWebProto.Votes.prototype.setAddress = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Votes.prototype.getOldVotesList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 2)
        }, TronWebProto.Votes.prototype.setOldVotesList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 2, t)
        }, TronWebProto.Votes.prototype.addOldVotes = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 2, t, TronWebProto.Vote, e)
        }, TronWebProto.Votes.prototype.clearOldVotesList = function() {
          return this.setOldVotesList([])
        }, TronWebProto.Votes.prototype.getNewVotesList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Vote, 3)
        }, TronWebProto.Votes.prototype.setNewVotesList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 3, t)
        }, TronWebProto.Votes.prototype.addNewVotes = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 3, t, TronWebProto.Vote, e)
        }, TronWebProto.Votes.prototype.clearNewVotesList = function() {
          return this.setNewVotesList([])
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.MarketOrderDetail.prototype.toObject = function(t) {
          return TronWebProto.MarketOrderDetail.toObject(t, this)
        }, TronWebProto.MarketOrderDetail.toObject = function(t, e) {
          var r = {
            makerorderid: e.getMakerorderid_asB64(),
            takerorderid: e.getTakerorderid_asB64(),
            fillsellquantity: n.Message.getFieldWithDefault(e, 3, 0),
            fillbuyquantity: n.Message.getFieldWithDefault(e, 4, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.MarketOrderDetail.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.MarketOrderDetail;
          return TronWebProto.MarketOrderDetail.deserializeBinaryFromReader(r, e)
        }, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setMakerorderid(r);
              break;
            case 2:
              r = e.readBytes(), t.setTakerorderid(r);
              break;
            case 3:
              r = e.readInt64(), t.setFillsellquantity(r);
              break;
            case 4:
              r = e.readInt64(), t.setFillbuyquantity(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.MarketOrderDetail.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.MarketOrderDetail.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.MarketOrderDetail.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getMakerorderid_asU8()).length > 0 && e.writeBytes(1, r), (r = t.getTakerorderid_asU8()).length > 0 && e.writeBytes(2, r), 0 !== (r = t.getFillsellquantity()) && e.writeInt64(3, r), 0 !== (r = t.getFillbuyquantity()) && e.writeInt64(4, r)
        }, TronWebProto.MarketOrderDetail.prototype.getMakerorderid = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asB64 = function() {
          return n.Message.bytesAsB64(this.getMakerorderid())
        }, TronWebProto.MarketOrderDetail.prototype.getMakerorderid_asU8 = function() {
          return n.Message.bytesAsU8(this.getMakerorderid())
        }, TronWebProto.MarketOrderDetail.prototype.setMakerorderid = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.MarketOrderDetail.prototype.getTakerorderid = function() {
          return n.Message.getFieldWithDefault(this, 2, "")
        }, TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asB64 = function() {
          return n.Message.bytesAsB64(this.getTakerorderid())
        }, TronWebProto.MarketOrderDetail.prototype.getTakerorderid_asU8 = function() {
          return n.Message.bytesAsU8(this.getTakerorderid())
        }, TronWebProto.MarketOrderDetail.prototype.setTakerorderid = function(t) {
          return n.Message.setProto3BytesField(this, 2, t)
        }, TronWebProto.MarketOrderDetail.prototype.getFillsellquantity = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.MarketOrderDetail.prototype.setFillsellquantity = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.MarketOrderDetail.prototype.getFillbuyquantity = function() {
          return n.Message.getFieldWithDefault(this, 4, 0)
        }, TronWebProto.MarketOrderDetail.prototype.setFillbuyquantity = function(t) {
          return n.Message.setProto3IntField(this, 4, t)
        }, TronWebProto.Transaction.repeatedFields_ = [2, 5], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.prototype.toObject = function(t) {
          return TronWebProto.Transaction.toObject(t, this)
        }, TronWebProto.Transaction.toObject = function(t, e) {
          var r, i = {
            rawData: (r = e.getRawData()) && TronWebProto.Transaction.raw.toObject(t, r),
            signatureList: e.getSignatureList_asB64(),
            retList: n.Message.toObjectList(e.getRetList(), TronWebProto.Transaction.Result.toObject, t)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.Transaction.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Transaction;
          return TronWebProto.Transaction.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Transaction.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = new TronWebProto.Transaction.raw;
              e.readMessage(r, TronWebProto.Transaction.raw.deserializeBinaryFromReader), t.setRawData(r);
              break;
            case 2:
              r = e.readBytes(), t.addSignature(r);
              break;
            case 5:
              r = new TronWebProto.Transaction.Result, e.readMessage(r, TronWebProto.Transaction.Result.deserializeBinaryFromReader), t.addRet(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Transaction.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Transaction.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Transaction.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          null != (r = t.getRawData()) && e.writeMessage(1, r, TronWebProto.Transaction.raw.serializeBinaryToWriter), (r = t.getSignatureList_asU8()).length > 0 && e.writeRepeatedBytes(2, r), (r = t.getRetList()).length > 0 && e.writeRepeatedMessage(5, r, TronWebProto.Transaction.Result.serializeBinaryToWriter)
        }, n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Contract.prototype.toObject = function(t) {
          return TronWebProto.Transaction.Contract.toObject(t, this)
        }, TronWebProto.Transaction.Contract.toObject = function(t, e) {
          var r, i = {
            type: n.Message.getFieldWithDefault(e, 1, 0),
            parameter: (r = e.getParameter()) && s.Any.toObject(t, r),
            provider: e.getProvider_asB64(),
            contractname: e.getContractname_asB64(),
            permissionId: n.Message.getFieldWithDefault(e, 5, 0)
          };
          return t && (i.$jspbMessageInstance = e), i
        }), TronWebProto.Transaction.Contract.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Transaction.Contract;
          return TronWebProto.Transaction.Contract.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Transaction.Contract.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readEnum();
              t.setType(r);
              break;
            case 2:
              r = new s.Any, e.readMessage(r, s.Any.deserializeBinaryFromReader), t.setParameter(r);
              break;
            case 3:
              r = e.readBytes(), t.setProvider(r);
              break;
            case 4:
              r = e.readBytes(), t.setContractname(r);
              break;
            case 5:
              r = e.readInt32(), t.setPermissionId(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Transaction.Contract.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Transaction.Contract.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Transaction.Contract.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getType()) && e.writeEnum(1, r), null != (r = t.getParameter()) && e.writeMessage(2, r, s.Any.serializeBinaryToWriter), (r = t.getProvider_asU8()).length > 0 && e.writeBytes(3, r), (r = t.getContractname_asU8()).length > 0 && e.writeBytes(4, r), 0 !== (r = t.getPermissionId()) && e.writeInt32(5, r)
        }, TronWebProto.Transaction.Contract.ContractType = {
          ACCOUNTCREATECONTRACT: 0,
          TRANSFERCONTRACT: 1,
          TRANSFERASSETCONTRACT: 2,
          VOTEASSETCONTRACT: 3,
          VOTEWITNESSCONTRACT: 4,
          WITNESSCREATECONTRACT: 5,
          ASSETISSUECONTRACT: 6,
          WITNESSUPDATECONTRACT: 8,
          PARTICIPATEASSETISSUECONTRACT: 9,
          ACCOUNTUPDATECONTRACT: 10,
          FREEZEBALANCECONTRACT: 11,
          UNFREEZEBALANCECONTRACT: 12,
          WITHDRAWBALANCECONTRACT: 13,
          UNFREEZEASSETCONTRACT: 14,
          UPDATEASSETCONTRACT: 15,
          PROPOSALCREATECONTRACT: 16,
          PROPOSALAPPROVECONTRACT: 17,
          PROPOSALDELETECONTRACT: 18,
          SETACCOUNTIDCONTRACT: 19,
          CUSTOMCONTRACT: 20,
          CREATESMARTCONTRACT: 30,
          TRIGGERSMARTCONTRACT: 31,
          GETCONTRACT: 32,
          UPDATESETTINGCONTRACT: 33,
          EXCHANGECREATECONTRACT: 41,
          EXCHANGEINJECTCONTRACT: 42,
          EXCHANGEWITHDRAWCONTRACT: 43,
          EXCHANGETRANSACTIONCONTRACT: 44,
          UPDATEENERGYLIMITCONTRACT: 45,
          ACCOUNTPERMISSIONUPDATECONTRACT: 46,
          CLEARABICONTRACT: 48,
          UPDATEBROKERAGECONTRACT: 49,
          SHIELDEDTRANSFERCONTRACT: 51,
          MARKETSELLASSETCONTRACT: 52,
          MARKETCANCELORDERCONTRACT: 53,
          FREEZEBALANCEV2CONTRACT: 54,
          UNFREEZEBALANCEV2CONTRACT: 55,
          WITHDRAWEXPIREUNFREEZECONTRACT: 56,
          DELEGATERESOURCECONTRACT: 57,
          UNDELEGATERESOURCECONTRACT: 58,
          CANCELALLUNFREEZEV2CONTRACT: 59
        }, TronWebProto.Transaction.Contract.prototype.getType = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Transaction.Contract.prototype.setType = function(t) {
          return n.Message.setProto3EnumField(this, 1, t)
        }, TronWebProto.Transaction.Contract.prototype.getParameter = function() {
          return n.Message.getWrapperField(this, s.Any, 2)
        }, TronWebProto.Transaction.Contract.prototype.setParameter = function(t) {
          return n.Message.setWrapperField(this, 2, t)
        }, TronWebProto.Transaction.Contract.prototype.clearParameter = function() {
          return this.setParameter(void 0)
        }, TronWebProto.Transaction.Contract.prototype.hasParameter = function() {
          return null != n.Message.getField(this, 2)
        }, TronWebProto.Transaction.Contract.prototype.getProvider = function() {
          return n.Message.getFieldWithDefault(this, 3, "")
        }, TronWebProto.Transaction.Contract.prototype.getProvider_asB64 = function() {
          return n.Message.bytesAsB64(this.getProvider())
        }, TronWebProto.Transaction.Contract.prototype.getProvider_asU8 = function() {
          return n.Message.bytesAsU8(this.getProvider())
        }, TronWebProto.Transaction.Contract.prototype.setProvider = function(t) {
          return n.Message.setProto3BytesField(this, 3, t)
        }, TronWebProto.Transaction.Contract.prototype.getContractname = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.Transaction.Contract.prototype.getContractname_asB64 = function() {
          return n.Message.bytesAsB64(this.getContractname())
        }, TronWebProto.Transaction.Contract.prototype.getContractname_asU8 = function() {
          return n.Message.bytesAsU8(this.getContractname())
        }, TronWebProto.Transaction.Contract.prototype.setContractname = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.Transaction.Contract.prototype.getPermissionId = function() {
          return n.Message.getFieldWithDefault(this, 5, 0)
        }, TronWebProto.Transaction.Contract.prototype.setPermissionId = function(t) {
          return n.Message.setProto3IntField(this, 5, t)
        }, TronWebProto.Transaction.Result.repeatedFields_ = [26], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.Result.prototype.toObject = function(t) {
          return TronWebProto.Transaction.Result.toObject(t, this)
        }, TronWebProto.Transaction.Result.toObject = function(t, e) {
          var r = {
            fee: n.Message.getFieldWithDefault(e, 1, 0),
            ret: n.Message.getFieldWithDefault(e, 2, 0),
            contractret: n.Message.getFieldWithDefault(e, 3, 0),
            assetissueid: n.Message.getFieldWithDefault(e, 14, ""),
            withdrawAmount: n.Message.getFieldWithDefault(e, 15, 0),
            unfreezeAmount: n.Message.getFieldWithDefault(e, 16, 0),
            exchangeReceivedAmount: n.Message.getFieldWithDefault(e, 18, 0),
            exchangeInjectAnotherAmount: n.Message.getFieldWithDefault(e, 19, 0),
            exchangeWithdrawAnotherAmount: n.Message.getFieldWithDefault(e, 20, 0),
            exchangeId: n.Message.getFieldWithDefault(e, 21, 0),
            shieldedTransactionFee: n.Message.getFieldWithDefault(e, 22, 0),
            orderid: e.getOrderid_asB64(),
            orderdetailsList: n.Message.toObjectList(e.getOrderdetailsList(), TronWebProto.MarketOrderDetail.toObject, t)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Transaction.Result.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Transaction.Result;
          return TronWebProto.Transaction.Result.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Transaction.Result.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readInt64();
              t.setFee(r);
              break;
            case 2:
              r = e.readEnum(), t.setRet(r);
              break;
            case 3:
              r = e.readEnum(), t.setContractret(r);
              break;
            case 14:
              r = e.readString(), t.setAssetissueid(r);
              break;
            case 15:
              r = e.readInt64(), t.setWithdrawAmount(r);
              break;
            case 16:
              r = e.readInt64(), t.setUnfreezeAmount(r);
              break;
            case 18:
              r = e.readInt64(), t.setExchangeReceivedAmount(r);
              break;
            case 19:
              r = e.readInt64(), t.setExchangeInjectAnotherAmount(r);
              break;
            case 20:
              r = e.readInt64(), t.setExchangeWithdrawAnotherAmount(r);
              break;
            case 21:
              r = e.readInt64(), t.setExchangeId(r);
              break;
            case 22:
              r = e.readInt64(), t.setShieldedTransactionFee(r);
              break;
            case 25:
              r = e.readBytes(), t.setOrderid(r);
              break;
            case 26:
              r = new TronWebProto.MarketOrderDetail, e.readMessage(r, TronWebProto.MarketOrderDetail.deserializeBinaryFromReader), t.addOrderdetails(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Transaction.Result.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Transaction.Result.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Transaction.Result.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          0 !== (r = t.getFee()) && e.writeInt64(1, r), 0 !== (r = t.getRet()) && e.writeEnum(2, r), 0 !== (r = t.getContractret()) && e.writeEnum(3, r), (r = t.getAssetissueid()).length > 0 && e.writeString(14, r), 0 !== (r = t.getWithdrawAmount()) && e.writeInt64(15, r), 0 !== (r = t.getUnfreezeAmount()) && e.writeInt64(16, r), 0 !== (r = t.getExchangeReceivedAmount()) && e.writeInt64(18, r), 0 !== (r = t.getExchangeInjectAnotherAmount()) && e.writeInt64(19, r), 0 !== (r = t.getExchangeWithdrawAnotherAmount()) && e.writeInt64(20, r), 0 !== (r = t.getExchangeId()) && e.writeInt64(21, r), 0 !== (r = t.getShieldedTransactionFee()) && e.writeInt64(22, r), (r = t.getOrderid_asU8()).length > 0 && e.writeBytes(25, r), (r = t.getOrderdetailsList()).length > 0 && e.writeRepeatedMessage(26, r, TronWebProto.MarketOrderDetail.serializeBinaryToWriter)
        }, TronWebProto.Transaction.Result.code = {
          SUCESS: 0,
          FAILED: 1
        }, TronWebProto.Transaction.Result.contractResult = {
          DEFAULT: 0,
          SUCCESS: 1,
          REVERT: 2,
          BAD_JUMP_DESTINATION: 3,
          OUT_OF_MEMORY: 4,
          PRECOMPILED_CONTRACT: 5,
          STACK_TOO_SMALL: 6,
          STACK_TOO_LARGE: 7,
          ILLEGAL_OPERATION: 8,
          STACK_OVERFLOW: 9,
          OUT_OF_ENERGY: 10,
          OUT_OF_TIME: 11,
          JVM_STACK_OVER_FLOW: 12,
          UNKNOWN: 13,
          TRANSFER_FAILED: 14,
          INVALID_CODE: 15
        }, TronWebProto.Transaction.Result.prototype.getFee = function() {
          return n.Message.getFieldWithDefault(this, 1, 0)
        }, TronWebProto.Transaction.Result.prototype.setFee = function(t) {
          return n.Message.setProto3IntField(this, 1, t)
        }, TronWebProto.Transaction.Result.prototype.getRet = function() {
          return n.Message.getFieldWithDefault(this, 2, 0)
        }, TronWebProto.Transaction.Result.prototype.setRet = function(t) {
          return n.Message.setProto3EnumField(this, 2, t)
        }, TronWebProto.Transaction.Result.prototype.getContractret = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.Transaction.Result.prototype.setContractret = function(t) {
          return n.Message.setProto3EnumField(this, 3, t)
        }, TronWebProto.Transaction.Result.prototype.getAssetissueid = function() {
          return n.Message.getFieldWithDefault(this, 14, "")
        }, TronWebProto.Transaction.Result.prototype.setAssetissueid = function(t) {
          return n.Message.setProto3StringField(this, 14, t)
        }, TronWebProto.Transaction.Result.prototype.getWithdrawAmount = function() {
          return n.Message.getFieldWithDefault(this, 15, 0)
        }, TronWebProto.Transaction.Result.prototype.setWithdrawAmount = function(t) {
          return n.Message.setProto3IntField(this, 15, t)
        }, TronWebProto.Transaction.Result.prototype.getUnfreezeAmount = function() {
          return n.Message.getFieldWithDefault(this, 16, 0)
        }, TronWebProto.Transaction.Result.prototype.setUnfreezeAmount = function(t) {
          return n.Message.setProto3IntField(this, 16, t)
        }, TronWebProto.Transaction.Result.prototype.getExchangeReceivedAmount = function() {
          return n.Message.getFieldWithDefault(this, 18, 0)
        }, TronWebProto.Transaction.Result.prototype.setExchangeReceivedAmount = function(t) {
          return n.Message.setProto3IntField(this, 18, t)
        }, TronWebProto.Transaction.Result.prototype.getExchangeInjectAnotherAmount = function() {
          return n.Message.getFieldWithDefault(this, 19, 0)
        }, TronWebProto.Transaction.Result.prototype.setExchangeInjectAnotherAmount = function(t) {
          return n.Message.setProto3IntField(this, 19, t)
        }, TronWebProto.Transaction.Result.prototype.getExchangeWithdrawAnotherAmount = function() {
          return n.Message.getFieldWithDefault(this, 20, 0)
        }, TronWebProto.Transaction.Result.prototype.setExchangeWithdrawAnotherAmount = function(t) {
          return n.Message.setProto3IntField(this, 20, t)
        }, TronWebProto.Transaction.Result.prototype.getExchangeId = function() {
          return n.Message.getFieldWithDefault(this, 21, 0)
        }, TronWebProto.Transaction.Result.prototype.setExchangeId = function(t) {
          return n.Message.setProto3IntField(this, 21, t)
        }, TronWebProto.Transaction.Result.prototype.getShieldedTransactionFee = function() {
          return n.Message.getFieldWithDefault(this, 22, 0)
        }, TronWebProto.Transaction.Result.prototype.setShieldedTransactionFee = function(t) {
          return n.Message.setProto3IntField(this, 22, t)
        }, TronWebProto.Transaction.Result.prototype.getOrderid = function() {
          return n.Message.getFieldWithDefault(this, 25, "")
        }, TronWebProto.Transaction.Result.prototype.getOrderid_asB64 = function() {
          return n.Message.bytesAsB64(this.getOrderid())
        }, TronWebProto.Transaction.Result.prototype.getOrderid_asU8 = function() {
          return n.Message.bytesAsU8(this.getOrderid())
        }, TronWebProto.Transaction.Result.prototype.setOrderid = function(t) {
          return n.Message.setProto3BytesField(this, 25, t)
        }, TronWebProto.Transaction.Result.prototype.getOrderdetailsList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.MarketOrderDetail, 26)
        }, TronWebProto.Transaction.Result.prototype.setOrderdetailsList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 26, t)
        }, TronWebProto.Transaction.Result.prototype.addOrderdetails = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 26, t, TronWebProto.MarketOrderDetail, e)
        }, TronWebProto.Transaction.Result.prototype.clearOrderdetailsList = function() {
          return this.setOrderdetailsList([])
        }, TronWebProto.Transaction.raw.repeatedFields_ = [9, 11], n.Message.GENERATE_TO_OBJECT && (TronWebProto.Transaction.raw.prototype.toObject = function(t) {
          return TronWebProto.Transaction.raw.toObject(t, this)
        }, TronWebProto.Transaction.raw.toObject = function(t, e) {
          var r = {
            refBlockBytes: e.getRefBlockBytes_asB64(),
            refBlockNum: n.Message.getFieldWithDefault(e, 3, 0),
            refBlockHash: e.getRefBlockHash_asB64(),
            expiration: n.Message.getFieldWithDefault(e, 8, 0),
            authsList: n.Message.toObjectList(e.getAuthsList(), TronWebProto.authority.toObject, t),
            data: e.getData_asB64(),
            contractList: n.Message.toObjectList(e.getContractList(), TronWebProto.Transaction.Contract.toObject, t),
            scripts: e.getScripts_asB64(),
            timestamp: n.Message.getFieldWithDefault(e, 14, 0),
            feeLimit: n.Message.getFieldWithDefault(e, 18, 0)
          };
          return t && (r.$jspbMessageInstance = e), r
        }), TronWebProto.Transaction.raw.deserializeBinary = function(t) {
          var e = new n.BinaryReader(t),
            r = new TronWebProto.Transaction.raw;
          return TronWebProto.Transaction.raw.deserializeBinaryFromReader(r, e)
        }, TronWebProto.Transaction.raw.deserializeBinaryFromReader = function(t, e) {
          for (; e.nextField() && !e.isEndGroup();) switch (e.getFieldNumber()) {
            case 1:
              var r = e.readBytes();
              t.setRefBlockBytes(r);
              break;
            case 3:
              r = e.readInt64(), t.setRefBlockNum(r);
              break;
            case 4:
              r = e.readBytes(), t.setRefBlockHash(r);
              break;
            case 8:
              r = e.readInt64(), t.setExpiration(r);
              break;
            case 9:
              r = new TronWebProto.authority, e.readMessage(r, TronWebProto.authority.deserializeBinaryFromReader), t.addAuths(r);
              break;
            case 10:
              r = e.readBytes(), t.setData(r);
              break;
            case 11:
              r = new TronWebProto.Transaction.Contract, e.readMessage(r, TronWebProto.Transaction.Contract.deserializeBinaryFromReader), t.addContract(r);
              break;
            case 12:
              r = e.readBytes(), t.setScripts(r);
              break;
            case 14:
              r = e.readInt64(), t.setTimestamp(r);
              break;
            case 18:
              r = e.readInt64(), t.setFeeLimit(r);
              break;
            default:
              e.skipField()
          }
          return t
        }, TronWebProto.Transaction.raw.prototype.serializeBinary = function() {
          var t = new n.BinaryWriter;
          return TronWebProto.Transaction.raw.serializeBinaryToWriter(this, t), t.getResultBuffer()
        }, TronWebProto.Transaction.raw.serializeBinaryToWriter = function(t, e) {
          var r = void 0;
          (r = t.getRefBlockBytes_asU8()).length > 0 && e.writeBytes(1, r), 0 !== (r = t.getRefBlockNum()) && e.writeInt64(3, r), (r = t.getRefBlockHash_asU8()).length > 0 && e.writeBytes(4, r), 0 !== (r = t.getExpiration()) && e.writeInt64(8, r), (r = t.getAuthsList()).length > 0 && e.writeRepeatedMessage(9, r, TronWebProto.authority.serializeBinaryToWriter), (r = t.getData_asU8()).length > 0 && e.writeBytes(10, r), (r = t.getContractList()).length > 0 && e.writeRepeatedMessage(11, r, TronWebProto.Transaction.Contract.serializeBinaryToWriter), (r = t.getScripts_asU8()).length > 0 && e.writeBytes(12, r), 0 !== (r = t.getTimestamp()) && e.writeInt64(14, r), 0 !== (r = t.getFeeLimit()) && e.writeInt64(18, r)
        }, TronWebProto.Transaction.raw.prototype.getRefBlockBytes = function() {
          return n.Message.getFieldWithDefault(this, 1, "")
        }, TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asB64 = function() {
          return n.Message.bytesAsB64(this.getRefBlockBytes())
        }, TronWebProto.Transaction.raw.prototype.getRefBlockBytes_asU8 = function() {
          return n.Message.bytesAsU8(this.getRefBlockBytes())
        }, TronWebProto.Transaction.raw.prototype.setRefBlockBytes = function(t) {
          return n.Message.setProto3BytesField(this, 1, t)
        }, TronWebProto.Transaction.raw.prototype.getRefBlockNum = function() {
          return n.Message.getFieldWithDefault(this, 3, 0)
        }, TronWebProto.Transaction.raw.prototype.setRefBlockNum = function(t) {
          return n.Message.setProto3IntField(this, 3, t)
        }, TronWebProto.Transaction.raw.prototype.getRefBlockHash = function() {
          return n.Message.getFieldWithDefault(this, 4, "")
        }, TronWebProto.Transaction.raw.prototype.getRefBlockHash_asB64 = function() {
          return n.Message.bytesAsB64(this.getRefBlockHash())
        }, TronWebProto.Transaction.raw.prototype.getRefBlockHash_asU8 = function() {
          return n.Message.bytesAsU8(this.getRefBlockHash())
        }, TronWebProto.Transaction.raw.prototype.setRefBlockHash = function(t) {
          return n.Message.setProto3BytesField(this, 4, t)
        }, TronWebProto.Transaction.raw.prototype.getExpiration = function() {
          return n.Message.getFieldWithDefault(this, 8, 0)
        }, TronWebProto.Transaction.raw.prototype.setExpiration = function(t) {
          return n.Message.setProto3IntField(this, 8, t)
        }, TronWebProto.Transaction.raw.prototype.getAuthsList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.authority, 9)
        }, TronWebProto.Transaction.raw.prototype.setAuthsList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 9, t)
        }, TronWebProto.Transaction.raw.prototype.addAuths = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 9, t, TronWebProto.authority, e)
        }, TronWebProto.Transaction.raw.prototype.clearAuthsList = function() {
          return this.setAuthsList([])
        }, TronWebProto.Transaction.raw.prototype.getData = function() {
          return n.Message.getFieldWithDefault(this, 10, "")
        }, TronWebProto.Transaction.raw.prototype.getData_asB64 = function() {
          return n.Message.bytesAsB64(this.getData())
        }, TronWebProto.Transaction.raw.prototype.getData_asU8 = function() {
          return n.Message.bytesAsU8(this.getData())
        }, TronWebProto.Transaction.raw.prototype.setData = function(t) {
          return n.Message.setProto3BytesField(this, 10, t)
        }, TronWebProto.Transaction.raw.prototype.getContractList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Contract, 11)
        }, TronWebProto.Transaction.raw.prototype.setContractList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 11, t)
        }, TronWebProto.Transaction.raw.prototype.addContract = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 11, t, TronWebProto.Transaction.Contract, e)
        }, TronWebProto.Transaction.raw.prototype.clearContractList = function() {
          return this.setContractList([])
        }, TronWebProto.Transaction.raw.prototype.getScripts = function() {
          return n.Message.getFieldWithDefault(this, 12, "")
        }, TronWebProto.Transaction.raw.prototype.getScripts_asB64 = function() {
          return n.Message.bytesAsB64(this.getScripts())
        }, TronWebProto.Transaction.raw.prototype.getScripts_asU8 = function() {
          return n.Message.bytesAsU8(this.getScripts())
        }, TronWebProto.Transaction.raw.prototype.setScripts = function(t) {
          return n.Message.setProto3BytesField(this, 12, t)
        }, TronWebProto.Transaction.raw.prototype.getTimestamp = function() {
          return n.Message.getFieldWithDefault(this, 14, 0)
        }, TronWebProto.Transaction.raw.prototype.setTimestamp = function(t) {
          return n.Message.setProto3IntField(this, 14, t)
        }, TronWebProto.Transaction.raw.prototype.getFeeLimit = function() {
          return n.Message.getFieldWithDefault(this, 18, 0)
        }, TronWebProto.Transaction.raw.prototype.setFeeLimit = function(t) {
          return n.Message.setProto3IntField(this, 18, t)
        }, TronWebProto.Transaction.prototype.getRawData = function() {
          return n.Message.getWrapperField(this, TronWebProto.Transaction.raw, 1)
        }, TronWebProto.Transaction.prototype.setRawData = function(t) {
          return n.Message.setWrapperField(this, 1, t)
        }, TronWebProto.Transaction.prototype.clearRawData = function() {
          return this.setRawData(void 0)
        }, TronWebProto.Transaction.prototype.hasRawData = function() {
          return null != n.Message.getField(this, 1)
        }, TronWebProto.Transaction.prototype.getSignatureList = function() {
          return n.Message.getRepeatedField(this, 2)
        }, TronWebProto.Transaction.prototype.getSignatureList_asB64 = function() {
          return n.Message.bytesListAsB64(this.getSignatureList())
        }, TronWebProto.Transaction.prototype.getSignatureList_asU8 = function() {
          return n.Message.bytesListAsU8(this.getSignatureList())
        }, TronWebProto.Transaction.prototype.setSignatureList = function(t) {
          return n.Message.setField(this, 2, t || [])
        }, TronWebProto.Transaction.prototype.addSignature = function(t, e) {
          return n.Message.addToRepeatedField(this, 2, t, e)
        }, TronWebProto.Transaction.prototype.clearSignatureList = function() {
          return this.setSignatureList([])
        }, TronWebProto.Transaction.prototype.getRetList = function() {
          return n.Message.getRepeatedWrapperField(this, TronWebProto.Transaction.Result, 5)
        }, TronWebProto.Transaction.prototype.setRetList = function(t) {
          return n.Message.setRepeatedWrapperField(this, 5, t)
        }, TronWebProto.Transaction.prototype.addRet = function(t, e) {
          return n.Message.addToRepeatedWrapperField(this, 5, t, TronWebProto.Transaction.Result, e)
        }, TronWebProto.Transaction.prototype.clearRetList = function() {
          return this.setRetList([])
        }, TronWebProto.AccountType = {
          NORMAL: 0,
          ASSETISSUE: 1,
          CONTRACT: 2
        }, i.object.extend(e, TronWebProto)
      },
      99175: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.wrapXOFConstructorWithOpts = e.wrapConstructorWithOpts = e.wrapConstructor = e.Hash = e.nextTick = e.swap32IfBE = e.byteSwapIfBE = e.swap8IfBE = e.isLE = void 0, e.isBytes = i, e.anumber = o, e.abytes = s, e.ahash = function(t) {
          if ("function" != typeof t || "function" != typeof t.create) throw Error("Hash should be wrapped by utils.createHasher");
          o(t.outputLen), o(t.blockLen)
        }, e.aexists = function(t, e = !0) {
          if (t.destroyed) throw Error("Hash instance has been destroyed");
          if (e && t.finished) throw Error("Hash#digest() has already been called")
        }, e.aoutput = function(t, e) {
          s(t);
          const r = e.outputLen;
          if (t.length < r) throw Error("digestInto() expects output buffer of length at least " + r)
        }, e.u8 = function(t) {
          return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
        }, e.u32 = function(t) {
          return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
        }, e.clean = function(...t) {
          for (let e = 0; e < t.length; e++) t[e].fill(0)
        }, e.createView = function(t) {
          return new DataView(t.buffer, t.byteOffset, t.byteLength)
        }, e.rotr = function(t, e) {
          return t << 32 - e | t >>> e
        }, e.rotl = function(t, e) {
          return t << e | t >>> 32 - e >>> 0
        }, e.byteSwap = a, e.byteSwap32 = u, e.bytesToHex = function(t) {
          if (s(t), c) return t.toHex();
          let e = "";
          for (let r = 0; r < t.length; r++) e += f[t[r]];
          return e
        }, e.hexToBytes = function(t) {
          if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
          if (c) return Uint8Array.fromHex(t);
          const e = t.length,
            r = e / 2;
          if (e % 2) throw Error("hex string expected, got unpadded hex of length " + e);
          const n = new Uint8Array(r);
          for (let e = 0, i = 0; r > e; e++, i += 2) {
            const r = h(t.charCodeAt(i)),
              o = h(t.charCodeAt(i + 1));
            if (void 0 === r || void 0 === o) {
              const e = t[i] + t[i + 1];
              throw Error('hex string expected, got non-hex character "' + e + '" at index ' + i)
            }
            n[e] = 16 * r + o
          }
          return n
        }, e.asyncLoop = async function(t, r, n) {
          let i = Date.now();
          for (let o = 0; t > o; o++) {
            n(o);
            const t = Date.now() - i;
            t >= 0 && r > t || (await (0, e.nextTick)(), i += t)
          }
        }, e.utf8ToBytes = d, e.bytesToUtf8 = function(t) {
          return (new TextDecoder).decode(t)
        }, e.toBytes = p, e.kdfInputToBytes = function(t) {
          return "string" == typeof t && (t = d(t)), s(t), t
        }, e.concatBytes = function(...t) {
          let e = 0;
          for (let r = 0; r < t.length; r++) {
            const n = t[r];
            s(n), e += n.length
          }
          const r = new Uint8Array(e);
          for (let e = 0, n = 0; e < t.length; e++) {
            const i = t[e];
            r.set(i, n), n += i.length
          }
          return r
        }, e.checkOpts = function(t, e) {
          if (void 0 !== e && "[object Object]" !== {}.toString.call(e)) throw Error("options should be object or undefined");
          return Object.assign(t, e)
        }, e.createHasher = b, e.createOptHasher = m, e.createXOFer = y, e.randomBytes = function(t = 32) {
          if (n.crypto && "function" == typeof n.crypto.getRandomValues) return n.crypto.getRandomValues(new Uint8Array(t));
          if (n.crypto && "function" == typeof n.crypto.randomBytes) return Uint8Array.from(n.crypto.randomBytes(t));
          throw Error("crypto.getRandomValues must be defined")
        };
        const n = r(25145);

        function i(t) {
          return t instanceof Uint8Array || ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name
        }

        function o(t) {
          if (!Number.isSafeInteger(t) || 0 > t) throw Error("positive integer expected, got " + t)
        }

        function s(t, ...e) {
          if (!i(t)) throw Error("Uint8Array expected");
          if (e.length > 0 && !e.includes(t.length)) throw Error("Uint8Array expected of length " + e + ", got length=" + t.length)
        }

        function a(t) {
          return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255
        }

        function u(t) {
          for (let e = 0; e < t.length; e++) t[e] = a(t[e]);
          return t
        }
        e.isLE = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0], e.swap8IfBE = e.isLE ? t => t : t => a(t), e.byteSwapIfBE = e.swap8IfBE, e.swap32IfBE = e.isLE ? t => t : u;
        const c = "function" == typeof Uint8Array.from([]).toHex && "function" == typeof Uint8Array.fromHex,
          f = Array.from({
            length: 256
          }, (t, e) => e.toString(16).padStart(2, "0")),
          l = {
            _t: 48,
            Dt: 57,
            A: 65,
            F: 70,
            a: 97,
            f: 102
          };

        function h(t) {
          return t < l._t || t > l.Dt ? t < l.A || t > l.F ? t < l.a || t > l.f ? void 0 : t - (l.a - 10) : t - (l.A - 10) : t - l._t
        }

        function d(t) {
          if ("string" != typeof t) throw Error("string expected");
          return new Uint8Array((new TextEncoder).encode(t))
        }

        function p(t) {
          return "string" == typeof t && (t = d(t)), s(t), t
        }

        function b(t) {
          const e = e => t().update(p(e)).digest(),
            r = t();
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
        }

        function m(t) {
          const e = (e, r) => t(r).update(p(e)).digest(),
            r = t({});
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = e => t(e), e
        }

        function y(t) {
          const e = (e, r) => t(r).update(p(e)).digest(),
            r = t({});
          return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = e => t(e), e
        }
        e.nextTick = async () => {}, e.Hash = class {}, e.wrapConstructor = b, e.wrapConstructorWithOpts = m, e.wrapXOFConstructorWithOpts = y
      },
      99317: function(t, e, r) {
        "use strict";
        var n = this && this.nt || function(t) {
          return t && t._ ? t : {
            default: t
          }
        };
        Object.defineProperty(e, "_", {
          value: !0
        }), e.defaultErrorMap = void 0, e.setErrorMap = function(t) {
          o = t
        }, e.getErrorMap = function() {
          return o
        };
        const i = n(r(75653));
        e.defaultErrorMap = i.default;
        let o = i.default
      },
      99546: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, i.default)(t), o.test(t)
        };
        var n, i = (n = r(83399)) && n._ ? n : {
            default: n
          },
          o = /^(0o)?[0-7]+$/i;
        t.exports = e.default, t.exports.default = e.default
      },
      99579: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.WalletContractV2R2 = void 0;
        const i = r(1307),
          o = r(20574);
        class s {
          static create(t) {
            return new s(t.workchain, t.publicKey)
          }
          constructor(t, e) {
            this.workchain = t, this.publicKey = e;
            let r = i.Cell.fromBoc(n.from("te6cckEBAQEAYwAAwv8AIN0gggFMl7ohggEznLqxnHGw7UTQ0x/XC//jBOCk8mCDCNcYINMf0x8B+CO78mPtRNDTH9P/0VExuvKhA/kBVBBC+RDyovgAApMg10qW0wfUAvsA6NGkyMsfy//J7VQETNeh", "base64"))[0],
              o = (0, i.beginCell)().storeUint(0, 32).storeBuffer(e).endCell();
            this.init = {
              code: r,
              data: o
            }, this.address = (0, i.contractAddress)(t, {
              code: r,
              data: o
            })
          }
          async getBalance(t) {
            return (await t.getState()).balance
          }
          async getSeqno(t) {
            return "active" === (await t.getState()).state.type ? (await t.get("seqno", [])).stack.readNumber() : 0
          }
          async send(t, e) {
            await t.external(e)
          }
          async sendTransfer(t, e) {
            let r = this.createTransfer(e);
            await this.send(t, r)
          }
          createTransfer(t) {
            let e = i.SendMode.PAY_GAS_SEPARATELY;
            return null !== t.sendMode && void 0 !== t.sendMode && (e = t.sendMode), (0, o.createWalletTransferV2)({
              seqno: t.seqno,
              sendMode: e,
              secretKey: t.secretKey,
              messages: t.messages,
              timeout: t.timeout
            })
          }
          sender(t, e) {
            return {
              send: async r => {
                let n = await this.getSeqno(t),
                  o = this.createTransfer({
                    seqno: n,
                    secretKey: e,
                    sendMode: r.sendMode,
                    messages: [(0, i.internal)({
                      to: r.to,
                      value: r.value,
                      init: r.init,
                      body: r.body,
                      bounce: r.bounce
                    })]
                  });
                await this.send(t, o)
              }
            }
          }
        }
        e.WalletContractV2R2 = s
      },
      99589: (t, e, r) => {
        const n = r(99718),
          i = r(16874),
          o = r(53908),
          s = r(61123),
          a = r(30144),
          u = r(56953),
          c = r(57414),
          f = r(93007),
          l = r(51832),
          h = r(32938),
          d = r(46254),
          p = r(24493),
          b = r(31729),
          m = r(50560),
          y = r(9970),
          g = r(11763),
          v = r(40909),
          w = r(43927),
          A = r(74277),
          T = r(35580),
          E = r(7059),
          P = r(94641),
          k = r(13999),
          x = r(54089),
          I = r(25200),
          S = r(72111),
          O = r(46170),
          B = r(93904),
          W = r(78311),
          M = r(97638),
          C = r(77631),
          R = r(19628),
          N = r(270),
          j = r(41261),
          _ = r(13874),
          D = r(97075),
          U = r(75571),
          L = r(5342),
          F = r(76780),
          $ = r(72525),
          z = r(75032);
        t.exports = {
          parse: a,
          valid: u,
          clean: c,
          inc: f,
          diff: l,
          major: h,
          minor: d,
          patch: p,
          prerelease: b,
          compare: m,
          rcompare: y,
          compareLoose: g,
          compareBuild: v,
          sort: w,
          rsort: A,
          gt: T,
          lt: E,
          eq: P,
          neq: k,
          gte: x,
          lte: I,
          cmp: S,
          coerce: O,
          Comparator: B,
          Range: W,
          satisfies: M,
          toComparators: C,
          maxSatisfying: R,
          minSatisfying: N,
          minVersion: j,
          validRange: _,
          outside: D,
          gtr: U,
          ltr: L,
          intersects: F,
          simplifyRange: $,
          subset: z,
          SemVer: o,
          re: n.re,
          src: n.src,
          tokens: n.t,
          SEMVER_SPEC_VERSION: i.SEMVER_SPEC_VERSION,
          RELEASE_TYPES: i.RELEASE_TYPES,
          compareIdentifiers: s.compareIdentifiers,
          rcompareIdentifiers: s.rcompareIdentifiers
        }
      },
      99718: (t, e, r) => {
        const {
          MAX_SAFE_COMPONENT_LENGTH: n,
          MAX_SAFE_BUILD_LENGTH: i,
          MAX_LENGTH: o
        } = r(16874), s = r(57272), a = (e = t.exports = {}).re = [], u = e.safeRe = [], c = e.src = [], f = e.safeSrc = [], l = e.t = {};
        let h = 0;
        const d = "[a-zA-Z0-9-]",
          p = [
            ["\\s", 1],
            ["\\d", o],
            [d, i]
          ],
          b = (t, e, r) => {
            const n = (t => {
                for (const [e, r] of p) t = t.split(e + "*").join(`${e}{0,${r}}`).split(e + "+").join(`${e}{1,${r}}`);
                return t
              })(e),
              i = h++;
            s(t, i, e), l[t] = i, c[i] = e, f[i] = n, a[i] = RegExp(e, r ? "g" : void 0), u[i] = RegExp(n, r ? "g" : void 0)
          };
        b("NUMERICIDENTIFIER", "0|[1-9]\\d*"), b("NUMERICIDENTIFIERLOOSE", "\\d+"), b("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${d}*`), b("MAINVERSION", `(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})\\.(${c[l.NUMERICIDENTIFIER]})`), b("MAINVERSIONLOOSE", `(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})\\.(${c[l.NUMERICIDENTIFIERLOOSE]})`), b("PRERELEASEIDENTIFIER", `(?:${c[l.NUMERICIDENTIFIER]}|${c[l.NONNUMERICIDENTIFIER]})`), b("PRERELEASEIDENTIFIERLOOSE", `(?:${c[l.NUMERICIDENTIFIERLOOSE]}|${c[l.NONNUMERICIDENTIFIER]})`), b("PRERELEASE", `(?:-(${c[l.PRERELEASEIDENTIFIER]}(?:\\.${c[l.PRERELEASEIDENTIFIER]})*))`), b("PRERELEASELOOSE", `(?:-?(${c[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${c[l.PRERELEASEIDENTIFIERLOOSE]})*))`), b("BUILDIDENTIFIER", d + "+"), b("BUILD", `(?:\\+(${c[l.BUILDIDENTIFIER]}(?:\\.${c[l.BUILDIDENTIFIER]})*))`), b("FULLPLAIN", `v?${c[l.MAINVERSION]}${c[l.PRERELEASE]}?${c[l.BUILD]}?`), b("FULL", `^${c[l.FULLPLAIN]}$`), b("LOOSEPLAIN", `[v=\\s]*${c[l.MAINVERSIONLOOSE]}${c[l.PRERELEASELOOSE]}?${c[l.BUILD]}?`), b("LOOSE", `^${c[l.LOOSEPLAIN]}$`), b("GTLT", "((?:<|>)?=?)"), b("XRANGEIDENTIFIERLOOSE", c[l.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*"), b("XRANGEIDENTIFIER", c[l.NUMERICIDENTIFIER] + "|x|X|\\*"), b("XRANGEPLAIN", `[v=\\s]*(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:\\.(${c[l.XRANGEIDENTIFIER]})(?:${c[l.PRERELEASE]})?${c[l.BUILD]}?)?)?`), b("XRANGEPLAINLOOSE", `[v=\\s]*(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${c[l.XRANGEIDENTIFIERLOOSE]})(?:${c[l.PRERELEASELOOSE]})?${c[l.BUILD]}?)?)?`), b("XRANGE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAIN]}$`), b("XRANGELOOSE", `^${c[l.GTLT]}\\s*${c[l.XRANGEPLAINLOOSE]}$`), b("COERCEPLAIN", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?`), b("COERCE", c[l.COERCEPLAIN] + "(?:$|[^\\d])"), b("COERCEFULL", c[l.COERCEPLAIN] + `(?:${c[l.PRERELEASE]})?(?:${c[l.BUILD]})?(?:$|[^\\d])`), b("COERCERTL", c[l.COERCE], !0), b("COERCERTLFULL", c[l.COERCEFULL], !0), b("LONETILDE", "(?:~>?)"), b("TILDETRIM", `(\\s*)${c[l.LONETILDE]}\\s+`, !0), e.tildeTrimReplace = "$1~", b("TILDE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAIN]}$`), b("TILDELOOSE", `^${c[l.LONETILDE]}${c[l.XRANGEPLAINLOOSE]}$`), b("LONECARET", "(?:\\^)"), b("CARETTRIM", `(\\s*)${c[l.LONECARET]}\\s+`, !0), e.caretTrimReplace = "$1^", b("CARET", `^${c[l.LONECARET]}${c[l.XRANGEPLAIN]}$`), b("CARETLOOSE", `^${c[l.LONECARET]}${c[l.XRANGEPLAINLOOSE]}$`), b("COMPARATORLOOSE", `^${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]})$|^$`), b("COMPARATOR", `^${c[l.GTLT]}\\s*(${c[l.FULLPLAIN]})$|^$`), b("COMPARATORTRIM", `(\\s*)${c[l.GTLT]}\\s*(${c[l.LOOSEPLAIN]}|${c[l.XRANGEPLAIN]})`, !0), e.comparatorTrimReplace = "$1$2$3", b("HYPHENRANGE", `^\\s*(${c[l.XRANGEPLAIN]})\\s+-\\s+(${c[l.XRANGEPLAIN]})\\s*$`), b("HYPHENRANGELOOSE", `^\\s*(${c[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${c[l.XRANGEPLAINLOOSE]})\\s*$`), b("STAR", "(<|>)?=?\\s*\\*"), b("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), b("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$")
      },
      99721: (t, e, r) => {
        "use strict";
        var n = r(36556),
          i = r(14035),
          o = n("RegExp.prototype.exec"),
          s = r(69675);
        t.exports = function(t) {
          if (!i(t)) throw new s("`regex` must be a RegExp");
          return function(e) {
            return null !== o(t, e)
          }
        }
      },
      99841: (t, e, r) => {
        "use strict";
        Object.defineProperty(e, "_", {
          value: !0
        }), e.default = function(t) {
          return (0, n.default)(t), o.test(t)
        };
        var n = i(r(83399));

        function i(t) {
          return t && t._ ? t : {
            default: t
          }
        }
        var o = (0, i(r(55730)).default)(["^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)", "(?:-((?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-z-][0-9a-z-]*))*))", "?(?:\\+([0-9a-z-]+(?:\\.[0-9a-z-]+)*))?$"], "i");
        t.exports = e.default, t.exports.default = e.default
      },
      99967: (t, e, r) => {
        "use strict";
        var n = r(48287).Buffer;
        Object.defineProperty(e, "_", {
          value: !0
        }), e.hmac_sha512 = void 0, e.hmac_sha512 = async function(t, e) {
          let r = "string" == typeof t ? n.from(t, "utf-8") : t,
            i = "string" == typeof e ? n.from(e, "utf-8") : e;
          const o = {
              name: "HMAC",
              hash: "SHA-512"
            },
            s = await window.crypto.subtle.importKey("raw", r, o, !1, ["sign"]);
          return n.from(await crypto.subtle.sign(o, s, i))
        }
      }
    },
    n = {};

  function i(t) {
    var e = n[t];
    if (void 0 !== e) return e.exports;
    var o = n[t] = {
      id: t,
      loaded: !1,
      exports: {}
    };
    return r[t].call(o.exports, o, o.exports, i), o.loaded = !0, o.exports
  }
  i.n = t => {
    var e = t && t._ ? () => t.default : () => t;
    return i.d(e, {
      a: e
    }), e
  }, e = Object.getPrototypeOf ? t => Object.getPrototypeOf(t) : t => t.__proto__, i.t = function(r, n) {
    if (1 & n && (r = this(r)), 8 & n || "object" == typeof r && r && (4 & n && r._ || 16 & n && "function" == typeof r.then)) return r;
    var o = Object.create(null);
    i.r(o);
    var s = {};
    t = t || [null, e({}), e([]), e(e)];
    for (var a = 2 & n && r;
      "object" == typeof a && !~t.indexOf(a); a = e(a)) Object.getOwnPropertyNames(a).forEach(t => s[t] = () => r[t]);
    return s.default = () => r, i.d(o, s), o
  }, i.d = (t, e) => {
    for (var r in e) i.o(e, r) && !i.o(t, r) && Object.defineProperty(t, r, {
      enumerable: !0,
      get: e[r]
    })
  }, i.g = function() {
    if ("object" == typeof globalThis) return globalThis;
    try {
      return this || Function("return this")()
    } catch {
      if ("object" == typeof window) return window
    }
  }(), i.o = (t, e) => ({}.hasOwnProperty.call(t, e)), i.r = t => {
    "u" > typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(t, "_", {
      value: !0
    })
  }, i.nmd = t => (t.paths = [], t.children || (t.children = []), t), (() => {
    "use strict";
    var t = {};
    i.r(t), i.d(t, {
      BRAND: () => ew,
      DIRTY: () => Dg,
      EMPTY_PATH: () => Rg,
      INVALID: () => _g,
      NEVER: () => Zw,
      OK: () => Ug,
      ParseStatus: () => jg,
      Schema: () => Vg,
      ZodAny: () => xv,
      ZodArray: () => Bv,
      ZodBigInt: () => wv,
      ZodBoolean: () => Av,
      ZodBranded: () => rw,
      ZodCatch: () => Xv,
      ZodDate: () => Tv,
      ZodDefault: () => Qv,
      ZodDiscriminatedUnion: () => Nv,
      ZodEffects: () => qv,
      ZodEnum: () => Kv,
      ZodError: () => Ig,
      ZodFirstPartyTypeKind: () => uw,
      ZodFunction: () => $v,
      ZodIntersection: () => _v,
      ZodIssueCode: () => kg,
      ZodLazy: () => zv,
      ZodLiteral: () => Hv,
      ZodMap: () => Lv,
      ZodNaN: () => tw,
      ZodNativeEnum: () => Vv,
      ZodNever: () => Sv,
      ZodNull: () => kv,
      ZodNullable: () => Yv,
      ZodNumber: () => vv,
      ZodObject: () => Mv,
      ZodOptional: () => Jv,
      ZodParsedType: () => Eg,
      ZodPipeline: () => nw,
      ZodPromise: () => Zv,
      ZodReadonly: () => iw,
      ZodRecord: () => Uv,
      ZodSchema: () => Vg,
      ZodSet: () => Fv,
      ZodString: () => yv,
      ZodSymbol: () => Ev,
      ZodTransformer: () => qv,
      ZodTuple: () => Dv,
      ZodType: () => Vg,
      ZodUndefined: () => Pv,
      ZodUnion: () => Cv,
      ZodUnknown: () => Iv,
      ZodVoid: () => Ov,
      addIssueToContext: () => Ng,
      any: () => vw,
      array: () => Ew,
      bigint: () => dw,
      boolean: () => pw,
      coerce: () => Vw,
      custom: () => sw,
      date: () => bw,
      datetimeRegex: () => dv,
      defaultErrorMap: () => Sg,
      discriminatedUnion: () => Iw,
      effect: () => Uw,
      enum: () => jw,
      function: () => Cw,
      getErrorMap: () => Wg,
      getParsedType: () => Pg,
      instanceof: () => cw,
      intersection: () => Sw,
      isAborted: () => Lg,
      isAsync: () => zg,
      isDirty: () => Fg,
      isValid: () => $g,
      late: () => aw,
      lazy: () => Rw,
      literal: () => Nw,
      makeIssue: () => Cg,
      map: () => Ww,
      nan: () => hw,
      nativeEnum: () => _w,
      never: () => Aw,
      null: () => gw,
      nullable: () => Fw,
      number: () => lw,
      object: () => Pw,
      objectUtil: () => Tg,
      oboolean: () => Kw,
      onumber: () => Gw,
      optional: () => Lw,
      ostring: () => Hw,
      pipeline: () => zw,
      preprocess: () => $w,
      promise: () => Dw,
      quotelessJson: () => xg,
      record: () => Bw,
      set: () => Mw,
      setErrorMap: () => Bg,
      strictObject: () => kw,
      string: () => fw,
      symbol: () => mw,
      transformer: () => Uw,
      tuple: () => Ow,
      undefined: () => yw,
      union: () => xw,
      unknown: () => ww,
      util: () => Ag,
      void: () => Tw
    });
    var e = {};
    i.r(e), i.d(e, {
      abiSchemaToJsonSchema: () => uA,
      codePointToInt: () => hA,
      ensureIfUint8Array: () => wA,
      ethAbiToJsonSchema: () => cA,
      fetchArrayElement: () => fA,
      hexToNumber: () => dA,
      hexToUint8Array: () => vA,
      numberToHex: () => pA,
      padLeft: () => bA,
      parseBaseType: () => sA,
      transformJsonDataToAbiFormat: () => lA,
      uint8ArrayToHexString: () => mA
    });
    var r = {};
    i.r(r), i.d(r, {
      isBatchRequest: () => WE,
      isBatchResponse: () => xE,
      isResponseRpcError: () => vE,
      isResponseWithError: () => AE,
      isResponseWithNotification: () => TE,
      isResponseWithResult: () => wE,
      isSubscriptionResult: () => EE,
      isValidResponse: () => kE,
      setRequestIdStart: () => SE,
      toBatchPayload: () => BE,
      toPayload: () => OE,
      validateResponse: () => PE
    });
    var n = {};
    i.r(n), i.d(n, {
      ChunkResponseParser: () => NE,
      Eip1193Provider: () => _E,
      EventEmitter: () => TT,
      SocketProvider: () => LE,
      Web3DeferredPromise: () => RE,
      asciiToHex: () => cT,
      bytesToHex: () => qA,
      bytesToUint8Array: () => VA,
      checkAddressCheckSum: () => kT,
      compareBlockNumbers: () => CT,
      convert: () => qT,
      convertScalarValue: () => VT,
      encodePacked: () => oE,
      ethUnitMap: () => GA,
      format: () => JT,
      fromAscii: () => fT,
      fromDecimal: () => tT,
      fromTwosComplement: () => zT,
      fromUtf8: () => nT,
      fromWei: () => mT,
      getStorageSlotNumForLongString: () => uE,
      hexToAscii: () => lT,
      hexToBytes: () => JA,
      hexToNumber: () => YA,
      hexToNumberString: () => eT,
      hexToString: () => uT,
      hexToUtf8: () => oT,
      isAddress: () => xT,
      isBatchRequest: () => WE,
      isBatchResponse: () => xE,
      isBloom: () => IT,
      isContractAddressInBloom: () => BT,
      isContractInitOptions: () => RT,
      isDataFormat: () => GT,
      isHex: () => PT,
      isHexStrict: () => ET,
      isInBloom: () => ST,
      isNullish: () => NT,
      isPromise: () => hE,
      isResponseRpcError: () => vE,
      isResponseWithError: () => AE,
      isResponseWithNotification: () => TE,
      isResponseWithResult: () => wE,
      isSubscriptionResult: () => EE,
      isTopic: () => WT,
      isTopicInBloom: () => MT,
      isUint8Array: () => $A,
      isUserEthereumAddressInBloom: () => OT,
      isValidResponse: () => kE,
      jsonRpc: () => r,
      keccak256: () => QT,
      keccak256Wrapper: () => QT,
      leftPad: () => FT,
      mergeDeep: () => _T,
      numberToHex: () => XA,
      padLeft: () => DT,
      padRight: () => UT,
      pollTillDefined: () => bE,
      pollTillDefinedAndReturnIntervalId: () => pE,
      processSolidityEncodePackedArgs: () => iE,
      randomBytes: () => cE,
      randomHex: () => fE,
      rejectIfConditionAtInterval: () => yE,
      rejectIfTimeout: () => mE,
      rightPad: () => LT,
      setRequestIdStart: () => SE,
      sha3: () => XT,
      sha3Raw: () => tE,
      soliditySha3: () => sE,
      soliditySha3Raw: () => aE,
      stringToHex: () => iT,
      toAscii: () => hT,
      toBatchPayload: () => BE,
      toBigInt: () => bT,
      toBool: () => vT,
      toChecksumAddress: () => gT,
      toDecimal: () => QA,
      toHex: () => dT,
      toNumber: () => pT,
      toPayload: () => OE,
      toTwosComplement: () => $T,
      toUtf8: () => sT,
      toWei: () => yT,
      uint8ArrayConcat: () => zA,
      uint8ArrayEquals: () => HA,
      utf8ToBytes: () => aT,
      utf8ToHex: () => rT,
      uuidV4: () => gE,
      validateResponse: () => PE,
      waitWithTimeout: () => dE
    });
    var o = {};
    i.r(o), i.d(o, {
      DO: () => UP,
      OG: () => QP,
      My: () => FP,
      Ph: () => KP,
      lX: () => VP,
      Id: () => YP,
      fg: () => ek,
      qj: () => JP,
      aT: () => GP,
      aY: () => DP,
      lq: () => ZP,
      z: () => qP,
      Q5: () => nk
    });
    var s = {};
    i.r(s), i.d(s, {
      secp256k1: () => Nk
    });
    var a = {};
    i.r(a), i.d(a, {
      base64DecodeFromString: () => vC,
      base64EncodeToString: () => wC,
      byte2hexStr: () => bC,
      byteArray2hexStr: () => gC,
      bytesToString: () => mC,
      hextoString: () => yC
    });
    var u = {};
    i.r(u), i.d(u, {
      arrayEquals: () => TC,
      base64DecodeFromString: () => vC,
      base64EncodeToString: () => wC,
      bin2String: () => AC,
      byte2hexStr: () => bC,
      byteArray2hexStr: () => gC,
      bytesToString: () => mC,
      getStringType: () => OC,
      hexChar2byte: () => PC,
      hexStr2byteArray: () => xC,
      hextoString: () => yC,
      isHexChar: () => kC,
      isNumber: () => SC,
      strToDate: () => IC,
      stringToBytes: () => EC
    });
    var c = {};
    i.r(c), i.d(c, {
      hasProperties: () => aR,
      hasProperty: () => sR,
      isArray: () => QC,
      isBigNumber: () => eR,
      isBoolean: () => tR,
      isFunction: () => nR,
      isHex: () => iR,
      isInteger: () => oR,
      isJson: () => XC,
      isNotNullOrUndefined: () => lR,
      isObject: () => YC,
      isString: () => rR,
      isValidURL: () => JC,
      mapEvent: () => uR,
      padLeft: () => fR,
      parseEvent: () => cR,
      sleep: () => hR
    });
    var f = {};
    i.r(f), i.d(f, {
      OG: () => y_,
      My: () => u_,
      Ph: () => l_,
      lX: () => h_,
      Id: () => m_,
      fg: () => w_,
      qj: () => b_,
      aT: () => f_,
      lq: () => d_,
      z: () => p_,
      Q5: () => T_
    });
    var l = {};
    i.r(l), i.d(l, {
      AbiCoder: () => lU,
      FormatTypes: () => Z$,
      Interface: () => z$,
      Mnemonic: () => Kj,
      Signature: () => oN,
      SigningKey: () => eD,
      Wordlist: () => _j,
      arrayify: () => V$,
      concat: () => RR,
      ethersHDNodeWallet: () => zF,
      id: () => Rj,
      isValidMnemonic: () => q$,
      joinSignature: () => K$,
      keccak256: () => Cj,
      recoverAddress: () => nD,
      sha256: () => oj,
      splitSignature: () => G$,
      toUtf8Bytes: () => dj,
      toUtf8String: () => pj,
      wordlists: () => GF
    });
    var h = {};
    i.r(h), i.d(h, {
      ADDRESS_PREFIX: () => Y$,
      ADDRESS_PREFIX_BYTE: () => Q$,
      ADDRESS_PREFIX_REGEX: () => X$,
      ADDRESS_SIZE: () => J$,
      TRON_BIP39_PATH_INDEX_0: () => ez,
      TRON_BIP39_PATH_PREFIX: () => tz,
      fromHex: () => rz,
      fromPrivateKey: () => sz,
      isAddress: () => az,
      isChecksumAddress: () => oz,
      toChecksumAddress: () => iz,
      toHex: () => nz
    });
    var d = {};
    i.r(d), i.d(d, {
      decode58: () => hz,
      encode58: () => lz
    });
    var p = {};
    i.r(p), i.d(p, {
      hasBrowserEnv: () => yH,
      hasStandardBrowserEnv: () => vH,
      hasStandardBrowserWebWorkerEnv: () => wH,
      navigator: () => gH,
      origin: () => AH
    });
    var b = {};
    i.r(b), i.d(b, {
      decodeParams: () => OG,
      decodeParamsV2ByABI: () => RG,
      encodeParams: () => BG,
      encodeParamsV2ByABI: () => CG
    });
    var m = {};
    i.r(m), i.d(m, {
      DTriggerSmartContract: () => jK,
      txCheck: () => CK,
      txCheckWithArgs: () => RK,
      txJsonToPb: () => OK,
      txJsonToPbWithArgs: () => BK,
      txPbToRawDataHex: () => MK,
      txPbToTxID: () => NK
    });
    var y = {};
    i.r(y), i.d(y, {
      ECKeySign: () => DV,
      SHA256: () => UV,
      Zn: () => IV,
      arrayToBase64String: () => kV,
      computeAddress: () => BV,
      decode58Check: () => MV,
      decodeBase58Address: () => TV,
      ecRecover: () => PV,
      genPriKey: () => OV,
      getAddressFromPriKey: () => WV,
      getAddressFromPriKeyBase64String: () => jV,
      getBase58CheckAddress: () => AV,
      getBase58CheckAddressFromPriKeyBase64String: () => RV,
      getHexStrAddressFromPriKeyBase64String: () => NV,
      getPubKeyFromPriKey: () => _V,
      getRowBytesFromTransactionBase64: () => SV,
      isAddressValid: () => CV,
      passwordToAddress: () => LV,
      pkToAddress: () => FV,
      sha3: () => $V,
      signBytes: () => xV,
      signTransaction: () => EV
    });
    var g = {};
    i.r(g), i.d(g, {
      generateAccount: () => HV,
      generateAccountWithMnemonic: () => KV,
      generateRandom: () => GV
    });
    var v = {};
    i.r(v), i.d(v, {
      TRON_MESSAGE_PREFIX: () => VV,
      hashMessage: () => ZV,
      signMessage: () => qV,
      verifyMessage: () => JV
    });
    var w = {};
    i.r(w), i.d(w, {
      AccountType: () => DG,
      ContractType: () => jG,
      Permission_PermissionType: () => _G,
      ResourceCode: () => QV
    });
    var A, T = ((A = T || {}).RESPONSE_READY = "RESPONSE_READY", A);
    const E = {
      isTrust: !0,
      isTrustWallet: !0,
      isMetaMask: !1
    };
    var P = i(73065),
      k = i.n(P),
      x = i(90251),
      I = i.n(x),
      S = i(14545),
      O = i.t(S, 2),
      B = i(65606);
    const {
      env: W = {},
      argv: M = [],
      platform: C = ""
    } = typeof B > "u" ? {} : B, R = "NO_COLOR" in W || M.includes("--no-color"), N = "FORCE_COLOR" in W || M.includes("--color"), j = "win32" === C, _ = "dumb" === W.TERM, D = O && S.isatty && S.isatty(1) && W.TERM && !_, U = !R && (N || j && !_ || D || "CI" in W && ("GITHUB_ACTIONS" in W || "GITLAB_CI" in W || "CIRCLECI" in W)), L = (t, e, r, n, i = e.substring(0, t) + n, o = e.substring(t + r.length), s = o.indexOf(r)) => i + (0 > s ? o : L(s, o, r, n)), F = (t, e, r) => ((t, e, r = t, n = t.length + 1) => i => i || "" !== i && void 0 !== i ? ((t, e, r, n, i) => 0 > t ? r + e + n : r + L(t, e, n, i) + n)(("" + i).indexOf(e, n), i, t, e, r) : "")(`[${t}m`, `[${e}m`, r), $ = {
      reset: F(0, 0),
      bold: F(1, 22, "[22m[1m"),
      dim: F(2, 22, "[22m[2m"),
      italic: F(3, 23),
      underline: F(4, 24),
      inverse: F(7, 27),
      hidden: F(8, 28),
      strikethrough: F(9, 29),
      black: F(30, 39),
      red: F(31, 39),
      green: F(32, 39),
      yellow: F(33, 39),
      blue: F(34, 39),
      magenta: F(35, 39),
      cyan: F(36, 39),
      white: F(37, 39),
      gray: F(90, 39),
      bgBlack: F(40, 49),
      bgRed: F(41, 49),
      bgGreen: F(42, 49),
      bgYellow: F(43, 49),
      bgBlue: F(44, 49),
      bgMagenta: F(45, 49),
      bgCyan: F(46, 49),
      bgWhite: F(47, 49),
      blackBright: F(90, 39),
      redBright: F(91, 39),
      greenBright: F(92, 39),
      yellowBright: F(93, 39),
      blueBright: F(94, 39),
      magentaBright: F(95, 39),
      cyanBright: F(96, 39),
      whiteBright: F(97, 39),
      bgBlackBright: F(100, 49),
      bgRedBright: F(101, 49),
      bgGreenBright: F(102, 49),
      bgYellowBright: F(103, 49),
      bgBlueBright: F(104, 49),
      bgMagentaBright: F(105, 49),
      bgCyanBright: F(106, 49),
      bgWhiteBright: F(107, 49)
    }, {
      reset: z,
      bold: H,
      dim: G,
      italic: K,
      underline: V,
      inverse: Z,
      hidden: q,
      strikethrough: J,
      black: Y,
      red: Q,
      green: X,
      yellow: tt,
      blue: et,
      magenta: rt,
      cyan: nt,
      white: it,
      gray: ot,
      bgBlack: st,
      bgRed: at,
      bgGreen: ut,
      bgYellow: ct,
      bgBlue: ft,
      bgMagenta: lt,
      bgCyan: ht,
      bgWhite: dt,
      blackBright: pt,
      redBright: bt,
      greenBright: mt,
      yellowBright: yt,
      blueBright: gt,
      magentaBright: vt,
      cyanBright: wt,
      whiteBright: At,
      bgBlackBright: Tt,
      bgRedBright: Et,
      bgGreenBright: Pt,
      bgYellowBright: kt,
      bgBlueBright: xt,
      bgMagentaBright: It,
      bgCyanBright: St,
      bgWhiteBright: Ot
    } = (({
      useColor: t = U
    } = {}) => t ? $ : Object.keys($).reduce((t, e) => ({
      ...t,
      [e]: String
    }), {}))();
    k().setLevel("DEBUG");
    var Bt = (t => (t.TRACE = "TRACE", t.DEBUG = "DEBUG", t.INFO = "INFO", t.WARN = "WARN", t.ERROR = "ERROR", t))(Bt || {});
    const Wt = {
      TRACE: rt,
      DEBUG: nt,
      INFO: et,
      WARN: tt,
      ERROR: Q
    };
    I().reg(k()), I().apply(k(), {
      format: (t, e, r) => `${ot(`[${r}]`)} ${Wt[t](t)}${"root"===e?"":X(` [${e}:]`)}`
    });
    const Mt = k().error.bind(k());
    k().error = (...t) => Mt(...t);
    const Ct = k();

    function Rt(t, e) {
      if (e) return Ct.getLogger(e).debug(t);
      Ct.debug(t)
    }
    const Nt = class t {
      static get(t) {
        const e = window.localStorage.getItem(t);
        if (e) return JSON.parse(e)
      }
      static set(t, e) {
        return window.localStorage.setItem(t, JSON.stringify(e))
      }
      static clear(t) {
        window.localStorage.removeItem(t)
      }
      static touchTimestamp() {
        t.set(t.TIMESTAMP_KEY, {
          timestamp: (new Date).getTime()
        })
      }
      static isExpired() {
        const e = t.get(t.TIMESTAMP_KEY);
        return !(e?.timestamp && (new Date).getTime() - e.timestamp < t.MAX_CACHE_LIFE || (t.touchTimestamp(), 0))
      }
    };
    Nt.TIMESTAMP_KEY = "trust:cache:timestamp", Nt.MAX_CACHE_LIFE = 864e5;
    let jt = Nt;
    var _t = (t => (t.INTERNAL = "INTERNAL", t.PUBLIC = "PUBLIC", t))(_t || {});

    function Dt(t, e) {
      return `${e}_${t}`
    }

    function Ut(t) {
      return Dt(t, "INTERNAL")
    }

    function Lt(t) {
      return Dt(t, "PUBLIC")
    }
    var Ft = (t => (t.EVM = "EVM", t.SOL = "SOL", t.BNB = "BNB", t.COSMOS = "COSMOS", t.TON = "TON", t.TRON = "TRON", t))(Ft || {}),
      $t = (t => (t.solana = "solana", t.ethereum = "ethereum", t.binance = "binance", t.cosmos = "cosmos", t.ton = "ton", t.tron = "tron", t))($t || {});
    Ft.EVM, Ft.SOL, Ft.BNB, Ft.COSMOS, Ft.TON, Ft.TRON, Ft.EVM, Ft.SOL, Ft.BNB, Ft.COSMOS, Ft.TON, Ft.TRON, Promise.resolve(!1), Promise.resolve(!0);
    var zt = Promise.resolve();

    function Ht(t, e) {
      return t || (t = 0), new Promise(function(r) {
        return setTimeout(function() {
          return r(e)
        }, t)
      })
    }

    function Gt() {
      return Math.random().toString(36).substring(2)
    }
    var Kt = 0;

    function Vt() {
      var t = 1e3 * Date.now();
      return Kt >= t && (t = Kt + 1), Kt = t, t
    }
    var Zt = {
      create: function(t) {
        var e = {
          time: Vt(),
          messagesCallback: null,
          bc: new BroadcastChannel(t),
          subFns: []
        };
        return e.bc.onmessage = function(t) {
          e.messagesCallback && e.messagesCallback(t.data)
        }, e
      },
      close: function(t) {
        t.bc.close(), t.subFns = []
      },
      onMessage: function(t, e) {
        t.messagesCallback = e
      },
      postMessage: function(t, e) {
        try {
          return t.bc.postMessage(e, !1), zt
        } catch (t) {
          return Promise.reject(t)
        }
      },
      canBeUsed: function() {
        if ("u" > typeof globalThis && globalThis.Deno && globalThis.Deno.args) return !0;
        if (("u" > typeof window || "u" > typeof self) && "function" == typeof BroadcastChannel) {
          if (BroadcastChannel.qn) throw Error("BroadcastChannel: Do not overwrite window.BroadcastChannel with this module, this is not a polyfill");
          return !0
        }
        return !1
      },
      type: "native",
      averageResponseTime: function() {
        return 150
      },
      microSeconds: Vt
    };
    class qt {
      ttl;
      map = new Map;
      Jn = !1;
      constructor(t) {
        this.ttl = t
      }
      has(t) {
        return this.map.has(t)
      }
      add(t) {
        this.map.set(t, Jt()), this.Jn || (this.Jn = !0, setTimeout(() => {
          this.Jn = !1,
            function(t) {
              const e = Jt() - t.ttl,
                r = t.map[Symbol.iterator]();
              for (;;) {
                const n = r.next().value;
                if (!n) return;
                const i = n[0];
                if (n[1] >= e) return;
                t.map.delete(i)
              }
            }(this)
        }, 0))
      }
      clear() {
        this.map.clear()
      }
    }

    function Jt() {
      return Date.now()
    }

    function Yt() {
      var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        e = JSON.parse(JSON.stringify(t));
      return typeof e.webWorkerSupport > "u" && (e.webWorkerSupport = !0), e.idb || (e.idb = {}), e.idb.ttl || (e.idb.ttl = 45e3), e.idb.fallbackInterval || (e.idb.fallbackInterval = 150), t.idb && "function" == typeof t.idb.onclose && (e.idb.onclose = t.idb.onclose), e.localstorage || (e.localstorage = {}), e.localstorage.removeTimeout || (e.localstorage.removeTimeout = 6e4), t.methods && (e.methods = t.methods), e.node || (e.node = {}), e.node.ttl || (e.node.ttl = 12e4), e.node.maxParallelWrites || (e.node.maxParallelWrites = 2048), typeof e.node.useFastPath > "u" && (e.node.useFastPath = !0), e
    }
    var Qt = "messages",
      Xt = {
        durability: "relaxed"
      };

    function te() {
      if ("u" > typeof indexedDB) return indexedDB;
      if ("u" > typeof window) {
        if ("u" > typeof window.mozIndexedDB) return window.mozIndexedDB;
        if ("u" > typeof window.webkitIndexedDB) return window.webkitIndexedDB;
        if ("u" > typeof window.msIndexedDB) return window.msIndexedDB
      }
      return !1
    }

    function ee(t) {
      t.commit && t.commit()
    }

    function re(t) {
      t.closed || ne(t).then(function() {
        return Ht(t.options.idb.fallbackInterval)
      }).then(function() {
        return re(t)
      })
    }

    function ne(t) {
      return t.closed || !t.messagesCallback ? zt : function(t, e) {
        var r = t.transaction(Qt, "readonly", Xt),
          n = r.objectStore(Qt),
          i = [],
          o = IDBKeyRange.bound(e + 1, 1 / 0);
        if (n.getAll) {
          var s = n.getAll(o);
          return new Promise(function(t, e) {
            s.onerror = function(t) {
              return e(t)
            }, s.onsuccess = function(e) {
              t(e.target.result)
            }
          })
        }
        return new Promise(function(t, s) {
          var a = function() {
            try {
              return o = IDBKeyRange.bound(e + 1, 1 / 0), n.openCursor(o)
            } catch {
              return n.openCursor()
            }
          }();
          a.onerror = function(t) {
            return s(t)
          }, a.onsuccess = function(n) {
            var o = n.target.result;
            o ? o.value.id < e + 1 ? o.continue(e + 1) : (i.push(o.value), o.continue()) : (ee(r), t(i))
          }
        })
      }(t.db, t.lastCursorId).then(function(e) {
        var r = e.filter(function(t) {
          return !!t
        }).map(function(e) {
          return e.id > t.lastCursorId && (t.lastCursorId = e.id), e
        }).filter(function(e) {
          return function(t, e) {
            return !(t.uuid === e.uuid || e.eMIs.has(t.id) || t.data.time < e.messagesCallbackTime)
          }(e, t)
        }).sort(function(t, e) {
          return t.time - e.time
        });
        return r.forEach(function(e) {
          t.messagesCallback && (t.eMIs.add(e.id), t.messagesCallback(e.data))
        }), zt
      })
    }
    var ie = {
      create: function(t, e) {
        return e = Yt(e),
          function(t) {
            var e = "pubkey.broadcast-channel-0-" + t,
              r = te().open(e);
            return r.onupgradeneeded = function(t) {
              t.target.result.createObjectStore(Qt, {
                keyPath: "id",
                autoIncrement: !0
              })
            }, new Promise(function(t, e) {
              r.onerror = function(t) {
                return e(t)
              }, r.onsuccess = function() {
                t(r.result)
              }
            })
          }(t).then(function(r) {
            var n = {
              closed: !1,
              lastCursorId: 0,
              channelName: t,
              options: e,
              uuid: Gt(),
              eMIs: new qt(2 * e.idb.ttl),
              writeBlockPromise: zt,
              messagesCallback: null,
              readQueuePromises: [],
              db: r
            };
            return r.onclose = function() {
              n.closed = !0, e.idb.onclose && e.idb.onclose()
            }, re(n), n
          })
      },
      close: function(t) {
        t.closed = !0, t.db.close()
      },
      onMessage: function(t, e, r) {
        t.messagesCallbackTime = r, t.messagesCallback = e, ne(t)
      },
      postMessage: function(t, e) {
        return t.writeBlockPromise = t.writeBlockPromise.then(function() {
          return function(t, e, r) {
            var n = {
                uuid: e,
                time: Date.now(),
                data: r
              },
              i = t.transaction([Qt], "readwrite", Xt);
            return new Promise(function(t, e) {
              i.oncomplete = function() {
                return t()
              }, i.onerror = function(t) {
                return e(t)
              }, i.objectStore(Qt).add(n), ee(i)
            })
          }(t.db, t.uuid, e)
        }).then(function() {
          0 === Math.floor(11 * Math.random() + 0) && function(t) {
            (function(t, e) {
              var r = Date.now() - e,
                n = t.transaction(Qt, "readonly", Xt),
                i = n.objectStore(Qt),
                o = [];
              return new Promise(function(t) {
                i.openCursor().onsuccess = function(e) {
                  var i = e.target.result;
                  if (i) {
                    var s = i.value;
                    s.time < r ? (o.push(s), i.continue()) : (ee(n), t(o))
                  } else t(o)
                }
              })
            })(t.db, t.options.idb.ttl).then(function(e) {
              return function(t, e) {
                if (t.closed) return Promise.resolve([]);
                var r = t.db.transaction(Qt, "readwrite", Xt).objectStore(Qt);
                return Promise.all(e.map(function(t) {
                  var e = r.delete(t);
                  return new Promise(function(t) {
                    e.onsuccess = function() {
                      return t()
                    }
                  })
                }))
              }(t, e.map(function(t) {
                return t.id
              }))
            })
          }(t)
        }), t.writeBlockPromise
      },
      canBeUsed: function() {
        return !!te()
      },
      type: "idb",
      averageResponseTime: function(t) {
        return 2 * t.idb.fallbackInterval
      },
      microSeconds: Vt
    };

    function oe() {
      var t;
      if (typeof window > "u") return null;
      try {
        t = window.localStorage, t = window["ie8-eventlistener/storage"] || window.localStorage
      } catch {}
      return t
    }

    function se(t) {
      return "pubkey.broadcastChannel-" + t
    }

    function ae() {
      var t = oe();
      if (!t) return !1;
      try {
        var e = "__broadcastchannel_check";
        t.setItem(e, "works"), t.removeItem(e)
      } catch {
        return !1
      }
      return !0
    }
    var ue = {
        create: function(t, e) {
          if (e = Yt(e), !ae()) throw Error("BroadcastChannel: localstorage cannot be used");
          var r = Gt(),
            n = new qt(e.localstorage.removeTimeout),
            i = {
              channelName: t,
              uuid: r,
              eMIs: n
            };
          return i.listener = function(t, e) {
            var r = se(t),
              n = function(t) {
                t.key === r && e(JSON.parse(t.newValue))
              };
            return window.addEventListener("storage", n), n
          }(t, function(t) {
            i.messagesCallback && t.uuid !== r && (!t.token || n.has(t.token) || t.data.time && t.data.time < i.messagesCallbackTime || (n.add(t.token), i.messagesCallback(t.data)))
          }), i
        },
        close: function(t) {
          ! function(t) {
            window.removeEventListener("storage", t)
          }(t.listener)
        },
        onMessage: function(t, e, r) {
          t.messagesCallbackTime = r, t.messagesCallback = e
        },
        postMessage: function(t, e) {
          return new Promise(function(r) {
            Ht().then(function() {
              var n = se(t.channelName),
                i = {
                  token: Gt(),
                  time: Date.now(),
                  data: e,
                  uuid: t.uuid
                },
                o = JSON.stringify(i);
              oe().setItem(n, o);
              var s = document.createEvent("Event");
              s.initEvent("storage", !0, !0), s.key = n, s.newValue = o, window.dispatchEvent(s), r()
            })
          })
        },
        canBeUsed: ae,
        type: "localstorage",
        averageResponseTime: function() {
          var t = navigator.userAgent.toLowerCase();
          return t.includes("safari") && !t.includes("chrome") ? 240 : 120
        },
        microSeconds: Vt
      },
      ce = Vt,
      fe = new Set,
      le = {
        create: function(t) {
          var e = {
            time: ce(),
            name: t,
            messagesCallback: null
          };
          return fe.add(e), e
        },
        close: function(t) {
          fe.delete(t)
        },
        onMessage: function(t, e) {
          t.messagesCallback = e
        },
        postMessage: function(t, e) {
          return new Promise(function(r) {
            return setTimeout(function() {
              Array.from(fe).forEach(function(r) {
                r.name === t.name && r !== t && r.messagesCallback && r.time < e.time && r.messagesCallback(e)
              }), r()
            }, 5)
          })
        },
        canBeUsed: function() {
          return !0
        },
        type: "simulate",
        averageResponseTime: function() {
          return 5
        },
        microSeconds: ce
      },
      he = [Zt, ie, ue],
      de = new Set,
      pe = 0,
      be = function(t, e) {
        this.id = pe++, de.add(this), this.name = t, this.options = Yt(e), this.method = function(t) {
            var e = [].concat(t.methods, he).filter(Boolean);
            if (t.type) {
              if ("simulate" === t.type) return le;
              var r = e.find(function(e) {
                return e.type === t.type
              });
              if (r) return r;
              throw Error("method-type " + t.type + " not found")
            }
            t.webWorkerSupport || (e = e.filter(function(t) {
              return "idb" !== t.type
            }));
            var n = e.find(function(t) {
              return t.canBeUsed()
            });
            if (n) return n;
            throw Error("No usable method found in " + JSON.stringify(he.map(function(t) {
              return t.type
            })))
          }(this.options), this.Yn = !1, this.Qn = null, this.Xn = {
            message: [],
            internal: []
          }, this.ti = new Set, this.ei = [], this.ri = null,
          function(t) {
            var e = t.method.create(t.name, t.options);
            ! function(t) {
              return t && "function" == typeof t.then
            }(e) ? t.ni = e: (t.ri = e, e.then(function(e) {
              t.ni = e
            }))
          }(this)
      };

    function me(t, e, r) {
      var n = {
        time: t.method.microSeconds(),
        type: e,
        data: r
      };
      return (t.ri ? t.ri : zt).then(function() {
        var e = t.method.postMessage(t.ni, n);
        return t.ti.add(e), e.catch().then(function() {
          return t.ti.delete(e)
        }), e
      })
    }

    function ye(t) {
      return t.Xn.message.length > 0 || t.Xn.internal.length > 0
    }

    function ge(t, e, r) {
      t.Xn[e].push(r),
        function(t) {
          if (!t.Yn && ye(t)) {
            var e = function(e) {
                t.Xn[e.type].forEach(function(t) {
                  e.time >= t.time && t.fn(e.data)
                })
              },
              r = t.method.microSeconds();
            t.ri ? t.ri.then(function() {
              t.Yn = !0, t.method.onMessage(t.ni, e, r)
            }) : (t.Yn = !0, t.method.onMessage(t.ni, e, r))
          }
        }(t)
    }

    function ve(t, e, r) {
      t.Xn[e] = t.Xn[e].filter(function(t) {
          return t !== r
        }),
        function(t) {
          if (t.Yn && !ye(t)) {
            t.Yn = !1;
            var e = t.method.microSeconds();
            t.method.onMessage(t.ni, null, e)
          }
        }(t)
    }
    be.qn = !0, be.prototype = {
      postMessage: function(t) {
        if (this.closed) throw Error("BroadcastChannel.postMessage(): Cannot post message after channel has closed " + JSON.stringify(t));
        return me(this, "message", t)
      },
      postInternal: function(t) {
        return me(this, "internal", t)
      },
      set onmessage(t) {
        var e = {
          time: this.method.microSeconds(),
          fn: t
        };
        ve(this, "message", this.Qn), t && "function" == typeof t ? (this.Qn = e, ge(this, "message", e)) : this.Qn = null
      },
      addEventListener: function(t, e) {
        ge(this, t, {
          time: this.method.microSeconds(),
          fn: e
        })
      },
      removeEventListener: function(t, e) {
        ve(this, t, this.Xn[t].find(function(t) {
          return t.fn === e
        }))
      },
      close: function() {
        var t = this;
        if (!this.closed) {
          de.delete(this), this.closed = !0;
          var e = this.ri ? this.ri : zt;
          return this.Qn = null, this.Xn.message = [], e.then(function() {
            return Promise.all(Array.from(t.ti))
          }).then(function() {
            return Promise.all(t.ei.map(function(t) {
              return t()
            }))
          }).then(function() {
            return t.method.close(t.ni)
          })
        }
      },
      get type() {
        return this.method.type
      },
      get isClosed() {
        return this.closed
      }
    };
    let we = (t = 21) => {
      let e = "",
        r = crypto.getRandomValues(new Uint8Array(t |= 0));
      for (; t--;) e += "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict" [63 & r[t]];
      return e
    };
    class Ae {
      constructor() {
        this.listeners = {}
      }
      addListener(t, e) {
        const r = this.listeners[t] || [];
        r.push(e), this.listeners[t] = r
      }
      once(t, e) {
        this.addListener(t, r => (delete this.listeners[t], e(r)))
      }
      emit(t, e) {
        return new Promise((r, n) => {
          const i = (t => `${t}_${we()}_callback`)(t);
          this.once(i, t => ((t, e, r) => new Promise((e, n) => {
            var i = t => {
                try {
                  s(r.next(t))
                } catch (t) {
                  n(t)
                }
              },
              o = t => {
                try {
                  s(r.throw(t))
                } catch (t) {
                  n(t)
                }
              },
              s = t => t.done ? e(t.value) : Promise.resolve(t.value).then(i, o);
            s((r = r.apply(t, null)).next())
          }))(this, 0, function*() {
            var e;
            null != (e = t.data) && e.error ? n(t.data.error) : r(t.data.params)
          })), this.send({
            method: t,
            data: {
              cbMethod: i,
              params: e
            }
          })
        })
      }
      disconnect() {}
    }
    var Te = (t, e, r) => new Promise((n, i) => {
      var o = t => {
          try {
            a(r.next(t))
          } catch (t) {
            i(t)
          }
        },
        s = t => {
          try {
            a(r.throw(t))
          } catch (t) {
            i(t)
          }
        },
        a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
      a((r = r.apply(t, e)).next())
    });
    class Ee extends Ae {
      constructor(t) {
        super(), this.port = new be(t), this.port.addEventListener("message", t => {
          const e = t.method;
          !e || !this.listeners[e] || this.listeners[e].forEach(e => e(t))
        })
      }
      listen(t) {
        const e = e => {
          t(e)
        };
        return this.port.addEventListener("message", e), () => this.port.removeEventListener("message", e)
      }
      send(t) {
        return Te(this, null, function*() {
          yield this.port.postMessage(t)
        })
      }
      disconnect() {
        return Te(this, null, function*() {
          yield this.port.close()
        })
      }
    }
    var Pe, ke = i(37007);
    const xe = "object" == typeof chrome && null != (Pe = null == chrome ? void 0 : chrome.runtime) && Pe.id ? i(96815) : {};
    xe.action = xe.action || xe.browserAction;
    const Ie = "CALLBACK";
    class Se {
      static isCallbackAdapterRequest(t) {
        return void 0 !== t.id
      }
      constructor(t) {
        this.setStrategy(t)
      }
      setHandler(t) {
        return this.handler = t, this
      }
      request(t, e) {
        if (!this.handler) throw Error("No handler defined for Adapter");
        return Se.isCallbackAdapterRequest(t) ? this.handler({
          network: e,
          id: t.id,
          name: t.method,
          params: t.params,
          object: t.params
        }) : this.handler({
          name: t.method,
          network: e,
          params: t.params,
          object: t.params
        })
      }
      setStrategy(t) {
        return this.strategy = t, this
      }
      getStrategy() {
        return this.strategy
      }
    }
    class Oe extends Error {
      constructor(t, e) {
        super(), this.code = t, this.message = e
      }
      toString() {
        return `${this.message} (${this.code})`
      }
    }
    var Be = Object.defineProperty,
      We = Object.defineProperties,
      Me = Object.getOwnPropertyDescriptors,
      Ce = Object.getOwnPropertySymbols,
      Re = {}.hasOwnProperty,
      Ne = {}.propertyIsEnumerable,
      je = (t, e, r) => e in t ? Be(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r;
    class _e extends Se {
      constructor() {
        super(Ie), this.callback = new Map
      }
      async request(t, e) {
        return new Promise((r, n) => {
          const i = (new Date).getTime() + Math.floor(1e3 * Math.random());
          this.callback.set(i.toString(), {
            reject: n,
            resolve: r
          }), super.request(((t, e) => We(t, Me(e)))(((t, e) => {
            for (var r in e || (e = {})) Re.call(e, r) && je(t, r, e[r]);
            if (Ce)
              for (var r of Ce(e)) Ne.call(e, r) && je(t, r, e[r]);
            return t
          })({}, t), {
            id: i
          }), e)
        })
      }
      sendResponse(t, e) {
        if (this.callback.has(t.toString())) {
          const r = this.callback.get(t.toString());
          this.callback.delete(t.toString()), r?.resolve(e)
        } else console.error("Unable to find callback for requestId: " + t)
      }
      sendError(t, e) {
        if (this.callback.has(t.toString())) {
          const r = this.callback.get(t.toString());
          this.callback.delete(t.toString());
          let n = e;
          "string" == typeof n && !isNaN(parseInt(n, 10)) && (n = new Oe(parseInt(n, 10), n)), r?.reject(n)
        } else console.error("Unable to find callback for requestId: " + t)
      }
    }
    class De extends Se {
      constructor() {
        super("PROMISES")
      }
      request(t, e) {
        return super.request(t, e)
      }
    }
    class Ue extends ke.EventEmitter {
      setAdapter(t) {
        return this.adapter = t, this
      }
      async request(t) {
        try {
          if (!this.adapter) throw Error("No adapter set, maybe you forgot to register the provider?");
          const e = await this.adapter.request(t, this.getNetwork());
          return this.emit("onResponseReady", t, e), e
        } catch (t) {
          throw t
        }
      }
      sendResponse(t, e) {
        if (!this.adapter) throw Error("Adapter not found");
        if (this.adapter.getStrategy() !== Ie) throw Error("Trying to send callback request on promisified adapter");
        this.adapter.sendResponse(t, e)
      }
      sendError(t, e) {
        if (!this.adapter) throw Error("Adapter not found");
        if (this.adapter.getStrategy() !== Ie) throw Error("Trying to send callback request on promisified adapter");
        this.adapter.sendError(t, e)
      }
    }
    class Le {
      constructor(t) {
        const e = t.strategy === Ie ? new _e : new De;
        t.handler && e.setHandler(t.handler), this.setAdapter(e)
      }
      setHandler(t) {
        this.adapter.setHandler(t)
      }
      setAdapter(t) {
        return this.adapter = t, this
      }
      registerProvider(t) {
        return t.setAdapter(this.adapter), this
      }
      registerProviders(t) {
        return t.forEach(t => this.registerProvider(t)), this
      }
      sendResponse(t, e) {
        "CALLBACK" === this.adapter.getStrategy() && this.adapter.sendResponse(t, e)
      }
      sendError(t, e) {
        "CALLBACK" === this.adapter.getStrategy() && this.adapter.sendError(t, e)
      }
    }
    const Fe = "in-page-channel-node-id";
    var $e = (t => (t[t.CRYPTO = 0] = "CRYPTO", t[t.NFT = 1] = "NFT", t[t.APPROVALS = 2] = "APPROVALS", t))($e || {}),
      ze = (t => (t[t.RWA = 0] = "RWA", t[t.AI = 1] = "AI", t[t.MEMES = 2] = "MEMES", t))(ze || {}),
      He = (t => (t[t.TOP = 0] = "TOP", t[t.BNB = 1] = "BNB", t[t.ETH = 2] = "ETH", t[t.SOL = 3] = "SOL", t))(He || {}),
      Ge = (t => (t[t.HOLDINGS = 0] = "HOLDINGS", t[t.HISTORY = 1] = "HISTORY", t[t.ABOUT = 2] = "ABOUT", t))(Ge || {}),
      Ke = (t, e, r) => new Promise((n, i) => {
        var o = t => {
            try {
              a(r.next(t))
            } catch (t) {
              i(t)
            }
          },
          s = t => {
            try {
              a(r.throw(t))
            } catch (t) {
              i(t)
            }
          },
          a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
        a((r = r.apply(t, e)).next())
      });
    class Ve {
      constructor() {
        this.callbacksDic = new Map, this.tryLoadBroadcastMessage(0)
      }
      tryLoadBroadcastMessage(t = 0) {
        return new Promise(e => {
          try {
            this.initBroadcastMessage(), e(null)
          } catch (r) {
            t >= 20 && (Ct.error("Unable to find node id to create broadcast system"), e(null)), Ct.error(r), setTimeout(() => e(this.tryLoadBroadcastMessage(t + 1)), 100)
          }
        })
      }
      listen(t) {
        const e = "cb_" + we(3);
        return this.tryLoadBroadcastMessage(0).then(() => {
          const r = this.broadcastMessage.listen(t);
          this.callbacksDic.set(e, r)
        }), () => {
          var t;
          this.callbacksDic.has(e) && (null == (t = this.callbacksDic.get(e)) || t())
        }
      }
      send(t) {
        return Ke(this, null, function*() {
          return yield this.tryLoadBroadcastMessage(0), this.broadcastMessage.send(t)
        })
      }
      disconnect() {
        return Ke(this, null, function*() {
          return yield this.tryLoadBroadcastMessage(0), this.broadcastMessage.disconnect()
        })
      }
      addListener(t, e) {
        this.tryLoadBroadcastMessage(0).then(() => this.broadcastMessage.addListener(t, e))
      }
      once(t, e) {
        this.tryLoadBroadcastMessage(0).then(() => this.broadcastMessage.once(t, e))
      }
      initBroadcastMessage() {
        if (this.broadcastMessage) return this.broadcastMessage;
        const t = document.getElementById(Fe);
        if (!t) throw Error(`IN_PAGE_CHANNEL_NODE_ID ${Fe} not found`);
        const e = t?.getAttribute("data-channel-name");
        return this.broadcastMessage = new Ee(e), Rt("Broadcast message created"), this.broadcastMessage
      }
      emit(t, e) {
        return Ke(this, null, function*() {
          return yield this.tryLoadBroadcastMessage(0), this.broadcastMessage.emit(t, e)
        })
      }
    }
    var Ze = Object.defineProperty,
      qe = Object.defineProperties,
      Je = Object.getOwnPropertyDescriptors,
      Ye = Object.getOwnPropertySymbols,
      Qe = {}.hasOwnProperty,
      Xe = {}.propertyIsEnumerable,
      tr = (t, e, r) => e in t ? Ze(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r;
    class er extends ke.EventEmitter {
      constructor() {
        super(), this.providers = {}, this.core = new Le({
          strategy: "PROMISES",
          handler: this.request.bind(this)
        }), this.broadcastMessage = new Ve
      }
      announce() {
        const t = () => Object.keys(this.providers).forEach(t => this.providers[t].announce());
        window.addEventListener("eip6963:requestProvider", () => {
          t()
        }), t()
      }
      loadCache() {
        Rt("Loading Cache"), jt.isExpired() ? Object.keys(this.providers).forEach(t => this.providers[t].clearCache()) : Object.keys(this.providers).forEach(t => this.providers[t].loadCache())
      }
      boot() {
        return Rt("Booting"), Object.keys(this.providers).forEach(t => this.providers[t].boot()), Rt("Booted"), this
      }
      start() {
        Rt("Starting Web3Provider"), Object.keys(this.providers).forEach(t => {
          this.providers[t].start(this.broadcastMessage), this.providers[t].registerEventListeners()
        }), window.dispatchEvent(new Event("trustwallet#initialized"))
      }
      register(t, e) {
        return this.providers[t] = e, this.core.registerProvider(e.provider), this
      }
      request(t) {
        return ((t, e, r) => new Promise((e, n) => {
          var i = t => {
              try {
                s(r.next(t))
              } catch (t) {
                n(t)
              }
            },
            o = t => {
              try {
                s(r.throw(t))
              } catch (t) {
                n(t)
              }
            },
            s = t => t.done ? e(t.value) : Promise.resolve(t.value).then(i, o);
          s((r = r.apply(t, null)).next())
        }))(this, 0, function*() {
          const {
            name: e,
            params: r,
            network: n
          } = t, i = n ?? $t.ethereum, o = this.providers[i], s = Lt(e);
          Rt(`Requested ${s} for ${i}`);
          const a = i === $t.ethereum ? o.provider.getChainId() : void 0;
          try {
            const t = yield this.broadcastMessage.emit(s, ((t, e) => qe(t, Je(e)))(((t, e) => {
              for (var r in e || (e = {})) Qe.call(e, r) && tr(t, r, e[r]);
              if (Ye)
                for (var r of Ye(e)) Xe.call(e, r) && tr(t, r, e[r]);
              return t
            })({}, r), {
              networkId: i,
              web3ChainId: a
            }));
            return this.emit(T.RESPONSE_READY, {
              event: s,
              networkId: i,
              data: t
            }), t
          } catch (t) {
            throw Ct.error(t), t
          }
        })
      }
      earlyInject() {
        Object.keys(this.providers).forEach(t => this.providers[t].earlyInject())
      }
    }
    er.EIP6963Info = {
      uuid: crypto.randomUUID(),
      name: "Trust Wallet",
      icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTgiIGhlaWdodD0iNjUiIHZpZXdCb3g9IjAgMCA1OCA2NSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgOS4zODk0OUwyOC44OTA3IDBWNjUuMDA0MkM4LjI1NDUgNTYuMzM2OSAwIDM5LjcyNDggMCAzMC4zMzUzVjkuMzg5NDlaIiBmaWxsPSIjMDUwMEZGIi8+CjxwYXRoIGQ9Ik01Ny43ODIyIDkuMzg5NDlMMjguODkxNSAwVjY1LjAwNDJDNDkuNTI3NyA1Ni4zMzY5IDU3Ljc4MjIgMzkuNzI0OCA1Ny43ODIyIDMwLjMzNTNWOS4zODk0OVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8yMjAxXzY5NDIpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIwMV82OTQyIiB4MT0iNTEuMzYxNSIgeTE9Ii00LjE1MjkzIiB4Mj0iMjkuNTM4NCIgeTI9IjY0LjUxNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjAyMTEyIiBzdG9wLWNvbG9yPSIjMDAwMEZGIi8+CjxzdG9wIG9mZnNldD0iMC4wNzYyNDIzIiBzdG9wLWNvbG9yPSIjMDA5NEZGIi8+CjxzdG9wIG9mZnNldD0iMC4xNjMwODkiIHN0b3AtY29sb3I9IiM0OEZGOTEiLz4KPHN0b3Agb2Zmc2V0PSIwLjQyMDA0OSIgc3RvcC1jb2xvcj0iIzAwOTRGRiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjgyODg2IiBzdG9wLWNvbG9yPSIjMDAzOEZGIi8+CjxzdG9wIG9mZnNldD0iMC45MDI0NjUiIHN0b3AtY29sb3I9IiMwNTAwRkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
      rdns: "com.trustwallet.app"
    };
    class rr {
      earlyInject() {}
      start(t) {}
      boot() {}
      announce() {}
      loadCache() {}
      clearCache() {}
      registerEventListeners() {}
      getChainId() {
        throw Error("Method not implemented.")
      }
    }
    class nr {
      constructor(t) {
        this.bm = t
      }
      call(t) {
        return ((t, e, r) => new Promise((e, n) => {
          var i = t => {
              try {
                s(r.next(t))
              } catch (t) {
                n(t)
              }
            },
            o = t => {
              try {
                s(r.throw(t))
              } catch (t) {
                n(t)
              }
            },
            s = t => t.done ? e(t.value) : Promise.resolve(t.value).then(i, o);
          s((r = r.apply(t, null)).next())
        }))(this, 0, function*() {
          return yield this.bm.emit(t.method, t.params || {
            networkId: $t.ethereum
          })
        })
      }
    }
    const ir = {
      ADD_CONNECTED_SITE: Ut("AddConnectedSite"),
      DISCONNECT_SITE: Ut("disconnectSite"),
      DISCONNECT_ALL: Ut("disconnectAllSites"),
      ETH_REQUEST_ACCOUNTS: Lt("requestAccounts"),
      ETH_ACCOUNTS: Lt("accounts"),
      ETH_COINBASE: Lt("coinbase"),
      ETH_SIGN_TYPED_MESSAGE: Lt("signTypedMessage"),
      ETH_SIGN_TYPED_DATA: Lt("signTypedData"),
      ETH_SIGN: Lt("sign"),
      ETH_SIGN_PERSONAL_MESSAGE: Lt("signPersonalMessage"),
      GENERIC_SIGN_MESSAGE: Lt("signMessage"),
      ETH_ESTIMATE_GAS: Lt("estimateGas"),
      ETH_SIGN_TRANSACTION: Lt("signTransaction"),
      ETH_SEND_TRANSACTION: Lt("sendTransaction"),
      ETH_CHAIN_ID: Lt("chainId"),
      WALLET_SWITCH_NETWORK: Lt("switchEthereumChain"),
      WALLET_REQUEST_PERMISSIONS: Lt("wallet_requestPermissions"),
      WALLET_GET_PERMISSIONS: "wallet_getPermissions",
      WALLET_REVOKE_PERMISSIONS: "wallet_revokePermissions",
      ETH_GET_ENCRYPTION_PUBLIC_KEY: "eth_getEncryptionPublicKey",
      ETH_DECRYPT: "eth_decrypt",
      WALLET_ADD_ETHEREUM_CHAIN: Lt("addEthereumChain"),
      WALLET_WATCH_ASSET: Lt("watchAsset"),
      NET_VERSION: Lt("net_version"),
      CLIENT_VERSION: Lt("web3_clientVersion"),
      PERSONAL_EC_RECOVER: Lt("ecRecover"),
      WEB3_SHA3: Lt("web3_sha3"),
      SOL_SIGN_RAW_TRANSACTION: Lt("signRawTransaction"),
      SOL_SIGN_RAW_TRANSACTION_MULTI: Lt("signRawTransactionMulti"),
      SOL_STAGE_RAW_TRANSACTION: Ut("SolStageRawTransaction"),
      SOL_SWAP_TRANSACTION: Ut("SolSwapTransaction"),
      TRON_SWAP_TRANSACTION: Ut("TronSwapTransaction"),
      DAPP_TRIGGERED_STAKING_TRANSACTION: Lt("dappTriggeredStakingTransaction"),
      LOADING_SPINNER_CONFIRMING: Lt("LOADING_SPINNER_CONFIRMING"),
      SIGN_COSMOS_TRANSACTION: Ut("SignCosmosTransaction"),
      CALCULATE_COSMOS_GAS: Ut("CalculateCosmosGas"),
      CALCULATE_TRON_FEE: Ut("CalculateTronFee"),
      BROADCAST_TON_TRANSACTION: Ut("BroadcastTonTransaction"),
      TON_DISCONNECT: Lt("tonConnect_disconnect"),
      TON_RECONNECT: Lt("tonConnect_reconnect"),
      SIGN_TRON_TRANSACTION: Ut("SignTronTransaction"),
      SWAP_TRANSACTION_CONFIRMATION: Ut("SwapTransactionConfirmation"),
      UNLOCK_POPUP: Lt("UnlockPopup"),
      TOGGLE_BEACON_CHAIN_NETWORK: Lt("ToggleBeaconChainNetwork"),
      SIGN_BNB_MESSAGE: Lt("SignBNBMessage"),
      FETCH_RECOMMENDED_DAPPS: Ut("FetchRecommendedDapps")
    };
    var or = (t => (t.MNEMONIC = "mnemonic", t.PRIVATE_KEY = "private key", t.WATCH_ONLY = "watchOnly", t.HARDWARE = "hardware", t))(or || {}),
      sr = Object.defineProperty,
      ar = Object.defineProperties,
      ur = Object.getOwnPropertyDescriptors,
      cr = Object.getOwnPropertySymbols,
      fr = {}.hasOwnProperty,
      lr = {}.propertyIsEnumerable,
      hr = (t, e, r) => e in t ? sr(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r,
      dr = (t, e) => {
        for (var r in e || (e = {})) fr.call(e, r) && hr(t, r, e[r]);
        if (cr)
          for (var r of cr(e)) lr.call(e, r) && hr(t, r, e[r]);
        return t
      },
      pr = (t, e) => ar(t, ur(e)),
      br = (t, e, r) => new Promise((n, i) => {
        var o = t => {
            try {
              a(r.next(t))
            } catch (t) {
              i(t)
            }
          },
          s = t => {
            try {
              a(r.throw(t))
            } catch (t) {
              i(t)
            }
          },
          a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
        a((r = r.apply(t, e)).next())
      }),
      mr = (t => (t.TOGGLE_BEACON_CHAIN_NETWORK = "ToggleBeaconChainNetwork", t.REQUEST_ACCOUNTS = "requestAccounts", t.GET_CHAIN_ID = "chainId", t.DAPP_TRIGGERED_STAKING_TRANSACTION = "dappTriggeredStakingTransaction", t.GET_ACTIVE_WALLET = "GetActiveWallet", t.SIGN_BNB_MESSAGE = "SignBNBMessage", t))(mr || {}),
      yr = (t => (t.CONNECT = "connect", t))(yr || {}),
      gr = (t => (t.ETH_REQUEST_ACCOUNTS = "eth_requestAccounts", t))(gr || {}),
      vr = (t => (t.MAINNET = "bbc-mainnet", t.TESTNET = "bbc-testnet", t.BSC = "bsc-mainnet", t))(vr || {});
    const wr = "Binance-Chain-Tigris",
      Ar = "Binance-Chain-Ganges";
    class Tr extends Ue {
      constructor() {
        super(...arguments), this.emitter = new ke.EventEmitter
      }
      getNetwork() {
        throw Error("Method not implemented.")
      }
      boot() {
        return br(this, null, function*() {
          const t = yield this.rpc.call({
            method: ir.ETH_CHAIN_ID
          });
          this.internalChainId = t === parseInt("0x61") ? Ar : wr;
          const e = yield this.rpc.call({
            method: Lt("GetActiveWallet"),
            params: {
              networkId: $t.binance
            }
          });
          this.hardware = e?.type === or.HARDWARE
        })
      }
      setRpc(t) {
        this.rpc = new nr(t)
      }
      setAddress(t) {
        this.address = t, this.selectedAddress = t
      }
      setEvmAddress(t) {
        this.evmAddress = t
      }
      setChainId(t) {
        this.internalChainId = t
      }
      redelegate(t) {
        return br(this, null, function*() {
          return Ct.getLogger(Tr.name).debug("Requesting redelegate", t), yield this.handleStaking("redelegate", t)
        })
      }
      undelegate(t) {
        return br(this, null, function*() {
          return Ct.getLogger(Tr.name).debug("Requesting undelegate", t), yield this.handleStaking("undelegate", t)
        })
      }
      delegate(t) {
        return br(this, null, function*() {
          return Ct.getLogger(Tr.name).debug("Requesting delegate", t), yield this.handleStaking("delegate", t)
        })
      }
      requestAccounts() {
        return br(this, null, function*() {
          return Ct.getLogger(Tr.name).debug("Request method for requestAccounts"), yield this.requestBnbAddress(), yield this.requestEVMAddress(), this.format()
        })
      }
      request(t) {
        return br(this, arguments, function*({
          method: t,
          params: e
        }) {
          Ct.getLogger(Tr.name).debug("Request method for " + t, e || "");
          const r = {
            eth_requestAccounts: () => br(this, null, function*() {
              const t = yield this.requestBnbAddress();
              return yield this.requestEVMAddress(), t
            })
          } [t];
          if (!r) throw Error("Invalid method requested");
          return r()
        })
      }
      on(t, e) {
        return Ct.getLogger(Tr.name).debug("DAppSubscribed to " + t.toString()), this.emitter.on(t, e.bind(e)), "connect" === t && setTimeout(() => {
          this.emitter.emit(t, {
            chainId: this.internalChainId
          })
        }, 500), this
      }
      requestBnbAddress() {
        return br(this, null, function*() {
          const t = yield this.rpc.call({
            method: Lt("requestAccounts"),
            params: {
              networkId: $t.binance
            }
          });
          return t.length > 0 && this.setAddress(t[0]), [this.address]
        })
      }
      requestEVMAddress() {
        return br(this, null, function*() {
          if (!this.hardware) {
            if (this.evmAddress) return [this.evmAddress];
            try {
              const t = yield this.rpc.call({
                method: Lt("requestAccounts"),
                params: {
                  networkId: $t.ethereum
                }
              });
              return t.length > 0 && this.setEvmAddress(t[0]), [this.evmAddress]
            } catch (t) {
              Ct.error(t)
            }
          }
        })
      }
      handleStaking(t, e) {
        return br(this, null, function*() {
          return yield this.rpc.call({
            method: Lt("dappTriggeredStakingTransaction"),
            params: pr(dr({}, e), {
              transactionType: t,
              networkId: $t.binance
            })
          })
        })
      }
      switchNetwork(t) {
        return br(this, null, function*() {
          switch (yield this.rpc.call({
              method: Lt("ToggleBeaconChainNetwork"),
              params: {
                network: t,
                networkId: $t.binance
              }
            }), t) {
            case "bbc-mainnet":
              this.internalChainId = wr;
              break;
            case "bbc-testnet":
              this.internalChainId = Ar
          }
          return this.emitter.emit("connect", {
            chainId: this.internalChainId
          }), {}
        })
      }
      bnbSign(t, e) {
        return br(this, null, function*() {
          return yield this.rpc.call({
            method: Lt("SignBNBMessage"),
            params: {
              address: t,
              message: e,
              networkId: $t.binance
            }
          })
        })
      }
      format() {
        return br(this, null, function*() {
          const t = yield this.rpc.call({
            method: Lt("GetActiveWallet"),
            params: {
              networkId: $t.binance
            }
          });
          return [{
            id: t.id,
            name: t.name,
            icon: "data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjQgMjQiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgY2xhc3M9InNjLXBraElSIGhnRUNmUyI+PHJlY3Qgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiByeD0iOCIgZmlsbD0iI2ZjNmU3NSI+PC9yZWN0Pjx0ZXh0IHg9IjUwJSIgeT0iNTAlIiBkb21pbmFudC1iYXNlbGluZT0iY2VudHJhbCIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzFlMjAyNiIgc3R5bGU9ImZvbnQtc3R5bGU6bm9ybWFsO2ZvbnQtc2l6ZToxNHB4O2ZvbnQtZmFtaWx5OkJpbmFuY2VQbGV4LCAtYXBwbGUtc3lzdGVtLCAmI3gyNzsuU0ZOU1RleHQtUmVndWxhciYjeDI3OywgJiN4Mjc7U2FuIEZyYW5jaXNjbyYjeDI3OywKQmxpbmtNYWNTeXN0ZW1Gb250LCAmI3gyNzsuUGluZ0ZhbmctU0MtUmVndWxhciYjeDI3OywgJiN4Mjc7TWljcm9zb2Z0IFlhSGVpJiN4Mjc7LCAmI3gyNztTZWdvZSBVSSYjeDI3OywgJiN4Mjc7SGVsdmV0aWNhIE5ldWUmI3gyNzssCkhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYiPkE8L3RleHQ+PC9zdmc+",
            addresses: [{
              type: this.internalChainId === wr ? "bbc-mainnet" : "bbc-testnet",
              address: this.address
            }, ...this.hardware ? [] : [{
              type: "eth",
              address: this.evmAddress
            }]],
            type: "local"
          }]
        })
      }
      get autoRefreshOnNetworkChange() {
        return !1
      }
      get chainId() {
        return this.internalChainId
      }
      get networkVersion() {
        return this.internalChainId
      }
    }
    const Er = {
      SITE_DISCONNECTED: Lt("SITE_DISCONNECTED"),
      CHAIN_CHANGED: Lt("CHAIN_CHANGED"),
      ACCOUNT_CHANGED: Lt("ACCOUNT_CHANGED"),
      DEFAULT_WALLET_CHANGED: Lt("DEFAULT_WALLET_CHANGED"),
      BNB_STAKING_CHAIN_CHANGED: Lt("BNB_STAKING_CHAIN_CHANGED"),
      ONE_TAP_CLOSED: Lt("OneTapClosed"),
      ONE_TAP_WAGMI: Lt("OneTapWagmi"),
      WALLET_CONNECTED_ON_ORIGIN: Lt("WalletConnectedOnOrigin")
    };
    class Pr extends rr {
      constructor() {
        super(), this.promisified = !0, this.provider = new Tr
      }
      start(t) {
        try {
          this.bm = t, this.provider.setRpc(this.bm), Object.assign(this.provider, E), window.BinanceChain || (window.BinanceChain = this.provider), window.TrustBinanceChain = this.provider, setTimeout(() => {
            this.provider.boot(), this.persist()
          }, 200)
        } catch (t) {
          Ct.error(t)
        }
      }
      onResponseReady({
        data: t,
        event: e,
        networkId: r
      }) {
        if (r === $t.binance && e === ir.ETH_REQUEST_ACCOUNTS && t.length > 0) {
          const e = t[0];
          this.provider.setAddress(e), this.provider.emitter.emit("accountsChanged", e ? [e] : [])
        }
      }
      fetchAlreadyConnectedAccount() {
        return ((t, e, r) => new Promise((e, n) => {
          var i = t => {
              try {
                s(r.next(t))
              } catch (t) {
                n(t)
              }
            },
            o = t => {
              try {
                s(r.throw(t))
              } catch (t) {
                n(t)
              }
            },
            s = t => t.done ? e(t.value) : Promise.resolve(t.value).then(i, o);
          s((r = r.apply(t, null)).next())
        }))(this, 0, function*() {
          const [t] = yield this.bm.emit(ir.ETH_ACCOUNTS, {
            networkId: $t.binance
          });
          t && (this.provider.setAddress(t), this.provider.emitter.emit("accountsChanged", t ? [t] : []), this.persist())
        })
      }
      getCacheKey() {
        return `${$t.binance}-${window.location.origin}`
      }
      persist() {
        return Rt("Cache updated for binance", Tr.name), jt.set(this.getCacheKey(), {
          address: this.provider.address,
          evmAddress: this.provider.evmAddress,
          chainId: this.provider.chainId,
          networkVersion: this.provider.networkVersion
        })
      }
      clearCache() {
        return Rt("Cache cleared for binance", Tr.name), jt.clear(this.getCacheKey())
      }
      loadCache() {
        return !1
      }
      registerEventListeners() {
        const t = this.bm;
        t.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received"), this.provider.emitter.emit("accountsChanged", [""]), this.clearCache()
        }), t.addListener(Er.ACCOUNT_CHANGED, t => {
          var e;
          Rt(Er.ACCOUNT_CHANGED + " received binance");
          const {
            address: r,
            network: n
          } = null != (e = t.data.params) ? e : {};
          this.provider.address && r !== this.provider.address && n === $t.binance && (Rt(Er.ACCOUNT_CHANGED + " received binance", r), this.provider.setAddress(r), location.reload()), this.provider.evmAddress && r !== this.provider.evmAddress && n === $t.ethereum && (Rt(Er.ACCOUNT_CHANGED + " received binance"), this.provider.setEvmAddress(r), location.reload())
        })
      }
    }
    var kr = i(48287).Buffer;
    class xr {
      constructor(t) {
        this.provider = t
      }
      async request(t, e) {
        if ("getKey" === t.method) {
          const e = await this.provider.internalRequest({
              method: "requestAccounts",
              params: t.params
            }),
            r = JSON.parse(e);
          return {
            algo: "secp256k1",
            address: r.address,
            bech32Address: r.address,
            pubKey: kr.from(r.pubKey, "hex")
          }
        }
        const r = {
          signAmino: "signTransaction",
          signDirect: "signTransaction",
          signArbitrary: "signMessage",
          sendTx: "sendTransaction"
        };
        return r[t.method] ? this.provider.internalRequest({
          method: r[t.method],
          params: t.params
        }) : e()
      }
    }
    var Ir, Sr = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      Or = (t, e, r) => (Sr(t, e, "read from private field"), r ? r.call(t) : e.get(t));
    const Br = class extends Ue {
      constructor(t) {
        super(), ((t, e) => {
          if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
          e instanceof WeakSet ? e.add(t) : e.set(t, !1)
        })(this, Ir), this.isKeplr = !0, this.isTrust = !0, this.isTrustWallet = !0, t && ("u" > typeof t.disableMobileAdapter && ((t, e, r) => {
          Sr(t, e, "write to private field"), e.set(t, r)
        })(this, Ir, t.disableMobileAdapter), "u" > typeof t.isKeplr && (this.isKeplr = t.isKeplr), "u" > typeof t.isTrust && (this.isTrust = t.isTrust, this.isTrustWallet = t.isTrust)), Or(this, Ir) || (this.mobileAdapter = new xr(this))
      }
      static bufferToHex(t) {
        return "0x" + kr.from(t).toString("hex")
      }
      getNetwork() {
        return Br.NETWORK
      }
      isMobileAdapterEnabled() {
        return !Or(this, Ir)
      }
      enable(t) {
        return this.request({
          method: "enable",
          params: {
            chainIds: t
          }
        })
      }
      internalRequest(t) {
        return super.request(t)
      }
      request(t) {
        const e = () => this.internalRequest(t);
        return this.mobileAdapter ? this.mobileAdapter.request(t, e) : e()
      }
      getKey(t) {
        return this.request({
          method: "getKey",
          params: {
            chainId: t
          }
        })
      }
      async sendTx(t, e, r) {
        const n = kr.from(e).toString("base64"),
          i = await this.request({
            method: "sendTx",
            params: {
              raw: n,
              chainId: t,
              mode: r
            }
          });
        return new Uint8Array(kr.from(i, "hex"))
      }
      async signArbitrary(t, e, r) {
        const n = kr.from(r),
          i = Br.bufferToHex(n);
        return await this.request({
          method: "signArbitrary",
          params: {
            chainId: t,
            data: i,
            signerAddress: e
          }
        })
      }
      async signAmino(t, e, r) {
        const n = await this.request({
            method: "signAmino",
            params: {
              chainId: t,
              sign_doc: r
            }
          }),
          {
            signed: i,
            signature: o
          } = JSON.parse(n);
        return {
          signed: i,
          signature: o
        }
      }
      async signDirect(t, e, r) {
        const n = {
            bodyBytes: Br.bufferToHex(r.bodyBytes),
            authInfoBytes: Br.bufferToHex(r.authInfoBytes)
          },
          i = await this.request({
            method: "signDirect",
            params: {
              signerAddress: e,
              chainId: t,
              sign_doc: n
            }
          }),
          {
            signature: o
          } = JSON.parse(i);
        return {
          signed: r,
          signature: o
        }
      }
      experimentalSuggestChain() {}
      getOfflineSignerDirect(t) {
        return {
          getAccounts: async () => [await this.getKey(t)],
          signDirect: async (e, r) => {
            if (t !== r.chainId) throw Error("Unmatched chain id with the offline signer");
            if ((await this.getKey(r.chainId)).address !== e) throw Error("Unknown signer address");
            return await this.signDirect(t, e, r)
          }
        }
      }
      getOfflineSigner(t) {
        return this.getOfflineSignerAmino(t)
      }
      getOfflineSignerAuto(t) {
        return this.getOfflineSignerAmino(t)
      }
      getOfflineSignerAmino(t) {
        return {
          getAccounts: async () => {
            const e = await this.getKey(t);
            return [{
              address: e.bech32Address,
              algo: "secp256k1",
              pubkey: e.pubKey
            }]
          },
          sign: (e, r) => this.signAmino(t, e, r),
          signAmino: (e, r) => this.signAmino(t, e, r)
        }
      }
    };
    let Wr = Br;
    Ir = new WeakMap, Wr.NETWORK = "cosmos";
    const Mr = class t extends rr {
      constructor() {
        super(), this.provider = new Wr({
          isKeplr: !0
        })
      }
      boot() {
        Rt("Booting Cosmos")
      }
      start(t) {
        this.bm = t, Object.assign(window.trustwallet, {
          cosmos: this.provider
        }), setTimeout(() => this.setWallet(), 300)
      }
      registerEventListeners() {
        const e = this.bm;
        e.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received")
        }), e.addListener(Er.ACCOUNT_CHANGED, e => {
          var r;
          const {
            network: n
          } = null != (r = e.data.params) ? r : {};
          n === $t.cosmos && (Rt(Er.ACCOUNT_CHANGED + " received {COSMOS}"), window.dispatchEvent(new Event(t.KEY_STORE_EVENT)))
        }), e.addListener(Er.DEFAULT_WALLET_CHANGED, t => (Rt(Er.DEFAULT_WALLET_CHANGED + " received"), this.setWallet()))
      }
      setWallet() {
        window.TrustCosmos = window.trustwallet.cosmos, Rt("Cosmos object set")
      }
    };
    Mr.KEY_STORE_EVENT = "trustwallet_keystorechange";
    let Cr = Mr;
    const Rr = {
      RESET: Ut("Reset"),
      LOCK: Ut("Lock"),
      LOCK_CALLBACK: Ut("Lock_callback"),
      AUTHENTICATE: Ut("Authenticate"),
      REGISTER_DEVICE: Ut("RegisterDevice"),
      APP_DISPLAYED: Ut("AppDisplayed"),
      WARNING_DISPLAYED: Ut("WarningDisplayed"),
      ICON_THEME_CHANGED: Ut("IconThemeChanged"),
      OPEN_POPUP: Ut("OpenPopup"),
      GET_APP_SETTINGS: Lt("GetAppSettings"),
      GET_APP_NODES: Lt("GetAppNodes"),
      GET_STORE: Ut("GetStore"),
      GET_REDUX_STATE: Ut("GetReduxState"),
      DISPATCH_REDUX_ACTION: Ut("DispatchReduxAction"),
      PING: Lt("Ping"),
      GET_ONE_TAP_SETTINGS: Lt("GetOneTapSettings"),
      ONE_TAP_DISMISS: Lt("OneTapDismiss"),
      ONE_TAP_CONNECT: Lt("OneTapConnect"),
      GET_TOKEN_SCANNER_I18N: Lt("GetTokenScannerI18n"),
      GET_TOKEN_SCANNER_ENABLED: Lt("GetTokenScannerEnabled"),
      GET_TOKEN_BASIC_INFO: Lt("GetTokenBasicInfo"),
      GET_TOKEN_MARKET_DATA: Lt("GetTokenMarketData"),
      GET_SIMILAR_TOKENS_COUNT: Lt("GetSimilarTokensCount"),
      GET_SIMILAR_TOKENS: Lt("GetSimilarTokens"),
      OPEN_SWAP_PAGE: Lt("OpenSwapPage"),
      GET_FEATURE_FLAG: Lt("GetFeatureFlag"),
      SET_TOKEN_SCANNER_ENABLED: Lt("SetTokenScannerEnabled"),
      TRACK_ANALYTICS: Lt("TrackAnalytics"),
      ANNOUNCEMENT_DISPLAYED: Ut("AnnouncementDisplayed"),
      FETCH_ANNOUNCEMENTS: Ut("FetchAnnouncements"),
      FETCH_USER_VIP_TIER_DATA: Ut("FetchUserVipTierData"),
      FETCH_FUNDING_METHODS: Ut("FetchFundingMethods"),
      ROUTE_CHANGED: Ut("RouteChanged")
    };
    var Nr, jr = i(28481),
      _r = i(48287).Buffer;
    class Dr extends Error {
      constructor(t, e) {
        super(), this.code = t, this.message = e
      }
      toString() {
        return `${this.message} (${this.code})`
      }
    }
    const Ur = class {
      constructor(t) {
        ((t, e) => {
          if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
          e instanceof WeakSet ? e.add(t) : e.set(t, ["eth_newFilter", "eth_newBlockFilter", "eth_newPendingTransactionFilter", "eth_uninstallFilter", "eth_subscribe"])
        })(this, Nr), this.provider = t
      }
      static isUTF8(t) {
        try {
          return new TextDecoder("utf8", {
            fatal: !0
          }).decode(t), !0
        } catch {
          return !1
        }
      }
      static bufferToHex(t) {
        return "0x" + _r.from(t).toString("hex")
      }
      static messageToBuffer(t) {
        let e = _r.from([]);
        try {
          e = "string" == typeof t ? _r.from(t.replace("0x", ""), "hex") : _r.from(t)
        } catch (t) {
          console.log("messageToBuffer error: " + t)
        }
        return e
      }
      async request(t) {
        if (((t, e) => (((t, e) => {
            if (!e.has(t)) throw TypeError("Cannot read from private field")
          })(t, e), e.get(t)))(this, Nr).includes(t.method)) return Promise.reject(new Dr(4200, "EthereumProvider does not support calling " + t.method));
        switch (t.method) {
          case "wallet_requestPermissions":
            return this.provider.internalRequest({
              method: "wallet_requestPermissions",
              params: t.params
            });
          case "eth_requestAccounts":
            return this.provider.internalRequest({
              method: "requestAccounts",
              params: {}
            });
          case "eth_sign":
            return this.ethSign(t.params);
          case "personal_sign":
            return this.personalSign(t.params);
          case "personal_ecRecover":
            return this.personalECRecover(t.params);
          case "eth_signTypedData_v3":
            return this.ethSignTypedData(t.params, jr.SignTypedDataVersion.V3);
          case "eth_signTypedData_v4":
            return this.ethSignTypedData(t.params, jr.SignTypedDataVersion.V4);
          case "eth_signTypedData":
            return this.ethSignTypedData(t.params, jr.SignTypedDataVersion.V1);
          case "eth_sendTransaction":
            return this.provider.internalRequest({
              method: "signTransaction",
              params: t.params[0]
            });
          case "wallet_watchAsset": {
            const {
              options: e,
              type: r
            } = t.params, {
              address: n,
              symbol: i,
              decimals: o
            } = e;
            let s, a;
            if (!i) try {
              const t = (await this.contractCall(n, "0x95d89b41")).slice(2),
                e = parseInt(t.slice(0, 64), 16),
                r = parseInt(t.slice(2 * e, 2 * e + 64), 16),
                i = 2 * e + 64,
                o = t.slice(i, i + 2 * r);
              s = "";
              for (let t = 0; t < o.length; t += 2) {
                const e = o.slice(t, t + 2),
                  r = String.fromCharCode(parseInt(e, 16));
                if ("\0" === r) break;
                s += r
              }
            } catch (t) {
              console.error(t)
            }
            if (!o) try {
              const t = await this.contractCall(n, "0x313ce567");
              a = parseInt(t, 16)
            } catch (t) {
              console.error(t)
            }
            return this.provider.internalRequest({
              method: "watchAsset",
              params: {
                type: r,
                contract: n,
                symbol: i || s,
                decimals: o || a
              }
            })
          }
          case "wallet_addEthereumChain":
            return this.provider.internalRequest({
              method: "addEthereumChain",
              params: t.params[0]
            });
          case "wallet_switchEthereumChain":
            return this.provider.internalRequest({
              method: "switchEthereumChain",
              params: t.params[0]
            });
          default:
            return await this.provider.getRPC().call({
              method: t.method,
              jsonrpc: "2.0",
              params: t.params
            })
        }
      }
      personalECRecover(t) {
        return this.provider.internalRequest({
          method: "ecRecover",
          params: {
            signature: t[1],
            message: t[0]
          }
        })
      }
      async personalSign(t) {
        const [e] = await this.provider.request({
          method: "eth_accounts"
        });
        if (!e) throw Error("Unable to execute personal_sign");
        let [r, n] = t;
        "string" == typeof r && e.toLowerCase() === r.toLowerCase() && (r = t[1], n = t[0]);
        const i = Ur.messageToBuffer(r);
        return this.provider.internalRequest({
          method: "signPersonalMessage",
          params: {
            data: 0 === i.length ? Ur.bufferToHex(r) : r,
            address: n
          }
        })
      }
      ethSign(t) {
        if (!t) throw Error("Missing params");
        const [e, r] = t, n = Ur.messageToBuffer(r), i = Ur.bufferToHex(n);
        return this.provider.internalRequest({
          method: Ur.isUTF8(n) ? "signPersonalMessage" : "signMessage",
          params: {
            data: i,
            address: e,
            isEthSign: !0
          }
        })
      }
      async ethSignTypedData(t, e) {
        const [r] = await this.provider.request({
          method: "eth_accounts"
        });
        if (!r) throw Error("Unable to execute ethSignTypedData, address is not present");
        let [n, i] = t;
        "string" == typeof n && r.toLowerCase() === n.toLowerCase() && (n = t[1], i = t[0]);
        const o = "string" == typeof n ? JSON.parse(n) : n,
          {
            chainId: s
          } = o.domain || {};
        if ("u" > typeof s && +s !== +this.provider.getChainId()) throw Error("Provided chainId does not match the currently active chain");
        const a = e !== jr.SignTypedDataVersion.V1 ? jr.TypedDataUtils.eip712Hash(o, e) : "";
        return this.provider.internalRequest({
          method: "signTypedMessage",
          params: {
            data: "0x" + a.toString("hex"),
            raw: "string" == typeof n ? n : JSON.stringify(n),
            address: i,
            version: e
          }
        })
      }
      contractCall(t, e) {
        return this.provider.getRPC().call({
          method: "eth_call",
          jsonrpc: "2.0",
          params: [{
            to: t,
            data: e
          }, "latest"]
        })
      }
    };
    let Lr = Ur;
    Nr = new WeakMap;
    var Fr, $r = Object.defineProperty,
      zr = Object.getOwnPropertySymbols,
      Hr = {}.hasOwnProperty,
      Gr = {}.propertyIsEnumerable,
      Kr = (t, e, r) => e in t ? $r(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r,
      Vr = (t, e) => {
        for (var r in e || (e = {})) Hr.call(e, r) && Kr(t, r, e[r]);
        if (zr)
          for (var r of zr(e)) Gr.call(e, r) && Kr(t, r, e[r]);
        return t
      },
      Zr = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      };
    class qr {
      constructor(t) {
        ((t, e) => {
          if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
          e instanceof WeakSet ? e.add(t) : e.set(t, void 0)
        })(this, Fr), ((t, e, r) => {
          Zr(t, e, "write to private field"), e.set(t, r)
        })(this, Fr, t)
      }
      async getBlockNumber() {
        return (await this.call({
          jsonrpc: "2.0",
          method: "eth_blockNumber",
          params: []
        })).result
      }
      async getBlockByNumber(t) {
        return (await this.call({
          jsonrpc: "2.0",
          method: "eth_getBlockByNumber",
          params: [t, !1]
        })).result
      }
      getFilterLogs(t) {
        return this.call({
          jsonrpc: "2.0",
          method: "eth_getLogs",
          params: [t]
        })
      }
      async call(t) {
        const e = await (await fetch(((t, e) => (Zr(t, e, "read from private field"), e.get(t)))(this, Fr), {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(Vr({
            id: (new Date).getTime() + Math.floor(1e3 * Math.random())
          }, t))
        })).json();
        if (!e.result && e.error) throw Error(e.error.message || "rpc error");
        return e.result
      }
    }
    Fr = new WeakMap;
    var Jr, Yr, Qr, Xr, tn, en, rn = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      nn = (t, e, r) => (rn(t, e, "read from private field"), r ? r.call(t) : e.get(t)),
      on = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
      },
      sn = (t, e, r, n) => (rn(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
    const an = class extends Ue {
      constructor(t) {
        super(), on(this, Jr, void 0), on(this, Yr, void 0), on(this, Qr, !1), on(this, Xr, !1), on(this, tn, void 0), on(this, en, void 0), this.isTrust = !0, this.isTrustWallet = !0, this.request = this.request.bind(this), t && (t.chainId && sn(this, Jr, t.chainId), (t.rpc || t.rpcUrl) && sn(this, Yr, t.rpc || t.rpcUrl), "u" > typeof t.overwriteMetamask && sn(this, Xr, t.overwriteMetamask), "u" > typeof t.disableMobileAdapter && sn(this, Qr, t.disableMobileAdapter), "u" > typeof t.isTrust && (this.isTrust = t.isTrust, this.isTrustWallet = t.isTrust), sn(this, en, new qr(nn(this, Yr)))), nn(this, Qr) || (this.mobileAdapter = new Lr(this)), super.on("onResponseReady", this.onResponseReady.bind(this)), this.connect()
      }
      connect() {
        this.emit("connect", {
          chainId: nn(this, Jr)
        })
      }
      enable() {
        return this.request({
          method: "eth_requestAccounts"
        })
      }
      sendAsync(t, e) {
        Array.isArray(t) ? Promise.all(t.map(t => this.request(t))).then(t => e(null, t)).catch(t => e(t, null)) : this.request(t).then(t => e(null, t)).catch(t => e(t, null))
      }
      ii(t) {
        const e = {
          jsonrpc: "2.0",
          result: null
        };
        switch (t.method) {
          case "eth_accounts":
          case "eth_coinbase":
          case "net_version":
          case "eth_chainId":
            e.result = this.handleStaticRequests({
              method: "eth_accounts"
            });
            break;
          default:
            throw new Dr(4200, `Trust does not support calling ${t.method} synchronously without a callback. Please provide a callback parameter to call ${t.method} asynchronously.`)
        }
        return e
      }
      send(t, e) {
        if ("string" == typeof t && (!e || Array.isArray(e))) {
          const r = this;
          return new Promise((n, i) => {
            try {
              const o = r.request({
                method: t,
                params: e
              });
              o instanceof Promise ? o.then(n).catch(i) : n(o)
            } catch (t) {
              i(t)
            }
          })
        }
        return t && "object" == typeof t && "function" == typeof e ? this.request(t).then(e) : this.ii(t)
      }
      internalRequest(t) {
        return super.request(t)
      }
      request(t) {
        if (this.mobileAdapter) {
          const e = this.handleStaticRequests(t, () => this.mobileAdapter.request(t));
          return e instanceof Promise ? e : Promise.resolve(e)
        }
        return this.handleStaticRequests(t, () => this.internalRequest(t))
      }
      handleStaticRequests(t, e) {
        switch (t.method) {
          case "net_version":
            return nn(this, Jr) ? parseInt(nn(this, Jr)) : void 0;
          case "eth_chainId":
            return nn(this, Jr);
          case "eth_accounts":
          case "eth_coinbase":
            return nn(this, tn) ? [nn(this, tn)] : []
        }
        if (e) return e()
      }
      onResponseReady(t, e) {
        var r, n, i, o;
        if (e) switch (t.method) {
          case "eth_requestAccounts":
          case "requestAccounts":
            sn(this, tn, e[0]);
            break;
          case "wallet_requestPermissions":
            sn(this, tn, null == (o = null == (i = null == (n = null == (r = e[0]) ? void 0 : r.caveats) ? void 0 : n[0]) ? void 0 : i.value) ? void 0 : o[0])
        }
      }
      getNetwork() {
        return an.NETWORK
      }
      get connected() {
        return !0
      }
      get isMetaMask() {
        return nn(this, Xr)
      }
      getChainId() {
        return nn(this, Jr)
      }
      getNetworkVersion() {
        return this.handleStaticRequests({
          method: "net_version "
        })
      }
      setChainId(t) {
        sn(this, Jr, t)
      }
      setRPCUrl(t) {
        sn(this, Yr, t), sn(this, en, new qr(nn(this, Yr)))
      }
      getRPC() {
        return nn(this, en)
      }
      setOverwriteMetamask(t) {
        sn(this, Xr, t)
      }
      getAddress() {
        return nn(this, tn)
      }
      setAddress(t) {
        sn(this, tn, t)
      }
      setRPC(t) {
        sn(this, en, t)
      }
    };
    let un = an;
    Jr = new WeakMap, Yr = new WeakMap, Qr = new WeakMap, Xr = new WeakMap, tn = new WeakMap, en = new WeakMap, un.NETWORK = "ethereum";
    var cn = Object.defineProperty,
      fn = Object.defineProperties,
      ln = Object.getOwnPropertyDescriptors,
      hn = Object.getOwnPropertySymbols,
      dn = {}.hasOwnProperty,
      pn = {}.propertyIsEnumerable,
      bn = (t, e, r) => e in t ? cn(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r,
      mn = (t, e, r) => new Promise((n, i) => {
        var o = t => {
            try {
              a(r.next(t))
            } catch (t) {
              i(t)
            }
          },
          s = t => {
            try {
              a(r.throw(t))
            } catch (t) {
              i(t)
            }
          },
          a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
        a((r = r.apply(t, e)).next())
      });
    class yn extends rr {
      constructor() {
        super(), this.provider = new un({
          isTrust: !0,
          overwriteMetamask: !0
        })
      }
      announce() {
        const t = new CustomEvent("eip6963:announceProvider", {
          detail: Object.freeze({
            info: er.EIP6963Info,
            provider: window.trustwallet
          })
        });
        window.dispatchEvent(t)
      }
      start(t) {
        try {
          this.bm = t, this.provider.setRPC(new nr(this.bm)), Promise.all([this.setChainId(), this.fetchAlreadyConnectedAccount()]), Object.assign(window.trustwallet, ((t, e) => fn(t, ln(e)))(((t, e) => {
            for (var r in e || (e = {})) dn.call(e, r) && bn(t, r, e[r]);
            if (hn)
              for (var r of hn(e)) pn.call(e, r) && bn(t, r, e[r]);
            return t
          })({}, E), {
            removeAllListeners: this.provider.removeAllListeners.bind(this.provider),
            removeListener: this.provider.removeListener.bind(this.provider),
            request: this.provider.request.bind(this.provider),
            send: this.provider.send.bind(this.provider),
            on: (t, e) => this.provider.on(t, e),
            off: (t, e) => this.provider.off(t, e)
          }));
          const e = this.provider,
            r = ["chainId", "networkVersion", "address", "enable", "send"],
            n = new Proxy(window.trustwallet, {
              get(t, n, i) {
                if (r.includes(n)) switch (n) {
                  case "chainId":
                    return e.getChainId.bind(e);
                  case "networkVersion":
                    return e.getNetworkVersion.bind(e);
                  case "address":
                    return e.getAddress.bind(e);
                  case "enable":
                    return e.enable.bind(e);
                  case "send":
                    return e.send.bind(e)
                }
                return Reflect.get(t, n, i)
              }
            });
          window.trustwallet = n, window.trustWallet = n, window.original = window.ethereum, window.original && Rt("Another wallet registered first"), window.ethereum = this.provider, this.setDefaultEthereumWallet().then(t => {
            setTimeout(() => this.setEthereumWallet(t), 300)
          }), this.provider.emit("connect", {
            chainId: this.provider.getChainId()
          }), window.dispatchEvent(new Event("ethereum#initialized"))
        } catch (t) {
          Ct.error(t)
        }
      }
      onResponseReady({
        data: t,
        event: e,
        networkId: r
      }) {
        if (r === $t.ethereum && e === ir.ETH_REQUEST_ACCOUNTS && t.length > 0) {
          const e = t[0];
          this.provider.setAddress(e), Rt("Emit accounts changed " + e), this.provider.emit("accountsChanged", e ? [e] : [])
        }
      }
      registerEventListeners() {
        const t = this.bm;
        t.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received"), this.provider.emit("accountsChanged", []), this.provider.setAddress(""), this.clearCache()
        }), t.addListener(Er.CHAIN_CHANGED, t => {
          Rt(Er.CHAIN_CHANGED + " received");
          const e = t.data.params;
          this.provider.setChainId("0x" + parseInt(e || "1").toString(16)), this.provider.emit("chainChanged", this.provider.getChainId()), this.provider.emit("networkChanged", parseInt(e || "1")), this.persist()
        }), t.addListener(Er.ACCOUNT_CHANGED, t => {
          var e;
          const {
            address: r,
            network: n
          } = null != (e = t.data.params) ? e : {};
          r !== this.provider.getAddress() && n === $t.ethereum && (Rt(Er.ACCOUNT_CHANGED + " received eth"), this.provider.setAddress(r), this.provider.emit("accountsChanged", r ? [r] : []), this.persist())
        }), t.addListener(Er.DEFAULT_WALLET_CHANGED, t => (Rt(Er.DEFAULT_WALLET_CHANGED + " received"), this.setEthereumWallet(t.data.params))), t.addListener(Er.ONE_TAP_WAGMI, () => {
          this.fetchAlreadyConnectedAccount()
        })
      }
      setEthereumWallet(t) {
        const e = window.original || window.ethereum || this.provider,
          r = t ? this.provider : e;
        window.ethereum = r, window.ethereum && !window.ethereum.isTrust && (this.provider.providers = [window.ethereum]), e.isMetaMask && window.ethereum.isTrust && this.provider.setOverwriteMetamask(t)
      }
      setDefaultEthereumWallet() {
        return mn(this, null, function*() {
          const {
            isDefaultWallet: t
          } = yield this.bm.emit(Rr.GET_APP_SETTINGS);
          return this.setEthereumWallet(t), t
        })
      }
      setChainId() {
        return mn(this, null, function*() {
          const t = yield this.bm.emit(ir.ETH_CHAIN_ID);
          this.provider.setChainId("0x" + parseInt(t || "1").toString(16)), Rt("Chain changed " + this.provider.getChainId()), this.provider.emit("chainChanged", this.provider.getChainId()), this.provider.emit("networkChanged", this.provider.getNetworkVersion()), this.persist()
        })
      }
      fetchAlreadyConnectedAccount() {
        return mn(this, null, function*() {
          const [t] = yield this.bm.emit(ir.ETH_ACCOUNTS, {
            networkId: $t.ethereum
          });
          t && (this.provider.setAddress(t), Rt("Emit accounts changed " + t), this.provider.emit("accountsChanged", t ? [t] : []), this.persist())
        })
      }
      getCacheKey() {
        return `${$t.ethereum}-${window.location.origin}`
      }
      persist() {
        return Rt("Cache updated for web3"), jt.set(this.getCacheKey(), {
          address: this.provider.getAddress(),
          chainId: this.provider.getChainId(),
          networkVersion: this.provider.getNetworkVersion()
        })
      }
      clearCache() {
        return Rt("Cache cleared for web3"), jt.clear(this.getCacheKey())
      }
      loadCache() {
        const t = jt.get(this.getCacheKey());
        if (t) {
          Rt("Cache loaded for web3");
          const {
            address: e,
            chainId: r
          } = t;
          this.provider.setChainId(r), this.provider.emit("chainChanged", this.provider.getChainId()), this.provider.emit("networkChanged", this.provider.getNetworkVersion()), this.provider.emit("accountsChanged", e ? [e] : [])
        } else this.clearCache()
      }
    }
    const gn = {
      START_POLL_GAS_FEES: Ut("PollGasFees"),
      STOP_POLL_GAS_FEES: Ut("StopPollGasFees"),
      GET_NODE: Lt("GetNode"),
      UPDATE_TRANSACTION_STATUS: Lt("UpdateTransactionStatus")
    };
    var vn = i(48287);
    const wn = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0;

    function An(t) {
      return t instanceof Uint8Array || ArrayBuffer.isView(t) && "Uint8Array" === t.constructor.name
    }

    function Tn(t) {
      if (!Number.isSafeInteger(t) || 0 > t) throw Error("positive integer expected, got " + t)
    }

    function En(t, ...e) {
      if (!An(t)) throw Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length)) throw Error("Uint8Array expected of length " + e + ", got length=" + t.length)
    }

    function Pn(t) {
      if ("function" != typeof t || "function" != typeof t.create) throw Error("Hash should be wrapped by utils.createHasher");
      Tn(t.outputLen), Tn(t.blockLen)
    }

    function kn(t, e = !0) {
      if (t.destroyed) throw Error("Hash instance has been destroyed");
      if (e && t.finished) throw Error("Hash#digest() has already been called")
    }

    function xn(t, e) {
      En(t);
      const r = e.outputLen;
      if (t.length < r) throw Error("digestInto() expects output buffer of length at least " + r)
    }

    function In(...t) {
      for (let e = 0; e < t.length; e++) t[e].fill(0)
    }

    function Sn(t) {
      return new DataView(t.buffer, t.byteOffset, t.byteLength)
    }

    function On(t, e) {
      return t << 32 - e | t >>> e
    }

    function Bn(t) {
      return t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255
    }
    const Wn = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0] ? t => t : function(t) {
        for (let e = 0; e < t.length; e++) t[e] = Bn(t[e]);
        return t
      },
      Mn = "function" == typeof Uint8Array.from([]).toHex && "function" == typeof Uint8Array.fromHex,
      Cn = Array.from({
        length: 256
      }, (t, e) => e.toString(16).padStart(2, "0"));

    function Rn(t) {
      if (En(t), Mn) return t.toHex();
      let e = "";
      for (let r = 0; r < t.length; r++) e += Cn[t[r]];
      return e
    }

    function Nn(t) {
      return 48 > t || t > 57 ? 65 > t || t > 70 ? 97 > t || t > 102 ? void 0 : t - 87 : t - 55 : t - 48
    }

    function jn(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      if (Mn) return Uint8Array.fromHex(t);
      const e = t.length,
        r = e / 2;
      if (e % 2) throw Error("hex string expected, got unpadded hex of length " + e);
      const n = new Uint8Array(r);
      for (let e = 0, i = 0; r > e; e++, i += 2) {
        const r = Nn(t.charCodeAt(i)),
          o = Nn(t.charCodeAt(i + 1));
        if (void 0 === r || void 0 === o) {
          const e = t[i] + t[i + 1];
          throw Error('hex string expected, got non-hex character "' + e + '" at index ' + i)
        }
        n[e] = 16 * r + o
      }
      return n
    }

    function _n(t) {
      if ("string" != typeof t) throw Error("string expected");
      return new Uint8Array((new TextEncoder).encode(t))
    }

    function Dn(t) {
      return "string" == typeof t && (t = _n(t)), En(t), t
    }

    function Un(...t) {
      let e = 0;
      for (let r = 0; r < t.length; r++) {
        const n = t[r];
        En(n), e += n.length
      }
      const r = new Uint8Array(e);
      for (let e = 0, n = 0; e < t.length; e++) {
        const i = t[e];
        r.set(i, n), n += i.length
      }
      return r
    }
    class Ln {}

    function Fn(t) {
      const e = e => t().update(Dn(e)).digest(),
        r = t();
      return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
    }

    function $n(t = 32) {
      if (wn && "function" == typeof wn.getRandomValues) return wn.getRandomValues(new Uint8Array(t));
      if (wn && "function" == typeof wn.randomBytes) return Uint8Array.from(wn.randomBytes(t));
      throw Error("crypto.getRandomValues must be defined")
    }

    function zn(t, e, r) {
      return t & e ^ ~t & r
    }

    function Hn(t, e, r) {
      return t & e ^ t & r ^ e & r
    }
    class Gn extends Ln {
      constructor(t, e, r, n) {
        super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = n, this.buffer = new Uint8Array(t), this.view = Sn(this.buffer)
      }
      update(t) {
        kn(this), En(t = Dn(t));
        const {
          view: e,
          buffer: r,
          blockLen: n
        } = this, i = t.length;
        for (let o = 0; i > o;) {
          const s = Math.min(n - this.pos, i - o);
          if (s === n) {
            const e = Sn(t);
            for (; i - o >= n; o += n) this.process(e, o);
            continue
          }
          r.set(t.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === n && (this.process(e, 0), this.pos = 0)
        }
        return this.length += t.length, this.roundClean(), this
      }
      digestInto(t) {
        kn(this), xn(t, this), this.finished = !0;
        const {
          buffer: e,
          view: r,
          blockLen: n,
          isLE: i
        } = this;
        let {
          pos: o
        } = this;
        e[o++] = 128, In(this.buffer.subarray(o)), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for (let t = o; n > t; t++) e[t] = 0;
        (function(t, e, r, n) {
          if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, r, n);
          const i = BigInt(32),
            o = BigInt(4294967295),
            s = +(r >> i & o),
            a = +(r & o),
            u = n ? 4 : 0,
            c = n ? 0 : 4;
          t.setUint32(e + u, s, n), t.setUint32(e + c, a, n)
        })(r, n - 8, BigInt(8 * this.length), i), this.process(r, 0);
        const s = Sn(t),
          a = this.outputLen;
        if (a % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
        const u = a / 4,
          c = this.get();
        if (u > c.length) throw Error("_sha2: outputLen bigger than state");
        for (let t = 0; u > t; t++) s.setUint32(4 * t, c[t], i)
      }
      digest() {
        const {
          buffer: t,
          outputLen: e
        } = this;
        this.digestInto(t);
        const r = t.slice(0, e);
        return this.destroy(), r
      }
      jt(t) {
        t || (t = new this.constructor), t.set(...this.get());
        const {
          blockLen: e,
          buffer: r,
          length: n,
          finished: i,
          destroyed: o,
          pos: s
        } = this;
        return t.destroyed = o, t.finished = i, t.length = n, t.pos = s, n % e && t.buffer.set(r), t
      }
      clone() {
        return this.jt()
      }
    }
    const Kn = Uint32Array.from([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
      Vn = (Uint32Array.from([3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428]), Uint32Array.from([3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428]), Uint32Array.from([1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209])),
      Zn = BigInt(2 ** 32 - 1),
      qn = BigInt(32);

    function Jn(t, e = !1) {
      return e ? {
        h: +(t & Zn),
        l: +(t >> qn & Zn)
      } : {
        h: 0 | +(t >> qn & Zn),
        l: 0 | +(t & Zn)
      }
    }

    function Yn(t, e = !1) {
      const r = t.length;
      let n = new Uint32Array(r),
        i = new Uint32Array(r);
      for (let o = 0; r > o; o++) {
        const {
          h: r,
          l: s
        } = Jn(t[o], e);
        [n[o], i[o]] = [r, s]
      }
      return [n, i]
    }
    const Qn = (t, e, r) => t >>> r,
      Xn = (t, e, r) => t << 32 - r | e >>> r,
      ti = (t, e, r) => t >>> r | e << 32 - r,
      ei = (t, e, r) => t << 32 - r | e >>> r,
      ri = (t, e, r) => t << 64 - r | e >>> r - 32,
      ni = (t, e, r) => t >>> r - 32 | e << 64 - r;

    function ii(t, e, r, n) {
      const i = (e >>> 0) + (n >>> 0);
      return {
        h: t + r + (i / 2 ** 32 | 0) | 0,
        l: 0 | i
      }
    }
    const oi = (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
      si = (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
      ai = (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
      ui = (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
      ci = (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0),
      fi = (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0,
      li = Uint32Array.from([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
      hi = new Uint32Array(64);
    class di extends Gn {
      constructor(t = 32) {
        super(64, t, 8, !1), this.A = 0 | Kn[0], this.B = 0 | Kn[1], this.C = 0 | Kn[2], this.D = 0 | Kn[3], this.E = 0 | Kn[4], this.F = 0 | Kn[5], this.G = 0 | Kn[6], this.H = 0 | Kn[7]
      }
      get() {
        const {
          A: t,
          B: e,
          C: r,
          D: n,
          E: i,
          F: o,
          G: s,
          H: a
        } = this;
        return [t, e, r, n, i, o, s, a]
      }
      set(t, e, r, n, i, o, s, a) {
        this.A = 0 | t, this.B = 0 | e, this.C = 0 | r, this.D = 0 | n, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) hi[r] = t.getUint32(e, !1);
        for (let t = 16; 64 > t; t++) {
          const e = hi[t - 15],
            r = hi[t - 2],
            n = On(e, 7) ^ On(e, 18) ^ e >>> 3,
            i = On(r, 17) ^ On(r, 19) ^ r >>> 10;
          hi[t] = i + hi[t - 7] + n + hi[t - 16] | 0
        }
        let {
          A: r,
          B: n,
          C: i,
          D: o,
          E: s,
          F: a,
          G: u,
          H: c
        } = this;
        for (let t = 0; 64 > t; t++) {
          const e = c + (On(s, 6) ^ On(s, 11) ^ On(s, 25)) + zn(s, a, u) + li[t] + hi[t] | 0,
            f = (On(r, 2) ^ On(r, 13) ^ On(r, 22)) + Hn(r, n, i) | 0;
          c = u, u = a, a = s, s = o + e | 0, o = i, i = n, n = r, r = e + f | 0
        }
        r = r + this.A | 0, n = n + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, u = u + this.G | 0, c = c + this.H | 0, this.set(r, n, i, o, s, a, u, c)
      }
      roundClean() {
        In(hi)
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), In(this.buffer)
      }
    }
    const pi = Yn(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
      bi = pi[0],
      mi = pi[1],
      yi = new Uint32Array(80),
      gi = new Uint32Array(80);
    class vi extends Gn {
      constructor(t = 64) {
        super(128, t, 16, !1), this.Ah = 0 | Vn[0], this.Al = 0 | Vn[1], this.Bh = 0 | Vn[2], this.Bl = 0 | Vn[3], this.Ch = 0 | Vn[4], this.Cl = 0 | Vn[5], this.Dh = 0 | Vn[6], this.Dl = 0 | Vn[7], this.Eh = 0 | Vn[8], this.El = 0 | Vn[9], this.Fh = 0 | Vn[10], this.Fl = 0 | Vn[11], this.Gh = 0 | Vn[12], this.Gl = 0 | Vn[13], this.Hh = 0 | Vn[14], this.Hl = 0 | Vn[15]
      }
      get() {
        const {
          Ah: t,
          Al: e,
          Bh: r,
          Bl: n,
          Ch: i,
          Cl: o,
          Dh: s,
          Dl: a,
          Eh: u,
          El: c,
          Fh: f,
          Fl: l,
          Gh: h,
          Gl: d,
          Hh: p,
          Hl: b
        } = this;
        return [t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b]
      }
      set(t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b) {
        this.Ah = 0 | t, this.Al = 0 | e, this.Bh = 0 | r, this.Bl = 0 | n, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | u, this.El = 0 | c, this.Fh = 0 | f, this.Fl = 0 | l, this.Gh = 0 | h, this.Gl = 0 | d, this.Hh = 0 | p, this.Hl = 0 | b
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) yi[r] = t.getUint32(e), gi[r] = t.getUint32(e += 4);
        for (let t = 16; 80 > t; t++) {
          const e = 0 | yi[t - 15],
            r = 0 | gi[t - 15],
            n = ti(e, r, 1) ^ ti(e, r, 8) ^ Qn(e, 0, 7),
            i = ei(e, r, 1) ^ ei(e, r, 8) ^ Xn(e, r, 7),
            o = 0 | yi[t - 2],
            s = 0 | gi[t - 2],
            a = ti(o, s, 19) ^ ri(o, s, 61) ^ Qn(o, 0, 6),
            u = ei(o, s, 19) ^ ni(o, s, 61) ^ Xn(o, s, 6),
            c = ai(i, u, gi[t - 7], gi[t - 16]),
            f = ui(c, n, a, yi[t - 7], yi[t - 16]);
          yi[t] = 0 | f, gi[t] = 0 | c
        }
        let {
          Ah: r,
          Al: n,
          Bh: i,
          Bl: o,
          Ch: s,
          Cl: a,
          Dh: u,
          Dl: c,
          Eh: f,
          El: l,
          Fh: h,
          Fl: d,
          Gh: p,
          Gl: b,
          Hh: m,
          Hl: y
        } = this;
        for (let t = 0; 80 > t; t++) {
          const e = ti(f, l, 14) ^ ti(f, l, 18) ^ ri(f, l, 41),
            g = ei(f, l, 14) ^ ei(f, l, 18) ^ ni(f, l, 41),
            v = f & h ^ ~f & p,
            w = ci(y, g, l & d ^ ~l & b, mi[t], gi[t]),
            A = fi(w, m, e, v, bi[t], yi[t]),
            T = 0 | w,
            E = ti(r, n, 28) ^ ri(r, n, 34) ^ ri(r, n, 39),
            P = ei(r, n, 28) ^ ni(r, n, 34) ^ ni(r, n, 39),
            k = r & i ^ r & s ^ i & s,
            x = n & o ^ n & a ^ o & a;
          m = 0 | p, y = 0 | b, p = 0 | h, b = 0 | d, h = 0 | f, d = 0 | l, ({
            h: f,
            l: l
          } = ii(0 | u, 0 | c, 0 | A, 0 | T)), u = 0 | s, c = 0 | a, s = 0 | i, a = 0 | o, i = 0 | r, o = 0 | n;
          const I = oi(T, P, x);
          r = si(I, A, E, k), n = 0 | I
        }({
          h: r,
          l: n
        } = ii(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)), ({
          h: i,
          l: o
        } = ii(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({
          h: s,
          l: a
        } = ii(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({
          h: u,
          l: c
        } = ii(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)), ({
          h: f,
          l: l
        } = ii(0 | this.Eh, 0 | this.El, 0 | f, 0 | l)), ({
          h: h,
          l: d
        } = ii(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)), ({
          h: p,
          l: b
        } = ii(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | b)), ({
          h: m,
          l: y
        } = ii(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y)
      }
      roundClean() {
        In(yi, gi)
      }
      destroy() {
        In(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
      }
    }
    Uint32Array.from([2352822216, 424955298, 1944164710, 2312950998, 502970286, 855612546, 1738396948, 1479516111, 258812777, 2077511080, 2011393907, 79989058, 1067287976, 1780299464, 286451373, 2446758561]), Uint32Array.from([573645204, 4230739756, 2673172387, 3360449730, 596883563, 1867755857, 2520282905, 1497426621, 2519219938, 2827943907, 3193839141, 1401305490, 721525244, 746961066, 246885852, 2177182882]);
    const wi = Fn(() => new di),
      Ai = Fn(() => new vi),
      Ti = BigInt(0),
      Ei = BigInt(1);

    function Pi(t, e = "") {
      if ("boolean" != typeof t) throw Error((e && `"${e}"`) + "expected boolean, got type=" + typeof t);
      return t
    }

    function ki(t, e, r = "") {
      const n = An(t),
        i = t?.length,
        o = void 0 !== e;
      if (!n || o && i !== e) throw Error((r && `"${r}" `) + "expected Uint8Array" + (o ? " of length " + e : "") + ", got " + (n ? "length=" + i : "type=" + typeof t));
      return t
    }

    function xi(t) {
      const e = t.toString(16);
      return 1 & e.length ? "0" + e : e
    }

    function Ii(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      return "" === t ? Ti : BigInt("0x" + t)
    }

    function Si(t) {
      return Ii(Rn(t))
    }

    function Oi(t) {
      return En(t), Ii(Rn(Uint8Array.from(t).reverse()))
    }

    function Bi(t, e) {
      return jn(t.toString(16).padStart(2 * e, "0"))
    }

    function Wi(t, e) {
      return Bi(t, e).reverse()
    }

    function Mi(t, e, r) {
      let n;
      if ("string" == typeof e) try {
        n = jn(e)
      } catch (e) {
        throw Error(t + " must be hex string or Uint8Array, cause: " + e)
      } else {
        if (!An(e)) throw Error(t + " must be hex string or Uint8Array");
        n = Uint8Array.from(e)
      }
      const i = n.length;
      if ("number" == typeof r && i !== r) throw Error(t + " of length " + r + " expected, got " + i);
      return n
    }

    function Ci(t) {
      return Uint8Array.from(t)
    }
    const Ri = t => "bigint" == typeof t && t >= Ti;

    function Ni(t, e, r, n) {
      if (! function(t, e, r) {
          return Ri(t) && Ri(e) && Ri(r) && t >= e && r > t
        }(e, r, n)) throw Error("expected valid " + t + ": " + r + " <= n < " + n + ", got " + e)
    }

    function ji(t) {
      let e;
      for (e = 0; t > Ti; t >>= Ei, e += 1);
      return e
    }
    const _i = t => (Ei << BigInt(t)) - Ei;

    function Di(t, e, r = {}) {
      if (!t || "object" != typeof t) throw Error("expected valid options object");

      function n(e, r, n) {
        const i = t[e];
        if (n && void 0 === i) return;
        const o = typeof i;
        if (o !== r || null === i) throw Error(`param "${e}" is invalid: expected ${r}, got ${o}`)
      }
      Object.entries(e).forEach(([t, e]) => n(t, e, !1)), Object.entries(r).forEach(([t, e]) => n(t, e, !0))
    }
    const Ui = () => {
      throw Error("not implemented")
    };

    function Li(t) {
      const e = new WeakMap;
      return (r, ...n) => {
        const i = e.get(r);
        if (void 0 !== i) return i;
        const o = t(r, ...n);
        return e.set(r, o), o
      }
    }
    const Fi = BigInt(0),
      $i = BigInt(1),
      zi = BigInt(2),
      Hi = BigInt(3),
      Gi = BigInt(4),
      Ki = BigInt(5),
      Vi = BigInt(7),
      Zi = BigInt(8),
      qi = BigInt(9),
      Ji = BigInt(16);

    function Yi(t, e) {
      const r = t % e;
      return Fi > r ? e + r : r
    }

    function Qi(t, e, r) {
      let n = t;
      for (; e-- > Fi;) n *= n, n %= r;
      return n
    }

    function Xi(t, e) {
      if (t === Fi) throw Error("invert: expected non-zero number");
      if (Fi >= e) throw Error("invert: expected positive modulus, got " + e);
      let r = Yi(t, e),
        n = e,
        i = Fi,
        o = $i,
        s = $i,
        a = Fi;
      for (; r !== Fi;) {
        const t = n / r,
          e = n % r,
          u = i - s * t,
          c = o - a * t;
        n = r, r = e, i = s, o = a, s = u, a = c
      }
      if (n !== $i) throw Error("invert: does not exist");
      return Yi(i, e)
    }

    function to(t, e, r) {
      if (!t.eql(t.sqr(e), r)) throw Error("Cannot find square root")
    }

    function eo(t, e) {
      const r = (t.ORDER + $i) / Gi,
        n = t.pow(e, r);
      return to(t, n, e), n
    }

    function ro(t, e) {
      const r = (t.ORDER - Ki) / Zi,
        n = t.mul(e, zi),
        i = t.pow(n, r),
        o = t.mul(e, i),
        s = t.mul(t.mul(o, zi), i),
        a = t.mul(o, t.sub(s, t.ONE));
      return to(t, a, e), a
    }

    function no(t) {
      if (Hi > t) throw Error("sqrt is not defined for small field");
      let e = t - $i,
        r = 0;
      for (; e % zi === Fi;) e /= zi, r++;
      let n = zi;
      const i = co(t);
      for (; 1 === ao(i, n);)
        if (n++ > 1e3) throw Error("Cannot find square root: probably non-prime P");
      if (1 === r) return eo;
      let o = i.pow(n, e);
      const s = (e + $i) / zi;
      return function(t, n) {
        if (t.is0(n)) return n;
        if (1 !== ao(t, n)) throw Error("Cannot find square root");
        let i = r,
          a = t.mul(t.ONE, o),
          u = t.pow(n, e),
          c = t.pow(n, s);
        for (; !t.eql(u, t.ONE);) {
          if (t.is0(u)) return t.ZERO;
          let e = 1,
            r = t.sqr(u);
          for (; !t.eql(r, t.ONE);)
            if (e++, r = t.sqr(r), e === i) throw Error("Cannot find square root");
          const n = $i << BigInt(i - e - 1),
            o = t.pow(a, n);
          i = e, a = t.sqr(o), u = t.mul(u, a), c = t.mul(c, o)
        }
        return c
      }
    }
    const io = (t, e) => (Yi(t, e) & $i) === $i,
      oo = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

    function so(t, e, r = !1) {
      const n = Array(e.length).fill(r ? t.ZERO : void 0),
        i = e.reduce((e, r, i) => t.is0(r) ? e : (n[i] = e, t.mul(e, r)), t.ONE),
        o = t.inv(i);
      return e.reduceRight((e, r, i) => t.is0(r) ? e : (n[i] = t.mul(e, n[i]), t.mul(e, r)), o), n
    }

    function ao(t, e) {
      const r = (t.ORDER - $i) / zi,
        n = t.pow(e, r),
        i = t.eql(n, t.ONE),
        o = t.eql(n, t.ZERO),
        s = t.eql(n, t.neg(t.ONE));
      if (!i && !o && !s) throw Error("invalid Legendre symbol result");
      return i ? 1 : o ? 0 : -1
    }

    function uo(t, e) {
      void 0 !== e && Tn(e);
      const r = void 0 !== e ? e : t.toString(2).length;
      return {
        nBitLength: r,
        nByteLength: Math.ceil(r / 8)
      }
    }

    function co(t, e, r = !1, n = {}) {
      if (Fi >= t) throw Error("invalid field: expected ORDER > 0, got " + t);
      let i, o, s, a = !1;
      if ("object" == typeof e && null != e) {
        if (n.sqrt || r) throw Error("cannot specify opts in two arguments");
        const t = e;
        t.BITS && (i = t.BITS), t.sqrt && (o = t.sqrt), "boolean" == typeof t.isLE && (r = t.isLE), "boolean" == typeof t.modFromBytes && (a = t.modFromBytes), s = t.allowedLengths
      } else "number" == typeof e && (i = e), n.sqrt && (o = n.sqrt);
      const {
        nBitLength: u,
        nByteLength: c
      } = uo(t, i);
      if (c > 2048) throw Error("invalid field: expected ORDER of <= 2048 bytes");
      let f;
      const l = Object.freeze({
        ORDER: t,
        isLE: r,
        BITS: u,
        BYTES: c,
        MASK: _i(u),
        ZERO: Fi,
        ONE: $i,
        allowedLengths: s,
        create: e => Yi(e, t),
        isValid: e => {
          if ("bigint" != typeof e) throw Error("invalid field element: expected bigint, got " + typeof e);
          return e >= Fi && t > e
        },
        is0: t => t === Fi,
        isValidNot0: t => !l.is0(t) && l.isValid(t),
        isOdd: t => (t & $i) === $i,
        neg: e => Yi(-e, t),
        eql: (t, e) => t === e,
        sqr: e => Yi(e * e, t),
        add: (e, r) => Yi(e + r, t),
        sub: (e, r) => Yi(e - r, t),
        mul: (e, r) => Yi(e * r, t),
        pow: (t, e) => function(t, e, r) {
          if (Fi > r) throw Error("invalid exponent, negatives unsupported");
          if (r === Fi) return t.ONE;
          if (r === $i) return e;
          let n = t.ONE,
            i = e;
          for (; r > Fi;) r & $i && (n = t.mul(n, i)), i = t.sqr(i), r >>= $i;
          return n
        }(l, t, e),
        div: (e, r) => Yi(e * Xi(r, t), t),
        sqrN: t => t * t,
        addN: (t, e) => t + e,
        subN: (t, e) => t - e,
        mulN: (t, e) => t * e,
        inv: e => Xi(e, t),
        sqrt: o || (e => (f || (f = function(t) {
          return t % Gi === Hi ? eo : t % Zi === Ki ? ro : t % Ji === qi ? function(t) {
            const e = co(t),
              r = no(t),
              n = r(e, e.neg(e.ONE)),
              i = r(e, n),
              o = r(e, e.neg(n)),
              s = (t + Vi) / Ji;
            return (t, e) => {
              let r = t.pow(e, s),
                a = t.mul(r, n);
              const u = t.mul(r, i),
                c = t.mul(r, o),
                f = t.eql(t.sqr(a), e),
                l = t.eql(t.sqr(u), e);
              r = t.cmov(r, a, f), a = t.cmov(c, u, l);
              const h = t.eql(t.sqr(a), e),
                d = t.cmov(r, a, h);
              return to(t, d, e), d
            }
          }(t) : no(t)
        }(t)), f(l, e))),
        toBytes: t => r ? Wi(t, c) : Bi(t, c),
        fromBytes: (e, n = !0) => {
          if (s) {
            if (!s.includes(e.length) || e.length > c) throw Error("Field.fromBytes: expected " + s + " bytes, got " + e.length);
            const t = new Uint8Array(c);
            t.set(e, r ? 0 : t.length - e.length), e = t
          }
          if (e.length !== c) throw Error("Field.fromBytes: expected " + c + " bytes, got " + e.length);
          let i = r ? Oi(e) : Si(e);
          if (a && (i = Yi(i, t)), !n && !l.isValid(i)) throw Error("invalid field element: outside of range 0..ORDER");
          return i
        },
        invertBatch: t => so(l, t),
        cmov: (t, e, r) => r ? e : t
      });
      return Object.freeze(l)
    }

    function fo(t) {
      if ("bigint" != typeof t) throw Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8)
    }

    function lo(t) {
      const e = fo(t);
      return e + Math.ceil(e / 2)
    }
    const ho = BigInt(0),
      po = BigInt(1);

    function bo(t, e) {
      const r = e.negate();
      return t ? r : e
    }

    function mo(t, e) {
      const r = so(t.Fp, e.map(t => t.Z));
      return e.map((e, n) => t.fromAffine(e.toAffine(r[n])))
    }

    function yo(t, e) {
      if (!Number.isSafeInteger(t) || 0 >= t || t > e) throw Error("invalid window size, expected [1.." + e + "], got W=" + t)
    }

    function go(t, e) {
      yo(t, e);
      const r = 2 ** t;
      return {
        windows: Math.ceil(e / t) + 1,
        windowSize: 2 ** (t - 1),
        mask: _i(t),
        maxNumber: r,
        shiftBy: BigInt(t)
      }
    }

    function vo(t, e, r) {
      const {
        windowSize: n,
        mask: i,
        maxNumber: o,
        shiftBy: s
      } = r;
      let a = +(t & i),
        u = t >> s;
      a > n && (a -= o, u += po);
      const c = e * n;
      return {
        nextN: u,
        offset: c + Math.abs(a) - 1,
        isZero: 0 === a,
        isNeg: 0 > a,
        isNegF: e % 2 != 0,
        offsetF: c
      }
    }
    const wo = new WeakMap,
      Ao = new WeakMap;

    function To(t) {
      return Ao.get(t) || 1
    }

    function Eo(t) {
      if (t !== ho) throw Error("invalid wNAF")
    }
    class Po {
      constructor(t, e) {
        this.BASE = t.BASE, this.ZERO = t.ZERO, this.Fn = t.Fn, this.bits = e
      }
      oi(t, e, r = this.ZERO) {
        let n = t;
        for (; e > ho;) e & po && (r = r.add(n)), n = n.double(), e >>= po;
        return r
      }
      precomputeWindow(t, e) {
        const {
          windows: r,
          windowSize: n
        } = go(e, this.bits), i = [];
        let o = t,
          s = o;
        for (let t = 0; r > t; t++) {
          s = o, i.push(s);
          for (let t = 1; n > t; t++) s = s.add(o), i.push(s);
          o = s.double()
        }
        return i
      }
      wNAF(t, e, r) {
        if (!this.Fn.isValid(r)) throw Error("invalid scalar");
        let n = this.ZERO,
          i = this.BASE;
        const o = go(t, this.bits);
        for (let t = 0; t < o.windows; t++) {
          const {
            nextN: s,
            offset: a,
            isZero: u,
            isNeg: c,
            isNegF: f,
            offsetF: l
          } = vo(r, t, o);
          r = s, u ? i = i.add(bo(f, e[l])) : n = n.add(bo(c, e[a]))
        }
        return Eo(r), {
          p: n,
          f: i
        }
      }
      wNAFUnsafe(t, e, r, n = this.ZERO) {
        const i = go(t, this.bits);
        for (let t = 0; t < i.windows && r !== ho; t++) {
          const {
            nextN: o,
            offset: s,
            isZero: a,
            isNeg: u
          } = vo(r, t, i);
          if (r = o, !a) {
            const t = e[s];
            n = n.add(u ? t.negate() : t)
          }
        }
        return Eo(r), n
      }
      getPrecomputes(t, e, r) {
        let n = wo.get(e);
        return n || (n = this.precomputeWindow(e, t), 1 !== t && ("function" == typeof r && (n = r(n)), wo.set(e, n))), n
      }
      cached(t, e, r) {
        const n = To(t);
        return this.wNAF(n, this.getPrecomputes(n, t, r), e)
      }
      unsafe(t, e, r, n) {
        const i = To(t);
        return 1 === i ? this.oi(t, e, n) : this.wNAFUnsafe(i, this.getPrecomputes(i, t, r), e, n)
      }
      createCache(t, e) {
        yo(e, this.bits), Ao.set(t, e), wo.delete(t)
      }
      hasCache(t) {
        return 1 !== To(t)
      }
    }

    function ko(t, e, r, n) {
      (function(t, e) {
        if (!Array.isArray(t)) throw Error("array expected");
        t.forEach((t, r) => {
          if (!(t instanceof e)) throw Error("invalid point at index " + r)
        })
      })(r, t),
      function(t, e) {
        if (!Array.isArray(t)) throw Error("array of scalars expected");
        t.forEach((t, r) => {
          if (!e.isValid(t)) throw Error("invalid scalar at index " + r)
        })
      }(n, e);
      const i = r.length,
        o = n.length;
      if (i !== o) throw Error("arrays of points and scalars must have equal length");
      const s = t.ZERO,
        a = ji(BigInt(i));
      let u = 1;
      a > 12 ? u = a - 3 : a > 4 ? u = a - 2 : a > 0 && (u = 2);
      const c = _i(u),
        f = Array(+c + 1).fill(s);
      let l = s;
      for (let t = Math.floor((e.BITS - 1) / u) * u; t >= 0; t -= u) {
        f.fill(s);
        for (let e = 0; o > e; e++) {
          const i = +(n[e] >> BigInt(t) & c);
          f[i] = f[i].add(r[e])
        }
        let e = s;
        for (let t = f.length - 1, r = s; t > 0; t--) r = r.add(f[t]), e = e.add(r);
        if (l = l.add(e), 0 !== t)
          for (let t = 0; u > t; t++) l = l.double()
      }
      return l
    }

    function xo(t, e, r) {
      if (e) {
        if (e.ORDER !== t) throw Error("Field.ORDER must match order: Fp == p, Fn == n");
        return function(t) {
          Di(t, oo.reduce((t, e) => (t[e] = "function", t), {
            ORDER: "bigint",
            MASK: "bigint",
            BYTES: "number",
            BITS: "number"
          }))
        }(e), e
      }
      return co(t, {
        isLE: r
      })
    }

    function Io(t, e, r = {}, n) {
      if (void 0 === n && (n = "edwards" === t), !e || "object" != typeof e) throw Error(`expected valid ${t} CURVE object`);
      for (const t of ["p", "n", "h"]) {
        const r = e[t];
        if ("bigint" != typeof r || ho >= r) throw Error(`CURVE.${t} must be positive bigint`)
      }
      const i = xo(e.p, r.Fp, n),
        o = xo(e.n, r.Fn, n),
        s = ["Gx", "Gy", "a", "weierstrass" === t ? "b" : "d"];
      for (const t of s)
        if (!i.isValid(e[t])) throw Error(`CURVE.${t} must be valid field element of CURVE.Fp`);
      return {
        CURVE: e = Object.freeze(Object.assign({}, e)),
        Fp: i,
        Fn: o
      }
    }
    const So = BigInt(0),
      Oo = BigInt(1),
      Bo = BigInt(2),
      Wo = BigInt(8);
    class Mo {
      constructor(t) {
        this.ep = t
      }
      static fromBytes(t) {
        Ui()
      }
      static fromHex(t) {
        Ui()
      }
      get x() {
        return this.toAffine().x
      }
      get y() {
        return this.toAffine().y
      }
      clearCofactor() {
        return this
      }
      assertValidity() {
        this.ep.assertValidity()
      }
      toAffine(t) {
        return this.ep.toAffine(t)
      }
      toHex() {
        return Rn(this.toBytes())
      }
      toString() {
        return this.toHex()
      }
      isTorsionFree() {
        return !0
      }
      isSmallOrder() {
        return !1
      }
      add(t) {
        return this.assertSame(t), this.init(this.ep.add(t.ep))
      }
      subtract(t) {
        return this.assertSame(t), this.init(this.ep.subtract(t.ep))
      }
      multiply(t) {
        return this.init(this.ep.multiply(t))
      }
      multiplyUnsafe(t) {
        return this.init(this.ep.multiplyUnsafe(t))
      }
      double() {
        return this.init(this.ep.double())
      }
      negate() {
        return this.init(this.ep.negate())
      }
      precompute(t, e) {
        return this.init(this.ep.precompute(t, e))
      }
      toRawBytes() {
        return this.toBytes()
      }
    }
    _n("HashToScalar-");
    const Co = BigInt(0),
      Ro = BigInt(1),
      No = BigInt(2),
      jo = (BigInt(3), BigInt(5)),
      _o = BigInt(8),
      Do = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),
      Uo = {
        p: Do,
        n: BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),
        h: _o,
        a: BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),
        d: BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),
        Gx: BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),
        Gy: BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")
      },
      Lo = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");

    function Fo(t, e) {
      const r = Do,
        n = Yi(e * e * e, r),
        i = function(t) {
          const e = BigInt(10),
            r = BigInt(20),
            n = BigInt(40),
            i = BigInt(80),
            o = Do,
            s = t * t % o * t % o,
            a = Qi(s, No, o) * s % o,
            u = Qi(a, Ro, o) * t % o,
            c = Qi(u, jo, o) * u % o,
            f = Qi(c, e, o) * c % o,
            l = Qi(f, r, o) * f % o,
            h = Qi(l, n, o) * l % o,
            d = Qi(h, i, o) * h % o,
            p = Qi(d, i, o) * h % o,
            b = Qi(p, e, o) * c % o;
          return {
            pow_p_5_8: Qi(b, No, o) * t % o,
            b2: s
          }
        }(t * Yi(n * n * e, r)).pow_p_5_8;
      let o = Yi(t * n * i, r);
      const s = Yi(e * o * o, r),
        a = o,
        u = Yi(o * Lo, r),
        c = s === t,
        f = s === Yi(-t, r),
        l = s === Yi(-t * Lo, r);
      return c && (o = a), (f || l) && (o = u), io(o, r) && (o = Yi(-o, r)), {
        isValid: c || f,
        value: o
      }
    }
    const $o = co(Uo.p, {
        isLE: !0
      }),
      zo = co(Uo.n, {
        isLE: !0
      }),
      Ho = {
        ...Uo,
        Fp: $o,
        hash: Ai,
        adjustScalarBytes: function(t) {
          return t[0] &= 248, t[31] &= 127, t[31] |= 64, t
        },
        uvRatio: Fo
      },
      Go = function(t) {
        const {
          CURVE: e,
          curveOpts: r,
          hash: n,
          eddsaOpts: i
        } = function(t) {
          const e = {
            a: t.a,
            d: t.d,
            p: t.Fp.ORDER,
            n: t.n,
            h: t.h,
            Gx: t.Gx,
            Gy: t.Gy
          };
          return {
            CURVE: e,
            curveOpts: {
              Fp: t.Fp,
              Fn: co(e.n, t.nBitLength, !0),
              uvRatio: t.uvRatio
            },
            hash: t.hash,
            eddsaOpts: {
              randomBytes: t.randomBytes,
              adjustScalarBytes: t.adjustScalarBytes,
              domain: t.domain,
              prehash: t.prehash,
              mapToCurve: t.mapToCurve
            }
          }
        }(t), o = function(t, e = {}) {
          const r = Io("edwards", t, e, e.FpFnLE),
            {
              Fp: n,
              Fn: i
            } = r;
          let o = r.CURVE;
          const {
            h: s
          } = o;
          Di(e, {}, {
            uvRatio: "function"
          });
          const a = Bo << BigInt(8 * i.BYTES) - Oo,
            u = t => n.create(t),
            c = e.uvRatio || ((t, e) => {
              try {
                return {
                  isValid: !0,
                  value: n.sqrt(n.div(t, e))
                }
              } catch {
                return {
                  isValid: !1,
                  value: So
                }
              }
            });
          if (! function(t, e, r, n) {
              const i = t.sqr(r),
                o = t.sqr(n),
                s = t.add(t.mul(e.a, i), o),
                a = t.add(t.ONE, t.mul(e.d, t.mul(i, o)));
              return t.eql(s, a)
            }(n, o, o.Gx, o.Gy)) throw Error("bad curve params: generator point");

          function f(t, e, r = !1) {
            return Ni("coordinate " + t, e, r ? Oo : So, a), e
          }

          function l(t) {
            if (!(t instanceof p)) throw Error("ExtendedPoint expected")
          }
          const h = Li((t, e) => {
              const {
                X: r,
                Y: i,
                Z: o
              } = t, s = t.is0();
              null == e && (e = s ? Wo : n.inv(o));
              const a = u(r * e),
                c = u(i * e),
                f = n.mul(o, e);
              if (s) return {
                x: So,
                y: Oo
              };
              if (f !== Oo) throw Error("invZ was invalid");
              return {
                x: a,
                y: c
              }
            }),
            d = Li(t => {
              const {
                a: e,
                d: r
              } = o;
              if (t.is0()) throw Error("bad point: ZERO");
              const {
                X: n,
                Y: i,
                Z: s,
                T: a
              } = t, c = u(n * n), f = u(i * i), l = u(s * s), h = u(l * l), d = u(c * e);
              if (u(l * u(d + f)) !== u(h + u(r * u(c * f)))) throw Error("bad point: equation left != right (1)");
              if (u(n * i) !== u(s * a)) throw Error("bad point: equation left != right (2)");
              return !0
            });
          class p {
            constructor(t, e, r, n) {
              this.X = f("x", t), this.Y = f("y", e), this.Z = f("z", r, !0), this.T = f("t", n), Object.freeze(this)
            }
            static CURVE() {
              return o
            }
            static fromAffine(t) {
              if (t instanceof p) throw Error("extended point not allowed");
              const {
                x: e,
                y: r
              } = t || {};
              return f("x", e), f("y", r), new p(e, r, Oo, u(e * r))
            }
            static fromBytes(t, e = !1) {
              const r = n.BYTES,
                {
                  a: i,
                  d: s
                } = o;
              t = Ci(ki(t, r, "point")), Pi(e, "zip215");
              const f = Ci(t),
                l = t[r - 1];
              f[r - 1] = -129 & l;
              const h = Oi(f),
                d = e ? a : n.ORDER;
              Ni("point.y", h, So, d);
              const b = u(h * h),
                m = u(b - Oo),
                y = u(s * b - i);
              let {
                isValid: g,
                value: v
              } = c(m, y);
              if (!g) throw Error("bad point: invalid y coordinate");
              const w = (v & Oo) === Oo,
                A = !!(128 & l);
              if (!e && v === So && A) throw Error("bad point: x=0 and x_0=1");
              return A !== w && (v = u(-v)), p.fromAffine({
                x: v,
                y: h
              })
            }
            static fromHex(t, e = !1) {
              return p.fromBytes(Mi("point", t), e)
            }
            get x() {
              return this.toAffine().x
            }
            get y() {
              return this.toAffine().y
            }
            precompute(t = 8, e = !0) {
              return b.createCache(this, t), e || this.multiply(Bo), this
            }
            assertValidity() {
              d(this)
            }
            equals(t) {
              l(t);
              const {
                X: e,
                Y: r,
                Z: n
              } = this, {
                X: i,
                Y: o,
                Z: s
              } = t, a = u(e * s), c = u(i * n), f = u(r * s), h = u(o * n);
              return a === c && f === h
            }
            is0() {
              return this.equals(p.ZERO)
            }
            negate() {
              return new p(u(-this.X), this.Y, this.Z, u(-this.T))
            }
            double() {
              const {
                a: t
              } = o, {
                X: e,
                Y: r,
                Z: n
              } = this, i = u(e * e), s = u(r * r), a = u(Bo * u(n * n)), c = u(t * i), f = e + r, l = u(u(f * f) - i - s), h = c + s, d = h - a, b = c - s, m = u(l * d), y = u(h * b), g = u(l * b), v = u(d * h);
              return new p(m, y, v, g)
            }
            add(t) {
              l(t);
              const {
                a: e,
                d: r
              } = o, {
                X: n,
                Y: i,
                Z: s,
                T: a
              } = this, {
                X: c,
                Y: f,
                Z: h,
                T: d
              } = t, b = u(n * c), m = u(i * f), y = u(a * r * d), g = u(s * h), v = u((n + i) * (c + f) - b - m), w = g - y, A = g + y, T = u(m - e * b), E = u(v * w), P = u(A * T), k = u(v * T), x = u(w * A);
              return new p(E, P, x, k)
            }
            subtract(t) {
              return this.add(t.negate())
            }
            multiply(t) {
              if (!i.isValidNot0(t)) throw Error("invalid scalar: expected 1 <= sc < curve.n");
              const {
                p: e,
                f: r
              } = b.cached(this, t, t => mo(p, t));
              return mo(p, [e, r])[0]
            }
            multiplyUnsafe(t, e = p.ZERO) {
              if (!i.isValid(t)) throw Error("invalid scalar: expected 0 <= sc < curve.n");
              return t === So ? p.ZERO : this.is0() || t === Oo ? this : b.unsafe(this, t, t => mo(p, t), e)
            }
            isSmallOrder() {
              return this.multiplyUnsafe(s).is0()
            }
            isTorsionFree() {
              return b.unsafe(this, o.n).is0()
            }
            toAffine(t) {
              return h(this, t)
            }
            clearCofactor() {
              return s === Oo ? this : this.multiplyUnsafe(s)
            }
            toBytes() {
              const {
                x: t,
                y: e
              } = this.toAffine(), r = n.toBytes(e);
              return r[r.length - 1] |= t & Oo ? 128 : 0, r
            }
            toHex() {
              return Rn(this.toBytes())
            }
            toString() {
              return `<Point ${this.is0()?"ZERO":this.toHex()}>`
            }
            get ex() {
              return this.X
            }
            get ey() {
              return this.Y
            }
            get ez() {
              return this.Z
            }
            get et() {
              return this.T
            }
            static normalizeZ(t) {
              return mo(p, t)
            }
            static msm(t, e) {
              return ko(p, i, t, e)
            }
            zt(t) {
              this.precompute(t)
            }
            toRawBytes() {
              return this.toBytes()
            }
          }
          p.BASE = new p(o.Gx, o.Gy, Oo, u(o.Gx * o.Gy)), p.ZERO = new p(So, Oo, Oo, So), p.Fp = n, p.Fn = i;
          const b = new Po(p, i.BITS);
          return p.BASE.precompute(8), p
        }(e, r);
        return function(t, e) {
          const r = e.Point;
          return Object.assign({}, e, {
            ExtendedPoint: r,
            CURVE: t,
            nBitLength: r.Fn.BITS,
            nByteLength: r.Fn.BYTES
          })
        }(t, function(t, e, r = {}) {
          if ("function" != typeof e) throw Error('"hash" function param is required');
          Di(r, {}, {
            adjustScalarBytes: "function",
            randomBytes: "function",
            domain: "function",
            prehash: "function",
            mapToCurve: "function"
          });
          const {
            prehash: n
          } = r, {
            BASE: i,
            Fp: o,
            Fn: s
          } = t, a = r.randomBytes || $n, u = r.adjustScalarBytes || (t => t), c = r.domain || ((t, e, r) => {
            if (Pi(r, "phflag"), e.length || r) throw Error("Contexts/pre-hash are not supported");
            return t
          });

          function f(t) {
            return s.create(Oi(t))
          }

          function l(t) {
            const {
              head: r,
              prefix: n,
              scalar: o
            } = function(t) {
              const r = m.secretKey;
              t = Mi("private key", t, r);
              const n = Mi("hashed private key", e(t), 2 * r),
                i = u(n.slice(0, r));
              return {
                head: i,
                prefix: n.slice(r, 2 * r),
                scalar: f(i)
              }
            }(t), s = i.multiply(o), a = s.toBytes();
            return {
              head: r,
              prefix: n,
              scalar: o,
              point: s,
              pointBytes: a
            }
          }

          function h(t) {
            return l(t).pointBytes
          }

          function d(t = Uint8Array.of(), ...r) {
            const i = Un(...r);
            return f(e(c(i, Mi("context", t), !!n)))
          }
          const p = {
              zip215: !0
            },
            b = o.BYTES,
            m = {
              secretKey: b,
              publicKey: b,
              signature: 2 * b,
              seed: b
            };

          function y(t = a(m.seed)) {
            return ki(t, m.seed, "seed")
          }
          const g = {
            getExtendedPublicKey: l,
            randomSecretKey: y,
            isValidSecretKey: function(t) {
              return An(t) && t.length === s.BYTES
            },
            isValidPublicKey: function(e, r) {
              try {
                return !!t.fromBytes(e, r)
              } catch {
                return !1
              }
            },
            toMontgomery(e) {
              const {
                y: r
              } = t.fromBytes(e), n = m.publicKey, i = 32 === n;
              if (!i && 57 !== n) throw Error("only defined for 25519 and 448");
              const s = i ? o.div(Oo + r, Oo - r) : o.div(r - Oo, r + Oo);
              return o.toBytes(s)
            },
            toMontgomerySecret(t) {
              const r = m.secretKey;
              ki(t, r);
              const n = e(t.subarray(0, r));
              return u(n).subarray(0, r)
            },
            randomPrivateKey: y,
            precompute: (e = 8, r = t.BASE) => r.precompute(e, !1)
          };
          return Object.freeze({
            keygen: function(t) {
              const e = g.randomSecretKey(t);
              return {
                secretKey: e,
                publicKey: h(e)
              }
            },
            getPublicKey: h,
            sign: function(t, e, r = {}) {
              t = Mi("message", t), n && (t = n(t));
              const {
                prefix: o,
                scalar: a,
                pointBytes: u
              } = l(e), c = d(r.context, o, t), f = i.multiply(c).toBytes(), h = d(r.context, f, u, t), p = s.create(c + h * a);
              if (!s.isValid(p)) throw Error("sign failed: invalid s");
              return ki(Un(f, s.toBytes(p)), m.signature, "result")
            },
            verify: function(e, r, o, s = p) {
              const {
                context: a,
                zip215: u
              } = s, c = m.signature;
              e = Mi("signature", e, c), r = Mi("message", r), o = Mi("publicKey", o, m.publicKey), void 0 !== u && Pi(u, "zip215"), n && (r = n(r));
              const f = c / 2,
                l = e.subarray(0, f),
                h = Oi(e.subarray(f, c));
              let b, y, g;
              try {
                b = t.fromBytes(o, u), y = t.fromBytes(l, u), g = i.multiplyUnsafe(h)
              } catch {
                return !1
              }
              if (!u && b.isSmallOrder()) return !1;
              const v = d(a, y.toBytes(), b.toBytes(), r);
              return y.add(b.multiplyUnsafe(v)).subtract(g).clearCofactor().is0()
            },
            utils: g,
            Point: t,
            lengths: m
          })
        }(o, n, i))
      }(Ho),
      Ko = Lo,
      Vo = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),
      Zo = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),
      qo = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),
      Jo = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),
      Yo = t => Fo(Ro, t),
      Qo = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
      Xo = t => Go.Point.Fp.create(Oi(t) & Qo);

    function ts(t) {
      const {
        d: e
      } = Uo, r = Do, n = t => $o.create(t), i = n(Ko * t * t), o = n((i + Ro) * qo);
      let s = BigInt(-1);
      const a = n((s - e * i) * n(i + e));
      let {
        isValid: u,
        value: c
      } = Fo(o, a), f = n(c * t);
      io(f, r) || (f = n(-f)), u || (c = f), u || (s = i);
      const l = n(s * (i - Ro) * Jo - a),
        h = c * c,
        d = n((c + c) * a),
        p = n(l * Vo),
        b = n(Ro - h),
        m = n(Ro + h);
      return new Go.Point(n(d * m), n(b * p), n(p * m), n(d * b))
    }
    class es extends Mo {
      constructor(t) {
        super(t)
      }
      static fromAffine(t) {
        return new es(Go.Point.fromAffine(t))
      }
      assertSame(t) {
        if (!(t instanceof es)) throw Error("RistrettoPoint expected")
      }
      init(t) {
        return new es(t)
      }
      static hashToCurve(t) {
        return function(t) {
          En(t, 64);
          const e = ts(Xo(t.subarray(0, 32))),
            r = ts(Xo(t.subarray(32, 64)));
          return new es(e.add(r))
        }(Mi("ristrettoHash", t, 64))
      }
      static fromBytes(t) {
        En(t, 32);
        const {
          a: e,
          d: r
        } = Uo, n = Do, i = t => $o.create(t), o = Xo(t);
        if (! function(t, e) {
            if (t.length !== e.length) return !1;
            let r = 0;
            for (let n = 0; n < t.length; n++) r |= t[n] ^ e[n];
            return 0 === r
          }($o.toBytes(o), t) || io(o, n)) throw Error("invalid ristretto255 encoding 1");
        const s = i(o * o),
          a = i(Ro + e * s),
          u = i(Ro - e * s),
          c = i(a * a),
          f = i(u * u),
          l = i(e * r * c - f),
          {
            isValid: h,
            value: d
          } = Yo(i(l * f)),
          p = i(d * u),
          b = i(d * p * l);
        let m = i((o + o) * p);
        io(m, n) && (m = i(-m));
        const y = i(a * b),
          g = i(m * y);
        if (!h || io(g, n) || y === Co) throw Error("invalid ristretto255 encoding 2");
        return new es(new Go.Point(m, y, Ro, g))
      }
      static fromHex(t) {
        return es.fromBytes(Mi("ristrettoHex", t, 32))
      }
      static msm(t, e) {
        return ko(es, Go.Point.Fn, t, e)
      }
      toBytes() {
        let {
          X: t,
          Y: e,
          Z: r,
          T: n
        } = this.ep;
        const i = Do,
          o = t => $o.create(t),
          s = o(o(r + e) * o(r - e)),
          a = o(t * e),
          u = o(a * a),
          {
            value: c
          } = Yo(o(s * u)),
          f = o(c * s),
          l = o(c * a),
          h = o(f * l * n);
        let d;
        if (io(n * h, i)) {
          let r = o(e * Ko),
            n = o(t * Ko);
          t = r, e = n, d = o(f * Zo)
        } else d = l;
        io(t * h, i) && (e = o(-e));
        let p = o((r - e) * d);
        return io(p, i) && (p = o(-p)), $o.toBytes(p)
      }
      equals(t) {
        this.assertSame(t);
        const {
          X: e,
          Y: r
        } = this.ep, {
          X: n,
          Y: i
        } = t.ep, o = t => $o.create(t), s = o(e * i) === o(r * n), a = o(r * i) === o(e * n);
        return s || a
      }
      is0() {
        return this.equals(es.ZERO)
      }
    }
    es.BASE = new es(Go.Point.BASE), es.ZERO = new es(Go.Point.ZERO), es.Fp = $o, es.Fn = zo;
    var rs = i(39404),
      ns = i.n(rs),
      is = i(16763),
      os = i.n(is);
    const ss = wi;
    var as = i(92755),
      us = i(601),
      cs = 1,
      fs = 2,
      ls = 3,
      hs = 4,
      ds = 5,
      ps = 6,
      bs = 7,
      ms = 8,
      ys = 9,
      gs = 10,
      vs = -32700,
      ws = -32603,
      As = -32602,
      Ts = -32601,
      Es = -32600,
      Ps = -32016,
      ks = -32015,
      xs = -32014,
      Is = -32013,
      Ss = -32012,
      Os = -32011,
      Bs = -32010,
      Ws = -32009,
      Ms = -32008,
      Cs = -32007,
      Rs = -32006,
      Ns = -32005,
      js = -32004,
      _s = -32003,
      Ds = -32002,
      Us = -32001,
      Ls = 28e5,
      Fs = 2800001,
      $s = 2800002,
      zs = 2800003,
      Hs = 2800004,
      Gs = 2800005,
      Ks = 2800006,
      Vs = 2800007,
      Zs = 2800008,
      qs = 2800009,
      Js = 2800010,
      Ys = 2800011,
      Qs = 323e4,
      Xs = 32300001,
      ta = 3230002,
      ea = 3230003,
      ra = 3230004,
      na = 361e4,
      ia = 3610001,
      oa = 3610002,
      sa = 3610003,
      aa = 3610004,
      ua = 3610005,
      ca = 3610006,
      fa = 3610007,
      la = 3611e3,
      ha = 3704e3,
      da = 3704001,
      pa = 3704002,
      ba = 3704003,
      ma = 3704004,
      ya = 4128e3,
      ga = 4128001,
      va = 4128002,
      wa = 4615e3,
      Aa = 4615001,
      Ta = 4615002,
      Ea = 4615003,
      Pa = 4615004,
      ka = 4615005,
      xa = 4615006,
      Ia = 4615007,
      Sa = 4615008,
      Oa = 4615009,
      Ba = 4615010,
      Wa = 4615011,
      Ma = 4615012,
      Ca = 4615013,
      Ra = 4615014,
      Na = 4615015,
      ja = 4615016,
      _a = 4615017,
      Da = 4615018,
      Ua = 4615019,
      La = 4615020,
      Fa = 4615021,
      $a = 4615022,
      za = 4615023,
      Ha = 4615024,
      Ga = 4615025,
      Ka = 4615026,
      Va = 4615027,
      Za = 4615028,
      qa = 4615029,
      Ja = 4615030,
      Ya = 4615031,
      Qa = 4615032,
      Xa = 4615033,
      tu = 4615034,
      eu = 4615035,
      ru = 4615036,
      nu = 4615037,
      iu = 4615038,
      ou = 4615039,
      su = 4615040,
      au = 4615041,
      uu = 4615042,
      cu = 4615043,
      fu = 4615044,
      lu = 4615045,
      hu = 4615046,
      du = 4615047,
      pu = 4615048,
      bu = 4615049,
      mu = 4615050,
      yu = 4615051,
      gu = 4615052,
      vu = 4615053,
      wu = 4615054,
      Au = 5508e3,
      Tu = 5508001,
      Eu = 5508002,
      Pu = 5508003,
      ku = 5508004,
      xu = 5508005,
      Iu = 5508006,
      Su = 5508007,
      Ou = 5508008,
      Bu = 5508009,
      Wu = 5508010,
      Mu = 5508011,
      Cu = 5663e3,
      Ru = 5663001,
      Nu = 5663002,
      ju = 5663003,
      _u = 5663004,
      Du = 5663005,
      Uu = 5663006,
      Lu = 5663007,
      Fu = 5663008,
      $u = 5663009,
      zu = 5663010,
      Hu = 5663011,
      Gu = 5663012,
      Ku = 5663013,
      Vu = 5663014,
      Zu = 5663015,
      qu = 5663016,
      Ju = 5663017,
      Yu = 5663018,
      Qu = 5663019,
      Xu = 5663020,
      tc = 705e4,
      ec = 7050001,
      rc = 7050002,
      nc = 7050003,
      ic = 7050004,
      oc = 7050005,
      sc = 7050006,
      ac = 7050007,
      uc = 7050008,
      cc = 7050009,
      fc = 7050010,
      lc = 7050011,
      hc = 7050012,
      dc = 7050013,
      pc = 7050014,
      bc = 7050015,
      mc = 7050016,
      yc = 7050017,
      gc = 7050018,
      vc = 7050019,
      wc = 7050020,
      Ac = 7050021,
      Tc = 7050022,
      Ec = 7050023,
      Pc = 7050024,
      kc = 7050025,
      xc = 7050026,
      Ic = 7050027,
      Sc = 7050028,
      Oc = 7050029,
      Bc = 7050030,
      Wc = 7050031,
      Mc = 7050032,
      Cc = 7050033,
      Rc = 7050034,
      Nc = 7050035,
      jc = 7050036,
      _c = 8078e3,
      Dc = 8078001,
      Uc = 8078002,
      Lc = 8078003,
      Fc = 8078004,
      $c = 8078005,
      zc = 8078006,
      Hc = 8078007,
      Gc = 8078008,
      Kc = 8078009,
      Vc = 8078010,
      Zc = 8078011,
      qc = 8078012,
      Jc = 8078013,
      Yc = 8078014,
      Qc = 8078015,
      Xc = 8078016,
      tf = 8078017,
      ef = 8078018,
      rf = 8078019,
      nf = 8078020,
      of = 8078021,
      sf = 8078022,
      af = 81e5,
      uf = 8100001,
      cf = 8100002,
      ff = 8100003,
      lf = 819e4,
      hf = 8190001,
      df = 8190002,
      pf = 8190003,
      bf = 8190004,
      mf = 99e5,
      yf = 9900001,
      gf = 9900002,
      vf = 9900003,
      wf = 9900004,
      Af = {
        [Qs]: "Account not found at address: $address",
        [ra]: "Not all accounts were decoded. Encoded accounts found at addresses: $addresses.",
        [ea]: "Expected decoded account at address: $address",
        [ta]: "Failed to decode account data at address: $address",
        [Xs]: "Accounts not found at addresses: $addresses",
        [qs]: "Unable to find a viable program address bump seed.",
        [$s]: "$putativeAddress is not a base58-encoded address.",
        [Ls]: "Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.",
        [zs]: "The `CryptoKey` must be an `Ed25519` public key.",
        [Ys]: "$putativeOffCurveAddress is not a base58-encoded off-curve address.",
        [Zs]: "Invalid seeds; point must fall off the Ed25519 curve.",
        [Hs]: "Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].",
        [Ks]: "A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.",
        [Vs]: "The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.",
        [Gs]: "Expected program derived address bump to be in the range [0, 255], got: $bump.",
        [Js]: "Program address cannot end with PDA marker.",
        [Fs]: "Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.",
        [hs]: "Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.",
        [cs]: "The network has progressed past the last block for which this transaction could have been committed.",
        [_c]: "Codec [$codecDescription] cannot decode empty byte arrays.",
        [sf]: "Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.",
        [nf]: "Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].",
        [$c]: "Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].",
        [zc]: "Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].",
        [Fc]: "Encoder and decoder must either both be fixed-size or variable-size.",
        [Gc]: "Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.",
        [Uc]: "Expected a fixed-size codec, got a variable-size one.",
        [Jc]: "Codec [$codecDescription] expected a positive byte length, got $bytesLength.",
        [Lc]: "Expected a variable-size codec, got a fixed-size one.",
        [rf]: "Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].",
        [Dc]: "Codec [$codecDescription] expected $expected bytes, got $bytesLength.",
        [ef]: "Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].",
        [Kc]: "Invalid discriminated union variant. Expected one of [$variants], got $value.",
        [Vc]: "Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.",
        [Qc]: "Invalid literal union variant. Expected one of [$variants], got $value.",
        [Hc]: "Expected [$codecDescription] to have $expected items, got $actual.",
        [qc]: "Invalid value $value for base $base with alphabet $alphabet.",
        [Xc]: "Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.",
        [Zc]: "Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.",
        [Yc]: "Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.",
        [of]: "Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].",
        [tf]: "Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.",
        [la]: "No random values implementation could be found.",
        [Oa]: "instruction requires an uninitialized account",
        [za]: "instruction tries to borrow reference for an account which is already borrowed",
        [Ha]: "instruction left account with an outstanding borrowed reference",
        [Fa]: "program other than the account's owner changed the size of the account data",
        [ka]: "account data too small for instruction",
        [$a]: "instruction expected an executable account",
        [hu]: "An account does not have enough lamports to be rent-exempt",
        [pu]: "Program arithmetic overflowed",
        [lu]: "Failed to serialize or deserialize account data: $encodedData",
        [wu]: "Builtin programs must consume compute units",
        [Qa]: "Cross-program invocation call depth too deep",
        [iu]: "Computational budget exceeded",
        [Ka]: "custom program error: #$code",
        [_a]: "instruction contains duplicate accounts",
        [Ga]: "instruction modifications of multiply-passed account differ",
        [Ja]: "executable accounts must be rent exempt",
        [Za]: "instruction changed executable accounts data",
        [qa]: "instruction changed the balance of an executable account",
        [Da]: "instruction changed executable bit of an account",
        [Ra]: "instruction modified data of an account it does not own",
        [Ca]: "instruction spent from the balance of an account it does not own",
        [Aa]: "generic instruction error",
        [mu]: "Provided owner is not allowed",
        [cu]: "Account is immutable",
        [fu]: "Incorrect authority provided",
        [Ia]: "incorrect program id for instruction",
        [xa]: "insufficient funds for instruction",
        [Pa]: "invalid account data for instruction",
        [du]: "Invalid account owner",
        [Ta]: "invalid program argument",
        [Va]: "program returned invalid error code",
        [Ea]: "invalid instruction data",
        [nu]: "Failed to reallocate account data",
        [ru]: "Provided seeds do not result in a valid address",
        [yu]: "Accounts data allocations exceeded the maximum allowed per transaction",
        [gu]: "Max accounts exceeded",
        [vu]: "Max instruction trace length exceeded",
        [eu]: "Length of the seed is too long for address generation",
        [Xa]: "An account required by the instruction is missing",
        [Sa]: "missing required signature for instruction",
        [Ma]: "instruction illegally modified the program id of an account",
        [La]: "insufficient account keys for instruction",
        [ou]: "Cross-program invocation with unauthorized signer or writable account",
        [su]: "Failed to create program execution environment",
        [uu]: "Program failed to compile",
        [au]: "Program failed to complete",
        [ja]: "instruction modified data of a read-only account",
        [Na]: "instruction changed the balance of a read-only account",
        [tu]: "Cross-program invocation reentrancy not allowed for this instruction",
        [Ua]: "instruction modified rent epoch of an account",
        [Wa]: "sum of account balances before and after instruction do not match",
        [Ba]: "instruction requires an initialized account",
        [wa]: "",
        [Ya]: "Unsupported program id",
        [bu]: "Unsupported sysvar",
        [ya]: "The instruction does not have any accounts.",
        [ga]: "The instruction does not have any data.",
        [va]: "Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.",
        [ds]: "Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.",
        [fs]: "The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`",
        [gf]: "Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [wf]: "Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.",
        [yf]: "Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [mf]: "Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [vf]: "Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant",
        [ws]: "JSON-RPC error: Internal JSON-RPC error ($__serverMessage)",
        [As]: "JSON-RPC error: Invalid method parameter(s) ($__serverMessage)",
        [Es]: "JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)",
        [Ts]: "JSON-RPC error: The method does not exist / is not available ($__serverMessage)",
        [vs]: "JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)",
        [Ss]: "$__serverMessage",
        [Us]: "$__serverMessage",
        [js]: "$__serverMessage",
        [xs]: "$__serverMessage",
        [Bs]: "$__serverMessage",
        [Ws]: "$__serverMessage",
        [Ps]: "Minimum context slot has not been reached",
        [Ns]: "Node is unhealthy; behind by $numSlotsBehind slots",
        [Ms]: "No snapshot",
        [Ds]: "Transaction simulation failed",
        [Cs]: "$__serverMessage",
        [Os]: "Transaction history is not available from this node",
        [Rs]: "$__serverMessage",
        [Is]: "Transaction signature length mismatch",
        [_s]: "Transaction signature verification failure",
        [ks]: "$__serverMessage",
        [ha]: "Key pair bytes must be of length 64, got $byteLength.",
        [da]: "Expected private key bytes with length 32. Actual length: $actualLength.",
        [pa]: "Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.",
        [ma]: "The provided private key does not match the provided public key.",
        [ba]: "Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.",
        [ps]: "Lamports value must be in the range [0, 2e64-1]",
        [bs]: "`$value` cannot be parsed as a `BigInt`",
        [gs]: "$message",
        [ms]: "`$value` cannot be parsed as a `Number`",
        [ls]: "No nonce account could be found at address `$nonceAccountAddress`",
        [lf]: "The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.",
        [df]: "WebSocket was closed before payload could be added to the send buffer",
        [pf]: "WebSocket connection closed",
        [bf]: "WebSocket failed to connect",
        [hf]: "Failed to obtain a subscription id from the server",
        [ff]: "Could not find an API plan for RPC method: `$method`",
        [af]: "The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.",
        [cf]: "HTTP error ($statusCode): $message",
        [uf]: "HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.",
        [Au]: "Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.",
        [Tu]: "The provided value does not implement the `KeyPairSigner` interface",
        [Pu]: "The provided value does not implement the `MessageModifyingSigner` interface",
        [ku]: "The provided value does not implement the `MessagePartialSigner` interface",
        [Eu]: "The provided value does not implement any of the `MessageSigner` interfaces",
        [Iu]: "The provided value does not implement the `TransactionModifyingSigner` interface",
        [Su]: "The provided value does not implement the `TransactionPartialSigner` interface",
        [Ou]: "The provided value does not implement the `TransactionSendingSigner` interface",
        [xu]: "The provided value does not implement any of the `TransactionSigner` interfaces",
        [Bu]: "More than one `TransactionSendingSigner` was identified.",
        [Wu]: "No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.",
        [Mu]: "Wallet account signers do not support signing multiple messages/transactions in a single operation",
        [fa]: "Cannot export a non-extractable key.",
        [ia]: "No digest implementation could be found.",
        [na]: "Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.",
        [oa]: "This runtime does not support the generation of Ed25519 key pairs.\n\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\n\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.",
        [sa]: "No signature verification implementation could be found.",
        [aa]: "No key generation implementation could be found.",
        [ua]: "No signing implementation could be found.",
        [ca]: "No key export implementation could be found.",
        [ys]: "Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given",
        [mc]: "Transaction processing left an account with an outstanding borrowed reference",
        [ec]: "Account in use",
        [rc]: "Account loaded twice",
        [nc]: "Attempt to debit an account but found no record of a prior credit.",
        [Ec]: "Transaction loads an address table account that doesn't exist",
        [ac]: "This transaction has already been processed",
        [uc]: "Blockhash not found",
        [cc]: "Loader call chain is too deep",
        [bc]: "Transactions are currently disabled due to cluster maintenance",
        [Bc]: "Transaction contains a duplicate instruction ($index) that is not allowed",
        [oc]: "Insufficient funds for fee",
        [Wc]: "Transaction results in an account ($accountIndex) with insufficient funds for rent",
        [sc]: "This account may not be used to pay transaction fees",
        [lc]: "Transaction contains an invalid account reference",
        [kc]: "Transaction loads an address table account with invalid data",
        [xc]: "Transaction address table lookup uses an invalid index",
        [Pc]: "Transaction loads an address table account with an invalid owner",
        [Cc]: "LoadedAccountsDataSizeLimit set for transaction must be greater than 0.",
        [dc]: "This program may not be used for executing instructions",
        [Ic]: "Transaction leaves an account with a lower balance than rent-exempt minimum",
        [vc]: "Transaction loads a writable account that cannot be written",
        [Mc]: "Transaction exceeded max loaded accounts data size cap",
        [fc]: "Transaction requires a fee but has no signature present",
        [ic]: "Attempt to load a program that does not exist",
        [Nc]: "Execution of the program referenced by account at index $accountIndex is temporarily restricted.",
        [Rc]: "ResanitizationNeeded",
        [pc]: "Transaction failed to sanitize accounts offsets correctly",
        [hc]: "Transaction did not pass signature verification",
        [Tc]: "Transaction locked too many accounts",
        [jc]: "Sum of account balances before and after transaction do not match",
        [tc]: "The transaction failed with the error `$errorName`",
        [gc]: "Transaction version is unsupported",
        [Ac]: "Transaction would exceed account data limit within the block",
        [Oc]: "Transaction would exceed total account data limit",
        [wc]: "Transaction would exceed max account limit within the block",
        [yc]: "Transaction would exceed max Block Cost Limit",
        [Sc]: "Transaction would exceed max Vote Cost Limit",
        [Zu]: "Attempted to sign a transaction with an address that is not a signer for it",
        [zu]: "Transaction is missing an address at index: $index.",
        [qu]: "Transaction has no expected signers therefore it cannot be encoded",
        [Xu]: "Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes",
        [Nu]: "Transaction does not have a blockhash lifetime",
        [ju]: "Transaction is not a durable nonce transaction",
        [Du]: "Contents of these address lookup tables unknown: $lookupTableAddresses",
        [Uu]: "Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved",
        [Fu]: "No fee payer set in CompiledTransaction",
        [Lu]: "Could not find program address at index $index",
        [Yu]: "Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more",
        [Qu]: "Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more",
        [Hu]: "Transaction is missing a fee payer.",
        [Gu]: "Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.",
        [Vu]: "Transaction first instruction is not advance nonce account instruction.",
        [Ku]: "Transaction with no instructions cannot be durable nonce transaction.",
        [Cu]: "This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees",
        [Ru]: "This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable",
        [Ju]: "The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.",
        [$u]: "Transaction is missing signatures for addresses: $addresses.",
        [_u]: "Transaction version must be in the range [0, 127]. `$actualVersion` given"
      },
      Tf = "i",
      Ef = "t",
      Pf = class extends Error {
        cause = this.cause;
        context;
        constructor(...[t, e]) {
          let r, n;
          if (e) {
            const {
              cause: t,
              ...i
            } = e;
            t && (n = {
              cause: t
            }), Object.keys(i).length > 0 && (r = i)
          }
          super(function(t, e = {}) {
            return function(t, e = {}) {
              const r = Af[t];
              if (0 === r.length) return "";
              let n;

              function i(t) {
                if (2 === n[Ef]) {
                  const i = r.slice(n[Tf] + 1, t);
                  o.push(i in e ? "" + e[i] : "$" + i)
                } else 1 === n[Ef] && o.push(r.slice(n[Tf], t))
              }
              const o = [];
              return r.split("").forEach((t, e) => {
                if (0 === e) return void(n = {
                  [Tf]: 0,
                  [Ef]: "\\" === r[0] ? 0 : "$" === r[0] ? 2 : 1
                });
                let o;
                switch (n[Ef]) {
                  case 0:
                    o = {
                      [Tf]: e,
                      [Ef]: 1
                    };
                    break;
                  case 1:
                    "\\" === t ? o = {
                      [Tf]: e,
                      [Ef]: 0
                    } : "$" === t && (o = {
                      [Tf]: e,
                      [Ef]: 2
                    });
                    break;
                  case 2:
                    "\\" === t ? o = {
                      [Tf]: e,
                      [Ef]: 0
                    } : "$" === t ? o = {
                      [Tf]: e,
                      [Ef]: 2
                    } : t.match(/\w/) || (o = {
                      [Tf]: e,
                      [Ef]: 1
                    })
                }
                o && (n !== o && i(e), n = o)
              }), i(), o.join("")
            }(t, e)
          }(t, r), n), this.context = {
            si: t,
            ...r
          }, this.name = "SolanaError"
        }
      };

    function kf(t) {
      return "fixedSize" in t && "number" == typeof t.fixedSize
    }
    var xf = (t => (t[t.Little = 0] = "Little", t[t.Big = 1] = "Big", t))(xf || {});

    function If(t) {
      return 1 !== t?.endian
    }
    var Sf = (t = {}) => function(t) {
        return function(t) {
          return Object.freeze({
            ...t,
            encode: e => {
              const r = new Uint8Array(function(t, e) {
                return "fixedSize" in e ? e.fixedSize : e.getSizeFromValue(t)
              }(e, t));
              return t.write(e, r, 0), r
            }
          })
        }({
          fixedSize: t.size,
          write(e, r, n) {
            t.range && function(t, e, r, n) {
              if (e > n || n > r) throw new Pf(Zc, {
                codecDescription: t,
                max: r,
                min: e,
                value: n
              })
            }(t.name, t.range[0], t.range[1], e);
            const i = new ArrayBuffer(t.size);
            return t.set(new DataView(i), e, If(t.config)), r.set(new Uint8Array(i), n), n + t.size
          }
        })
      }({
        config: t,
        name: "u64",
        range: [0n, BigInt("0xffffffffffffffff")],
        set: (t, e, r) => t.setBigUint64(0, BigInt(e), r),
        size: 8
      }),
      Of = (t = {}) => function(t, e) {
        if (kf(t) !== kf(e)) throw new Pf(Fc);
        if (kf(t) && kf(e) && t.fixedSize !== e.fixedSize) throw new Pf($c, {
          decoderFixedSize: e.fixedSize,
          encoderFixedSize: t.fixedSize
        });
        if (!kf(t) && !kf(e) && t.maxSize !== e.maxSize) throw new Pf(zc, {
          decoderMaxSize: e.maxSize,
          encoderMaxSize: t.maxSize
        });
        return {
          ...e,
          ...t,
          decode: e.decode,
          encode: t.encode,
          read: e.read,
          write: t.write
        }
      }(Sf(t), ((t = {}) => function(t) {
        return function(t) {
          return Object.freeze({
            ...t,
            decode: (e, r = 0) => t.read(e, r)[0]
          })
        }({
          fixedSize: t.size,
          read(e, r = 0) {
            (function(t, e, r = 0) {
              if (0 >= e.length - r) throw new Pf(_c, {
                codecDescription: t
              })
            })(t.name, e, r),
            function(t, e, r, n = 0) {
              const i = r.length - n;
              if (e > i) throw new Pf(Dc, {
                bytesLength: i,
                codecDescription: t,
                expected: e
              })
            }(t.name, t.size, e, r);
            const n = new DataView(function(t, e, r) {
              const n = t.byteOffset + (e ?? 0),
                i = r ?? t.byteLength;
              return t.buffer.slice(n, n + i)
            }(e, r, t.size));
            return [t.get(n, If(t.config)), r + t.size]
          }
        })
      }({
        config: t,
        get: (t, e) => t.getBigUint64(0, e),
        name: "u64",
        size: 8
      }))(t));
    class Bf extends TypeError {
      constructor(t, e) {
        let r;
        const {
          message: n,
          explanation: i,
          ...o
        } = t, {
          path: s
        } = t, a = 0 === s.length ? n : `At path: ${s.join(".")} -- ${n}`;
        super(i ?? a), null != i && (this.cause = a), Object.assign(this, o), this.name = this.constructor.name, this.failures = () => r ?? (r = [t, ...e()])
      }
    }

    function Wf(t) {
      return "object" == typeof t && null != t
    }

    function Mf(t) {
      return Wf(t) && !Array.isArray(t)
    }

    function Cf(t) {
      return "symbol" == typeof t ? t.toString() : "string" == typeof t ? JSON.stringify(t) : "" + t
    }

    function Rf(t, e, r, n) {
      if (!0 === t) return;
      !1 === t ? t = {} : "string" == typeof t && (t = {
        message: t
      });
      const {
        path: i,
        branch: o
      } = e, {
        type: s
      } = r, {
        refinement: a,
        message: u = `Expected a value of type \`${s}\`${a?` with refinement \`${a}\``:""}, but received: \`${Cf(n)}\``
      } = t;
      return {
        value: n,
        type: s,
        refinement: a,
        key: i[i.length - 1],
        path: i,
        branch: o,
        ...t,
        message: u
      }
    }

    function* Nf(t, e, r, n) {
      (function(t) {
        return Wf(t) && "function" == typeof t[Symbol.iterator]
      })(t) || (t = [t]);
      for (const i of t) {
        const t = Rf(i, e, r, n);
        t && (yield t)
      }
    }

    function* jf(t, e, r = {}) {
      const {
        path: n = [],
        branch: i = [t],
        coerce: o = !1,
        mask: s = !1
      } = r, a = {
        path: n,
        branch: i,
        mask: s
      };
      o && (t = e.coercer(t, a));
      let u = "valid";
      for (const n of e.validator(t, a)) n.explanation = r.message, u = "not_valid", yield [n, void 0];
      for (let [c, f, l] of e.entries(t, a)) {
        const e = jf(f, l, {
          path: void 0 === c ? n : [...n, c],
          branch: void 0 === c ? i : [...i, f],
          coerce: o,
          mask: s,
          message: r.message
        });
        for (const r of e) r[0] ? (u = null != r[0].refinement ? "not_refined" : "not_valid", yield [r[0], void 0]) : o && (f = r[1], void 0 === c ? t = f : t instanceof Map ? t.set(c, f) : t instanceof Set ? t.add(f) : Wf(t) && (void 0 !== f || c in t) && (t[c] = f))
      }
      if ("not_valid" !== u)
        for (const n of e.refiner(t, a)) n.explanation = r.message, u = "not_refined", yield [n, void 0];
      "valid" === u && (yield [void 0, t])
    }
    class _f {
      constructor(t) {
        const {
          type: e,
          schema: r,
          validator: n,
          refiner: i,
          coercer: o = t => t,
          entries: s = function*() {}
        } = t;
        this.type = e, this.schema = r, this.entries = s, this.coercer = o, this.validator = n ? (t, e) => Nf(n(t, e), e, this, t) : () => [], this.refiner = i ? (t, e) => Nf(i(t, e), e, this, t) : () => []
      }
      assert(t, e) {
        return function(t, e, r) {
          const n = Lf(t, e, {
            message: r
          });
          if (n[0]) throw n[0]
        }(t, this, e)
      }
      create(t, e) {
        return Df(t, this, e)
      }
      is(t) {
        return Uf(t, this)
      }
      mask(t, e) {
        return function(t, e, r) {
          const n = Lf(t, e, {
            coerce: !0,
            mask: !0,
            message: r
          });
          if (n[0]) throw n[0];
          return n[1]
        }(t, this, e)
      }
      validate(t, e = {}) {
        return Lf(t, this, e)
      }
    }

    function Df(t, e, r) {
      const n = Lf(t, e, {
        coerce: !0,
        message: r
      });
      if (n[0]) throw n[0];
      return n[1]
    }

    function Uf(t, e) {
      return !Lf(t, e)[0]
    }

    function Lf(t, e, r = {}) {
      const n = jf(t, e, r),
        i = function(t) {
          const {
            done: e,
            value: r
          } = t.next();
          return e ? void 0 : r
        }(n);
      return i[0] ? [new Bf(i[0], function*() {
        for (const t of n) t[0] && (yield t[0])
      }), void 0] : [void 0, i[1]]
    }

    function Ff(t, e) {
      return new _f({
        type: t,
        schema: null,
        validator: e
      })
    }

    function $f(t) {
      return new _f({
        type: "array",
        schema: t,
        * entries(e) {
          if (t && Array.isArray(e))
            for (const [r, n] of e.entries()) yield [r, n, t]
        },
        coercer: t => Array.isArray(t) ? t.slice() : t,
        validator: t => Array.isArray(t) || "Expected an array value, but received: " + Cf(t)
      })
    }

    function zf() {
      return Ff("boolean", t => "boolean" == typeof t)
    }

    function Hf(t) {
      return Ff("instance", e => e instanceof t || `Expected a \`${t.name}\` instance, but received: ${Cf(e)}`)
    }

    function Gf(t) {
      const e = Cf(t),
        r = typeof t;
      return new _f({
        type: "literal",
        schema: "string" === r || "number" === r || "boolean" === r ? t : null,
        validator: r => r === t || `Expected the literal \`${e}\`, but received: ${Cf(r)}`
      })
    }

    function Kf(t) {
      return new _f({
        ...t,
        validator: (e, r) => null === e || t.validator(e, r),
        refiner: (e, r) => null === e || t.refiner(e, r)
      })
    }

    function Vf() {
      return Ff("number", t => "number" == typeof t && !isNaN(t) || "Expected a number, but received: " + Cf(t))
    }

    function Zf(t) {
      return new _f({
        ...t,
        validator: (e, r) => void 0 === e || t.validator(e, r),
        refiner: (e, r) => void 0 === e || t.refiner(e, r)
      })
    }

    function qf(t, e) {
      return new _f({
        type: "record",
        schema: null,
        * entries(r) {
          if (Wf(r))
            for (const n in r) {
              const i = r[n];
              yield [n, n, t], yield [n, i, e]
            }
        },
        validator: t => Mf(t) || "Expected an object, but received: " + Cf(t),
        coercer: t => Mf(t) ? {
          ...t
        } : t
      })
    }

    function Jf() {
      return Ff("string", t => "string" == typeof t || "Expected a string, but received: " + Cf(t))
    }

    function Yf(t) {
      const e = Ff("never", () => !1);
      return new _f({
        type: "tuple",
        schema: null,
        * entries(r) {
          if (Array.isArray(r)) {
            const n = Math.max(t.length, r.length);
            for (let i = 0; n > i; i++) yield [i, r[i], t[i] || e]
          }
        },
        validator: t => Array.isArray(t) || "Expected an array, but received: " + Cf(t),
        coercer: t => Array.isArray(t) ? t.slice() : t
      })
    }

    function Qf(t) {
      const e = Object.keys(t);
      return new _f({
        type: "type",
        schema: t,
        * entries(r) {
          if (Wf(r))
            for (const n of e) yield [n, r[n], t[n]]
        },
        validator: t => Mf(t) || "Expected an object, but received: " + Cf(t),
        coercer: t => Mf(t) ? {
          ...t
        } : t
      })
    }

    function Xf(t) {
      const e = t.map(t => t.type).join(" | ");
      return new _f({
        type: "union",
        schema: null,
        coercer(e, r) {
          for (const n of t) {
            const [t, i] = n.validate(e, {
              coerce: !0,
              mask: r.mask
            });
            if (!t) return i
          }
          return e
        },
        validator(r, n) {
          const i = [];
          for (const e of t) {
            const [...t] = jf(r, e, n), [o] = t;
            if (!o[0]) return [];
            for (const [e] of t) e && i.push(e)
          }
          return [`Expected the value to satisfy a union of \`${e}\`, but received: ${Cf(r)}`, ...i]
        }
      })
    }

    function tl() {
      return Ff("unknown", () => !0)
    }

    function el(t, e, r) {
      return new _f({
        ...t,
        coercer: (n, i) => Uf(n, e) ? t.coercer(r(n, i), i) : t.coercer(n, i)
      })
    }
    var rl = i(40022),
      nl = i.n(rl),
      il = i(23678),
      ol = class extends il {
        socket;
        constructor(t, e, r) {
          super(), this.socket = new window.WebSocket(t, r), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = t => this.emit("message", t.data), this.socket.onerror = t => this.emit("error", t), this.socket.onclose = t => {
            this.emit("close", t.code, t.reason)
          }
        }
        send(t, e, r) {
          const n = r || e;
          try {
            this.socket.send(t), n()
          } catch (t) {
            n(t)
          }
        }
        close(t, e) {
          this.socket.close(t, e)
        }
        addEventListener(t, e, r) {
          this.socket.addEventListener(t, e, r)
        }
      },
      sl = class {
        encode(t) {
          return JSON.stringify(t)
        }
        decode(t) {
          return JSON.parse(t)
        }
      },
      al = class extends il {
        address;
        rpc_id;
        queue;
        options;
        autoconnect;
        ready;
        reconnect;
        reconnect_timer_id;
        reconnect_interval;
        max_reconnects;
        rest_options;
        current_reconnects;
        generate_request_id;
        socket;
        webSocketFactory;
        dataPack;
        constructor(t, e = "ws://localhost:8080", {
          autoconnect: r = !0,
          reconnect: n = !0,
          reconnect_interval: i = 1e3,
          max_reconnects: o = 5,
          ...s
        } = {}, a, u) {
          super(), this.webSocketFactory = t, this.queue = {}, this.rpc_id = 0, this.address = e, this.autoconnect = r, this.ready = !1, this.reconnect = n, this.reconnect_timer_id = void 0, this.reconnect_interval = i, this.max_reconnects = o, this.rest_options = s, this.current_reconnects = 0, this.generate_request_id = a || (() => "number" == typeof this.rpc_id ? ++this.rpc_id : +this.rpc_id + 1), this.dataPack = u || new sl, this.autoconnect && this.Lr(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          })
        }
        connect() {
          this.socket || this.Lr(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
          })
        }
        call(t, e, r, n) {
          return !n && "object" == typeof r && (n = r, r = null), new Promise((i, o) => {
            if (!this.ready) return o(Error("socket not ready"));
            const s = this.generate_request_id(t, e),
              a = {
                jsonrpc: "2.0",
                method: t,
                params: e || void 0,
                id: s
              };
            this.socket.send(this.dataPack.encode(a), n, t => {
              if (t) return o(t);
              this.queue[s] = {
                promise: [i, o]
              }, r && (this.queue[s].timeout = setTimeout(() => {
                delete this.queue[s], o(Error("reply timeout"))
              }, r))
            })
          })
        }
        async login(t) {
          const e = await this.call("rpc.login", t);
          if (!e) throw Error("authentication failed");
          return e
        }
        async listMethods() {
          return await this.call("__listMethods")
        }
        notify(t, e) {
          return new Promise((r, n) => {
            if (!this.ready) return n(Error("socket not ready"));
            const i = {
              jsonrpc: "2.0",
              method: t,
              params: e
            };
            this.socket.send(this.dataPack.encode(i), t => {
              if (t) return n(t);
              r()
            })
          })
        }
        async subscribe(t) {
          "string" == typeof t && (t = [t]);
          const e = await this.call("rpc.on", t);
          if ("string" == typeof t && "ok" !== e[t]) throw Error("Failed subscribing to an event '" + t + "' with: " + e[t]);
          return e
        }
        async unsubscribe(t) {
          "string" == typeof t && (t = [t]);
          const e = await this.call("rpc.off", t);
          if ("string" == typeof t && "ok" !== e[t]) throw Error("Failed unsubscribing from an event with: " + e);
          return e
        }
        close(t, e) {
          this.socket && this.socket.close(t || 1e3, e)
        }
        setAutoReconnect(t) {
          this.reconnect = t
        }
        setReconnectInterval(t) {
          this.reconnect_interval = t
        }
        setMaxReconnects(t) {
          this.max_reconnects = t
        }
        getCurrentReconnects() {
          return this.current_reconnects
        }
        getMaxReconnects() {
          return this.max_reconnects
        }
        isReconnecting() {
          return void 0 !== this.reconnect_timer_id
        }
        willReconnect() {
          return this.reconnect && (0 === this.max_reconnects || this.current_reconnects < this.max_reconnects)
        }
        Lr(t, e) {
          clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(t, e), this.socket.addEventListener("open", () => {
            this.ready = !0, this.emit("open"), this.current_reconnects = 0
          }), this.socket.addEventListener("message", ({
            data: t
          }) => {
            t instanceof ArrayBuffer && (t = vn.Buffer.from(t).toString());
            try {
              t = this.dataPack.decode(t)
            } catch {
              return
            }
            if (t.notification && this.listeners(t.notification).length) {
              if (!Object.keys(t.params).length) return this.emit(t.notification);
              const e = [t.notification];
              if (t.params.constructor === Object) e.push(t.params);
              else
                for (let r = 0; r < t.params.length; r++) e.push(t.params[r]);
              return Promise.resolve().then(() => {
                this.emit.apply(this, e)
              })
            }
            if (!this.queue[t.id]) return t.method ? Promise.resolve().then(() => {
              this.emit(t.method, t?.params)
            }) : void 0;
            "error" in t == "result" in t && this.queue[t.id].promise[1](Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[t.id].timeout && clearTimeout(this.queue[t.id].timeout), t.error ? this.queue[t.id].promise[1](t.error) : this.queue[t.id].promise[0](t.result), delete this.queue[t.id]
          }), this.socket.addEventListener("error", t => this.emit("error", t)), this.socket.addEventListener("close", ({
            code: r,
            reason: n
          }) => {
            this.ready && setTimeout(() => this.emit("close", r, n), 0), this.ready = !1, this.socket = void 0, 1e3 !== r && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || 0 === this.max_reconnects) ? this.reconnect_timer_id = setTimeout(() => this.Lr(t, e), this.reconnect_interval) : this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects && setTimeout(() => this.emit("max_reconnects_reached", r, n), 1))
          })
        }
      };
    const ul = BigInt(0),
      cl = BigInt(1),
      fl = BigInt(2),
      ll = BigInt(7),
      hl = BigInt(256),
      dl = BigInt(113),
      pl = [],
      bl = [],
      ml = [];
    for (let t = 0, e = cl, r = 1, n = 0; 24 > t; t++) {
      [r, n] = [n, (2 * r + 3 * n) % 5], pl.push(2 * (5 * n + r)), bl.push((t + 1) * (t + 2) / 2 % 64);
      let i = ul;
      for (let t = 0; 7 > t; t++) e = (e << cl ^ (e >> ll) * dl) % hl, e & fl && (i ^= cl << (cl << BigInt(t)) - cl);
      ml.push(i)
    }
    const yl = Yn(ml, !0),
      gl = yl[0],
      vl = yl[1],
      wl = (t, e, r) => r > 32 ? ((t, e, r) => e << r - 32 | t >>> 64 - r)(t, e, r) : ((t, e, r) => t << r | e >>> 32 - r)(t, e, r),
      Al = (t, e, r) => r > 32 ? ((t, e, r) => t << r - 32 | e >>> 64 - r)(t, e, r) : ((t, e, r) => e << r | t >>> 32 - r)(t, e, r);
    class Tl extends Ln {
      constructor(t, e, r, n = !1, i = 24) {
        if (super(), this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, this.enableXOF = !1, this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = n, this.rounds = i, Tn(r), 0 >= t || t >= 200) throw Error("only keccak-f1600 function is supported");
        this.state = new Uint8Array(200), this.state32 = function(t) {
          return new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4))
        }(this.state)
      }
      clone() {
        return this.jt()
      }
      keccak() {
        Wn(this.state32),
          function(t, e = 24) {
            const r = new Uint32Array(10);
            for (let n = 24 - e; 24 > n; n++) {
              for (let e = 0; 10 > e; e++) r[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
              for (let e = 0; 10 > e; e += 2) {
                const n = (e + 8) % 10,
                  i = (e + 2) % 10,
                  o = r[i],
                  s = r[i + 1],
                  a = wl(o, s, 1) ^ r[n],
                  u = Al(o, s, 1) ^ r[n + 1];
                for (let r = 0; 50 > r; r += 10) t[e + r] ^= a, t[e + r + 1] ^= u
              }
              let e = t[2],
                i = t[3];
              for (let r = 0; 24 > r; r++) {
                const n = bl[r],
                  o = wl(e, i, n),
                  s = Al(e, i, n),
                  a = pl[r];
                e = t[a], i = t[a + 1], t[a] = o, t[a + 1] = s
              }
              for (let e = 0; 50 > e; e += 10) {
                for (let n = 0; 10 > n; n++) r[n] = t[e + n];
                for (let n = 0; 10 > n; n++) t[e + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10]
              }
              t[0] ^= gl[n], t[1] ^= vl[n]
            }
            In(r)
          }(this.state32, this.rounds), Wn(this.state32), this.posOut = 0, this.pos = 0
      }
      update(t) {
        kn(this), En(t = Dn(t));
        const {
          blockLen: e,
          state: r
        } = this, n = t.length;
        for (let i = 0; n > i;) {
          const o = Math.min(e - this.pos, n - i);
          for (let e = 0; o > e; e++) r[this.pos++] ^= t[i++];
          this.pos === e && this.keccak()
        }
        return this
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
          state: t,
          suffix: e,
          pos: r,
          blockLen: n
        } = this;
        t[r] ^= e, !!(128 & e) && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak()
      }
      writeInto(t) {
        kn(this, !1), En(t), this.finish();
        const e = this.state,
          {
            blockLen: r
          } = this;
        for (let n = 0, i = t.length; i > n;) {
          this.posOut >= r && this.keccak();
          const o = Math.min(r - this.posOut, i - n);
          t.set(e.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o
        }
        return t
      }
      xofInto(t) {
        if (!this.enableXOF) throw Error("XOF is not possible for this instance");
        return this.writeInto(t)
      }
      xof(t) {
        return Tn(t), this.xofInto(new Uint8Array(t))
      }
      digestInto(t) {
        if (xn(t, this), this.finished) throw Error("digest() was already called");
        return this.writeInto(t), this.destroy(), t
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
      }
      destroy() {
        this.destroyed = !0, In(this.state)
      }
      jt(t) {
        const {
          blockLen: e,
          suffix: r,
          outputLen: n,
          rounds: i,
          enableXOF: o
        } = this;
        return t || (t = new Tl(e, r, n, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = r, t.outputLen = n, t.enableXOF = o, t.destroyed = this.destroyed, t
      }
    }
    const El = Fn(() => new Tl(136, 1, 32));
    class Pl extends Ln {
      constructor(t, e) {
        super(), this.finished = !1, this.destroyed = !1, Pn(t);
        const r = Dn(e);
        if (this.iHash = t.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n = this.blockLen,
          i = new Uint8Array(n);
        i.set(r.length > n ? t.create().update(r).digest() : r);
        for (let t = 0; t < i.length; t++) i[t] ^= 54;
        this.iHash.update(i), this.oHash = t.create();
        for (let t = 0; t < i.length; t++) i[t] ^= 106;
        this.oHash.update(i), In(i)
      }
      update(t) {
        return kn(this), this.iHash.update(t), this
      }
      digestInto(t) {
        kn(this), En(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
      }
      digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t
      }
      jt(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: e,
          iHash: r,
          finished: n,
          destroyed: i,
          blockLen: o,
          outputLen: s
        } = this;
        return t.finished = n, t.destroyed = i, t.blockLen = o, t.outputLen = s, t.oHash = e.jt(t.oHash), t.iHash = r.jt(t.iHash), t
      }
      clone() {
        return this.jt()
      }
      destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
      }
    }
    const kl = (t, e, r) => new Pl(t, e).update(r).digest();
    kl.create = (t, e) => new Pl(t, e);
    const xl = (t, e) => (t + (0 > t ? -e : e) / Ml) / e;

    function Il(t) {
      if (!["compact", "recovered", "der"].includes(t)) throw Error('Signature format must be "compact", "recovered", or "der"');
      return t
    }

    function Sl(t, e) {
      const r = {};
      for (let n of Object.keys(e)) r[n] = void 0 === t[n] ? e[n] : t[n];
      return Pi(r.lowS, "lowS"), Pi(r.prehash, "prehash"), void 0 !== r.format && Il(r.format), r
    }
    const Ol = {
        Err: class extends Error {
          constructor(t = "") {
            super(t)
          }
        },
        ai: {
          encode: (t, e) => {
            const {
              Err: r
            } = Ol;
            if (0 > t || t > 256) throw new r("tlv.encode: wrong tag");
            if (1 & e.length) throw new r("tlv.encode: unpadded data");
            const n = e.length / 2,
              i = xi(n);
            if (i.length / 2 & 128) throw new r("tlv.encode: long form length too big");
            const o = n > 127 ? xi(i.length / 2 | 128) : "";
            return xi(t) + o + i + e
          },
          decode(t, e) {
            const {
              Err: r
            } = Ol;
            let n = 0;
            if (0 > t || t > 256) throw new r("tlv.encode: wrong tag");
            if (2 > e.length || e[n++] !== t) throw new r("tlv.decode: wrong tlv");
            const i = e[n++];
            let o = 0;
            if (128 & i) {
              const t = 127 & i;
              if (!t) throw new r("tlv.decode(long): indefinite length not supported");
              if (t > 4) throw new r("tlv.decode(long): byte length is too big");
              const s = e.subarray(n, n + t);
              if (s.length !== t) throw new r("tlv.decode: length bytes not complete");
              if (0 === s[0]) throw new r("tlv.decode(long): zero leftmost byte");
              for (const t of s) o = o << 8 | t;
              if (n += t, 128 > o) throw new r("tlv.decode(long): not minimal encoding")
            } else o = i;
            const s = e.subarray(n, n + o);
            if (s.length !== o) throw new r("tlv.decode: wrong value length");
            return {
              v: s,
              l: e.subarray(n + o)
            }
          }
        },
        ui: {
          encode(t) {
            const {
              Err: e
            } = Ol;
            if (Bl > t) throw new e("integer: negative integers are not allowed");
            let r = xi(t);
            if (8 & Number.parseInt(r[0], 16) && (r = "00" + r), 1 & r.length) throw new e("unexpected DER parsing assertion: unpadded hex");
            return r
          },
          decode(t) {
            const {
              Err: e
            } = Ol;
            if (128 & t[0]) throw new e("invalid signature integer: negative");
            if (0 === t[0] && !(128 & t[1])) throw new e("invalid signature integer: unnecessary leading zero");
            return Si(t)
          }
        },
        toSig(t) {
          const {
            Err: e,
            ui: r,
            ai: n
          } = Ol, i = Mi("signature", t), {
            v: o,
            l: s
          } = n.decode(48, i);
          if (s.length) throw new e("invalid signature: left bytes after parsing");
          const {
            v: a,
            l: u
          } = n.decode(2, o), {
            v: c,
            l: f
          } = n.decode(2, u);
          if (f.length) throw new e("invalid signature: left bytes after parsing");
          return {
            r: r.decode(a),
            s: r.decode(c)
          }
        },
        hexFromSig(t) {
          const {
            ai: e,
            ui: r
          } = Ol, n = e.encode(2, r.encode(t.r)) + e.encode(2, r.encode(t.s));
          return e.encode(48, n)
        }
      },
      Bl = BigInt(0),
      Wl = BigInt(1),
      Ml = BigInt(2),
      Cl = BigInt(3),
      Rl = BigInt(4);

    function Nl(t, e) {
      const {
        BYTES: r
      } = t;
      let n;
      if ("bigint" == typeof e) n = e;
      else {
        let i = Mi("private key", e);
        try {
          n = t.fromBytes(i)
        } catch {
          throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)
        }
      }
      if (!t.isValidNot0(n)) throw Error("invalid private key: out of range [1..N-1]");
      return n
    }

    function jl(t) {
      return Uint8Array.of(t ? 2 : 3)
    }

    function _l(t, e) {
      return {
        secretKey: e.BYTES,
        publicKey: 1 + t.BYTES,
        publicKeyUncompressed: 1 + 2 * t.BYTES,
        publicKeyHasPrefix: !0,
        signature: 2 * e.BYTES
      }
    }

    function Dl(t) {
      const {
        CURVE: e,
        curveOpts: r,
        hash: n,
        ecdsaOpts: i
      } = function(t) {
        const {
          CURVE: e,
          curveOpts: r
        } = function(t) {
          const e = {
              a: t.a,
              b: t.b,
              p: t.Fp.ORDER,
              n: t.n,
              h: t.h,
              Gx: t.Gx,
              Gy: t.Gy
            },
            r = t.Fp;
          let n = t.allowedPrivateKeyLengths ? Array.from(new Set(t.allowedPrivateKeyLengths.map(t => Math.ceil(t / 2)))) : void 0;
          return {
            CURVE: e,
            curveOpts: {
              Fp: r,
              Fn: co(e.n, {
                BITS: t.nBitLength,
                allowedLengths: n,
                modFromBytes: t.wrapPrivateKey
              }),
              allowInfinityPoint: t.allowInfinityPoint,
              endo: t.endo,
              isTorsionFree: t.isTorsionFree,
              clearCofactor: t.clearCofactor,
              fromBytes: t.fromBytes,
              toBytes: t.toBytes
            }
          }
        }(t), n = {
          hmac: t.hmac,
          randomBytes: t.randomBytes,
          lowS: t.lowS,
          bits2int: t.bits2int,
          bits2int_modN: t.bits2int_modN
        };
        return {
          CURVE: e,
          curveOpts: r,
          hash: t.hash,
          ecdsaOpts: n
        }
      }(t);
      return function(t, e) {
        const r = e.Point;
        return Object.assign({}, e, {
          ProjectivePoint: r,
          CURVE: Object.assign({}, t, uo(r.Fn.ORDER, r.Fn.BITS))
        })
      }(t, function(t, e, r = {}) {
        Pn(e), Di(r, {}, {
          hmac: "function",
          lowS: "boolean",
          randomBytes: "function",
          bits2int: "function",
          bits2int_modN: "function"
        });
        const n = r.randomBytes || $n,
          i = r.hmac || ((t, ...r) => kl(e, t, Un(...r))),
          {
            Fp: o,
            Fn: s
          } = t,
          {
            ORDER: a,
            BITS: u
          } = s,
          {
            keygen: c,
            getPublicKey: f,
            getSharedSecret: l,
            utils: h,
            lengths: d
          } = function(t, e = {}) {
            const {
              Fn: r
            } = t, n = e.randomBytes || $n, i = Object.assign(_l(t.Fp, r), {
              seed: lo(r.ORDER)
            });

            function o(t) {
              try {
                return !!Nl(r, t)
              } catch {
                return !1
              }
            }

            function s(t = n(i.seed)) {
              return function(t, e, r = !1) {
                const n = t.length,
                  i = fo(e),
                  o = lo(e);
                if (16 > n || o > n || n > 1024) throw Error("expected " + o + "-1024 bytes of input, got " + n);
                const s = Yi(r ? Oi(t) : Si(t), e - $i) + $i;
                return r ? Wi(s, i) : Bi(s, i)
              }(ki(t, i.seed, "seed"), r.ORDER)
            }

            function a(e, n = !0) {
              return t.BASE.multiply(Nl(r, e)).toBytes(n)
            }

            function u(e) {
              if ("bigint" == typeof e) return !1;
              if (e instanceof t) return !0;
              const {
                secretKey: n,
                publicKey: o,
                publicKeyUncompressed: s
              } = i;
              if (r.allowedLengths || n === o) return;
              const a = Mi("key", e).length;
              return a === o || a === s
            }
            return Object.freeze({
              getPublicKey: a,
              getSharedSecret: function(e, n, i = !0) {
                if (!0 === u(e)) throw Error("first arg must be private key");
                if (!1 === u(n)) throw Error("second arg must be public key");
                const o = Nl(r, e);
                return t.fromHex(n).multiply(o).toBytes(i)
              },
              keygen: function(t) {
                const e = s(t);
                return {
                  secretKey: e,
                  publicKey: a(e)
                }
              },
              Point: t,
              utils: {
                isValidSecretKey: o,
                isValidPublicKey: function(e, r) {
                  const {
                    publicKey: n,
                    publicKeyUncompressed: o
                  } = i;
                  try {
                    const i = e.length;
                    return !(!0 === r && i !== n || !1 === r && i !== o || !t.fromBytes(e))
                  } catch {
                    return !1
                  }
                },
                randomSecretKey: s,
                isValidPrivateKey: o,
                randomPrivateKey: s,
                normPrivateKeyToScalar: t => Nl(r, t),
                precompute: (e = 8, r = t.BASE) => r.precompute(e, !1)
              },
              lengths: i
            })
          }(t, r),
          p = {
            prehash: !1,
            lowS: "boolean" == typeof r.lowS && r.lowS,
            format: void 0,
            extraEntropy: !1
          },
          b = "compact";

        function m(t) {
          return t > a >> Wl
        }

        function y(t, e) {
          if (!s.isValidNot0(e)) throw Error(`invalid signature ${t}: out of range 1..Point.Fn.ORDER`);
          return e
        }
        class g {
          constructor(t, e, r) {
            this.r = y("r", t), this.s = y("s", e), null != r && (this.recovery = r), Object.freeze(this)
          }
          static fromBytes(t, e = b) {
            let r;
            if (function(t, e) {
                Il(e);
                const r = d.signature;
                ki(t, "compact" === e ? r : "recovered" === e ? r + 1 : void 0, e + " signature")
              }(t, e), "der" === e) {
              const {
                r: e,
                s: r
              } = Ol.toSig(ki(t));
              return new g(e, r)
            }
            "recovered" === e && (r = t[0], e = "compact", t = t.subarray(1));
            const n = s.BYTES,
              i = t.subarray(0, n),
              o = t.subarray(n, 2 * n);
            return new g(s.fromBytes(i), s.fromBytes(o), r)
          }
          static fromHex(t, e) {
            return this.fromBytes(jn(t), e)
          }
          addRecoveryBit(t) {
            return new g(this.r, this.s, t)
          }
          recoverPublicKey(e) {
            const r = o.ORDER,
              {
                r: n,
                s: i,
                recovery: u
              } = this;
            if (null == u || ![0, 1, 2, 3].includes(u)) throw Error("recovery id invalid");
            if (r > a * Ml && u > 1) throw Error("recovery id is ambiguous for h>1 curve");
            const c = 2 === u || 3 === u ? n + a : n;
            if (!o.isValid(c)) throw Error("recovery id 2 or 3 invalid");
            const f = o.toBytes(c),
              l = t.fromBytes(Un(jl(!(1 & u)), f)),
              h = s.inv(c),
              d = w(Mi("msgHash", e)),
              p = s.create(-d * h),
              b = s.create(i * h),
              m = t.BASE.multiplyUnsafe(p).add(l.multiplyUnsafe(b));
            if (m.is0()) throw Error("point at infinify");
            return m.assertValidity(), m
          }
          hasHighS() {
            return m(this.s)
          }
          toBytes(t = b) {
            if (Il(t), "der" === t) return jn(Ol.hexFromSig(this));
            const e = s.toBytes(this.r),
              r = s.toBytes(this.s);
            if ("recovered" === t) {
              if (null == this.recovery) throw Error("recovery bit must be present");
              return Un(Uint8Array.of(this.recovery), e, r)
            }
            return Un(e, r)
          }
          toHex(t) {
            return Rn(this.toBytes(t))
          }
          assertValidity() {}
          static fromCompact(t) {
            return g.fromBytes(Mi("sig", t), "compact")
          }
          static fromDER(t) {
            return g.fromBytes(Mi("sig", t), "der")
          }
          normalizeS() {
            return this.hasHighS() ? new g(this.r, s.neg(this.s), this.recovery) : this
          }
          toDERRawBytes() {
            return this.toBytes("der")
          }
          toDERHex() {
            return Rn(this.toBytes("der"))
          }
          toCompactRawBytes() {
            return this.toBytes("compact")
          }
          toCompactHex() {
            return Rn(this.toBytes("compact"))
          }
        }
        const v = r.bits2int || function(t) {
            if (t.length > 8192) throw Error("input is too large");
            const e = Si(t),
              r = 8 * t.length - u;
            return r > 0 ? e >> BigInt(r) : e
          },
          w = r.bits2int_modN || function(t) {
            return s.create(v(t))
          },
          A = _i(u);

        function T(t) {
          return Ni("num < 2^" + u, t, Bl, A), s.toBytes(t)
        }

        function E(t, r) {
          return ki(t, void 0, "message"), r ? ki(e(t), void 0, "prehashed message") : t
        }
        return Object.freeze({
          keygen: c,
          getPublicKey: f,
          getSharedSecret: l,
          utils: h,
          lengths: d,
          Point: t,
          sign: function(r, o, a = {}) {
            r = Mi("message", r);
            const {
              seed: u,
              k2sig: c
            } = function(e, r, i) {
              if (["recovered", "canonical"].some(t => t in i)) throw Error("sign() legacy options not supported");
              const {
                lowS: o,
                prehash: a,
                extraEntropy: u
              } = Sl(i, p);
              e = E(e, a);
              const c = w(e),
                f = Nl(s, r),
                l = [T(f), T(c)];
              if (null != u && !1 !== u) {
                const t = !0 === u ? n(d.secretKey) : u;
                l.push(Mi("extraEntropy", t))
              }
              const h = Un(...l),
                b = c;
              return {
                seed: h,
                k2sig: function(e) {
                  const r = v(e);
                  if (!s.isValidNot0(r)) return;
                  const n = s.inv(r),
                    i = t.BASE.multiply(r).toAffine(),
                    a = s.create(i.x);
                  if (a === Bl) return;
                  const u = s.create(n * s.create(b + a * f));
                  if (u === Bl) return;
                  let c = (i.x === a ? 0 : 2) | +(i.y & Wl),
                    l = u;
                  return o && m(u) && (l = s.neg(u), c ^= 1), new g(a, l, c)
                }
              }
            }(r, o, a);
            return function(t, e, r) {
              if ("number" != typeof t || 2 > t) throw Error("hashLen must be a number");
              if ("number" != typeof e || 2 > e) throw Error("qByteLen must be a number");
              if ("function" != typeof r) throw Error("hmacFn must be a function");
              const n = t => new Uint8Array(t),
                i = t => Uint8Array.of(t);
              let o = n(t),
                s = n(t),
                a = 0;
              const u = () => {
                  o.fill(1), s.fill(0), a = 0
                },
                c = (...t) => r(s, o, ...t),
                f = (t = n(0)) => {
                  s = c(i(0), t), o = c(), 0 !== t.length && (s = c(i(1), t), o = c())
                },
                l = () => {
                  if (a++ >= 1e3) throw Error("drbg: tried 1000 values");
                  let t = 0;
                  const r = [];
                  for (; e > t;) {
                    o = c();
                    const e = o.slice();
                    r.push(e), t += o.length
                  }
                  return Un(...r)
                };
              return (t, e) => {
                let r;
                for (u(), f(t); !(r = e(l()));) f();
                return u(), r
              }
            }(e.outputLen, s.BYTES, i)(u, c)
          },
          verify: function(e, r, n, i = {}) {
            const {
              lowS: o,
              prehash: a,
              format: u
            } = Sl(i, p);
            if (n = Mi("publicKey", n), r = E(Mi("message", r), a), "strict" in i) throw Error("options.strict was renamed to lowS");
            const c = void 0 === u ? function(t) {
              let e;
              const r = "string" == typeof t || An(t),
                n = !r && null !== t && "object" == typeof t && "bigint" == typeof t.r && "bigint" == typeof t.s;
              if (!r && !n) throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");
              if (n) e = new g(t.r, t.s);
              else if (r) {
                try {
                  e = g.fromBytes(Mi("sig", t), "der")
                } catch (t) {
                  if (!(t instanceof Ol.Err)) throw t
                }
                if (!e) try {
                  e = g.fromBytes(Mi("sig", t), "compact")
                } catch {
                  return !1
                }
              }
              return e || !1
            }(e) : g.fromBytes(Mi("sig", e), u);
            if (!1 === c) return !1;
            try {
              const e = t.fromBytes(n);
              if (o && c.hasHighS()) return !1;
              const {
                r: i,
                s: a
              } = c, u = w(r), f = s.inv(a), l = s.create(u * f), h = s.create(i * f), d = t.BASE.multiplyUnsafe(l).add(e.multiplyUnsafe(h));
              return !d.is0() && s.create(d.x) === i
            } catch {
              return !1
            }
          },
          recoverPublicKey: function(t, e, r = {}) {
            const {
              prehash: n
            } = Sl(r, p);
            return e = E(e, n), g.fromBytes(t, "recovered").recoverPublicKey(e).toBytes()
          },
          Signature: g,
          hash: e
        })
      }(function(t, e = {}) {
        const r = Io("weierstrass", t, e),
          {
            Fp: n,
            Fn: i
          } = r;
        let o = r.CURVE;
        const {
          h: s,
          n: a
        } = o;
        Di(e, {}, {
          allowInfinityPoint: "boolean",
          clearCofactor: "function",
          isTorsionFree: "function",
          fromBytes: "function",
          toBytes: "function",
          endo: "object",
          wrapPrivateKey: "boolean"
        });
        const {
          endo: u
        } = e;
        if (u && (!n.is0(o.a) || "bigint" != typeof u.beta || !Array.isArray(u.basises))) throw Error('invalid endo: expected "beta": bigint and "basises": array');
        const c = _l(n, i);

        function f() {
          if (!n.isOdd) throw Error("compression is not supported: Field does not have .isOdd()")
        }
        const l = e.toBytes || function(t, e, r) {
            const {
              x: i,
              y: o
            } = e.toAffine(), s = n.toBytes(i);
            return Pi(r, "isCompressed"), r ? (f(), Un(jl(!n.isOdd(o)), s)) : Un(Uint8Array.of(4), s, n.toBytes(o))
          },
          h = e.fromBytes || function(t) {
            ki(t, void 0, "Point");
            const {
              publicKey: e,
              publicKeyUncompressed: r
            } = c, i = t.length, o = t[0], s = t.subarray(1);
            if (i !== e || 2 !== o && 3 !== o) {
              if (i === r && 4 === o) {
                const t = n.BYTES,
                  e = n.fromBytes(s.subarray(0, t)),
                  r = n.fromBytes(s.subarray(t, 2 * t));
                if (!p(e, r)) throw Error("bad point: is not on curve");
                return {
                  x: e,
                  y: r
                }
              }
              throw Error(`bad point: got length ${i}, expected compressed=${e} or uncompressed=${r}`)
            } {
              const t = n.fromBytes(s);
              if (!n.isValid(t)) throw Error("bad point: is not on curve, wrong x");
              const e = d(t);
              let r;
              try {
                r = n.sqrt(e)
              } catch (t) {
                const e = t instanceof Error ? ": " + t.message : "";
                throw Error("bad point: is not on curve, sqrt error" + e)
              }
              return f(), !(1 & ~o) !== n.isOdd(r) && (r = n.neg(r)), {
                x: t,
                y: r
              }
            }
          };

        function d(t) {
          const e = n.sqr(t),
            r = n.mul(e, t);
          return n.add(n.add(r, n.mul(t, o.a)), o.b)
        }

        function p(t, e) {
          const r = n.sqr(e),
            i = d(t);
          return n.eql(r, i)
        }
        if (!p(o.Gx, o.Gy)) throw Error("bad curve params: generator point");
        const b = n.mul(n.pow(o.a, Cl), Rl),
          m = n.mul(n.sqr(o.b), BigInt(27));
        if (n.is0(n.add(b, m))) throw Error("bad curve params: a or b");

        function y(t, e, r = !1) {
          if (!n.isValid(e) || r && n.is0(e)) throw Error("bad point coordinate " + t);
          return e
        }

        function g(t) {
          if (!(t instanceof E)) throw Error("ProjectivePoint expected")
        }

        function v(t) {
          if (!u || !u.basises) throw Error("no endo");
          return function(t, e, r) {
            const [
              [n, i],
              [o, s]
            ] = e, a = xl(s * t, r), u = xl(-i * t, r);
            let c = t - a * n - u * o,
              f = -a * i - u * s;
            const l = Bl > c,
              h = Bl > f;
            l && (c = -c), h && (f = -f);
            const d = _i(Math.ceil(ji(r) / 2)) + Wl;
            if (Bl > c || c >= d || Bl > f || f >= d) throw Error("splitScalar (endomorphism): failed, k=" + t);
            return {
              k1neg: l,
              k1: c,
              k2neg: h,
              k2: f
            }
          }(t, u.basises, i.ORDER)
        }
        const w = Li((t, e) => {
            const {
              X: r,
              Y: i,
              Z: o
            } = t;
            if (n.eql(o, n.ONE)) return {
              x: r,
              y: i
            };
            const s = t.is0();
            null == e && (e = s ? n.ONE : n.inv(o));
            const a = n.mul(r, e),
              u = n.mul(i, e),
              c = n.mul(o, e);
            if (s) return {
              x: n.ZERO,
              y: n.ZERO
            };
            if (!n.eql(c, n.ONE)) throw Error("invZ was invalid");
            return {
              x: a,
              y: u
            }
          }),
          A = Li(t => {
            if (t.is0()) {
              if (e.allowInfinityPoint && !n.is0(t.Y)) return;
              throw Error("bad point: ZERO")
            }
            const {
              x: r,
              y: i
            } = t.toAffine();
            if (!n.isValid(r) || !n.isValid(i)) throw Error("bad point: x or y not field elements");
            if (!p(r, i)) throw Error("bad point: equation left != right");
            if (!t.isTorsionFree()) throw Error("bad point: not in prime-order subgroup");
            return !0
          });

        function T(t, e, r, i, o) {
          return r = new E(n.mul(r.X, t), r.Y, r.Z), e = bo(i, e), r = bo(o, r), e.add(r)
        }
        class E {
          constructor(t, e, r) {
            this.X = y("x", t), this.Y = y("y", e, !0), this.Z = y("z", r), Object.freeze(this)
          }
          static CURVE() {
            return o
          }
          static fromAffine(t) {
            const {
              x: e,
              y: r
            } = t || {};
            if (!t || !n.isValid(e) || !n.isValid(r)) throw Error("invalid affine point");
            if (t instanceof E) throw Error("projective point not allowed");
            return n.is0(e) && n.is0(r) ? E.ZERO : new E(e, r, n.ONE)
          }
          static fromBytes(t) {
            const e = E.fromAffine(h(ki(t, void 0, "point")));
            return e.assertValidity(), e
          }
          static fromHex(t) {
            return E.fromBytes(Mi("pointHex", t))
          }
          get x() {
            return this.toAffine().x
          }
          get y() {
            return this.toAffine().y
          }
          precompute(t = 8, e = !0) {
            return k.createCache(this, t), e || this.multiply(Cl), this
          }
          assertValidity() {
            A(this)
          }
          hasEvenY() {
            const {
              y: t
            } = this.toAffine();
            if (!n.isOdd) throw Error("Field doesn't support isOdd");
            return !n.isOdd(t)
          }
          equals(t) {
            g(t);
            const {
              X: e,
              Y: r,
              Z: i
            } = this, {
              X: o,
              Y: s,
              Z: a
            } = t, u = n.eql(n.mul(e, a), n.mul(o, i)), c = n.eql(n.mul(r, a), n.mul(s, i));
            return u && c
          }
          negate() {
            return new E(this.X, n.neg(this.Y), this.Z)
          }
          double() {
            const {
              a: t,
              b: e
            } = o, r = n.mul(e, Cl), {
              X: i,
              Y: s,
              Z: a
            } = this;
            let u = n.ZERO,
              c = n.ZERO,
              f = n.ZERO,
              l = n.mul(i, i),
              h = n.mul(s, s),
              d = n.mul(a, a),
              p = n.mul(i, s);
            return p = n.add(p, p), f = n.mul(i, a), f = n.add(f, f), u = n.mul(t, f), c = n.mul(r, d), c = n.add(u, c), u = n.sub(h, c), c = n.add(h, c), c = n.mul(u, c), u = n.mul(p, u), f = n.mul(r, f), d = n.mul(t, d), p = n.sub(l, d), p = n.mul(t, p), p = n.add(p, f), f = n.add(l, l), l = n.add(f, l), l = n.add(l, d), l = n.mul(l, p), c = n.add(c, l), d = n.mul(s, a), d = n.add(d, d), l = n.mul(d, p), u = n.sub(u, l), f = n.mul(d, h), f = n.add(f, f), f = n.add(f, f), new E(u, c, f)
          }
          add(t) {
            g(t);
            const {
              X: e,
              Y: r,
              Z: i
            } = this, {
              X: s,
              Y: a,
              Z: u
            } = t;
            let c = n.ZERO,
              f = n.ZERO,
              l = n.ZERO;
            const h = o.a,
              d = n.mul(o.b, Cl);
            let p = n.mul(e, s),
              b = n.mul(r, a),
              m = n.mul(i, u),
              y = n.add(e, r),
              v = n.add(s, a);
            y = n.mul(y, v), v = n.add(p, b), y = n.sub(y, v), v = n.add(e, i);
            let w = n.add(s, u);
            return v = n.mul(v, w), w = n.add(p, m), v = n.sub(v, w), w = n.add(r, i), c = n.add(a, u), w = n.mul(w, c), c = n.add(b, m), w = n.sub(w, c), l = n.mul(h, v), c = n.mul(d, m), l = n.add(c, l), c = n.sub(b, l), l = n.add(b, l), f = n.mul(c, l), b = n.add(p, p), b = n.add(b, p), m = n.mul(h, m), v = n.mul(d, v), b = n.add(b, m), m = n.sub(p, m), m = n.mul(h, m), v = n.add(v, m), p = n.mul(b, v), f = n.add(f, p), p = n.mul(w, v), c = n.mul(y, c), c = n.sub(c, p), p = n.mul(y, b), l = n.mul(w, l), l = n.add(l, p), new E(c, f, l)
          }
          subtract(t) {
            return this.add(t.negate())
          }
          is0() {
            return this.equals(E.ZERO)
          }
          multiply(t) {
            const {
              endo: r
            } = e;
            if (!i.isValidNot0(t)) throw Error("invalid scalar: out of range");
            let n, o;
            const s = t => k.cached(this, t, t => mo(E, t));
            if (r) {
              const {
                k1neg: e,
                k1: i,
                k2neg: a,
                k2: u
              } = v(t), {
                p: c,
                f: f
              } = s(i), {
                p: l,
                f: h
              } = s(u);
              o = f.add(h), n = T(r.beta, c, l, e, a)
            } else {
              const {
                p: e,
                f: r
              } = s(t);
              n = e, o = r
            }
            return mo(E, [n, o])[0]
          }
          multiplyUnsafe(t) {
            const {
              endo: r
            } = e, n = this;
            if (!i.isValid(t)) throw Error("invalid scalar: out of range");
            if (t === Bl || n.is0()) return E.ZERO;
            if (t === Wl) return n;
            if (k.hasCache(this)) return this.multiply(t);
            if (r) {
              const {
                k1neg: e,
                k1: i,
                k2neg: o,
                k2: s
              } = v(t), {
                p1: a,
                p2: u
              } = function(t, e, r, n) {
                let i = e,
                  o = t.ZERO,
                  s = t.ZERO;
                for (; r > ho || n > ho;) r & po && (o = o.add(i)), n & po && (s = s.add(i)), i = i.double(), r >>= po, n >>= po;
                return {
                  p1: o,
                  p2: s
                }
              }(E, n, i, s);
              return T(r.beta, a, u, e, o)
            }
            return k.unsafe(n, t)
          }
          multiplyAndAddUnsafe(t, e, r) {
            const n = this.multiplyUnsafe(e).add(t.multiplyUnsafe(r));
            return n.is0() ? void 0 : n
          }
          toAffine(t) {
            return w(this, t)
          }
          isTorsionFree() {
            const {
              isTorsionFree: t
            } = e;
            return s === Wl || (t ? t(E, this) : k.unsafe(this, a).is0())
          }
          clearCofactor() {
            const {
              clearCofactor: t
            } = e;
            return s === Wl ? this : t ? t(E, this) : this.multiplyUnsafe(s)
          }
          isSmallOrder() {
            return this.multiplyUnsafe(s).is0()
          }
          toBytes(t = !0) {
            return Pi(t, "isCompressed"), this.assertValidity(), l(E, this, t)
          }
          toHex(t = !0) {
            return Rn(this.toBytes(t))
          }
          toString() {
            return `<Point ${this.is0()?"ZERO":this.toHex()}>`
          }
          get px() {
            return this.X
          }
          get py() {
            return this.X
          }
          get pz() {
            return this.Z
          }
          toRawBytes(t = !0) {
            return this.toBytes(t)
          }
          zt(t) {
            this.precompute(t)
          }
          static normalizeZ(t) {
            return mo(E, t)
          }
          static msm(t, e) {
            return ko(E, i, t, e)
          }
          static fromPrivateKey(t) {
            return E.BASE.multiply(Nl(i, t))
          }
        }
        E.BASE = new E(o.Gx, o.Gy, n.ONE), E.ZERO = new E(n.ZERO, n.ONE, n.ZERO), E.Fp = n, E.Fn = i;
        const P = i.BITS,
          k = new Po(E, e.endo ? Math.ceil(P / 2) : P);
        return E.BASE.precompute(8), E
      }(e, r), n, i))
    }
    const Ul = {
        p: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
        n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
        h: BigInt(1),
        a: BigInt(0),
        b: BigInt(7),
        Gx: BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),
        Gy: BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")
      },
      Ll = {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        basises: [
          [BigInt("0x3086d221a7d46bcde86c90e49284eb15"), -BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],
          [BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), BigInt("0x3086d221a7d46bcde86c90e49284eb15")]
        ]
      },
      Fl = BigInt(2),
      $l = co(Ul.p, {
        sqrt: function(t) {
          const e = Ul.p,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            a = BigInt(44),
            u = BigInt(88),
            c = t * t * t % e,
            f = c * c * t % e,
            l = Qi(f, r, e) * f % e,
            h = Qi(l, r, e) * f % e,
            d = Qi(h, Fl, e) * c % e,
            p = Qi(d, i, e) * d % e,
            b = Qi(p, o, e) * p % e,
            m = Qi(b, a, e) * b % e,
            y = Qi(m, u, e) * m % e,
            g = Qi(y, a, e) * b % e,
            v = Qi(g, r, e) * f % e,
            w = Qi(v, s, e) * p % e,
            A = Qi(w, n, e) * c % e,
            T = Qi(A, Fl, e);
          if (!$l.eql($l.sqr(T), t)) throw Error("Cannot find square root");
          return T
        }
      }),
      zl = function(t, e) {
        const r = e => Dl({
          ...t,
          hash: e
        });
        return {
          ...r(e),
          create: r
        }
      }({
        ...Ul,
        Fp: $l,
        lowS: !0,
        endo: Ll
      }, wi);
    Go.utils.randomPrivateKey;
    const Hl = () => {
        const t = Go.utils.randomPrivateKey(),
          e = Gl(t),
          r = new Uint8Array(64);
        return r.set(t), r.set(e, 32), {
          publicKey: e,
          secretKey: r
        }
      },
      Gl = Go.getPublicKey;

    function Kl(t) {
      try {
        return Go.ExtendedPoint.fromHex(t), !0
      } catch {
        return !1
      }
    }
    const Vl = (t, e) => Go.sign(t, e.slice(0, 32)),
      Zl = Go.verify,
      ql = t => vn.Buffer.isBuffer(t) ? t : t instanceof Uint8Array ? vn.Buffer.from(t.buffer, t.byteOffset, t.byteLength) : vn.Buffer.from(t);
    class Jl {
      constructor(t) {
        Object.assign(this, t)
      }
      encode() {
        return vn.Buffer.from((0, as.serialize)(Yl, this))
      }
      static decode(t) {
        return (0, as.deserialize)(Yl, this, t)
      }
      static decodeUnchecked(t) {
        return (0, as.deserializeUnchecked)(Yl, this, t)
      }
    }
    const Yl = new Map;
    var Ql;
    const Xl = 32;
    let th = 1;
    class eh extends Jl {
      constructor(t) {
        if (super({}), this.ci = void 0, function(t) {
            return void 0 !== t.ci
          }(t)) this.ci = t.ci;
        else {
          if ("string" == typeof t) {
            const e = os().decode(t);
            if (e.length != Xl) throw Error("Invalid public key input");
            this.ci = new(ns())(e)
          } else this.ci = new(ns())(t);
          if (this.ci.byteLength() > Xl) throw Error("Invalid public key input")
        }
      }
      static unique() {
        const t = new eh(th);
        return th += 1, new eh(t.toBuffer())
      }
      equals(t) {
        return this.ci.eq(t.ci)
      }
      toBase58() {
        return os().encode(this.toBytes())
      }
      toJSON() {
        return this.toBase58()
      }
      toBytes() {
        const t = this.toBuffer();
        return new Uint8Array(t.buffer, t.byteOffset, t.byteLength)
      }
      toBuffer() {
        const t = this.ci.toArrayLike(vn.Buffer);
        if (t.length === Xl) return t;
        const e = vn.Buffer.alloc(32);
        return t.copy(e, 32 - t.length), e
      }
      get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
      }
      toString() {
        return this.toBase58()
      }
      static async createWithSeed(t, e, r) {
        const n = vn.Buffer.concat([t.toBuffer(), vn.Buffer.from(e), r.toBuffer()]),
          i = ss(n);
        return new eh(i)
      }
      static createProgramAddressSync(t, e) {
        let r = vn.Buffer.alloc(0);
        t.forEach(function(t) {
          if (t.length > 32) throw new TypeError("Max seed length exceeded");
          r = vn.Buffer.concat([r, ql(t)])
        }), r = vn.Buffer.concat([r, e.toBuffer(), vn.Buffer.from("ProgramDerivedAddress")]);
        const n = ss(r);
        if (Kl(n)) throw Error("Invalid seeds, address must fall off the curve");
        return new eh(n)
      }
      static async createProgramAddress(t, e) {
        return this.createProgramAddressSync(t, e)
      }
      static findProgramAddressSync(t, e) {
        let r, n = 255;
        for (; 0 != n;) {
          try {
            const i = t.concat(vn.Buffer.from([n]));
            r = this.createProgramAddressSync(i, e)
          } catch (t) {
            if (t instanceof TypeError) throw t;
            n--;
            continue
          }
          return [r, n]
        }
        throw Error("Unable to find a viable program address nonce")
      }
      static async findProgramAddress(t, e) {
        return this.findProgramAddressSync(t, e)
      }
      static isOnCurve(t) {
        return Kl(new eh(t).toBytes())
      }
    }
    Ql = eh, eh.default = new Ql("11111111111111111111111111111111"), Yl.set(eh, {
      kind: "struct",
      fields: [
        ["_bn", "u256"]
      ]
    }), new eh("BPFLoader1111111111111111111111111111111111");
    const rh = 1232;
    class nh extends Error {
      constructor(t) {
        super(`Signature ${t} has expired: block height exceeded.`), this.signature = void 0, this.signature = t
      }
    }
    Object.defineProperty(nh.prototype, "name", {
      value: "TransactionExpiredBlockheightExceededError"
    });
    class ih extends Error {
      constructor(t, e) {
        super(`Transaction was not confirmed in ${e.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${t} using the Solana Explorer or CLI tools.`), this.signature = void 0, this.signature = t
      }
    }
    Object.defineProperty(ih.prototype, "name", {
      value: "TransactionExpiredTimeoutError"
    });
    class oh extends Error {
      constructor(t) {
        super(`Signature ${t} has expired: the nonce is no longer valid.`), this.signature = void 0, this.signature = t
      }
    }
    Object.defineProperty(oh.prototype, "name", {
      value: "TransactionExpiredNonceInvalidError"
    });
    class sh {
      constructor(t, e) {
        this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = t, this.accountKeysFromLookups = e
      }
      keySegments() {
        const t = [this.staticAccountKeys];
        return this.accountKeysFromLookups && (t.push(this.accountKeysFromLookups.writable), t.push(this.accountKeysFromLookups.readonly)), t
      }
      get(t) {
        for (const e of this.keySegments()) {
          if (t < e.length) return e[t];
          t -= e.length
        }
      }
      get length() {
        return this.keySegments().flat().length
      }
      compileInstructions(t) {
        if (this.length > 256) throw Error("Account index overflow encountered during compilation");
        const e = new Map;
        this.keySegments().flat().forEach((t, r) => {
          e.set(t.toBase58(), r)
        });
        const r = t => {
          const r = e.get(t.toBase58());
          if (void 0 === r) throw Error("Encountered an unknown instruction account key during compilation");
          return r
        };
        return t.map(t => ({
          programIdIndex: r(t.programId),
          accountKeyIndexes: t.keys.map(t => r(t.pubkey)),
          data: t.data
        }))
      }
    }
    const ah = (t = "publicKey") => us.av(32, t),
      uh = (t = "signature") => us.av(64, t),
      ch = (t = "string") => {
        const e = us.w3([us.DH("length"), us.DH("lengthPadding"), us.av(us.cY(us.DH(), -8), "chars")], t),
          r = e.decode.bind(e),
          n = e.encode.bind(e),
          i = e;
        return i.decode = (t, e) => r(t, e).chars.toString(), i.encode = (t, e, r) => {
          const i = {
            chars: vn.Buffer.from(t, "utf8")
          };
          return n(i, e, r)
        }, i.alloc = t => us.DH().span + us.DH().span + vn.Buffer.from(t, "utf8").length, i
      };

    function fh(t, e) {
      const r = t => {
        if (t.span >= 0) return t.span;
        if ("function" == typeof t.alloc) return t.alloc(e[t.property]);
        if ("count" in t && "elementLayout" in t) {
          const n = e[t.property];
          if (Array.isArray(n)) return n.length * r(t.elementLayout)
        } else if ("fields" in t) return fh({
          layout: t
        }, e[t.property]);
        return 0
      };
      let n = 0;
      return t.layout.fields.forEach(t => {
        n += r(t)
      }), n
    }

    function lh(t) {
      let e = 0,
        r = 0;
      for (;;) {
        let n = t.shift();
        if (e |= (127 & n) << 7 * r, r += 1, !(128 & n)) break
      }
      return e
    }

    function hh(t, e) {
      let r = e;
      for (;;) {
        let e = 127 & r;
        if (r >>= 7, 0 == r) {
          t.push(e);
          break
        }
        e |= 128, t.push(e)
      }
    }

    function dh(t, e) {
      if (!t) throw Error(e || "Assertion failed")
    }
    class ph {
      constructor(t, e) {
        this.payer = void 0, this.keyMetaMap = void 0, this.payer = t, this.keyMetaMap = e
      }
      static compile(t, e) {
        const r = new Map,
          n = t => {
            const e = t.toBase58();
            let n = r.get(e);
            return void 0 === n && (n = {
              isSigner: !1,
              isWritable: !1,
              isInvoked: !1
            }, r.set(e, n)), n
          },
          i = n(e);
        i.isSigner = !0, i.isWritable = !0;
        for (const e of t) {
          n(e.programId).isInvoked = !0;
          for (const t of e.keys) {
            const e = n(t.pubkey);
            e.isSigner ||= t.isSigner, e.isWritable ||= t.isWritable
          }
        }
        return new ph(e, r)
      }
      getMessageComponents() {
        const t = [...this.keyMetaMap.entries()];
        dh(256 >= t.length, "Max static account keys length exceeded");
        const e = t.filter(([, t]) => t.isSigner && t.isWritable),
          r = t.filter(([, t]) => t.isSigner && !t.isWritable),
          n = t.filter(([, t]) => !t.isSigner && t.isWritable),
          i = t.filter(([, t]) => !t.isSigner && !t.isWritable),
          o = {
            numRequiredSignatures: e.length + r.length,
            numReadonlySignedAccounts: r.length,
            numReadonlyUnsignedAccounts: i.length
          };
        {
          dh(e.length > 0, "Expected at least one writable signer key");
          const [t] = e[0];
          dh(t === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        return [o, [...e.map(([t]) => new eh(t)), ...r.map(([t]) => new eh(t)), ...n.map(([t]) => new eh(t)), ...i.map(([t]) => new eh(t))]]
      }
      extractTableLookup(t) {
        const [e, r] = this.drainKeysFoundInLookupTable(t.state.addresses, t => !t.isSigner && !t.isInvoked && t.isWritable), [n, i] = this.drainKeysFoundInLookupTable(t.state.addresses, t => !t.isSigner && !t.isInvoked && !t.isWritable);
        if (0 !== e.length || 0 !== n.length) return [{
          accountKey: t.key,
          writableIndexes: e,
          readonlyIndexes: n
        }, {
          writable: r,
          readonly: i
        }]
      }
      drainKeysFoundInLookupTable(t, e) {
        const r = [],
          n = [];
        for (const [i, o] of this.keyMetaMap.entries())
          if (e(o)) {
            const e = new eh(i),
              o = t.findIndex(t => t.equals(e));
            o >= 0 && (dh(256 > o, "Max lookup table index exceeded"), r.push(o), n.push(e), this.keyMetaMap.delete(i))
          } return [r, n]
      }
    }
    const bh = "Reached end of buffer unexpectedly";

    function mh(t) {
      if (0 === t.length) throw Error(bh);
      return t.shift()
    }

    function yh(t, ...e) {
      const [r] = e;
      if (2 === e.length ? r + (e[1] ?? 0) > t.length : r >= t.length) throw Error(bh);
      return t.splice(...e)
    }
    class gh {
      constructor(t) {
        this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = new Map, this.header = t.header, this.accountKeys = t.accountKeys.map(t => new eh(t)), this.recentBlockhash = t.recentBlockhash, this.instructions = t.instructions, this.instructions.forEach(t => this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]))
      }
      get version() {
        return "legacy"
      }
      get staticAccountKeys() {
        return this.accountKeys
      }
      get compiledInstructions() {
        return this.instructions.map(t => ({
          programIdIndex: t.programIdIndex,
          accountKeyIndexes: t.accounts,
          data: os().decode(t.data)
        }))
      }
      get addressTableLookups() {
        return []
      }
      getAccountKeys() {
        return new sh(this.staticAccountKeys)
      }
      static compile(t) {
        const e = ph.compile(t.instructions, t.payerKey),
          [r, n] = e.getMessageComponents(),
          i = new sh(n).compileInstructions(t.instructions).map(t => ({
            programIdIndex: t.programIdIndex,
            accounts: t.accountKeyIndexes,
            data: os().encode(t.data)
          }));
        return new gh({
          header: r,
          accountKeys: n,
          recentBlockhash: t.recentBlockhash,
          instructions: i
        })
      }
      isAccountSigner(t) {
        return t < this.header.numRequiredSignatures
      }
      isAccountWritable(t) {
        const e = this.header.numRequiredSignatures;
        if (t < this.header.numRequiredSignatures) return e - this.header.numReadonlySignedAccounts > t;
        {
          const r = t - e;
          return this.accountKeys.length - e - this.header.numReadonlyUnsignedAccounts > r
        }
      }
      isProgramId(t) {
        return this.indexToProgramIds.has(t)
      }
      programIds() {
        return [...this.indexToProgramIds.values()]
      }
      nonProgramIds() {
        return this.accountKeys.filter((t, e) => !this.isProgramId(e))
      }
      serialize() {
        const t = this.accountKeys.length;
        let e = [];
        hh(e, t);
        const r = this.instructions.map(t => {
          const {
            accounts: e,
            programIdIndex: r
          } = t, n = Array.from(os().decode(t.data));
          let i = [];
          hh(i, e.length);
          let o = [];
          return hh(o, n.length), {
            programIdIndex: r,
            keyIndicesCount: vn.Buffer.from(i),
            keyIndices: e,
            dataLength: vn.Buffer.from(o),
            data: n
          }
        });
        let n = [];
        hh(n, r.length);
        let i = vn.Buffer.alloc(rh);
        vn.Buffer.from(n).copy(i);
        let o = n.length;
        r.forEach(t => {
          const e = us.w3([us.u8("programIdIndex"), us.av(t.keyIndicesCount.length, "keyIndicesCount"), us.O6(us.u8("keyIndex"), t.keyIndices.length, "keyIndices"), us.av(t.dataLength.length, "dataLength"), us.O6(us.u8("userdatum"), t.data.length, "data")]).encode(t, i, o);
          o += e
        }), i = i.slice(0, o);
        const s = us.w3([us.av(1, "numRequiredSignatures"), us.av(1, "numReadonlySignedAccounts"), us.av(1, "numReadonlyUnsignedAccounts"), us.av(e.length, "keyCount"), us.O6(ah("key"), t, "keys"), ah("recentBlockhash")]),
          a = {
            numRequiredSignatures: vn.Buffer.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: vn.Buffer.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: vn.Buffer.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: vn.Buffer.from(e),
            keys: this.accountKeys.map(t => ql(t.toBytes())),
            recentBlockhash: os().decode(this.recentBlockhash)
          };
        let u = vn.Buffer.alloc(2048);
        const c = s.encode(a, u);
        return i.copy(u, c), u.slice(0, c + i.length)
      }
      static from(t) {
        let e = [...t];
        const r = mh(e);
        if (r !== (127 & r)) throw Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const n = mh(e),
          i = mh(e),
          o = lh(e);
        let s = [];
        for (let t = 0; o > t; t++) {
          const t = yh(e, 0, Xl);
          s.push(new eh(vn.Buffer.from(t)))
        }
        const a = yh(e, 0, Xl),
          u = lh(e);
        let c = [];
        for (let t = 0; u > t; t++) {
          const t = mh(e),
            r = yh(e, 0, lh(e)),
            n = yh(e, 0, lh(e)),
            i = os().encode(vn.Buffer.from(n));
          c.push({
            programIdIndex: t,
            accounts: r,
            data: i
          })
        }
        const f = {
          header: {
            numRequiredSignatures: r,
            numReadonlySignedAccounts: n,
            numReadonlyUnsignedAccounts: i
          },
          recentBlockhash: os().encode(vn.Buffer.from(a)),
          accountKeys: s,
          instructions: c
        };
        return new gh(f)
      }
    }
    class vh {
      constructor(t) {
        this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = t.header, this.staticAccountKeys = t.staticAccountKeys, this.recentBlockhash = t.recentBlockhash, this.compiledInstructions = t.compiledInstructions, this.addressTableLookups = t.addressTableLookups
      }
      get version() {
        return 0
      }
      get numAccountKeysFromLookups() {
        let t = 0;
        for (const e of this.addressTableLookups) t += e.readonlyIndexes.length + e.writableIndexes.length;
        return t
      }
      getAccountKeys(t) {
        let e;
        if (t && "accountKeysFromLookups" in t && t.accountKeysFromLookups) {
          if (this.numAccountKeysFromLookups != t.accountKeysFromLookups.writable.length + t.accountKeysFromLookups.readonly.length) throw Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
          e = t.accountKeysFromLookups
        } else if (t && "addressLookupTableAccounts" in t && t.addressLookupTableAccounts) e = this.resolveAddressTableLookups(t.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0) throw Error("Failed to get account keys because address table lookups were not resolved");
        return new sh(this.staticAccountKeys, e)
      }
      isAccountSigner(t) {
        return t < this.header.numRequiredSignatures
      }
      isAccountWritable(t) {
        const e = this.header.numRequiredSignatures,
          r = this.staticAccountKeys.length;
        if (r > t) {
          if (t < this.header.numRequiredSignatures) return e - this.header.numReadonlySignedAccounts > t;
          {
            const n = t - e;
            return r - e - this.header.numReadonlyUnsignedAccounts > n
          }
        } {
          const e = t - r;
          return this.addressTableLookups.reduce((t, e) => t + e.writableIndexes.length, 0) > e
        }
      }
      resolveAddressTableLookups(t) {
        const e = {
          writable: [],
          readonly: []
        };
        for (const r of this.addressTableLookups) {
          const n = t.find(t => t.key.equals(r.accountKey));
          if (!n) throw Error("Failed to find address lookup table account for table key " + r.accountKey.toBase58());
          for (const t of r.writableIndexes) {
            if (t >= n.state.addresses.length) throw Error(`Failed to find address for index ${t} in address lookup table ${r.accountKey.toBase58()}`);
            e.writable.push(n.state.addresses[t])
          }
          for (const t of r.readonlyIndexes) {
            if (t >= n.state.addresses.length) throw Error(`Failed to find address for index ${t} in address lookup table ${r.accountKey.toBase58()}`);
            e.readonly.push(n.state.addresses[t])
          }
        }
        return e
      }
      static compile(t) {
        const e = ph.compile(t.instructions, t.payerKey),
          r = [],
          n = {
            writable: [],
            readonly: []
          },
          i = t.addressLookupTableAccounts || [];
        for (const t of i) {
          const i = e.extractTableLookup(t);
          if (void 0 !== i) {
            const [t, {
              writable: e,
              readonly: o
            }] = i;
            r.push(t), n.writable.push(...e), n.readonly.push(...o)
          }
        }
        const [o, s] = e.getMessageComponents(), a = new sh(s, n).compileInstructions(t.instructions);
        return new vh({
          header: o,
          staticAccountKeys: s,
          recentBlockhash: t.recentBlockhash,
          compiledInstructions: a,
          addressTableLookups: r
        })
      }
      serialize() {
        const t = [];
        hh(t, this.staticAccountKeys.length);
        const e = this.serializeInstructions(),
          r = [];
        hh(r, this.compiledInstructions.length);
        const n = this.serializeAddressTableLookups(),
          i = [];
        hh(i, this.addressTableLookups.length);
        const o = us.w3([us.u8("prefix"), us.w3([us.u8("numRequiredSignatures"), us.u8("numReadonlySignedAccounts"), us.u8("numReadonlyUnsignedAccounts")], "header"), us.av(t.length, "staticAccountKeysLength"), us.O6(ah(), this.staticAccountKeys.length, "staticAccountKeys"), ah("recentBlockhash"), us.av(r.length, "instructionsLength"), us.av(e.length, "serializedInstructions"), us.av(i.length, "addressTableLookupsLength"), us.av(n.length, "serializedAddressTableLookups")]),
          s = new Uint8Array(rh),
          a = o.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array(t),
            staticAccountKeys: this.staticAccountKeys.map(t => t.toBytes()),
            recentBlockhash: os().decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(r),
            serializedInstructions: e,
            addressTableLookupsLength: new Uint8Array(i),
            serializedAddressTableLookups: n
          }, s);
        return s.slice(0, a)
      }
      serializeInstructions() {
        let t = 0;
        const e = new Uint8Array(rh);
        for (const r of this.compiledInstructions) {
          const n = [];
          hh(n, r.accountKeyIndexes.length);
          const i = [];
          hh(i, r.data.length), t += us.w3([us.u8("programIdIndex"), us.av(n.length, "encodedAccountKeyIndexesLength"), us.O6(us.u8(), r.accountKeyIndexes.length, "accountKeyIndexes"), us.av(i.length, "encodedDataLength"), us.av(r.data.length, "data")]).encode({
            programIdIndex: r.programIdIndex,
            encodedAccountKeyIndexesLength: new Uint8Array(n),
            accountKeyIndexes: r.accountKeyIndexes,
            encodedDataLength: new Uint8Array(i),
            data: r.data
          }, e, t)
        }
        return e.slice(0, t)
      }
      serializeAddressTableLookups() {
        let t = 0;
        const e = new Uint8Array(rh);
        for (const r of this.addressTableLookups) {
          const n = [];
          hh(n, r.writableIndexes.length);
          const i = [];
          hh(i, r.readonlyIndexes.length), t += us.w3([ah("accountKey"), us.av(n.length, "encodedWritableIndexesLength"), us.O6(us.u8(), r.writableIndexes.length, "writableIndexes"), us.av(i.length, "encodedReadonlyIndexesLength"), us.O6(us.u8(), r.readonlyIndexes.length, "readonlyIndexes")]).encode({
            accountKey: r.accountKey.toBytes(),
            encodedWritableIndexesLength: new Uint8Array(n),
            writableIndexes: r.writableIndexes,
            encodedReadonlyIndexesLength: new Uint8Array(i),
            readonlyIndexes: r.readonlyIndexes
          }, e, t)
        }
        return e.slice(0, t)
      }
      static deserialize(t) {
        let e = [...t];
        const r = mh(e),
          n = 127 & r;
        dh(r !== n, "Expected versioned message but received legacy message"), dh(0 === n, "Expected versioned message with version 0 but found version " + n);
        const i = {
            numRequiredSignatures: mh(e),
            numReadonlySignedAccounts: mh(e),
            numReadonlyUnsignedAccounts: mh(e)
          },
          o = [],
          s = lh(e);
        for (let t = 0; s > t; t++) o.push(new eh(yh(e, 0, Xl)));
        const a = os().encode(yh(e, 0, Xl)),
          u = lh(e),
          c = [];
        for (let t = 0; u > t; t++) {
          const t = mh(e),
            r = yh(e, 0, lh(e)),
            n = lh(e),
            i = new Uint8Array(yh(e, 0, n));
          c.push({
            programIdIndex: t,
            accountKeyIndexes: r,
            data: i
          })
        }
        const f = lh(e),
          l = [];
        for (let t = 0; f > t; t++) {
          const t = new eh(yh(e, 0, Xl)),
            r = yh(e, 0, lh(e)),
            n = yh(e, 0, lh(e));
          l.push({
            accountKey: t,
            writableIndexes: r,
            readonlyIndexes: n
          })
        }
        return new vh({
          header: i,
          staticAccountKeys: o,
          recentBlockhash: a,
          compiledInstructions: c,
          addressTableLookups: l
        })
      }
    }
    const wh = {
      deserializeMessageVersion(t) {
        const e = t[0],
          r = 127 & e;
        return r === e ? "legacy" : r
      },
      deserialize: t => {
        const e = wh.deserializeMessageVersion(t);
        if ("legacy" === e) return gh.from(t);
        if (0 === e) return vh.deserialize(t);
        throw Error(`Transaction message version ${e} deserialization is not supported`)
      }
    };
    let Ah = function(t) {
      return t[t.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED", t[t.PROCESSED = 1] = "PROCESSED", t[t.TIMED_OUT = 2] = "TIMED_OUT", t[t.NONCE_INVALID = 3] = "NONCE_INVALID", t
    }({});
    const Th = vn.Buffer.alloc(64).fill(0);
    class Eh {
      constructor(t) {
        this.keys = void 0, this.programId = void 0, this.data = vn.Buffer.alloc(0), this.programId = t.programId, this.keys = t.keys, t.data && (this.data = t.data)
      }
      toJSON() {
        return {
          keys: this.keys.map(({
            pubkey: t,
            isSigner: e,
            isWritable: r
          }) => ({
            pubkey: t.toJSON(),
            isSigner: e,
            isWritable: r
          })),
          programId: this.programId.toJSON(),
          data: [...this.data]
        }
      }
    }
    class Ph {
      get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
      }
      constructor(t) {
        if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this.fi = void 0, this.li = void 0, t)
          if (t.feePayer && (this.feePayer = t.feePayer), t.signatures && (this.signatures = t.signatures), {}.hasOwnProperty.call(t, "nonceInfo")) {
            const {
              minContextSlot: e,
              nonceInfo: r
            } = t;
            this.minNonceContextSlot = e, this.nonceInfo = r
          } else if ({}.hasOwnProperty.call(t, "lastValidBlockHeight")) {
          const {
            blockhash: e,
            lastValidBlockHeight: r
          } = t;
          this.recentBlockhash = e, this.lastValidBlockHeight = r
        } else {
          const {
            recentBlockhash: e,
            nonceInfo: r
          } = t;
          r && (this.nonceInfo = r), this.recentBlockhash = e
        }
      }
      toJSON() {
        return {
          recentBlockhash: this.recentBlockhash || null,
          feePayer: this.feePayer ? this.feePayer.toJSON() : null,
          nonceInfo: this.nonceInfo ? {
            nonce: this.nonceInfo.nonce,
            nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
          } : null,
          instructions: this.instructions.map(t => t.toJSON()),
          signers: this.signatures.map(({
            publicKey: t
          }) => t.toJSON())
        }
      }
      add(...t) {
        if (0 === t.length) throw Error("No instructions");
        return t.forEach(t => {
          "instructions" in t ? this.instructions = this.instructions.concat(t.instructions) : "data" in t && "programId" in t && "keys" in t ? this.instructions.push(t) : this.instructions.push(new Eh(t))
        }), this
      }
      compileMessage() {
        if (this.fi && JSON.stringify(this.toJSON()) === JSON.stringify(this.li)) return this.fi;
        let t, e, r;
        if (this.nonceInfo ? (t = this.nonceInfo.nonce, e = this.instructions[0] != this.nonceInfo.nonceInstruction ? [this.nonceInfo.nonceInstruction, ...this.instructions] : this.instructions) : (t = this.recentBlockhash, e = this.instructions), !t) throw Error("Transaction recentBlockhash required");
        if (1 > e.length && console.warn("No instructions provided"), this.feePayer) r = this.feePayer;
        else {
          if (0 >= this.signatures.length || !this.signatures[0].publicKey) throw Error("Transaction fee payer required");
          r = this.signatures[0].publicKey
        }
        for (let t = 0; t < e.length; t++)
          if (void 0 === e[t].programId) throw Error(`Transaction instruction index ${t} has undefined program id`);
        const n = [],
          i = [];
        e.forEach(t => {
          t.keys.forEach(t => {
            i.push({
              ...t
            })
          });
          const e = t.programId.toString();
          n.includes(e) || n.push(e)
        }), n.forEach(t => {
          i.push({
            pubkey: new eh(t),
            isSigner: !1,
            isWritable: !1
          })
        });
        const o = [];
        i.forEach(t => {
          const e = t.pubkey.toString(),
            r = o.findIndex(t => t.pubkey.toString() === e);
          r > -1 ? (o[r].isWritable = o[r].isWritable || t.isWritable, o[r].isSigner = o[r].isSigner || t.isSigner) : o.push(t)
        }), o.sort(function(t, e) {
          return t.isSigner !== e.isSigner ? t.isSigner ? -1 : 1 : t.isWritable !== e.isWritable ? t.isWritable ? -1 : 1 : t.pubkey.toBase58().localeCompare(e.pubkey.toBase58(), "en", {
            localeMatcher: "best fit",
            usage: "sort",
            sensitivity: "variant",
            ignorePunctuation: !1,
            numeric: !1,
            caseFirst: "lower"
          })
        });
        const s = o.findIndex(t => t.pubkey.equals(r));
        if (s > -1) {
          const [t] = o.splice(s, 1);
          t.isSigner = !0, t.isWritable = !0, o.unshift(t)
        } else o.unshift({
          pubkey: r,
          isSigner: !0,
          isWritable: !0
        });
        for (const t of this.signatures) {
          const e = o.findIndex(e => e.pubkey.equals(t.publicKey));
          if (-1 >= e) throw Error("unknown signer: " + t.publicKey.toString());
          o[e].isSigner || (o[e].isSigner = !0, console.warn("Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release."))
        }
        let a = 0,
          u = 0,
          c = 0;
        const f = [],
          l = [];
        o.forEach(({
          pubkey: t,
          isSigner: e,
          isWritable: r
        }) => {
          e ? (f.push(t.toString()), a += 1, r || (u += 1)) : (l.push(t.toString()), r || (c += 1))
        });
        const h = f.concat(l),
          d = e.map(t => {
            const {
              data: e,
              programId: r
            } = t;
            return {
              programIdIndex: h.indexOf(r.toString()),
              accounts: t.keys.map(t => h.indexOf(t.pubkey.toString())),
              data: os().encode(e)
            }
          });
        return d.forEach(t => {
          dh(t.programIdIndex >= 0), t.accounts.forEach(t => dh(t >= 0))
        }), new gh({
          header: {
            numRequiredSignatures: a,
            numReadonlySignedAccounts: u,
            numReadonlyUnsignedAccounts: c
          },
          accountKeys: h,
          recentBlockhash: t,
          instructions: d
        })
      }
      di() {
        const t = this.compileMessage(),
          e = t.accountKeys.slice(0, t.header.numRequiredSignatures);
        return this.signatures.length === e.length && this.signatures.every((t, r) => e[r].equals(t.publicKey)) || (this.signatures = e.map(t => ({
          signature: null,
          publicKey: t
        }))), t
      }
      serializeMessage() {
        return this.di().serialize()
      }
      async getEstimatedFee(t) {
        return (await t.getFeeForMessage(this.compileMessage())).value
      }
      setSigners(...t) {
        if (0 === t.length) throw Error("No signers");
        const e = new Set;
        this.signatures = t.filter(t => {
          const r = t.toString();
          return !e.has(r) && (e.add(r), !0)
        }).map(t => ({
          signature: null,
          publicKey: t
        }))
      }
      sign(...t) {
        if (0 === t.length) throw Error("No signers");
        const e = new Set,
          r = [];
        for (const n of t) {
          const t = n.publicKey.toString();
          e.has(t) || (e.add(t), r.push(n))
        }
        this.signatures = r.map(t => ({
          signature: null,
          publicKey: t.publicKey
        }));
        const n = this.di();
        this.pi(n, ...r)
      }
      partialSign(...t) {
        if (0 === t.length) throw Error("No signers");
        const e = new Set,
          r = [];
        for (const n of t) {
          const t = n.publicKey.toString();
          e.has(t) || (e.add(t), r.push(n))
        }
        const n = this.di();
        this.pi(n, ...r)
      }
      pi(t, ...e) {
        const r = t.serialize();
        e.forEach(t => {
          const e = Vl(r, t.secretKey);
          this.bi(t.publicKey, ql(e))
        })
      }
      addSignature(t, e) {
        this.di(), this.bi(t, e)
      }
      bi(t, e) {
        dh(64 === e.length);
        const r = this.signatures.findIndex(e => t.equals(e.publicKey));
        if (0 > r) throw Error("unknown signer: " + t.toString());
        this.signatures[r].signature = vn.Buffer.from(e)
      }
      verifySignatures(t = !0) {
        return !this.mi(this.serializeMessage(), t)
      }
      mi(t, e) {
        const r = {};
        for (const {
            signature: n,
            publicKey: i
          }
          of this.signatures) null === n ? e && (r.missing ||= []).push(i) : Zl(n, t, i.toBytes()) || (r.invalid ||= []).push(i);
        return r.invalid || r.missing ? r : void 0
      }
      serialize(t) {
        const {
          requireAllSignatures: e,
          verifySignatures: r
        } = Object.assign({
          requireAllSignatures: !0,
          verifySignatures: !0
        }, t), n = this.serializeMessage();
        if (r) {
          const t = this.mi(n, e);
          if (t) {
            let e = "Signature verification failed.";
            throw t.invalid && (e += `\nInvalid signature for public key${1===t.invalid.length?"":"(s)"} [\`${t.invalid.map(t=>t.toBase58()).join("`, `")}\`].`), t.missing && (e += `\nMissing signature for public key${1===t.missing.length?"":"(s)"} [\`${t.missing.map(t=>t.toBase58()).join("`, `")}\`].`), Error(e)
          }
        }
        return this.yi(n)
      }
      yi(t) {
        const {
          signatures: e
        } = this, r = [];
        hh(r, e.length);
        const n = r.length + 64 * e.length + t.length,
          i = vn.Buffer.alloc(n);
        return dh(256 > e.length), vn.Buffer.from(r).copy(i, 0), e.forEach(({
          signature: t
        }, e) => {
          null !== t && (dh(64 === t.length, "signature has invalid length"), vn.Buffer.from(t).copy(i, r.length + 64 * e))
        }), t.copy(i, r.length + 64 * e.length), dh(i.length <= rh, `Transaction too large: ${i.length} > 1232`), i
      }
      get keys() {
        return dh(1 === this.instructions.length), this.instructions[0].keys.map(t => t.pubkey)
      }
      get programId() {
        return dh(1 === this.instructions.length), this.instructions[0].programId
      }
      get data() {
        return dh(1 === this.instructions.length), this.instructions[0].data
      }
      static from(t) {
        let e = [...t];
        const r = lh(e);
        let n = [];
        for (let t = 0; r > t; t++) {
          const t = yh(e, 0, 64);
          n.push(os().encode(vn.Buffer.from(t)))
        }
        return Ph.populate(gh.from(e), n)
      }
      static populate(t, e = []) {
        const r = new Ph;
        return r.recentBlockhash = t.recentBlockhash, t.header.numRequiredSignatures > 0 && (r.feePayer = t.accountKeys[0]), e.forEach((e, n) => {
          const i = {
            signature: e == os().encode(Th) ? null : os().decode(e),
            publicKey: t.accountKeys[n]
          };
          r.signatures.push(i)
        }), t.instructions.forEach(e => {
          const n = e.accounts.map(e => {
            const n = t.accountKeys[e];
            return {
              pubkey: n,
              isSigner: r.signatures.some(t => t.publicKey.toString() === n.toString()) || t.isAccountSigner(e),
              isWritable: t.isAccountWritable(e)
            }
          });
          r.instructions.push(new Eh({
            keys: n,
            programId: t.accountKeys[e.programIdIndex],
            data: os().decode(e.data)
          }))
        }), r.fi = t, r.li = r.toJSON(), r
      }
    }
    class kh {
      get version() {
        return this.message.version
      }
      constructor(t, e) {
        if (this.signatures = void 0, this.message = void 0, void 0 !== e) dh(e.length === t.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"), this.signatures = e;
        else {
          const e = [];
          for (let r = 0; r < t.header.numRequiredSignatures; r++) e.push(new Uint8Array(64));
          this.signatures = e
        }
        this.message = t
      }
      serialize() {
        const t = this.message.serialize(),
          e = [];
        hh(e, this.signatures.length);
        const r = us.w3([us.av(e.length, "encodedSignaturesLength"), us.O6(uh(), this.signatures.length, "signatures"), us.av(t.length, "serializedMessage")]),
          n = new Uint8Array(2048),
          i = r.encode({
            encodedSignaturesLength: new Uint8Array(e),
            signatures: this.signatures,
            serializedMessage: t
          }, n);
        return n.slice(0, i)
      }
      static deserialize(t) {
        let e = [...t];
        const r = [],
          n = lh(e);
        for (let t = 0; n > t; t++) r.push(new Uint8Array(yh(e, 0, 64)));
        const i = wh.deserialize(new Uint8Array(e));
        return new kh(i, r)
      }
      sign(t) {
        const e = this.message.serialize(),
          r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const n of t) {
          const t = r.findIndex(t => t.equals(n.publicKey));
          dh(t >= 0, "Cannot sign with non signer key " + n.publicKey.toBase58()), this.signatures[t] = Vl(e, n.secretKey)
        }
      }
      addSignature(t, e) {
        dh(64 === e.byteLength, "Signature must be 64 bytes long");
        const r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(e => e.equals(t));
        dh(r >= 0, `Can not add signature; \`${t.toBase58()}\` is not required to sign this transaction`), this.signatures[r] = e
      }
    }
    const xh = new eh("SysvarC1ock11111111111111111111111111111111"),
      Ih = (new eh("SysvarEpochSchedu1e111111111111111111111111"), new eh("Sysvar1nstructions1111111111111111111111111"), new eh("SysvarRecentB1ockHashes11111111111111111111")),
      Sh = new eh("SysvarRent111111111111111111111111111111111"),
      Oh = (new eh("SysvarRewards111111111111111111111111111111"), new eh("SysvarS1otHashes111111111111111111111111111"), new eh("SysvarS1otHistory11111111111111111111111111"), new eh("SysvarStakeHistory1111111111111111111111111"));
    class Bh extends Error {
      constructor({
        action: t,
        signature: e,
        transactionMessage: r,
        logs: n
      }) {
        const i = n ? `Logs: \n${JSON.stringify(n.slice(-10),null,2)}. ` : "",
          o = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let s;
        switch (t) {
          case "send":
            s = `Transaction ${e} resulted in an error. \n${r}. ` + i + o;
            break;
          case "simulate":
            s = `Simulation failed. \nMessage: ${r}. \n` + i + o;
            break;
          default:
            s = `Unknown action '${t}'`
        }
        super(s), this.signature = void 0, this.transactionMessage = void 0, this.transactionLogs = void 0, this.signature = e, this.transactionMessage = r, this.transactionLogs = n || void 0
      }
      get transactionError() {
        return {
          message: this.transactionMessage,
          logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
      }
      get logs() {
        const t = this.transactionLogs;
        if (null == t || "object" != typeof t || !("then" in t)) return t
      }
      async getLogs(t) {
        return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise((e, r) => {
          t.getTransaction(this.signature).then(t => {
            if (t && t.meta && t.meta.logMessages) {
              const r = t.meta.logMessages;
              this.transactionLogs = r, e(r)
            } else r(Error("Log messages not found"))
          }).catch(r)
        })), await this.transactionLogs
      }
    }
    class Wh extends Error {
      constructor({
        code: t,
        message: e,
        data: r
      }, n) {
        super(null != n ? `${n}: ${e}` : e), this.code = void 0, this.data = void 0, this.code = t, this.data = r, this.name = "SolanaJSONRPCError"
      }
    }
    async function Mh(t, e, r, n) {
      const i = n && {
          skipPreflight: n.skipPreflight,
          preflightCommitment: n.preflightCommitment || n.commitment,
          maxRetries: n.maxRetries,
          minContextSlot: n.minContextSlot
        },
        o = await t.sendTransaction(e, r, i);
      let s;
      if (null != e.recentBlockhash && null != e.lastValidBlockHeight) s = (await t.confirmTransaction({
        abortSignal: n?.abortSignal,
        signature: o,
        blockhash: e.recentBlockhash,
        lastValidBlockHeight: e.lastValidBlockHeight
      }, n && n.commitment)).value;
      else if (null != e.minNonceContextSlot && null != e.nonceInfo) {
        const {
          nonceInstruction: r
        } = e.nonceInfo, i = r.keys[0].pubkey;
        s = (await t.confirmTransaction({
          abortSignal: n?.abortSignal,
          minContextSlot: e.minNonceContextSlot,
          nonceAccountPubkey: i,
          nonceValue: e.nonceInfo.nonce,
          signature: o
        }, n && n.commitment)).value
      } else null != n?.abortSignal && console.warn("sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable."), s = (await t.confirmTransaction(o, n && n.commitment)).value;
      if (s.err) throw null != o ? new Bh({
        action: "send",
        signature: o,
        transactionMessage: `Status: (${JSON.stringify(s)})`
      }) : Error(`Transaction ${o} failed (${JSON.stringify(s)})`);
      return o
    }

    function Ch(t) {
      return new Promise(e => setTimeout(e, t))
    }

    function Rh(t, e) {
      const r = 0 > t.layout.span ? fh(t, e) : t.layout.span,
        n = vn.Buffer.alloc(r),
        i = Object.assign({
          instruction: t.index
        }, e);
      return t.layout.encode(i, n), n
    }
    const Nh = us.I0("lamportsPerSignature"),
      jh = us.w3([us.DH("version"), us.DH("state"), ah("authorizedPubkey"), ah("nonce"), us.w3([Nh], "feeCalculator")]),
      _h = jh.span;
    class Dh {
      constructor(t) {
        this.authorizedPubkey = void 0, this.nonce = void 0, this.feeCalculator = void 0, this.authorizedPubkey = t.authorizedPubkey, this.nonce = t.nonce, this.feeCalculator = t.feeCalculator
      }
      static fromAccountData(t) {
        const e = jh.decode(ql(t), 0);
        return new Dh({
          authorizedPubkey: new eh(e.authorizedPubkey),
          nonce: new eh(e.nonce).toString(),
          feeCalculator: e.feeCalculator
        })
      }
    }

    function Uh(t) {
      const e = (0, us.av)(8, t),
        r = e.decode.bind(e),
        n = e.encode.bind(e),
        i = e,
        o = Of();
      return i.decode = (t, e) => {
        const n = r(t, e);
        return o.decode(n)
      }, i.encode = (t, e, r) => {
        const i = o.encode(t);
        return n(i, e, r)
      }, i
    }
    const Lh = Object.freeze({
      Create: {
        index: 0,
        layout: us.w3([us.DH("instruction"), us.Wg("lamports"), us.Wg("space"), ah("programId")])
      },
      Assign: {
        index: 1,
        layout: us.w3([us.DH("instruction"), ah("programId")])
      },
      Transfer: {
        index: 2,
        layout: us.w3([us.DH("instruction"), Uh("lamports")])
      },
      CreateWithSeed: {
        index: 3,
        layout: us.w3([us.DH("instruction"), ah("base"), ch("seed"), us.Wg("lamports"), us.Wg("space"), ah("programId")])
      },
      AdvanceNonceAccount: {
        index: 4,
        layout: us.w3([us.DH("instruction")])
      },
      WithdrawNonceAccount: {
        index: 5,
        layout: us.w3([us.DH("instruction"), us.Wg("lamports")])
      },
      InitializeNonceAccount: {
        index: 6,
        layout: us.w3([us.DH("instruction"), ah("authorized")])
      },
      AuthorizeNonceAccount: {
        index: 7,
        layout: us.w3([us.DH("instruction"), ah("authorized")])
      },
      Allocate: {
        index: 8,
        layout: us.w3([us.DH("instruction"), us.Wg("space")])
      },
      AllocateWithSeed: {
        index: 9,
        layout: us.w3([us.DH("instruction"), ah("base"), ch("seed"), us.Wg("space"), ah("programId")])
      },
      AssignWithSeed: {
        index: 10,
        layout: us.w3([us.DH("instruction"), ah("base"), ch("seed"), ah("programId")])
      },
      TransferWithSeed: {
        index: 11,
        layout: us.w3([us.DH("instruction"), Uh("lamports"), ch("seed"), ah("programId")])
      },
      UpgradeNonceAccount: {
        index: 12,
        layout: us.w3([us.DH("instruction")])
      }
    });
    class Fh {
      constructor() {}
      static createAccount(t) {
        const e = Rh(Lh.Create, {
          lamports: t.lamports,
          space: t.space,
          programId: ql(t.programId.toBuffer())
        });
        return new Eh({
          keys: [{
            pubkey: t.fromPubkey,
            isSigner: !0,
            isWritable: !0
          }, {
            pubkey: t.newAccountPubkey,
            isSigner: !0,
            isWritable: !0
          }],
          programId: this.programId,
          data: e
        })
      }
      static transfer(t) {
        let e, r;
        return "basePubkey" in t ? (e = Rh(Lh.TransferWithSeed, {
          lamports: BigInt(t.lamports),
          seed: t.seed,
          programId: ql(t.programId.toBuffer())
        }), r = [{
          pubkey: t.fromPubkey,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: t.basePubkey,
          isSigner: !0,
          isWritable: !1
        }, {
          pubkey: t.toPubkey,
          isSigner: !1,
          isWritable: !0
        }]) : (e = Rh(Lh.Transfer, {
          lamports: BigInt(t.lamports)
        }), r = [{
          pubkey: t.fromPubkey,
          isSigner: !0,
          isWritable: !0
        }, {
          pubkey: t.toPubkey,
          isSigner: !1,
          isWritable: !0
        }]), new Eh({
          keys: r,
          programId: this.programId,
          data: e
        })
      }
      static assign(t) {
        let e, r;
        return "basePubkey" in t ? (e = Rh(Lh.AssignWithSeed, {
          base: ql(t.basePubkey.toBuffer()),
          seed: t.seed,
          programId: ql(t.programId.toBuffer())
        }), r = [{
          pubkey: t.accountPubkey,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: t.basePubkey,
          isSigner: !0,
          isWritable: !1
        }]) : (e = Rh(Lh.Assign, {
          programId: ql(t.programId.toBuffer())
        }), r = [{
          pubkey: t.accountPubkey,
          isSigner: !0,
          isWritable: !0
        }]), new Eh({
          keys: r,
          programId: this.programId,
          data: e
        })
      }
      static createAccountWithSeed(t) {
        const e = Rh(Lh.CreateWithSeed, {
          base: ql(t.basePubkey.toBuffer()),
          seed: t.seed,
          lamports: t.lamports,
          space: t.space,
          programId: ql(t.programId.toBuffer())
        });
        let r = [{
          pubkey: t.fromPubkey,
          isSigner: !0,
          isWritable: !0
        }, {
          pubkey: t.newAccountPubkey,
          isSigner: !1,
          isWritable: !0
        }];
        return t.basePubkey.equals(t.fromPubkey) || r.push({
          pubkey: t.basePubkey,
          isSigner: !0,
          isWritable: !1
        }), new Eh({
          keys: r,
          programId: this.programId,
          data: e
        })
      }
      static createNonceAccount(t) {
        const e = new Ph;
        "basePubkey" in t && "seed" in t ? e.add(Fh.createAccountWithSeed({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.noncePubkey,
          basePubkey: t.basePubkey,
          seed: t.seed,
          lamports: t.lamports,
          space: _h,
          programId: this.programId
        })) : e.add(Fh.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.noncePubkey,
          lamports: t.lamports,
          space: _h,
          programId: this.programId
        }));
        const r = {
          noncePubkey: t.noncePubkey,
          authorizedPubkey: t.authorizedPubkey
        };
        return e.add(this.nonceInitialize(r)), e
      }
      static nonceInitialize(t) {
        const e = Rh(Lh.InitializeNonceAccount, {
            authorized: ql(t.authorizedPubkey.toBuffer())
          }),
          r = {
            keys: [{
              pubkey: t.noncePubkey,
              isSigner: !1,
              isWritable: !0
            }, {
              pubkey: Ih,
              isSigner: !1,
              isWritable: !1
            }, {
              pubkey: Sh,
              isSigner: !1,
              isWritable: !1
            }],
            programId: this.programId,
            data: e
          };
        return new Eh(r)
      }
      static nonceAdvance(t) {
        const e = Rh(Lh.AdvanceNonceAccount),
          r = {
            keys: [{
              pubkey: t.noncePubkey,
              isSigner: !1,
              isWritable: !0
            }, {
              pubkey: Ih,
              isSigner: !1,
              isWritable: !1
            }, {
              pubkey: t.authorizedPubkey,
              isSigner: !0,
              isWritable: !1
            }],
            programId: this.programId,
            data: e
          };
        return new Eh(r)
      }
      static nonceWithdraw(t) {
        const e = Rh(Lh.WithdrawNonceAccount, {
          lamports: t.lamports
        });
        return new Eh({
          keys: [{
            pubkey: t.noncePubkey,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: t.toPubkey,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: Ih,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: Sh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: t.authorizedPubkey,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: e
        })
      }
      static nonceAuthorize(t) {
        const e = Rh(Lh.AuthorizeNonceAccount, {
          authorized: ql(t.newAuthorizedPubkey.toBuffer())
        });
        return new Eh({
          keys: [{
            pubkey: t.noncePubkey,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: t.authorizedPubkey,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: e
        })
      }
      static allocate(t) {
        let e, r;
        return "basePubkey" in t ? (e = Rh(Lh.AllocateWithSeed, {
          base: ql(t.basePubkey.toBuffer()),
          seed: t.seed,
          space: t.space,
          programId: ql(t.programId.toBuffer())
        }), r = [{
          pubkey: t.accountPubkey,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: t.basePubkey,
          isSigner: !0,
          isWritable: !1
        }]) : (e = Rh(Lh.Allocate, {
          space: t.space
        }), r = [{
          pubkey: t.accountPubkey,
          isSigner: !0,
          isWritable: !0
        }]), new Eh({
          keys: r,
          programId: this.programId,
          data: e
        })
      }
    }
    Fh.programId = new eh("11111111111111111111111111111111");
    class $h {
      constructor() {}
      static getMinNumSignatures(t) {
        return 2 * (Math.ceil(t / $h.chunkSize) + 1 + 1)
      }
      static async load(t, e, r, n, i) {
        {
          const o = await t.getMinimumBalanceForRentExemption(i.length),
            s = await t.getAccountInfo(r.publicKey, "confirmed");
          let a = null;
          if (null !== s) {
            if (s.executable) return console.error("Program load failed, account is already executable"), !1;
            s.data.length !== i.length && (a = a || new Ph, a.add(Fh.allocate({
              accountPubkey: r.publicKey,
              space: i.length
            }))), s.owner.equals(n) || (a = a || new Ph, a.add(Fh.assign({
              accountPubkey: r.publicKey,
              programId: n
            }))), s.lamports < o && (a = a || new Ph, a.add(Fh.transfer({
              fromPubkey: e.publicKey,
              toPubkey: r.publicKey,
              lamports: o - s.lamports
            })))
          } else a = (new Ph).add(Fh.createAccount({
            fromPubkey: e.publicKey,
            newAccountPubkey: r.publicKey,
            lamports: o > 0 ? o : 1,
            space: i.length,
            programId: n
          }));
          null !== a && await Mh(t, a, [e, r], {
            commitment: "confirmed"
          })
        }
        const o = us.w3([us.DH("instruction"), us.DH("offset"), us.DH("bytesLength"), us.DH("bytesLengthPadding"), us.O6(us.u8("byte"), us.cY(us.DH(), -8), "bytes")]),
          s = $h.chunkSize;
        let a = 0,
          u = i,
          c = [];
        for (; u.length > 0;) {
          const i = u.slice(0, s),
            f = vn.Buffer.alloc(s + 16);
          o.encode({
            instruction: 0,
            offset: a,
            bytes: i,
            bytesLength: 0,
            bytesLengthPadding: 0
          }, f);
          const l = (new Ph).add({
            keys: [{
              pubkey: r.publicKey,
              isSigner: !0,
              isWritable: !0
            }],
            programId: n,
            data: f
          });
          c.push(Mh(t, l, [e, r], {
            commitment: "confirmed"
          })), t.gi.includes("solana.com") && await Ch(250), a += s, u = u.slice(s)
        }
        await Promise.all(c);
        {
          const i = us.w3([us.DH("instruction")]),
            o = vn.Buffer.alloc(i.span);
          i.encode({
            instruction: 1
          }, o);
          const s = (new Ph).add({
              keys: [{
                pubkey: r.publicKey,
                isSigner: !0,
                isWritable: !0
              }, {
                pubkey: Sh,
                isSigner: !1,
                isWritable: !1
              }],
              programId: n,
              data: o
            }),
            a = "processed",
            u = await t.sendTransaction(s, [e, r], {
              preflightCommitment: a
            }),
            {
              context: c,
              value: f
            } = await t.confirmTransaction({
              signature: u,
              lastValidBlockHeight: s.lastValidBlockHeight,
              blockhash: s.recentBlockhash
            }, a);
          if (f.err) throw Error(`Transaction ${u} failed (${JSON.stringify(f)})`);
          for (;;) {
            try {
              if (await t.getSlot({
                  commitment: a
                }) > c.slot) break
            } catch {}
            await new Promise(t => setTimeout(t, 200))
          }
        }
        return !0
      }
    }
    var zh, Hh;
    $h.chunkSize = 932, new eh("BPFLoader2111111111111111111111111111111111");
    var Gh = function() {
        if (Hh) return zh;
        Hh = 1;
        var t = {}.toString,
          e = Object.keys || function(t) {
            var e = [];
            for (var r in t) e.push(r);
            return e
          };

        function r(n, i) {
          var o, s, a, u, c, f, l;
          if (!0 === n) return "true";
          if (!1 === n) return "false";
          switch (typeof n) {
            case "object":
              if (null === n) return null;
              if (n.toJSON && "function" == typeof n.toJSON) return r(n.toJSON(), i);
              if ("[object Array]" === (l = t.call(n))) {
                for (a = "[", s = n.length - 1, o = 0; s > o; o++) a += r(n[o], !0) + ",";
                return s > -1 && (a += r(n[o], !0)), a + "]"
              }
              if ("[object Object]" === l) {
                for (s = (u = e(n).sort()).length, a = "", o = 0; s > o;) void 0 !== (f = r(n[c = u[o]], !1)) && (a && (a += ","), a += JSON.stringify(c) + ":" + f), o++;
                return "{" + a + "}"
              }
              return JSON.stringify(n);
            case "function":
            case "undefined":
              return i ? null : void 0;
            case "string":
              return JSON.stringify(n);
            default:
              return isFinite(n) ? n : null
          }
        }
        return zh = function(t) {
          var e = r(t, !1);
          if (void 0 !== e) return "" + e
        }
      }(),
      Kh = function(t) {
        return t && t._ && {}.hasOwnProperty.call(t, "default") ? t.default : t
      }(Gh);

    function Vh(t) {
      let e = 0;
      for (; t > 1;) t /= 2, e++;
      return e
    }
    class Zh {
      constructor(t, e, r, n, i) {
        this.slotsPerEpoch = void 0, this.leaderScheduleSlotOffset = void 0, this.warmup = void 0, this.firstNormalEpoch = void 0, this.firstNormalSlot = void 0, this.slotsPerEpoch = t, this.leaderScheduleSlotOffset = e, this.warmup = r, this.firstNormalEpoch = n, this.firstNormalSlot = i
      }
      getEpoch(t) {
        return this.getEpochAndSlotIndex(t)[0]
      }
      getEpochAndSlotIndex(t) {
        if (t < this.firstNormalSlot) {
          const e = Vh(function(t) {
            return 0 === t ? 1 : (t--, t |= t >> 1, t |= t >> 2, t |= t >> 4, t |= t >> 8, t |= t >> 16, 1 + (t |= t >> 32))
          }(t + 32 + 1)) - Vh(32) - 1;
          return [e, t - (this.getSlotsInEpoch(e) - 32)]
        } {
          const e = t - this.firstNormalSlot,
            r = Math.floor(e / this.slotsPerEpoch);
          return [this.firstNormalEpoch + r, e % this.slotsPerEpoch]
        }
      }
      getFirstSlotInEpoch(t) {
        return t > this.firstNormalEpoch ? (t - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot : 32 * (Math.pow(2, t) - 1)
      }
      getLastSlotInEpoch(t) {
        return this.getFirstSlotInEpoch(t) + this.getSlotsInEpoch(t) - 1
      }
      getSlotsInEpoch(t) {
        return t < this.firstNormalEpoch ? Math.pow(2, t + Vh(32)) : this.slotsPerEpoch
      }
    }
    var qh = globalThis.fetch;
    class Jh extends al {
      constructor(t, e, r) {
        super(t => {
          const r = function(t, e) {
            return new ol(t, e)
          }(t, {
            autoconnect: !0,
            max_reconnects: 5,
            reconnect: !0,
            reconnect_interval: 1e3,
            ...e
          });
          return this.underlyingSocket = "socket" in r ? r.socket : r, r
        }, t, e, r), this.underlyingSocket = void 0
      }
      call(...t) {
        const e = this.underlyingSocket?.readyState;
        return 1 === e ? super.call(...t) : Promise.reject(Error("Tried to call a JSON-RPC method `" + t[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + e + ")"))
      }
      notify(...t) {
        const e = this.underlyingSocket?.readyState;
        return 1 === e ? super.notify(...t) : Promise.reject(Error("Tried to send a JSON-RPC notification `" + t[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + e + ")"))
      }
    }
    class Yh {
      constructor(t) {
        this.key = void 0, this.state = void 0, this.key = t.key, this.state = t.state
      }
      isActive() {
        const t = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === t
      }
      static deserialize(t) {
        const e = function(t, e) {
            let r;
            try {
              r = t.layout.decode(e)
            } catch (t) {
              throw Error("invalid instruction; " + t)
            }
            if (r.typeIndex !== t.index) throw Error(`invalid account data; account type mismatch ${r.typeIndex} != ${t.index}`);
            return r
          }(Qh, t),
          r = t.length - 56;
        dh(r >= 0, "lookup table is invalid"), dh(r % 32 == 0, "lookup table is invalid");
        const n = r / 32,
          {
            addresses: i
          } = us.w3([us.O6(ah(), n, "addresses")]).decode(t.slice(56));
        return {
          deactivationSlot: e.deactivationSlot,
          lastExtendedSlot: e.lastExtendedSlot,
          lastExtendedSlotStartIndex: e.lastExtendedStartIndex,
          authority: 0 !== e.authority.length ? new eh(e.authority[0]) : void 0,
          addresses: i.map(t => new eh(t))
        }
      }
    }
    const Qh = {
        index: 1,
        layout: us.w3([us.DH("typeIndex"), Uh("deactivationSlot"), us.I0("lastExtendedSlot"), us.u8("lastExtendedStartIndex"), us.u8(), us.O6(ah(), us.cY(us.u8(), -1), "authority")])
      },
      Xh = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i,
      td = el(Hf(eh), Jf(), t => new eh(t)),
      ed = Yf([Jf(), Gf("base64")]),
      rd = el(Hf(vn.Buffer), ed, t => vn.Buffer.from(t[0], "base64"));

    function nd(t) {
      let e, r;
      if ("string" == typeof t) e = t;
      else if (t) {
        const {
          commitment: n,
          ...i
        } = t;
        e = n, r = i
      }
      return {
        commitment: e,
        config: r
      }
    }

    function id(t) {
      return t.map(t => "memcmp" in t ? {
        ...t,
        memcmp: {
          ...t.memcmp,
          encoding: t.memcmp.encoding ?? "base58"
        }
      } : t)
    }

    function od(t) {
      return Xf([Qf({
        jsonrpc: Gf("2.0"),
        id: Jf(),
        result: t
      }), Qf({
        jsonrpc: Gf("2.0"),
        id: Jf(),
        error: Qf({
          code: tl(),
          message: Jf(),
          data: Zf(Ff("any", () => !0))
        })
      })])
    }
    const sd = od(tl());

    function ad(t) {
      return el(od(t), sd, e => "error" in e ? e : {
        ...e,
        result: Df(e.result, t)
      })
    }

    function ud(t) {
      return ad(Qf({
        context: Qf({
          slot: Vf()
        }),
        value: t
      }))
    }

    function cd(t) {
      return Qf({
        context: Qf({
          slot: Vf()
        }),
        value: t
      })
    }

    function fd(t, e) {
      return 0 === t ? new vh({
        header: e.header,
        staticAccountKeys: e.accountKeys.map(t => new eh(t)),
        recentBlockhash: e.recentBlockhash,
        compiledInstructions: e.instructions.map(t => ({
          programIdIndex: t.programIdIndex,
          accountKeyIndexes: t.accounts,
          data: os().decode(t.data)
        })),
        addressTableLookups: e.addressTableLookups
      }) : new gh(e)
    }
    const ld = Qf({
        foundation: Vf(),
        foundationTerm: Vf(),
        initial: Vf(),
        taper: Vf(),
        terminal: Vf()
      }),
      hd = ad($f(Kf(Qf({
        epoch: Vf(),
        effectiveSlot: Vf(),
        amount: Vf(),
        postBalance: Vf(),
        commission: Zf(Kf(Vf()))
      })))),
      dd = $f(Qf({
        slot: Vf(),
        prioritizationFee: Vf()
      })),
      pd = Qf({
        total: Vf(),
        validator: Vf(),
        foundation: Vf(),
        epoch: Vf()
      }),
      bd = Qf({
        epoch: Vf(),
        slotIndex: Vf(),
        slotsInEpoch: Vf(),
        absoluteSlot: Vf(),
        blockHeight: Zf(Vf()),
        transactionCount: Zf(Vf())
      }),
      md = Qf({
        slotsPerEpoch: Vf(),
        leaderScheduleSlotOffset: Vf(),
        warmup: zf(),
        firstNormalEpoch: Vf(),
        firstNormalSlot: Vf()
      }),
      yd = qf(Jf(), $f(Vf())),
      gd = Kf(Xf([Qf({}), Jf()])),
      vd = Qf({
        err: gd
      }),
      wd = Gf("receivedSignature"),
      Ad = Qf({
        "solana-core": Jf(),
        "feature-set": Zf(Vf())
      }),
      Td = Qf({
        program: Jf(),
        programId: td,
        parsed: tl()
      }),
      Ed = Qf({
        programId: td,
        accounts: $f(td),
        data: Jf()
      }),
      Pd = ud(Qf({
        err: Kf(Xf([Qf({}), Jf()])),
        logs: Kf($f(Jf())),
        accounts: Zf(Kf($f(Kf(Qf({
          executable: zf(),
          owner: Jf(),
          lamports: Vf(),
          data: $f(Jf()),
          rentEpoch: Zf(Vf())
        }))))),
        unitsConsumed: Zf(Vf()),
        returnData: Zf(Kf(Qf({
          programId: Jf(),
          data: Yf([Jf(), Gf("base64")])
        }))),
        innerInstructions: Zf(Kf($f(Qf({
          index: Vf(),
          instructions: $f(Xf([Td, Ed]))
        }))))
      })),
      kd = ud(Qf({
        byIdentity: qf(Jf(), $f(Vf())),
        range: Qf({
          firstSlot: Vf(),
          lastSlot: Vf()
        })
      })),
      xd = ad(ld),
      Id = ad(pd),
      Sd = ad(dd),
      Od = ad(bd),
      Bd = ad(md),
      Wd = ad(yd),
      Md = ad(Vf()),
      Cd = ud(Qf({
        total: Vf(),
        circulating: Vf(),
        nonCirculating: Vf(),
        nonCirculatingAccounts: $f(td)
      })),
      Rd = Qf({
        amount: Jf(),
        uiAmount: Kf(Vf()),
        decimals: Vf(),
        uiAmountString: Zf(Jf())
      }),
      Nd = ud($f(Qf({
        address: td,
        amount: Jf(),
        uiAmount: Kf(Vf()),
        decimals: Vf(),
        uiAmountString: Zf(Jf())
      }))),
      jd = ud($f(Qf({
        pubkey: td,
        account: Qf({
          executable: zf(),
          owner: td,
          lamports: Vf(),
          data: rd,
          rentEpoch: Vf()
        })
      }))),
      _d = Qf({
        program: Jf(),
        parsed: tl(),
        space: Vf()
      }),
      Dd = ud($f(Qf({
        pubkey: td,
        account: Qf({
          executable: zf(),
          owner: td,
          lamports: Vf(),
          data: _d,
          rentEpoch: Vf()
        })
      }))),
      Ud = ud($f(Qf({
        lamports: Vf(),
        address: td
      }))),
      Ld = Qf({
        executable: zf(),
        owner: td,
        lamports: Vf(),
        data: rd,
        rentEpoch: Vf()
      }),
      Fd = Qf({
        pubkey: td,
        account: Ld
      }),
      $d = el(Xf([Hf(vn.Buffer), _d]), Xf([ed, _d]), t => Array.isArray(t) ? Df(t, rd) : t),
      zd = Qf({
        executable: zf(),
        owner: td,
        lamports: Vf(),
        data: $d,
        rentEpoch: Vf()
      }),
      Hd = Qf({
        pubkey: td,
        account: zd
      }),
      Gd = Qf({
        state: Xf([Gf("active"), Gf("inactive"), Gf("activating"), Gf("deactivating")]),
        active: Vf(),
        inactive: Vf()
      }),
      Kd = ad($f(Qf({
        signature: Jf(),
        slot: Vf(),
        err: gd,
        memo: Kf(Jf()),
        blockTime: Zf(Kf(Vf()))
      }))),
      Vd = ad($f(Qf({
        signature: Jf(),
        slot: Vf(),
        err: gd,
        memo: Kf(Jf()),
        blockTime: Zf(Kf(Vf()))
      }))),
      Zd = Qf({
        subscription: Vf(),
        result: cd(Ld)
      }),
      qd = Qf({
        pubkey: td,
        account: Ld
      }),
      Jd = Qf({
        subscription: Vf(),
        result: cd(qd)
      }),
      Yd = Qf({
        parent: Vf(),
        slot: Vf(),
        root: Vf()
      }),
      Qd = Qf({
        subscription: Vf(),
        result: Yd
      }),
      Xd = Xf([Qf({
        type: Xf([Gf("firstShredReceived"), Gf("completed"), Gf("optimisticConfirmation"), Gf("root")]),
        slot: Vf(),
        timestamp: Vf()
      }), Qf({
        type: Gf("createdBank"),
        parent: Vf(),
        slot: Vf(),
        timestamp: Vf()
      }), Qf({
        type: Gf("frozen"),
        slot: Vf(),
        timestamp: Vf(),
        stats: Qf({
          numTransactionEntries: Vf(),
          numSuccessfulTransactions: Vf(),
          numFailedTransactions: Vf(),
          maxTransactionsPerEntry: Vf()
        })
      }), Qf({
        type: Gf("dead"),
        slot: Vf(),
        timestamp: Vf(),
        err: Jf()
      })]),
      tp = Qf({
        subscription: Vf(),
        result: Xd
      }),
      ep = Qf({
        subscription: Vf(),
        result: cd(Xf([vd, wd]))
      }),
      rp = Qf({
        subscription: Vf(),
        result: Vf()
      }),
      np = Qf({
        pubkey: Jf(),
        gossip: Kf(Jf()),
        tpu: Kf(Jf()),
        rpc: Kf(Jf()),
        version: Kf(Jf())
      }),
      ip = Qf({
        votePubkey: Jf(),
        nodePubkey: Jf(),
        activatedStake: Vf(),
        epochVoteAccount: zf(),
        epochCredits: $f(Yf([Vf(), Vf(), Vf()])),
        commission: Vf(),
        lastVote: Vf(),
        rootSlot: Kf(Vf())
      }),
      op = ad(Qf({
        current: $f(ip),
        delinquent: $f(ip)
      })),
      sp = Xf([Gf("processed"), Gf("confirmed"), Gf("finalized")]),
      ap = Qf({
        slot: Vf(),
        confirmations: Kf(Vf()),
        err: gd,
        confirmationStatus: Zf(sp)
      }),
      up = ud($f(Kf(ap))),
      cp = ad(Vf()),
      fp = Qf({
        accountKey: td,
        writableIndexes: $f(Vf()),
        readonlyIndexes: $f(Vf())
      }),
      lp = Qf({
        signatures: $f(Jf()),
        message: Qf({
          accountKeys: $f(Jf()),
          header: Qf({
            numRequiredSignatures: Vf(),
            numReadonlySignedAccounts: Vf(),
            numReadonlyUnsignedAccounts: Vf()
          }),
          instructions: $f(Qf({
            accounts: $f(Vf()),
            data: Jf(),
            programIdIndex: Vf()
          })),
          recentBlockhash: Jf(),
          addressTableLookups: Zf($f(fp))
        })
      }),
      hp = Qf({
        pubkey: td,
        signer: zf(),
        writable: zf(),
        source: Zf(Xf([Gf("transaction"), Gf("lookupTable")]))
      }),
      dp = Qf({
        accountKeys: $f(hp),
        signatures: $f(Jf())
      }),
      pp = Qf({
        parsed: tl(),
        program: Jf(),
        programId: td
      }),
      bp = Qf({
        accounts: $f(td),
        data: Jf(),
        programId: td
      }),
      mp = el(Xf([bp, pp]), Xf([Qf({
        parsed: tl(),
        program: Jf(),
        programId: Jf()
      }), Qf({
        accounts: $f(Jf()),
        data: Jf(),
        programId: Jf()
      })]), t => Df(t, "accounts" in t ? bp : pp)),
      yp = Qf({
        signatures: $f(Jf()),
        message: Qf({
          accountKeys: $f(hp),
          instructions: $f(mp),
          recentBlockhash: Jf(),
          addressTableLookups: Zf(Kf($f(fp)))
        })
      }),
      gp = Qf({
        accountIndex: Vf(),
        mint: Jf(),
        owner: Zf(Jf()),
        programId: Zf(Jf()),
        uiTokenAmount: Rd
      }),
      vp = Qf({
        writable: $f(td),
        readonly: $f(td)
      }),
      wp = Qf({
        err: gd,
        fee: Vf(),
        innerInstructions: Zf(Kf($f(Qf({
          index: Vf(),
          instructions: $f(Qf({
            accounts: $f(Vf()),
            data: Jf(),
            programIdIndex: Vf()
          }))
        })))),
        preBalances: $f(Vf()),
        postBalances: $f(Vf()),
        logMessages: Zf(Kf($f(Jf()))),
        preTokenBalances: Zf(Kf($f(gp))),
        postTokenBalances: Zf(Kf($f(gp))),
        loadedAddresses: Zf(vp),
        computeUnitsConsumed: Zf(Vf())
      }),
      Ap = Qf({
        err: gd,
        fee: Vf(),
        innerInstructions: Zf(Kf($f(Qf({
          index: Vf(),
          instructions: $f(mp)
        })))),
        preBalances: $f(Vf()),
        postBalances: $f(Vf()),
        logMessages: Zf(Kf($f(Jf()))),
        preTokenBalances: Zf(Kf($f(gp))),
        postTokenBalances: Zf(Kf($f(gp))),
        loadedAddresses: Zf(vp),
        computeUnitsConsumed: Zf(Vf())
      }),
      Tp = Xf([Gf(0), Gf("legacy")]),
      Ep = Qf({
        pubkey: Jf(),
        lamports: Vf(),
        postBalance: Kf(Vf()),
        rewardType: Kf(Jf()),
        commission: Zf(Kf(Vf()))
      }),
      Pp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        transactions: $f(Qf({
          transaction: lp,
          meta: Kf(wp),
          version: Zf(Tp)
        })),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      kp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      xp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        transactions: $f(Qf({
          transaction: dp,
          meta: Kf(wp),
          version: Zf(Tp)
        })),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      Ip = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        transactions: $f(Qf({
          transaction: yp,
          meta: Kf(Ap),
          version: Zf(Tp)
        })),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      Sp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        transactions: $f(Qf({
          transaction: dp,
          meta: Kf(Ap),
          version: Zf(Tp)
        })),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      Op = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf()),
        blockHeight: Kf(Vf())
      }))),
      Bp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        transactions: $f(Qf({
          transaction: lp,
          meta: Kf(wp)
        })),
        rewards: Zf($f(Ep)),
        blockTime: Kf(Vf())
      }))),
      Wp = ad(Kf(Qf({
        blockhash: Jf(),
        previousBlockhash: Jf(),
        parentSlot: Vf(),
        signatures: $f(Jf()),
        blockTime: Kf(Vf())
      }))),
      Mp = ad(Kf(Qf({
        slot: Vf(),
        meta: Kf(wp),
        blockTime: Zf(Kf(Vf())),
        transaction: lp,
        version: Zf(Tp)
      }))),
      Cp = ad(Kf(Qf({
        slot: Vf(),
        transaction: yp,
        meta: Kf(Ap),
        blockTime: Zf(Kf(Vf())),
        version: Zf(Tp)
      }))),
      Rp = ud(Qf({
        blockhash: Jf(),
        lastValidBlockHeight: Vf()
      })),
      Np = ud(zf()),
      jp = ad($f(Qf({
        slot: Vf(),
        numTransactions: Vf(),
        numSlots: Vf(),
        samplePeriodSecs: Vf()
      }))),
      _p = ud(Kf(Qf({
        feeCalculator: Qf({
          lamportsPerSignature: Vf()
        })
      }))),
      Dp = ad(Jf()),
      Up = ad(Jf()),
      Lp = Qf({
        err: gd,
        logs: $f(Jf()),
        signature: Jf()
      }),
      Fp = Qf({
        result: cd(Lp),
        subscription: Vf()
      }),
      $p = {
        "solana-client": "js/1.0.0-maintenance"
      };
    class zp {
      constructor(t, e) {
        let r, n, i, o, s, a;
        this.wi = void 0, this.Ai = void 0, this.gi = void 0, this.Ti = void 0, this.Ei = void 0, this.Pi = void 0, this.ki = void 0, this.xi = void 0, this.Ii = !1, this.Si = null, this.Oi = null, this.Bi = 0, this.Wi = !1, this.Mi = !1, this.Ci = {
          latestBlockhash: null,
          lastFetch: 0,
          transactionSignatures: [],
          simulatedSignatures: []
        }, this.Ri = 0, this.Ni = {}, this.ji = {}, this._i = {}, this.Di = {}, this.Ui = {}, this.Li = new Set, this.getBlockHeight = (() => {
          const t = {};
          return async e => {
            const {
              commitment: r,
              config: n
            } = nd(e), i = this.Fi([], r, void 0, n), o = Kh(i);
            return t[o] = t[o] ?? (async () => {
              try {
                const t = Df(await this.Pi("getBlockHeight", i), ad(Vf()));
                if ("error" in t) throw new Wh(t.error, "failed to get block height information");
                return t.result
              } finally {
                delete t[o]
              }
            })(), await t[o]
          }
        })(), e && "string" == typeof e ? this.wi = e : e && (this.wi = e.commitment, this.Ai = e.confirmTransactionInitialTimeout, r = e.wsEndpoint, n = e.httpHeaders, i = e.fetch, o = e.fetchMiddleware, s = e.disableRetryOnRateLimit, a = e.httpAgent), this.gi = function(t) {
          if (!1 === /^https?:/.test(t)) throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
          return t
        }(t), this.Ti = r || function(t) {
          const e = t.match(Xh);
          if (null == e) throw TypeError(`Failed to validate endpoint URL \`${t}\``);
          const [r, n, i, o] = e, s = t.startsWith("https:") ? "wss:" : "ws:", a = null == i ? null : parseInt(i.slice(1), 10);
          return `${s}//${n}${null==a?"":":"+(a+1)}${o}`
        }(t), this.Ei = function(t, e, r, n, i, o) {
          const s = r || qh;
          let a;
          return null != o && console.warn("You have supplied an `httpAgent` when creating a `Connection` in a browser environment.It has been ignored; `httpAgent` is only used in Node environments."), n && (a = async (t, e) => {
            const r = await new Promise((r, i) => {
              try {
                n(t, e, (t, e) => r([t, e]))
              } catch (t) {
                i(t)
              }
            });
            return await s(...r)
          }), new(nl())(async (r, n) => {
            const o = {
              method: "POST",
              body: r,
              agent: void 0,
              headers: Object.assign({
                "Content-Type": "application/json"
              }, e || {}, $p)
            };
            try {
              let e, r = 5,
                u = 500;
              for (; e = a ? await a(t, o) : await s(t, o), 429 === e.status && !0 !== i && (r -= 1, 0 !== r);) console.error(`Server responded with ${e.status} ${e.statusText}.  Retrying after ${u}ms delay...`), await Ch(u), u *= 2;
              const c = await e.text();
              e.ok ? n(null, c) : n(Error(`${e.status} ${e.statusText}: ${c}`))
            } catch (t) {
              t instanceof Error && n(t)
            }
          }, {})
        }(t, n, i, o, s, a), this.Pi = function(t) {
          return (e, r) => new Promise((n, i) => {
            t.request(e, r, (t, e) => {
              t ? i(t) : n(e)
            })
          })
        }(this.Ei), this.ki = function(t) {
          return e => new Promise((r, n) => {
            0 === e.length && r([]);
            const i = e.map(e => t.request(e.methodName, e.args));
            t.request(i, (t, e) => {
              t ? n(t) : r(e)
            })
          })
        }(this.Ei), this.xi = new Jh(this.Ti, {
          autoconnect: !1,
          max_reconnects: 1 / 0
        }), this.xi.on("open", this.$i.bind(this)), this.xi.on("error", this.zi.bind(this)), this.xi.on("close", this.Hi.bind(this)), this.xi.on("accountNotification", this.Gi.bind(this)), this.xi.on("programNotification", this.Ki.bind(this)), this.xi.on("slotNotification", this.Vi.bind(this)), this.xi.on("slotsUpdatesNotification", this.Zi.bind(this)), this.xi.on("signatureNotification", this.qi.bind(this)), this.xi.on("rootNotification", this.Ji.bind(this)), this.xi.on("logsNotification", this.Yi.bind(this))
      }
      get commitment() {
        return this.wi
      }
      get rpcEndpoint() {
        return this.gi
      }
      async getBalanceAndContext(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.Fi([t.toBase58()], r, void 0, n), o = Df(await this.Pi("getBalance", i), ud(Vf()));
        if ("error" in o) throw new Wh(o.error, "failed to get balance for " + t.toBase58());
        return o.result
      }
      async getBalance(t, e) {
        return await this.getBalanceAndContext(t, e).then(t => t.value).catch(e => {
          throw Error("failed to get balance of account " + t.toBase58() + ": " + e)
        })
      }
      async getBlockTime(t) {
        const e = Df(await this.Pi("getBlockTime", [t]), ad(Kf(Vf())));
        if ("error" in e) throw new Wh(e.error, "failed to get block time for slot " + t);
        return e.result
      }
      async getMinimumLedgerSlot() {
        const t = Df(await this.Pi("minimumLedgerSlot", []), ad(Vf()));
        if ("error" in t) throw new Wh(t.error, "failed to get minimum ledger slot");
        return t.result
      }
      async getFirstAvailableBlock() {
        const t = Df(await this.Pi("getFirstAvailableBlock", []), Md);
        if ("error" in t) throw new Wh(t.error, "failed to get first available block");
        return t.result
      }
      async getSupply(t) {
        let e = {};
        e = "string" == typeof t ? {
          commitment: t
        } : t ? {
          ...t,
          commitment: t && t.commitment || this.commitment
        } : {
          commitment: this.commitment
        };
        const r = Df(await this.Pi("getSupply", [e]), Cd);
        if ("error" in r) throw new Wh(r.error, "failed to get supply");
        return r.result
      }
      async getTokenSupply(t, e) {
        const r = this.Fi([t.toBase58()], e),
          n = Df(await this.Pi("getTokenSupply", r), ud(Rd));
        if ("error" in n) throw new Wh(n.error, "failed to get token supply");
        return n.result
      }
      async getTokenAccountBalance(t, e) {
        const r = this.Fi([t.toBase58()], e),
          n = Df(await this.Pi("getTokenAccountBalance", r), ud(Rd));
        if ("error" in n) throw new Wh(n.error, "failed to get token account balance");
        return n.result
      }
      async getTokenAccountsByOwner(t, e, r) {
        const {
          commitment: n,
          config: i
        } = nd(r);
        let o = [t.toBase58()];
        "mint" in e ? o.push({
          mint: e.mint.toBase58()
        }) : o.push({
          programId: e.programId.toBase58()
        });
        const s = this.Fi(o, n, "base64", i),
          a = Df(await this.Pi("getTokenAccountsByOwner", s), jd);
        if ("error" in a) throw new Wh(a.error, "failed to get token accounts owned by account " + t.toBase58());
        return a.result
      }
      async getParsedTokenAccountsByOwner(t, e, r) {
        let n = [t.toBase58()];
        "mint" in e ? n.push({
          mint: e.mint.toBase58()
        }) : n.push({
          programId: e.programId.toBase58()
        });
        const i = this.Fi(n, r, "jsonParsed"),
          o = Df(await this.Pi("getTokenAccountsByOwner", i), Dd);
        if ("error" in o) throw new Wh(o.error, "failed to get token accounts owned by account " + t.toBase58());
        return o.result
      }
      async getLargestAccounts(t) {
        const e = {
            ...t,
            commitment: t && t.commitment || this.commitment
          },
          r = e.filter || e.commitment ? [e] : [],
          n = Df(await this.Pi("getLargestAccounts", r), Ud);
        if ("error" in n) throw new Wh(n.error, "failed to get largest accounts");
        return n.result
      }
      async getTokenLargestAccounts(t, e) {
        const r = this.Fi([t.toBase58()], e),
          n = Df(await this.Pi("getTokenLargestAccounts", r), Nd);
        if ("error" in n) throw new Wh(n.error, "failed to get token largest accounts");
        return n.result
      }
      async getAccountInfoAndContext(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.Fi([t.toBase58()], r, "base64", n), o = Df(await this.Pi("getAccountInfo", i), ud(Kf(Ld)));
        if ("error" in o) throw new Wh(o.error, "failed to get info about account " + t.toBase58());
        return o.result
      }
      async getParsedAccountInfo(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.Fi([t.toBase58()], r, "jsonParsed", n), o = Df(await this.Pi("getAccountInfo", i), ud(Kf(zd)));
        if ("error" in o) throw new Wh(o.error, "failed to get info about account " + t.toBase58());
        return o.result
      }
      async getAccountInfo(t, e) {
        try {
          return (await this.getAccountInfoAndContext(t, e)).value
        } catch (e) {
          throw Error("failed to get info about account " + t.toBase58() + ": " + e)
        }
      }
      async getMultipleParsedAccounts(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = t.map(t => t.toBase58()), o = this.Fi([i], r, "jsonParsed", n), s = Df(await this.Pi("getMultipleAccounts", o), ud($f(Kf(zd))));
        if ("error" in s) throw new Wh(s.error, "failed to get info for accounts " + i);
        return s.result
      }
      async getMultipleAccountsInfoAndContext(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = t.map(t => t.toBase58()), o = this.Fi([i], r, "base64", n), s = Df(await this.Pi("getMultipleAccounts", o), ud($f(Kf(Ld))));
        if ("error" in s) throw new Wh(s.error, "failed to get info for accounts " + i);
        return s.result
      }
      async getMultipleAccountsInfo(t, e) {
        return (await this.getMultipleAccountsInfoAndContext(t, e)).value
      }
      async getStakeActivation(t, e, r) {
        const {
          commitment: n,
          config: i
        } = nd(e), o = this.Fi([t.toBase58()], n, void 0, {
          ...i,
          epoch: r ?? i?.epoch
        }), s = Df(await this.Pi("getStakeActivation", o), ad(Gd));
        if ("error" in s) throw new Wh(s.error, "failed to get Stake Activation " + t.toBase58());
        return s.result
      }
      async getProgramAccounts(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), {
          encoding: i,
          ...o
        } = n || {}, s = this.Fi([t.toBase58()], r, i || "base64", {
          ...o,
          ...o.filters ? {
            filters: id(o.filters)
          } : null
        }), a = await this.Pi("getProgramAccounts", s), u = $f(Fd), c = !0 === o.withContext ? Df(a, ud(u)) : Df(a, ad(u));
        if ("error" in c) throw new Wh(c.error, "failed to get accounts owned by program " + t.toBase58());
        return c.result
      }
      async getParsedProgramAccounts(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.Fi([t.toBase58()], r, "jsonParsed", n), o = Df(await this.Pi("getProgramAccounts", i), ad($f(Hd)));
        if ("error" in o) throw new Wh(o.error, "failed to get accounts owned by program " + t.toBase58());
        return o.result
      }
      async confirmTransaction(t, e) {
        let r, n;
        if ("string" == typeof t) r = t;
        else {
          const e = t;
          if (e.abortSignal?.aborted) return Promise.reject(e.abortSignal.reason);
          r = e.signature
        }
        try {
          n = os().decode(r)
        } catch {
          throw Error("signature must be base58 encoded: " + r)
        }
        return dh(64 === n.length, "signature has invalid length"), "string" == typeof t ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
          commitment: e || this.commitment,
          signature: r
        }) : "lastValidBlockHeight" in t ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
          commitment: e || this.commitment,
          strategy: t
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
          commitment: e || this.commitment,
          strategy: t
        })
      }
      getCancellationPromise(t) {
        return new Promise((e, r) => {
          null != t && (t.aborted ? r(t.reason) : t.addEventListener("abort", () => {
            r(t.reason)
          }))
        })
      }
      getTransactionConfirmationPromise({
        commitment: t,
        signature: e
      }) {
        let r, n, i = !1;
        return {
          abortConfirmation: () => {
            n && (n(), n = void 0), null != r && (this.removeSignatureListener(r), r = void 0)
          },
          confirmationPromise: new Promise((o, s) => {
            try {
              r = this.onSignature(e, (t, e) => {
                r = void 0;
                const n = {
                  context: e,
                  value: t
                };
                o({
                  Qi: Ah.PROCESSED,
                  response: n
                })
              }, t);
              const a = new Promise(t => {
                null == r ? t() : n = this.Xi(r, e => {
                  "subscribed" === e && t()
                })
              });
              (async () => {
                if (await a, i) return;
                const r = await this.getSignatureStatus(e);
                if (i || null == r) return;
                const {
                  context: n,
                  value: u
                } = r;
                if (null != u)
                  if (u?.err) s(u.err);
                  else {
                    switch (t) {
                      case "confirmed":
                      case "single":
                      case "singleGossip":
                        if ("processed" === u.confirmationStatus) return;
                        break;
                      case "finalized":
                      case "max":
                      case "root":
                        if ("processed" === u.confirmationStatus || "confirmed" === u.confirmationStatus) return
                    }
                    i = !0, o({
                      Qi: Ah.PROCESSED,
                      response: {
                        context: n,
                        value: u
                      }
                    })
                  }
              })()
            } catch (t) {
              s(t)
            }
          })
        }
      }
      async confirmTransactionUsingBlockHeightExceedanceStrategy({
        commitment: t,
        strategy: {
          abortSignal: e,
          lastValidBlockHeight: r,
          signature: n
        }
      }) {
        let i = !1;
        const o = new Promise(e => {
            const n = async () => {
              try {
                return await this.getBlockHeight(t)
              } catch {
                return -1
              }
            };
            (async () => {
              let t = await n();
              if (!i) {
                for (; r >= t;)
                  if (await Ch(1e3), i || (t = await n(), i)) return;
                e({
                  Qi: Ah.BLOCKHEIGHT_EXCEEDED
                })
              }
            })()
          }),
          {
            abortConfirmation: s,
            confirmationPromise: a
          } = this.getTransactionConfirmationPromise({
            commitment: t,
            signature: n
          }),
          u = this.getCancellationPromise(e);
        let c;
        try {
          const t = await Promise.race([u, a, o]);
          if (t.Qi !== Ah.PROCESSED) throw new nh(n);
          c = t.response
        } finally {
          i = !0, s()
        }
        return c
      }
      async confirmTransactionUsingDurableNonceStrategy({
        commitment: t,
        strategy: {
          abortSignal: e,
          minContextSlot: r,
          nonceAccountPubkey: n,
          nonceValue: i,
          signature: o
        }
      }) {
        let s = !1;
        const a = new Promise(e => {
            let o = i,
              a = null;
            const u = async () => {
              try {
                const {
                  context: e,
                  value: i
                } = await this.getNonceAndContext(n, {
                  commitment: t,
                  minContextSlot: r
                });
                return a = e.slot, i?.nonce
              } catch {
                return o
              }
            };
            (async () => {
              if (o = await u(), !s)
                for (;;) {
                  if (i !== o) return void e({
                    Qi: Ah.NONCE_INVALID,
                    slotInWhichNonceDidAdvance: a
                  });
                  if (await Ch(2e3), s || (o = await u(), s)) return
                }
            })()
          }),
          {
            abortConfirmation: u,
            confirmationPromise: c
          } = this.getTransactionConfirmationPromise({
            commitment: t,
            signature: o
          }),
          f = this.getCancellationPromise(e);
        let l;
        try {
          const e = await Promise.race([f, c, a]);
          if (e.Qi === Ah.PROCESSED) l = e.response;
          else {
            let n;
            for (;;) {
              const t = await this.getSignatureStatus(o);
              if (null == t) break;
              if (t.context.slot >= (e.slotInWhichNonceDidAdvance ?? r)) {
                n = t;
                break
              }
              await Ch(400)
            }
            if (!n?.value) throw new oh(o);
            {
              const e = t || "finalized",
                {
                  confirmationStatus: r
                } = n.value;
              switch (e) {
                case "processed":
                case "recent":
                  if ("processed" !== r && "confirmed" !== r && "finalized" !== r) throw new oh(o);
                  break;
                case "confirmed":
                case "single":
                case "singleGossip":
                  if ("confirmed" !== r && "finalized" !== r) throw new oh(o);
                  break;
                case "finalized":
                case "max":
                case "root":
                  if ("finalized" !== r) throw new oh(o)
              }
              l = {
                context: n.context,
                value: {
                  err: n.value.err
                }
              }
            }
          }
        } finally {
          s = !0, u()
        }
        return l
      }
      async confirmTransactionUsingLegacyTimeoutStrategy({
        commitment: t,
        signature: e
      }) {
        let r;
        const n = new Promise(e => {
            let n = this.Ai || 6e4;
            switch (t) {
              case "processed":
              case "recent":
              case "single":
              case "confirmed":
              case "singleGossip":
                n = this.Ai || 3e4
            }
            r = setTimeout(() => e({
              Qi: Ah.TIMED_OUT,
              timeoutMs: n
            }), n)
          }),
          {
            abortConfirmation: i,
            confirmationPromise: o
          } = this.getTransactionConfirmationPromise({
            commitment: t,
            signature: e
          });
        let s;
        try {
          const t = await Promise.race([o, n]);
          if (t.Qi !== Ah.PROCESSED) throw new ih(e, t.timeoutMs / 1e3);
          s = t.response
        } finally {
          clearTimeout(r), i()
        }
        return s
      }
      async getClusterNodes() {
        const t = Df(await this.Pi("getClusterNodes", []), ad($f(np)));
        if ("error" in t) throw new Wh(t.error, "failed to get cluster nodes");
        return t.result
      }
      async getVoteAccounts(t) {
        const e = this.Fi([], t),
          r = Df(await this.Pi("getVoteAccounts", e), op);
        if ("error" in r) throw new Wh(r.error, "failed to get vote accounts");
        return r.result
      }
      async getSlot(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, void 0, r), i = Df(await this.Pi("getSlot", n), ad(Vf()));
        if ("error" in i) throw new Wh(i.error, "failed to get slot");
        return i.result
      }
      async getSlotLeader(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, void 0, r), i = Df(await this.Pi("getSlotLeader", n), ad(Jf()));
        if ("error" in i) throw new Wh(i.error, "failed to get slot leader");
        return i.result
      }
      async getSlotLeaders(t, e) {
        const r = [t, e],
          n = Df(await this.Pi("getSlotLeaders", r), ad($f(td)));
        if ("error" in n) throw new Wh(n.error, "failed to get slot leaders");
        return n.result
      }
      async getSignatureStatus(t, e) {
        const {
          context: r,
          value: n
        } = await this.getSignatureStatuses([t], e);
        return dh(1 === n.length), {
          context: r,
          value: n[0]
        }
      }
      async getSignatureStatuses(t, e) {
        const r = [t];
        e && r.push(e);
        const n = Df(await this.Pi("getSignatureStatuses", r), up);
        if ("error" in n) throw new Wh(n.error, "failed to get signature status");
        return n.result
      }
      async getTransactionCount(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, void 0, r), i = Df(await this.Pi("getTransactionCount", n), ad(Vf()));
        if ("error" in i) throw new Wh(i.error, "failed to get transaction count");
        return i.result
      }
      async getTotalSupply(t) {
        return (await this.getSupply({
          commitment: t,
          excludeNonCirculatingAccountsList: !0
        })).value.total
      }
      async getInflationGovernor(t) {
        const e = this.Fi([], t),
          r = Df(await this.Pi("getInflationGovernor", e), xd);
        if ("error" in r) throw new Wh(r.error, "failed to get inflation");
        return r.result
      }
      async getInflationReward(t, e, r) {
        const {
          commitment: n,
          config: i
        } = nd(r), o = this.Fi([t.map(t => t.toBase58())], n, void 0, {
          ...i,
          epoch: e ?? i?.epoch
        }), s = Df(await this.Pi("getInflationReward", o), hd);
        if ("error" in s) throw new Wh(s.error, "failed to get inflation reward");
        return s.result
      }
      async getInflationRate() {
        const t = Df(await this.Pi("getInflationRate", []), Id);
        if ("error" in t) throw new Wh(t.error, "failed to get inflation rate");
        return t.result
      }
      async getEpochInfo(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, void 0, r), i = Df(await this.Pi("getEpochInfo", n), Od);
        if ("error" in i) throw new Wh(i.error, "failed to get epoch info");
        return i.result
      }
      async getEpochSchedule() {
        const t = Df(await this.Pi("getEpochSchedule", []), Bd);
        if ("error" in t) throw new Wh(t.error, "failed to get epoch schedule");
        const e = t.result;
        return new Zh(e.slotsPerEpoch, e.leaderScheduleSlotOffset, e.warmup, e.firstNormalEpoch, e.firstNormalSlot)
      }
      async getLeaderSchedule() {
        const t = Df(await this.Pi("getLeaderSchedule", []), Wd);
        if ("error" in t) throw new Wh(t.error, "failed to get leader schedule");
        return t.result
      }
      async getMinimumBalanceForRentExemption(t, e) {
        const r = this.Fi([t], e),
          n = Df(await this.Pi("getMinimumBalanceForRentExemption", r), cp);
        return "error" in n ? (console.warn("Unable to fetch minimum balance for rent exemption"), 0) : n.result
      }
      async getRecentBlockhashAndContext(t) {
        const {
          context: e,
          value: {
            blockhash: r
          }
        } = await this.getLatestBlockhashAndContext(t);
        return {
          context: e,
          value: {
            blockhash: r,
            feeCalculator: {
              get lamportsPerSignature() {
                throw Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")
              },
              toJSON: () => ({})
            }
          }
        }
      }
      async getRecentPerformanceSamples(t) {
        const e = Df(await this.Pi("getRecentPerformanceSamples", t ? [t] : []), jp);
        if ("error" in e) throw new Wh(e.error, "failed to get recent performance samples");
        return e.result
      }
      async getFeeCalculatorForBlockhash(t, e) {
        const r = this.Fi([t], e),
          n = Df(await this.Pi("getFeeCalculatorForBlockhash", r), _p);
        if ("error" in n) throw new Wh(n.error, "failed to get fee calculator");
        const {
          context: i,
          value: o
        } = n.result;
        return {
          context: i,
          value: null !== o ? o.feeCalculator : null
        }
      }
      async getFeeForMessage(t, e) {
        const r = ql(t.serialize()).toString("base64"),
          n = this.Fi([r], e),
          i = Df(await this.Pi("getFeeForMessage", n), ud(Kf(Vf())));
        if ("error" in i) throw new Wh(i.error, "failed to get fee for message");
        if (null === i.result) throw Error("invalid blockhash");
        return i.result
      }
      async getRecentPrioritizationFees(t) {
        const e = t?.lockedWritableAccounts?.map(t => t.toBase58()),
          r = e?.length ? [e] : [],
          n = Df(await this.Pi("getRecentPrioritizationFees", r), Sd);
        if ("error" in n) throw new Wh(n.error, "failed to get recent prioritization fees");
        return n.result
      }
      async getRecentBlockhash(t) {
        try {
          return (await this.getRecentBlockhashAndContext(t)).value
        } catch (t) {
          throw Error("failed to get recent blockhash: " + t)
        }
      }
      async getLatestBlockhash(t) {
        try {
          return (await this.getLatestBlockhashAndContext(t)).value
        } catch (t) {
          throw Error("failed to get recent blockhash: " + t)
        }
      }
      async getLatestBlockhashAndContext(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, void 0, r), i = Df(await this.Pi("getLatestBlockhash", n), Rp);
        if ("error" in i) throw new Wh(i.error, "failed to get latest blockhash");
        return i.result
      }
      async isBlockhashValid(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.Fi([t], r, void 0, n), o = Df(await this.Pi("isBlockhashValid", i), Np);
        if ("error" in o) throw new Wh(o.error, "failed to determine if the blockhash `" + t + "`is valid");
        return o.result
      }
      async getVersion() {
        const t = Df(await this.Pi("getVersion", []), ad(Ad));
        if ("error" in t) throw new Wh(t.error, "failed to get version");
        return t.result
      }
      async getGenesisHash() {
        const t = Df(await this.Pi("getGenesisHash", []), ad(Jf()));
        if ("error" in t) throw new Wh(t.error, "failed to get genesis hash");
        return t.result
      }
      async getBlock(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.eo([t], r, void 0, n), o = await this.Pi("getBlock", i);
        try {
          switch (n?.transactionDetails) {
            case "accounts": {
              const t = Df(o, xp);
              if ("error" in t) throw t.error;
              return t.result
            }
            case "none": {
              const t = Df(o, kp);
              if ("error" in t) throw t.error;
              return t.result
            }
            default: {
              const t = Df(o, Pp);
              if ("error" in t) throw t.error;
              const {
                result: e
              } = t;
              return e ? {
                ...e,
                transactions: e.transactions.map(({
                  transaction: t,
                  meta: e,
                  version: r
                }) => ({
                  meta: e,
                  transaction: {
                    ...t,
                    message: fd(r, t.message)
                  },
                  version: r
                }))
              } : null
            }
          }
        } catch (t) {
          throw new Wh(t, "failed to get confirmed block")
        }
      }
      async getParsedBlock(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.eo([t], r, "jsonParsed", n), o = await this.Pi("getBlock", i);
        try {
          switch (n?.transactionDetails) {
            case "accounts": {
              const t = Df(o, Sp);
              if ("error" in t) throw t.error;
              return t.result
            }
            case "none": {
              const t = Df(o, Op);
              if ("error" in t) throw t.error;
              return t.result
            }
            default: {
              const t = Df(o, Ip);
              if ("error" in t) throw t.error;
              return t.result
            }
          }
        } catch (t) {
          throw new Wh(t, "failed to get block")
        }
      }
      async getBlockProduction(t) {
        let e, r;
        if ("string" == typeof t) r = t;
        else if (t) {
          const {
            commitment: n,
            ...i
          } = t;
          r = n, e = i
        }
        const n = this.Fi([], r, "base64", e),
          i = Df(await this.Pi("getBlockProduction", n), kd);
        if ("error" in i) throw new Wh(i.error, "failed to get block production information");
        return i.result
      }
      async getTransaction(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.eo([t], r, void 0, n), o = Df(await this.Pi("getTransaction", i), Mp);
        if ("error" in o) throw new Wh(o.error, "failed to get transaction");
        const s = o.result;
        return s && {
          ...s,
          transaction: {
            ...s.transaction,
            message: fd(s.version, s.transaction.message)
          }
        }
      }
      async getParsedTransaction(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = this.eo([t], r, "jsonParsed", n), o = Df(await this.Pi("getTransaction", i), Cp);
        if ("error" in o) throw new Wh(o.error, "failed to get transaction");
        return o.result
      }
      async getParsedTransactions(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = t.map(t => ({
          methodName: "getTransaction",
          args: this.eo([t], r, "jsonParsed", n)
        }));
        return (await this.ki(i)).map(t => {
          const e = Df(t, Cp);
          if ("error" in e) throw new Wh(e.error, "failed to get transactions");
          return e.result
        })
      }
      async getTransactions(t, e) {
        const {
          commitment: r,
          config: n
        } = nd(e), i = t.map(t => ({
          methodName: "getTransaction",
          args: this.eo([t], r, void 0, n)
        }));
        return (await this.ki(i)).map(t => {
          const e = Df(t, Mp);
          if ("error" in e) throw new Wh(e.error, "failed to get transactions");
          const r = e.result;
          return r && {
            ...r,
            transaction: {
              ...r.transaction,
              message: fd(r.version, r.transaction.message)
            }
          }
        })
      }
      async getConfirmedBlock(t, e) {
        const r = this.eo([t], e),
          n = Df(await this.Pi("getBlock", r), Bp);
        if ("error" in n) throw new Wh(n.error, "failed to get confirmed block");
        const i = n.result;
        if (!i) throw Error("Confirmed block " + t + " not found");
        const o = {
          ...i,
          transactions: i.transactions.map(({
            transaction: t,
            meta: e
          }) => {
            const r = new gh(t.message);
            return {
              meta: e,
              transaction: {
                ...t,
                message: r
              }
            }
          })
        };
        return {
          ...o,
          transactions: o.transactions.map(({
            transaction: t,
            meta: e
          }) => ({
            meta: e,
            transaction: Ph.populate(t.message, t.signatures)
          }))
        }
      }
      async getBlocks(t, e, r) {
        const n = this.eo(void 0 !== e ? [t, e] : [t], r),
          i = Df(await this.Pi("getBlocks", n), ad($f(Vf())));
        if ("error" in i) throw new Wh(i.error, "failed to get blocks");
        return i.result
      }
      async getBlockSignatures(t, e) {
        const r = this.eo([t], e, void 0, {
            transactionDetails: "signatures",
            rewards: !1
          }),
          n = Df(await this.Pi("getBlock", r), Wp);
        if ("error" in n) throw new Wh(n.error, "failed to get block");
        const i = n.result;
        if (!i) throw Error("Block " + t + " not found");
        return i
      }
      async getConfirmedBlockSignatures(t, e) {
        const r = this.eo([t], e, void 0, {
            transactionDetails: "signatures",
            rewards: !1
          }),
          n = Df(await this.Pi("getBlock", r), Wp);
        if ("error" in n) throw new Wh(n.error, "failed to get confirmed block");
        const i = n.result;
        if (!i) throw Error("Confirmed block " + t + " not found");
        return i
      }
      async getConfirmedTransaction(t, e) {
        const r = this.eo([t], e),
          n = Df(await this.Pi("getTransaction", r), Mp);
        if ("error" in n) throw new Wh(n.error, "failed to get transaction");
        const i = n.result;
        if (!i) return i;
        const o = new gh(i.transaction.message),
          s = i.transaction.signatures;
        return {
          ...i,
          transaction: Ph.populate(o, s)
        }
      }
      async getParsedConfirmedTransaction(t, e) {
        const r = this.eo([t], e, "jsonParsed"),
          n = Df(await this.Pi("getTransaction", r), Cp);
        if ("error" in n) throw new Wh(n.error, "failed to get confirmed transaction");
        return n.result
      }
      async getParsedConfirmedTransactions(t, e) {
        const r = t.map(t => ({
          methodName: "getTransaction",
          args: this.eo([t], e, "jsonParsed")
        }));
        return (await this.ki(r)).map(t => {
          const e = Df(t, Cp);
          if ("error" in e) throw new Wh(e.error, "failed to get confirmed transactions");
          return e.result
        })
      }
      async getConfirmedSignaturesForAddress(t, e, r) {
        let n = {},
          i = await this.getFirstAvailableBlock();
        for (; !("until" in n) && --e > 0 && e >= i;) try {
          const t = await this.getConfirmedBlockSignatures(e, "finalized");
          t.signatures.length > 0 && (n.until = t.signatures[t.signatures.length - 1].toString())
        } catch (t) {
          if (t instanceof Error && t.message.includes("skipped")) continue;
          throw t
        }
        let o = await this.getSlot("finalized");
        for (; !("before" in n) && ++r <= o;) try {
          const t = await this.getConfirmedBlockSignatures(r);
          t.signatures.length > 0 && (n.before = t.signatures[t.signatures.length - 1].toString())
        } catch (t) {
          if (t instanceof Error && t.message.includes("skipped")) continue;
          throw t
        }
        return (await this.getConfirmedSignaturesForAddress2(t, n)).map(t => t.signature)
      }
      async getConfirmedSignaturesForAddress2(t, e, r) {
        const n = this.eo([t.toBase58()], r, void 0, e),
          i = Df(await this.Pi("getConfirmedSignaturesForAddress2", n), Kd);
        if ("error" in i) throw new Wh(i.error, "failed to get confirmed signatures for address");
        return i.result
      }
      async getSignaturesForAddress(t, e, r) {
        const n = this.eo([t.toBase58()], r, void 0, e),
          i = Df(await this.Pi("getSignaturesForAddress", n), Vd);
        if ("error" in i) throw new Wh(i.error, "failed to get signatures for address");
        return i.result
      }
      async getAddressLookupTable(t, e) {
        const {
          context: r,
          value: n
        } = await this.getAccountInfoAndContext(t, e);
        let i = null;
        return null !== n && (i = new Yh({
          key: t,
          state: Yh.deserialize(n.data)
        })), {
          context: r,
          value: i
        }
      }
      async getNonceAndContext(t, e) {
        const {
          context: r,
          value: n
        } = await this.getAccountInfoAndContext(t, e);
        let i = null;
        return null !== n && (i = Dh.fromAccountData(n.data)), {
          context: r,
          value: i
        }
      }
      async getNonce(t, e) {
        return await this.getNonceAndContext(t, e).then(t => t.value).catch(e => {
          throw Error("failed to get nonce for account " + t.toBase58() + ": " + e)
        })
      }
      async requestAirdrop(t, e) {
        const r = Df(await this.Pi("requestAirdrop", [t.toBase58(), e]), Dp);
        if ("error" in r) throw new Wh(r.error, `airdrop to ${t.toBase58()} failed`);
        return r.result
      }
      async ro(t) {
        if (!t) {
          for (; this.Mi;) await Ch(100);
          const t = Date.now() - this.Ci.lastFetch >= 3e4;
          if (null !== this.Ci.latestBlockhash && !t) return this.Ci.latestBlockhash
        }
        return await this.no()
      }
      async no() {
        this.Mi = !0;
        try {
          const t = Date.now(),
            e = this.Ci.latestBlockhash,
            r = e ? e.blockhash : null;
          for (let t = 0; 50 > t; t++) {
            const t = await this.getLatestBlockhash("finalized");
            if (r !== t.blockhash) return this.Ci = {
              latestBlockhash: t,
              lastFetch: Date.now(),
              transactionSignatures: [],
              simulatedSignatures: []
            }, t;
            await Ch(200)
          }
          throw Error(`Unable to obtain a new blockhash after ${Date.now()-t}ms`)
        } finally {
          this.Mi = !1
        }
      }
      async getStakeMinimumDelegation(t) {
        const {
          commitment: e,
          config: r
        } = nd(t), n = this.Fi([], e, "base64", r), i = Df(await this.Pi("getStakeMinimumDelegation", n), ud(Vf()));
        if ("error" in i) throw new Wh(i.error, "failed to get stake minimum delegation");
        return i.result
      }
      async simulateTransaction(t, e, r) {
        if ("message" in t) {
          const n = t.serialize(),
            i = vn.Buffer.from(n).toString("base64");
          if (Array.isArray(e) || void 0 !== r) throw Error("Invalid arguments");
          const o = e || {};
          o.encoding = "base64", "commitment" in o || (o.commitment = this.commitment), e && "object" == typeof e && "innerInstructions" in e && (o.innerInstructions = e.innerInstructions);
          const s = [i, o],
            a = Df(await this.Pi("simulateTransaction", s), Pd);
          if ("error" in a) throw Error("failed to simulate transaction: " + a.error.message);
          return a.result
        }
        let n;
        if (t instanceof Ph) {
          let e = t;
          n = new Ph, n.feePayer = e.feePayer, n.instructions = t.instructions, n.nonceInfo = e.nonceInfo, n.signatures = e.signatures
        } else n = Ph.populate(t), n.fi = n.li = void 0;
        if (void 0 !== e && !Array.isArray(e)) throw Error("Invalid arguments");
        const i = e;
        if (n.nonceInfo && i) n.sign(...i);
        else {
          let t = this.Wi;
          for (;;) {
            const e = await this.ro(t);
            if (n.lastValidBlockHeight = e.lastValidBlockHeight, n.recentBlockhash = e.blockhash, !i) break;
            if (n.sign(...i), !n.signature) throw Error("!signature");
            const r = n.signature.toString("base64");
            if (!this.Ci.simulatedSignatures.includes(r) && !this.Ci.transactionSignatures.includes(r)) {
              this.Ci.simulatedSignatures.push(r);
              break
            }
            t = !0
          }
        }
        const o = n.di(),
          s = o.serialize(),
          a = n.yi(s).toString("base64"),
          u = {
            encoding: "base64",
            commitment: this.commitment
          };
        if (r) {
          const t = (Array.isArray(r) ? r : o.nonProgramIds()).map(t => t.toBase58());
          u.accounts = {
            encoding: "base64",
            addresses: t
          }
        }
        i && (u.sigVerify = !0), e && "object" == typeof e && "innerInstructions" in e && (u.innerInstructions = e.innerInstructions);
        const c = [a, u],
          f = Df(await this.Pi("simulateTransaction", c), Pd);
        if ("error" in f) {
          let t;
          if ("data" in f.error && (t = f.error.data.logs, t && Array.isArray(t))) {
            const e = "\n    ",
              r = e + t.join(e);
            console.error(f.error.message, r)
          }
          throw new Bh({
            action: "simulate",
            signature: "",
            transactionMessage: f.error.message,
            logs: t
          })
        }
        return f.result
      }
      async sendTransaction(t, e, r) {
        if ("version" in t) {
          if (e && Array.isArray(e)) throw Error("Invalid arguments");
          const r = t.serialize();
          return await this.sendRawTransaction(r, e)
        }
        if (void 0 === e || !Array.isArray(e)) throw Error("Invalid arguments");
        const n = e;
        if (t.nonceInfo) t.sign(...n);
        else {
          let e = this.Wi;
          for (;;) {
            const r = await this.ro(e);
            if (t.lastValidBlockHeight = r.lastValidBlockHeight, t.recentBlockhash = r.blockhash, t.sign(...n), !t.signature) throw Error("!signature");
            const i = t.signature.toString("base64");
            if (!this.Ci.transactionSignatures.includes(i)) {
              this.Ci.transactionSignatures.push(i);
              break
            }
            e = !0
          }
        }
        const i = t.serialize();
        return await this.sendRawTransaction(i, r)
      }
      async sendRawTransaction(t, e) {
        const r = ql(t).toString("base64");
        return await this.sendEncodedTransaction(r, e)
      }
      async sendEncodedTransaction(t, e) {
        const r = {
            encoding: "base64"
          },
          n = e && e.skipPreflight,
          i = !0 === n ? "processed" : e && e.preflightCommitment || this.commitment;
        e && null != e.maxRetries && (r.maxRetries = e.maxRetries), e && null != e.minContextSlot && (r.minContextSlot = e.minContextSlot), n && (r.skipPreflight = n), i && (r.preflightCommitment = i);
        const o = [t, r],
          s = Df(await this.Pi("sendTransaction", o), Up);
        if ("error" in s) {
          let t;
          throw "data" in s.error && (t = s.error.data.logs), new Bh({
            action: n ? "send" : "simulate",
            signature: "",
            transactionMessage: s.error.message,
            logs: t
          })
        }
        return s.result
      }
      $i() {
        this.Ii = !0, this.Si = setInterval(() => {
          (async () => {
            try {
              await this.xi.notify("ping")
            } catch {}
          })()
        }, 5e3), this.io()
      }
      zi(t) {
        this.Ii = !1, console.error("ws error:", t.message)
      }
      Hi(t) {
        this.Ii = !1, this.Bi = (this.Bi + 1) % Number.MAX_SAFE_INTEGER, this.Oi && (clearTimeout(this.Oi), this.Oi = null), this.Si && (clearInterval(this.Si), this.Si = null), 1e3 !== t ? (this.Di = {}, Object.entries(this.Ui).forEach(([t, e]) => {
          this.oo(t, {
            ...e,
            state: "pending"
          })
        })) : this.io()
      }
      oo(t, e) {
        const r = this.Ui[t]?.state;
        if (this.Ui[t] = e, r !== e.state) {
          const r = this._i[t];
          r && r.forEach(t => {
            try {
              t(e.state)
            } catch {}
          })
        }
      }
      Xi(t, e) {
        const r = this.ji[t];
        if (null == r) return () => {};
        const n = this._i[r] ||= new Set;
        return n.add(e), () => {
          n.delete(e), 0 === n.size && delete this._i[r]
        }
      }
      async io() {
        if (0 === Object.keys(this.Ui).length) return void(this.Ii && (this.Ii = !1, this.Oi = setTimeout(() => {
          this.Oi = null;
          try {
            this.xi.close()
          } catch (t) {
            t instanceof Error && console.log("Error when closing socket connection: " + t.message)
          }
        }, 500)));
        if (null !== this.Oi && (clearTimeout(this.Oi), this.Oi = null, this.Ii = !0), !this.Ii) return void this.xi.connect();
        const t = this.Bi,
          e = () => t === this.Bi;
        await Promise.all(Object.keys(this.Ui).map(async t => {
          const r = this.Ui[t];
          if (void 0 !== r) switch (r.state) {
            case "pending":
            case "unsubscribed":
              if (0 === r.callbacks.size) return delete this.Ui[t], "unsubscribed" === r.state && delete this.Di[r.serverSubscriptionId], void await this.io();
              await (async () => {
                const {
                  args: n,
                  method: i
                } = r;
                try {
                  this.oo(t, {
                    ...r,
                    state: "subscribing"
                  });
                  const e = await this.xi.call(i, n);
                  this.oo(t, {
                    ...r,
                    serverSubscriptionId: e,
                    state: "subscribed"
                  }), this.Di[e] = r.callbacks, await this.io()
                } catch (o) {
                  if (console.error(`Received ${o instanceof Error?"":"JSON-RPC "}error calling \`${i}\``, {
                      args: n,
                      error: o
                    }), !e()) return;
                  this.oo(t, {
                    ...r,
                    state: "pending"
                  }), await this.io()
                }
              })();
              break;
            case "subscribed":
              0 === r.callbacks.size && await (async () => {
                const {
                  serverSubscriptionId: n,
                  unsubscribeMethod: i
                } = r;
                if (this.Li.has(n)) this.Li.delete(n);
                else {
                  this.oo(t, {
                    ...r,
                    state: "unsubscribing"
                  }), this.oo(t, {
                    ...r,
                    state: "unsubscribing"
                  });
                  try {
                    await this.xi.call(i, [n])
                  } catch (n) {
                    if (n instanceof Error && console.error(i + " error:", n.message), !e()) return;
                    return this.oo(t, {
                      ...r,
                      state: "subscribed"
                    }), void await this.io()
                  }
                }
                this.oo(t, {
                  ...r,
                  state: "unsubscribed"
                }), await this.io()
              })()
          }
        }))
      }
      so(t, e) {
        const r = this.Di[t];
        void 0 !== r && r.forEach(t => {
          try {
            t(...e)
          } catch (t) {
            console.error(t)
          }
        })
      }
      Gi(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, Zd);
        this.so(r, [e.value, e.context])
      }
      ao(t, e) {
        const r = this.Ri++,
          n = Kh([t.method, e]),
          i = this.Ui[n];
        return void 0 === i ? this.Ui[n] = {
          ...t,
          args: e,
          callbacks: new Set([t.callback]),
          state: "pending"
        } : i.callbacks.add(t.callback), this.ji[r] = n, this.Ni[r] = async () => {
          delete this.Ni[r], delete this.ji[r];
          const e = this.Ui[n];
          dh(void 0 !== e, "Could not find a `Subscription` when tearing down client subscription #" + r), e.callbacks.delete(t.callback), await this.io()
        }, this.io(), r
      }
      onAccountChange(t, e, r) {
        const {
          commitment: n,
          config: i
        } = nd(r), o = this.Fi([t.toBase58()], n || this.wi || "finalized", "base64", i);
        return this.ao({
          callback: e,
          method: "accountSubscribe",
          unsubscribeMethod: "accountUnsubscribe"
        }, o)
      }
      async removeAccountChangeListener(t) {
        await this.uo(t, "account change")
      }
      Ki(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, Jd);
        this.so(r, [{
          accountId: e.value.pubkey,
          accountInfo: e.value.account
        }, e.context])
      }
      onProgramAccountChange(t, e, r, n) {
        const {
          commitment: i,
          config: o
        } = nd(r), s = this.Fi([t.toBase58()], i || this.wi || "finalized", "base64", o || (n ? {
          filters: id(n)
        } : void 0));
        return this.ao({
          callback: e,
          method: "programSubscribe",
          unsubscribeMethod: "programUnsubscribe"
        }, s)
      }
      async removeProgramAccountChangeListener(t) {
        await this.uo(t, "program account change")
      }
      onLogs(t, e, r) {
        const n = this.Fi(["object" == typeof t ? {
          mentions: [t.toString()]
        } : t], r || this.wi || "finalized");
        return this.ao({
          callback: e,
          method: "logsSubscribe",
          unsubscribeMethod: "logsUnsubscribe"
        }, n)
      }
      async removeOnLogsListener(t) {
        await this.uo(t, "logs")
      }
      Yi(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, Fp);
        this.so(r, [e.value, e.context])
      }
      Vi(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, Qd);
        this.so(r, [e])
      }
      onSlotChange(t) {
        return this.ao({
          callback: t,
          method: "slotSubscribe",
          unsubscribeMethod: "slotUnsubscribe"
        }, [])
      }
      async removeSlotChangeListener(t) {
        await this.uo(t, "slot change")
      }
      Zi(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, tp);
        this.so(r, [e])
      }
      onSlotUpdate(t) {
        return this.ao({
          callback: t,
          method: "slotsUpdatesSubscribe",
          unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
      }
      async removeSlotUpdateListener(t) {
        await this.uo(t, "slot update")
      }
      async uo(t, e) {
        const r = this.Ni[t];
        r ? await r() : console.warn(`Ignored unsubscribe request because an active subscription with id \`${t}\` for '${e}' events could not be found.`)
      }
      Fi(t, e, r, n) {
        const i = e || this.wi;
        if (i || r || n) {
          let e = {};
          r && (e.encoding = r), i && (e.commitment = i), n && (e = Object.assign(e, n)), t.push(e)
        }
        return t
      }
      eo(t, e, r, n) {
        const i = e || this.wi;
        if (i && !["confirmed", "finalized"].includes(i)) throw Error("Using Connection with default commitment: `" + this.wi + "`, but method requires at least `confirmed`");
        return this.Fi(t, e, r, n)
      }
      qi(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, ep);
        "receivedSignature" !== e.value && this.Li.add(r), this.so(r, "receivedSignature" === e.value ? [{
          type: "received"
        }, e.context] : [{
          type: "status",
          result: e.value
        }, e.context])
      }
      onSignature(t, e, r) {
        const n = this.Fi([t], r || this.wi || "finalized"),
          i = this.ao({
            callback: (t, r) => {
              if ("status" === t.type) {
                e(t.result, r);
                try {
                  this.removeSignatureListener(i)
                } catch {}
              }
            },
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
          }, n);
        return i
      }
      onSignatureWithOptions(t, e, r) {
        const {
          commitment: n,
          ...i
        } = {
          ...r,
          commitment: r && r.commitment || this.wi || "finalized"
        }, o = this.Fi([t], n, void 0, i), s = this.ao({
          callback: (t, r) => {
            e(t, r);
            try {
              this.removeSignatureListener(s)
            } catch {}
          },
          method: "signatureSubscribe",
          unsubscribeMethod: "signatureUnsubscribe"
        }, o);
        return s
      }
      async removeSignatureListener(t) {
        await this.uo(t, "signature result")
      }
      Ji(t) {
        const {
          result: e,
          subscription: r
        } = Df(t, rp);
        this.so(r, [e])
      }
      onRootChange(t) {
        return this.ao({
          callback: t,
          method: "rootSubscribe",
          unsubscribeMethod: "rootUnsubscribe"
        }, [])
      }
      async removeRootChangeListener(t) {
        await this.uo(t, "root change")
      }
    }
    class Hp {
      constructor(t) {
        this.co = void 0, this.co = t ?? Hl()
      }
      static generate() {
        return new Hp(Hl())
      }
      static fromSecretKey(t, e) {
        if (64 !== t.byteLength) throw Error("bad secret key size");
        const r = t.slice(32, 64);
        if (!e || !e.skipValidation) {
          const e = t.slice(0, 32),
            n = Gl(e);
          for (let t = 0; 32 > t; t++)
            if (r[t] !== n[t]) throw Error("provided secretKey is invalid")
        }
        return new Hp({
          publicKey: r,
          secretKey: t
        })
      }
      static fromSeed(t) {
        const e = Gl(t),
          r = new Uint8Array(64);
        return r.set(t), r.set(e, 32), new Hp({
          publicKey: e,
          secretKey: r
        })
      }
      get publicKey() {
        return new eh(this.co.publicKey)
      }
      get secretKey() {
        return new Uint8Array(this.co.secretKey)
      }
    }
    Object.freeze({
      CreateLookupTable: {
        index: 0,
        layout: us.w3([us.DH("instruction"), Uh("recentSlot"), us.u8("bumpSeed")])
      },
      FreezeLookupTable: {
        index: 1,
        layout: us.w3([us.DH("instruction")])
      },
      ExtendLookupTable: {
        index: 2,
        layout: us.w3([us.DH("instruction"), Uh(), us.O6(ah(), us.cY(us.DH(), -8), "addresses")])
      },
      DeactivateLookupTable: {
        index: 3,
        layout: us.w3([us.DH("instruction")])
      },
      CloseLookupTable: {
        index: 4,
        layout: us.w3([us.DH("instruction")])
      }
    }), new eh("AddressLookupTab1e1111111111111111111111111"), Object.freeze({
      RequestUnits: {
        index: 0,
        layout: us.w3([us.u8("instruction"), us.DH("units"), us.DH("additionalFee")])
      },
      RequestHeapFrame: {
        index: 1,
        layout: us.w3([us.u8("instruction"), us.DH("bytes")])
      },
      SetComputeUnitLimit: {
        index: 2,
        layout: us.w3([us.u8("instruction"), us.DH("units")])
      },
      SetComputeUnitPrice: {
        index: 3,
        layout: us.w3([us.u8("instruction"), Uh("microLamports")])
      }
    }), new eh("ComputeBudget111111111111111111111111111111");
    const Gp = us.w3([us.u8("numSignatures"), us.u8("padding"), us.NX("signatureOffset"), us.NX("signatureInstructionIndex"), us.NX("publicKeyOffset"), us.NX("publicKeyInstructionIndex"), us.NX("messageDataOffset"), us.NX("messageDataSize"), us.NX("messageInstructionIndex")]);
    class Kp {
      constructor() {}
      static createInstructionWithPublicKey(t) {
        const {
          publicKey: e,
          message: r,
          signature: n,
          instructionIndex: i
        } = t;
        dh(32 === e.length, `Public Key must be 32 bytes but received ${e.length} bytes`), dh(64 === n.length, `Signature must be 64 bytes but received ${n.length} bytes`);
        const o = Gp.span,
          s = o + e.length,
          a = s + n.length,
          u = vn.Buffer.alloc(a + r.length),
          c = i ?? 65535;
        return Gp.encode({
          numSignatures: 1,
          padding: 0,
          signatureOffset: s,
          signatureInstructionIndex: c,
          publicKeyOffset: o,
          publicKeyInstructionIndex: c,
          messageDataOffset: a,
          messageDataSize: r.length,
          messageInstructionIndex: c
        }, u), u.fill(e, o), u.fill(n, s), u.fill(r, a), new Eh({
          keys: [],
          programId: Kp.programId,
          data: u
        })
      }
      static createInstructionWithPrivateKey(t) {
        const {
          privateKey: e,
          message: r,
          instructionIndex: n
        } = t;
        dh(64 === e.length, `Private key must be 64 bytes but received ${e.length} bytes`);
        try {
          const t = Hp.fromSecretKey(e),
            i = t.publicKey.toBytes(),
            o = Vl(r, t.secretKey);
          return this.createInstructionWithPublicKey({
            publicKey: i,
            message: r,
            signature: o,
            instructionIndex: n
          })
        } catch (t) {
          throw Error("Error creating instruction; " + t)
        }
      }
    }
    Kp.programId = new eh("Ed25519SigVerify111111111111111111111111111"), zl.utils.isValidPrivateKey;
    const Vp = zl.getPublicKey,
      Zp = us.w3([us.u8("numSignatures"), us.NX("signatureOffset"), us.u8("signatureInstructionIndex"), us.NX("ethAddressOffset"), us.u8("ethAddressInstructionIndex"), us.NX("messageDataOffset"), us.NX("messageDataSize"), us.u8("messageInstructionIndex"), us.av(20, "ethAddress"), us.av(64, "signature"), us.u8("recoveryId")]);
    class qp {
      constructor() {}
      static publicKeyToEthAddress(t) {
        dh(64 === t.length, `Public key must be 64 bytes but received ${t.length} bytes`);
        try {
          return vn.Buffer.from(El(ql(t))).slice(-20)
        } catch (t) {
          throw Error("Error constructing Ethereum address: " + t)
        }
      }
      static createInstructionWithPublicKey(t) {
        const {
          publicKey: e,
          message: r,
          signature: n,
          recoveryId: i,
          instructionIndex: o
        } = t;
        return qp.createInstructionWithEthAddress({
          ethAddress: qp.publicKeyToEthAddress(e),
          message: r,
          signature: n,
          recoveryId: i,
          instructionIndex: o
        })
      }
      static createInstructionWithEthAddress(t) {
        const {
          ethAddress: e,
          message: r,
          signature: n,
          recoveryId: i,
          instructionIndex: o = 0
        } = t;
        let s;
        s = "string" == typeof e ? e.startsWith("0x") ? vn.Buffer.from(e.substr(2), "hex") : vn.Buffer.from(e, "hex") : e, dh(20 === s.length, `Address must be 20 bytes but received ${s.length} bytes`);
        const a = 12 + s.length,
          u = a + n.length + 1,
          c = vn.Buffer.alloc(Zp.span + r.length);
        return Zp.encode({
          numSignatures: 1,
          signatureOffset: a,
          signatureInstructionIndex: o,
          ethAddressOffset: 12,
          ethAddressInstructionIndex: o,
          messageDataOffset: u,
          messageDataSize: r.length,
          messageInstructionIndex: o,
          signature: ql(n),
          ethAddress: ql(s),
          recoveryId: i
        }, c), c.fill(ql(r), Zp.span), new Eh({
          keys: [],
          programId: qp.programId,
          data: c
        })
      }
      static createInstructionWithPrivateKey(t) {
        const {
          privateKey: e,
          message: r,
          instructionIndex: n
        } = t;
        dh(32 === e.length, `Private key must be 32 bytes but received ${e.length} bytes`);
        try {
          const t = ql(e),
            i = Vp(t, !1).slice(1),
            o = vn.Buffer.from(El(ql(r))),
            [s, a] = ((t, e) => {
              const r = zl.sign(t, e);
              return [r.toCompactRawBytes(), r.recovery]
            })(o, t);
          return this.createInstructionWithPublicKey({
            publicKey: i,
            message: r,
            signature: s,
            recoveryId: a,
            instructionIndex: n
          })
        } catch (t) {
          throw Error("Error creating instruction; " + t)
        }
      }
    }
    var Jp;
    qp.programId = new eh("KeccakSecp256k11111111111111111111111111111");
    const Yp = new eh("StakeConfig11111111111111111111111111111111");
    class Qp {
      constructor(t, e, r) {
        this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = t, this.epoch = e, this.custodian = r
      }
    }
    Jp = Qp, Qp.default = new Jp(0, 0, eh.default);
    const Xp = Object.freeze({
      Initialize: {
        index: 0,
        layout: us.w3([us.DH("instruction"), ((t = "authorized") => us.w3([ah("staker"), ah("withdrawer")], t))(), ((t = "lockup") => us.w3([us.Wg("unixTimestamp"), us.Wg("epoch"), ah("custodian")], t))()])
      },
      Authorize: {
        index: 1,
        layout: us.w3([us.DH("instruction"), ah("newAuthorized"), us.DH("stakeAuthorizationType")])
      },
      Delegate: {
        index: 2,
        layout: us.w3([us.DH("instruction")])
      },
      Split: {
        index: 3,
        layout: us.w3([us.DH("instruction"), us.Wg("lamports")])
      },
      Withdraw: {
        index: 4,
        layout: us.w3([us.DH("instruction"), us.Wg("lamports")])
      },
      Deactivate: {
        index: 5,
        layout: us.w3([us.DH("instruction")])
      },
      Merge: {
        index: 7,
        layout: us.w3([us.DH("instruction")])
      },
      AuthorizeWithSeed: {
        index: 8,
        layout: us.w3([us.DH("instruction"), ah("newAuthorized"), us.DH("stakeAuthorizationType"), ch("authoritySeed"), ah("authorityOwner")])
      }
    });
    Object.freeze({
      Staker: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    class tb {
      constructor() {}
      static initialize(t) {
        const {
          stakePubkey: e,
          authorized: r,
          lockup: n
        } = t, i = n || Qp.default, o = Rh(Xp.Initialize, {
          authorized: {
            staker: ql(r.staker.toBuffer()),
            withdrawer: ql(r.withdrawer.toBuffer())
          },
          lockup: {
            unixTimestamp: i.unixTimestamp,
            epoch: i.epoch,
            custodian: ql(i.custodian.toBuffer())
          }
        }), s = {
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: Sh,
            isSigner: !1,
            isWritable: !1
          }],
          programId: this.programId,
          data: o
        };
        return new Eh(s)
      }
      static createAccountWithSeed(t) {
        const e = new Ph;
        e.add(Fh.createAccountWithSeed({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          basePubkey: t.basePubkey,
          seed: t.seed,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey: r,
          authorized: n,
          lockup: i
        } = t;
        return e.add(this.initialize({
          stakePubkey: r,
          authorized: n,
          lockup: i
        }))
      }
      static createAccount(t) {
        const e = new Ph;
        e.add(Fh.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.stakePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId
        }));
        const {
          stakePubkey: r,
          authorized: n,
          lockup: i
        } = t;
        return e.add(this.initialize({
          stakePubkey: r,
          authorized: n,
          lockup: i
        }))
      }
      static delegate(t) {
        const {
          stakePubkey: e,
          authorizedPubkey: r,
          votePubkey: n
        } = t, i = Rh(Xp.Delegate);
        return (new Ph).add({
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: xh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: Oh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: Yp,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: i
        })
      }
      static authorize(t) {
        const {
          stakePubkey: e,
          authorizedPubkey: r,
          newAuthorizedPubkey: n,
          stakeAuthorizationType: i,
          custodianPubkey: o
        } = t, s = Rh(Xp.Authorize, {
          newAuthorized: ql(n.toBuffer()),
          stakeAuthorizationType: i.index
        }), a = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: xh,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }];
        return o && a.push({
          pubkey: o,
          isSigner: !0,
          isWritable: !1
        }), (new Ph).add({
          keys: a,
          programId: this.programId,
          data: s
        })
      }
      static authorizeWithSeed(t) {
        const {
          stakePubkey: e,
          authorityBase: r,
          authoritySeed: n,
          authorityOwner: i,
          newAuthorizedPubkey: o,
          stakeAuthorizationType: s,
          custodianPubkey: a
        } = t, u = Rh(Xp.AuthorizeWithSeed, {
          newAuthorized: ql(o.toBuffer()),
          stakeAuthorizationType: s.index,
          authoritySeed: n,
          authorityOwner: ql(i.toBuffer())
        }), c = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }, {
          pubkey: xh,
          isSigner: !1,
          isWritable: !1
        }];
        return a && c.push({
          pubkey: a,
          isSigner: !0,
          isWritable: !1
        }), (new Ph).add({
          keys: c,
          programId: this.programId,
          data: u
        })
      }
      static splitInstruction(t) {
        const {
          stakePubkey: e,
          authorizedPubkey: r,
          splitStakePubkey: n,
          lamports: i
        } = t, o = Rh(Xp.Split, {
          lamports: i
        });
        return new Eh({
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: n,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: o
        })
      }
      static split(t, e) {
        const r = new Ph;
        return r.add(Fh.createAccount({
          fromPubkey: t.authorizedPubkey,
          newAccountPubkey: t.splitStakePubkey,
          lamports: e,
          space: this.space,
          programId: this.programId
        })), r.add(this.splitInstruction(t))
      }
      static splitWithSeed(t, e) {
        const {
          stakePubkey: r,
          authorizedPubkey: n,
          splitStakePubkey: i,
          basePubkey: o,
          seed: s,
          lamports: a
        } = t, u = new Ph;
        return u.add(Fh.allocate({
          accountPubkey: i,
          basePubkey: o,
          seed: s,
          space: this.space,
          programId: this.programId
        })), e && e > 0 && u.add(Fh.transfer({
          fromPubkey: t.authorizedPubkey,
          toPubkey: i,
          lamports: e
        })), u.add(this.splitInstruction({
          stakePubkey: r,
          authorizedPubkey: n,
          splitStakePubkey: i,
          lamports: a
        }))
      }
      static merge(t) {
        const {
          stakePubkey: e,
          sourceStakePubKey: r,
          authorizedPubkey: n
        } = t, i = Rh(Xp.Merge);
        return (new Ph).add({
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: r,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: xh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: Oh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: n,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: i
        })
      }
      static withdraw(t) {
        const {
          stakePubkey: e,
          authorizedPubkey: r,
          toPubkey: n,
          lamports: i,
          custodianPubkey: o
        } = t, s = Rh(Xp.Withdraw, {
          lamports: i
        }), a = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: n,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: xh,
          isSigner: !1,
          isWritable: !1
        }, {
          pubkey: Oh,
          isSigner: !1,
          isWritable: !1
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }];
        return o && a.push({
          pubkey: o,
          isSigner: !0,
          isWritable: !1
        }), (new Ph).add({
          keys: a,
          programId: this.programId,
          data: s
        })
      }
      static deactivate(t) {
        const {
          stakePubkey: e,
          authorizedPubkey: r
        } = t, n = Rh(Xp.Deactivate);
        return (new Ph).add({
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: xh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: n
        })
      }
    }
    tb.programId = new eh("Stake11111111111111111111111111111111111111"), tb.space = 200;
    const eb = Object.freeze({
      InitializeAccount: {
        index: 0,
        layout: us.w3([us.DH("instruction"), ((t = "voteInit") => us.w3([ah("nodePubkey"), ah("authorizedVoter"), ah("authorizedWithdrawer"), us.u8("commission")], t))()])
      },
      Authorize: {
        index: 1,
        layout: us.w3([us.DH("instruction"), ah("newAuthorized"), us.DH("voteAuthorizationType")])
      },
      Withdraw: {
        index: 3,
        layout: us.w3([us.DH("instruction"), us.Wg("lamports")])
      },
      UpdateValidatorIdentity: {
        index: 4,
        layout: us.w3([us.DH("instruction")])
      },
      AuthorizeWithSeed: {
        index: 10,
        layout: us.w3([us.DH("instruction"), ((t = "voteAuthorizeWithSeedArgs") => us.w3([us.DH("voteAuthorizationType"), ah("currentAuthorityDerivedKeyOwnerPubkey"), ch("currentAuthorityDerivedKeySeed"), ah("newAuthorized")], t))()])
      }
    });
    Object.freeze({
      Voter: {
        index: 0
      },
      Withdrawer: {
        index: 1
      }
    });
    class rb {
      constructor() {}
      static initializeAccount(t) {
        const {
          votePubkey: e,
          nodePubkey: r,
          voteInit: n
        } = t, i = Rh(eb.InitializeAccount, {
          voteInit: {
            nodePubkey: ql(n.nodePubkey.toBuffer()),
            authorizedVoter: ql(n.authorizedVoter.toBuffer()),
            authorizedWithdrawer: ql(n.authorizedWithdrawer.toBuffer()),
            commission: n.commission
          }
        }), o = {
          keys: [{
            pubkey: e,
            isSigner: !1,
            isWritable: !0
          }, {
            pubkey: Sh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: xh,
            isSigner: !1,
            isWritable: !1
          }, {
            pubkey: r,
            isSigner: !0,
            isWritable: !1
          }],
          programId: this.programId,
          data: i
        };
        return new Eh(o)
      }
      static createAccount(t) {
        const e = new Ph;
        return e.add(Fh.createAccount({
          fromPubkey: t.fromPubkey,
          newAccountPubkey: t.votePubkey,
          lamports: t.lamports,
          space: this.space,
          programId: this.programId
        })), e.add(this.initializeAccount({
          votePubkey: t.votePubkey,
          nodePubkey: t.voteInit.nodePubkey,
          voteInit: t.voteInit
        }))
      }
      static authorize(t) {
        const {
          votePubkey: e,
          authorizedPubkey: r,
          newAuthorizedPubkey: n,
          voteAuthorizationType: i
        } = t, o = Rh(eb.Authorize, {
          newAuthorized: ql(n.toBuffer()),
          voteAuthorizationType: i.index
        }), s = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: xh,
          isSigner: !1,
          isWritable: !1
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }];
        return (new Ph).add({
          keys: s,
          programId: this.programId,
          data: o
        })
      }
      static authorizeWithSeed(t) {
        const {
          currentAuthorityDerivedKeyBasePubkey: e,
          currentAuthorityDerivedKeyOwnerPubkey: r,
          currentAuthorityDerivedKeySeed: n,
          newAuthorizedPubkey: i,
          voteAuthorizationType: o,
          votePubkey: s
        } = t, a = Rh(eb.AuthorizeWithSeed, {
          voteAuthorizeWithSeedArgs: {
            currentAuthorityDerivedKeyOwnerPubkey: ql(r.toBuffer()),
            currentAuthorityDerivedKeySeed: n,
            newAuthorized: ql(i.toBuffer()),
            voteAuthorizationType: o.index
          }
        }), u = [{
          pubkey: s,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: xh,
          isSigner: !1,
          isWritable: !1
        }, {
          pubkey: e,
          isSigner: !0,
          isWritable: !1
        }];
        return (new Ph).add({
          keys: u,
          programId: this.programId,
          data: a
        })
      }
      static withdraw(t) {
        const {
          votePubkey: e,
          authorizedWithdrawerPubkey: r,
          lamports: n,
          toPubkey: i
        } = t, o = Rh(eb.Withdraw, {
          lamports: n
        }), s = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: i,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }];
        return (new Ph).add({
          keys: s,
          programId: this.programId,
          data: o
        })
      }
      static safeWithdraw(t, e, r) {
        if (t.lamports > e - r) throw Error("Withdraw will leave vote account with insufficient funds.");
        return rb.withdraw(t)
      }
      static updateValidatorIdentity(t) {
        const {
          votePubkey: e,
          authorizedWithdrawerPubkey: r,
          nodePubkey: n
        } = t, i = Rh(eb.UpdateValidatorIdentity), o = [{
          pubkey: e,
          isSigner: !1,
          isWritable: !0
        }, {
          pubkey: n,
          isSigner: !0,
          isWritable: !1
        }, {
          pubkey: r,
          isSigner: !0,
          isWritable: !1
        }];
        return (new Ph).add({
          keys: o,
          programId: this.programId,
          data: i
        })
      }
    }
    var nb, ib;
    rb.programId = new eh("Vote111111111111111111111111111111111111111"), rb.space = 3762, new eh("Va1idator1nfo111111111111111111111111111111"), Qf({
        name: Jf(),
        website: Zf(Jf()),
        details: Zf(Jf()),
        iconUrl: Zf(Jf()),
        keybaseUsername: Zf(Jf())
      }), new eh("Vote111111111111111111111111111111111111111"), us.w3([ah("nodePubkey"), ah("authorizedWithdrawer"), us.u8("commission"), us.I0(), us.O6(us.w3([us.I0("slot"), us.DH("confirmationCount")]), us.cY(us.DH(), -8), "votes"), us.u8("rootSlotValid"), us.I0("rootSlot"), us.I0(), us.O6(us.w3([us.I0("epoch"), ah("authorizedVoter")]), us.cY(us.DH(), -8), "authorizedVoters"), us.w3([us.O6(us.w3([ah("authorizedPubkey"), us.I0("epochOfLastAuthorizedSwitch"), us.I0("targetEpoch")]), 32, "buf"), us.I0("idx"), us.u8("isEmpty")], "priorVoters"), us.I0(), us.O6(us.w3([us.I0("epoch"), us.I0("credits"), us.I0("prevCredits")]), us.cY(us.DH(), -8), "epochCredits"), us.w3([us.I0("slot"), us.I0("timestamp")], "lastTimestamp")]),
      function(t) {
        t.NUMBER = "NUMBER_NUMBER", t.HEX = "NUMBER_HEX", t.STR = "NUMBER_STR", t.BIGINT = "NUMBER_BIGINT"
      }(nb || (nb = {})),
      function(t) {
        t.HEX = "BYTES_HEX", t.UINT8ARRAY = "BYTES_UINT8ARRAY"
      }(ib || (ib = {}));
    const ob = {
        number: nb.BIGINT,
        bytes: ib.HEX
      },
      sb = {
        number: nb.HEX,
        bytes: ib.HEX
      };
    var ab, ub;
    ! function(t) {
      t.EARLIEST = "earliest", t.LATEST = "latest", t.PENDING = "pending", t.SAFE = "safe", t.FINALIZED = "finalized", t.COMMITTED = "committed"
    }(ab || (ab = {})),
    function(t) {
      t.chainstart = "chainstart", t.frontier = "frontier", t.homestead = "homestead", t.dao = "dao", t.tangerineWhistle = "tangerineWhistle", t.spuriousDragon = "spuriousDragon", t.byzantium = "byzantium", t.constantinople = "constantinople", t.petersburg = "petersburg", t.istanbul = "istanbul", t.muirGlacier = "muirGlacier", t.berlin = "berlin", t.london = "london", t.altair = "altair", t.arrowGlacier = "arrowGlacier", t.grayGlacier = "grayGlacier", t.bellatrix = "bellatrix", t.merge = "merge", t.capella = "capella", t.shanghai = "shanghai"
    }(ub || (ub = {}));
    const cb = Object.getPrototypeOf(Uint8Array);
    var fb = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const lb = Symbol.for("web3/base-provider");
    class hb {
      static isWeb3Provider(t) {
        return t instanceof hb || !(!t || !t[lb])
      }
      get[lb]() {
        return !0
      }
      send(t, e) {
        this.request(t).then(t => {
          e(null, t)
        }).catch(t => {
          e(t)
        })
      }
      sendAsync(t) {
        return fb(this, void 0, void 0, function*() {
          return this.request(t)
        })
      }
      asEIP1193Provider() {
        const t = Object.create(this),
          e = t.request;
        return t.request = function(t) {
          return fb(this, void 0, void 0, function*() {
            return (yield e(t)).result
          })
        }, t.asEIP1193Provider = void 0, t
      }
    }
    class db extends Array {
      constructor(t) {
        super(), this.fo = t
      }
    }
    const pb = 4001,
      bb = 4100,
      mb = 4200,
      yb = 4900,
      gb = 4901,
      vb = -32700,
      wb = -32600,
      Ab = -32601,
      Tb = -32602,
      Eb = -32603,
      Pb = -32e3,
      kb = -32001,
      xb = -32002,
      Ib = -32003,
      Sb = -32004,
      Ob = -32005,
      Bb = -32006;
    class Wb extends Error {
      get innerError() {
        return this.cause instanceof Mb ? this.cause.errors : this.cause
      }
      set innerError(t) {
        this.cause = Array.isArray(t) ? new Mb(t) : t
      }
      constructor(t, e) {
        super(t), this.cause = Array.isArray(e) ? new Mb(e) : e, this.name = this.constructor.name, "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(new.target.constructor) : this.stack = Error().stack
      }
      static convertToString(t, e = !1) {
        if (null == t) return "undefined";
        const r = JSON.stringify(t, (t, e) => "bigint" == typeof e ? e.toString() : e);
        return e && ["bigint", "string"].includes(typeof t) ? r.replace(/['\\"]+/g, "") : r
      }
      toJSON() {
        return {
          name: this.name,
          code: this.code,
          message: this.message,
          cause: this.cause,
          innerError: this.cause
        }
      }
    }
    class Mb extends Wb {
      constructor(t) {
        super(`Multiple errors occurred: [${t.map(t=>t.message).join("], [")}]`), this.code = 208, this.errors = t
      }
    }
    class Cb extends Wb {
      constructor(t, e) {
        super(`Invalid value given "${Wb.convertToString(t,!0)}". Error: ${e}.`), this.name = this.constructor.name
      }
    }
    class Rb extends Wb {
      constructor() {
        super("Private key must be 32 bytes."), this.code = 701
      }
    }
    class Nb extends Wb {
      constructor() {
        super("Invalid Private Key, Not a valid string or uint8Array"), this.code = 702
      }
    }
    class jb extends Wb {
      constructor(t) {
        super(`"${t}"`), this.code = 802
      }
    }
    class _b extends Wb {
      constructor() {
        super("Invalid key derivation function"), this.code = 703
      }
    }
    class Db extends Wb {
      constructor() {
        super("Key derivation failed - possibly wrong password"), this.code = 704
      }
    }
    class Ub extends Wb {
      constructor() {
        super("Unsupported key store version"), this.code = 705
      }
    }
    class Lb extends Wb {
      constructor() {
        super("Password cannot be empty"), this.code = 706
      }
    }
    class Fb extends Wb {
      constructor() {
        super("Initialization vector must be 16 bytes"), this.code = 707
      }
    }
    class $b extends Wb {
      constructor() {
        super("c > 1000, pbkdf2 is less secure with less iterations"), this.code = 709
      }
    }
    class zb extends Wb {
      constructor(t, e) {
        super(t), this.code = 500, e && (this.errorCode = e.code, this.errorReason = e.reason)
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          errorCode: this.errorCode,
          errorReason: this.errorReason
        })
      }
    }
    class Hb extends zb {
      constructor(t) {
        super("Connection not open", t), this.code = 503
      }
    }
    class Gb extends zb {
      constructor(t) {
        super(`Maximum number of reconnect attempts reached! (${t})`), this.code = 505
      }
    }
    class Kb extends zb {
      constructor() {
        super("CONNECTION ERROR: Provider started to reconnect before the response got received!"), this.code = 506
      }
    }
    class Vb extends zb {
      constructor(t) {
        super("Request already sent with following id: " + t), this.code = 507
      }
    }
    class Zb extends Wb {
      constructor(t, e) {
        super(t), this.code = 300, this.receipt = e
      }
    }
    class qb extends Wb {
      constructor(t, e) {
        super(`The resolver at ${t} does not implement requested method: "${e}".`), this.address = t, this.name = e, this.code = 301
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          address: this.address,
          name: this.name
        })
      }
    }
    class Jb extends Zb {
      constructor(t) {
        if (super(t.message || "Error"), this.name = "name" in t && t.name || this.constructor.name, this.stack = "stack" in t && t.stack || void 0, this.code = t.code, "object" == typeof t.data) {
          let e;
          e = t.data && "originalError" in t.data ? t.data.originalError : t.data, this.data = e.data, this.cause = new Jb(e)
        } else this.data = t.data
      }
      setDecodedProperties(t, e, r) {
        this.errorName = t, this.errorSignature = e, this.errorArgs = r
      }
      toJSON() {
        let t = Object.assign(Object.assign({}, super.toJSON()), {
          data: this.data
        });
        return this.errorName && (t = Object.assign(Object.assign({}, t), {
          errorName: this.errorName,
          errorSignature: this.errorSignature,
          errorArgs: this.errorArgs
        })), t
      }
    }
    class Yb extends Zb {
      constructor(t) {
        super("Error happened while trying to execute a function inside a smart contract"), this.code = 310, this.cause = new Jb(t)
      }
    }
    class Qb extends Cb {
      constructor(t) {
        var e, r;
        super(`data: ${null!==(e=t.data)&&void 0!==e?e:"undefined"}, input: ${null!==(r=t.input)&&void 0!==r?r:"undefined"}`, 'You can\'t have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.'), this.code = 311
      }
    }
    class Xb extends Wb {
      constructor(t) {
        super("ENS is not supported on network " + t), this.code = 902
      }
    }
    class tm extends Wb {
      constructor() {
        super("Network not synced"), this.code = 903
      }
    }
    class em extends Wb {
      constructor(t) {
        super(`Invalid parameters passed. "${"u">typeof t?t:""}"`), this.hint = t, this.code = 207
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          hint: this.hint
        })
      }
    }
    class rm extends Wb {
      constructor() {
        super(...arguments), this.code = 201
      }
    }
    class nm extends Wb {
      constructor() {
        super("The method you're trying to call is not implemented."), this.code = 202
      }
    }
    class im extends Wb {
      constructor() {
        super(...arguments), this.code = 203
      }
    }
    class om extends Wb {
      constructor() {
        super(...arguments), this.code = 204
      }
    }
    class sm extends Wb {
      constructor(t, e) {
        super(t), this.code = 205, this.props = e ?? {}
      }
    }
    class am extends Wb {
      constructor(t) {
        super(`A plugin with the namespace: ${t} has already been registered.`), this.code = 206
      }
    }
    class um extends Wb {
      constructor() {
        super(...arguments), this.code = 600
      }
    }
    class cm extends Wb {
      constructor(t) {
        super(`Client URL "${t}" is invalid.`), this.code = 602
      }
    }
    class fm extends Wb {
      constructor() {
        super(...arguments), this.code = 603
      }
    }
    class lm extends Wb {
      constructor() {
        super(...arguments), this.code = 604
      }
    }
    class hm extends Cb {
      constructor() {
        super(...arguments), this.code = 801
      }
    }
    class dm extends Wb {
      constructor(t, e) {
        super(t), this.receipt = e, this.code = 400
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          receipt: this.receipt
        })
      }
    }
    class pm extends Wb {
      constructor(t, e, r, n) {
        super("Transaction has been reverted by the EVM" + (void 0 === r ? "" : ":\n " + Wb.convertToString(r))), this.reason = t, this.signature = e, this.receipt = r, this.data = n, this.code = 402
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          reason: this.reason,
          signature: this.signature,
          receipt: this.receipt,
          data: this.data
        })
      }
    }
    class bm extends pm {
      constructor(t, e, r, n, i, o, s) {
        super(t), this.reason = t, this.customErrorName = e, this.customErrorDecodedSignature = r, this.customErrorArguments = n, this.signature = i, this.receipt = o, this.data = s, this.code = 438
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          reason: this.reason,
          customErrorName: this.customErrorName,
          customErrorDecodedSignature: this.customErrorDecodedSignature,
          customErrorArguments: this.customErrorArguments,
          signature: this.signature,
          receipt: this.receipt,
          data: this.data
        })
      }
    }
    class mm extends dm {
      constructor(t) {
        super("Transaction has been reverted by the EVM" + (void 0 === t ? "" : ":\n " + Wb.convertToString(t)), t), this.code = 405
      }
    }
    class ym extends dm {
      constructor() {
        super("Raw transaction undefined"), this.code = 407
      }
    }
    class gm extends dm {
      constructor() {
        super("Transaction not found"), this.code = 430
      }
    }
    class vm extends Cb {
      constructor(t) {
        super(t, "invalid transaction with invalid sender"), this.code = 408
      }
    }
    class wm extends Cb {
      constructor(t) {
        super(t, "invalid transaction with invalid receiver"), this.code = 437
      }
    }
    class Am extends Cb {
      constructor() {
        super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain"), this.code = 410
      }
    }
    class Tm extends Cb {
      constructor() {
        super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId"), this.code = 411
      }
    }
    class Em extends Cb {
      constructor(t) {
        super(JSON.stringify(t), "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId"), this.code = 412
      }
    }
    class Pm extends Cb {
      constructor(t) {
        super(JSON.stringify(t), "Chain doesnt match in tx.chain tx.common.basechain"), this.code = 435
      }
    }
    class km extends Cb {
      constructor(t) {
        super(JSON.stringify(t), "hardfork doesnt match in tx.hardfork tx.common.hardfork"), this.code = 436
      }
    }
    class xm extends Cb {
      constructor() {
        super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together."), this.code = 413
      }
    }
    class Im extends Cb {
      constructor(t) {
        var e, r;
        super("MissingChainOrHardforkError", `When specifying chain and hardfork, both values must be defined. Received "chain": ${null!==(e=t.chain)&&void 0!==e?e:"undefined"}, "hardfork": ${null!==(r=t.hardfork)&&void 0!==r?r:"undefined"}`), this.code = 414
      }
    }
    class Sm extends Wb {
      constructor() {
        super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions'), this.code = 440
      }
    }
    class Om extends Cb {
      constructor(t) {
        var e, r, n, i;
        super(`gas: ${null!==(e=t.gas)&&void 0!==e?e:"undefined"}, gasPrice: ${null!==(r=t.gasPrice)&&void 0!==r?r:"undefined"}, maxPriorityFeePerGas: ${null!==(n=t.maxPriorityFeePerGas)&&void 0!==n?n:"undefined"}, maxFeePerGas: ${null!==(i=t.maxFeePerGas)&&void 0!==i?i:"undefined"}`, '"gas" is missing'), this.code = 415, this.cause = new Sm
      }
    }
    class Bm extends Wb {
      constructor() {
        super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both'), this.code = 441
      }
    }
    class Wm extends Cb {
      constructor(t) {
        var e, r, n, i;
        super(`gas: ${null!==(e=t.gas)&&void 0!==e?e:"undefined"}, gasPrice: ${null!==(r=t.gasPrice)&&void 0!==r?r:"undefined"}, maxPriorityFeePerGas: ${null!==(n=t.maxPriorityFeePerGas)&&void 0!==n?n:"undefined"}, maxFeePerGas: ${null!==(i=t.maxFeePerGas)&&void 0!==i?i:"undefined"}`, "transaction must specify legacy or fee market gas properties, not both"), this.code = 434, this.cause = new Bm
      }
    }
    class Mm extends Cb {
      constructor(t) {
        var e, r;
        super(`gas: ${null!==(e=t.gas)&&void 0!==e?e:"undefined"}, gasPrice: ${null!==(r=t.gasPrice)&&void 0!==r?r:"undefined"}`, "Gas or gasPrice is lower than 0"), this.code = 416
      }
    }
    class Cm extends Cb {
      constructor(t) {
        var e, r;
        super(`maxPriorityFeePerGas: ${null!==(e=t.maxPriorityFeePerGas)&&void 0!==e?e:"undefined"}, maxFeePerGas: ${null!==(r=t.maxFeePerGas)&&void 0!==r?r:"undefined"}`, "maxPriorityFeePerGas or maxFeePerGas is lower than 0"), this.code = 417
      }
    }
    class Rm extends Cb {
      constructor(t) {
        super(t, "eip-1559 transactions don't support gasPrice"), this.code = 418
      }
    }
    class Nm extends Cb {
      constructor(t) {
        var e, r;
        super(`maxPriorityFeePerGas: ${null!==(e=t.maxPriorityFeePerGas)&&void 0!==e?e:"undefined"}, maxFeePerGas: ${null!==(r=t.maxFeePerGas)&&void 0!==r?r:"undefined"}`, "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas"), this.code = 419
      }
    }
    class jm extends Cb {
      constructor(t) {
        super(t, "invalid transaction object"), this.code = 420
      }
    }
    class _m extends Cb {
      constructor(t) {
        var e, r;
        super(`nonce: ${null!==(e=t.nonce)&&void 0!==e?e:"undefined"}, chainId: ${null!==(r=t.chainId)&&void 0!==r?r:"undefined"}`, "Nonce or chainId is lower than 0"), this.code = 421
      }
    }
    class Dm extends Cb {
      constructor() {
        super("UnableToPopulateNonceError", "unable to populate nonce, no from address available"), this.code = 422
      }
    }
    class Um extends Cb {
      constructor() {
        super("Eip1559NotSupportedError", "Network doesn't support eip-1559"), this.code = 423
      }
    }
    class Lm extends Cb {
      constructor(t) {
        super(t, "unsupported transaction type"), this.code = 424
      }
    }
    class Fm extends Cb {
      constructor(t) {
        var e, r;
        super(`data: ${null!==(e=t.data)&&void 0!==e?e:"undefined"}, input: ${null!==(r=t.input)&&void 0!==r?r:"undefined"}`, 'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.'), this.code = 425
      }
    }
    class $m extends Wb {
      constructor(t) {
        super(`The connected Ethereum Node did not respond within ${t.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\n\tTransaction Hash: ${t.transactionHash?t.transactionHash.toString():"not available"}`), this.code = 431
      }
    }

    function zm(t) {
      return "Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!\n\tTransaction Hash: " + (t ? t.toString() : "not available")
    }
    class Hm extends Wb {
      constructor(t) {
        super(`Transaction was not mined within ${t.numberOfSeconds} seconds. ${zm(t.transactionHash)}`), this.code = 426
      }
    }
    class Gm extends Wb {
      constructor(t) {
        super(`Transaction started at ${t.starterBlockNumber} but was not mined within ${t.numberOfBlocks} blocks. ${zm(t.transactionHash)}`), this.code = 432
      }
    }
    class Km extends Cb {
      constructor(t) {
        var e, r;
        super(`receipt: ${JSON.stringify(t.receipt)}, blockHash: ${null===(e=t.blockHash)||void 0===e?void 0:e.toString()}, transactionHash: ${null===(r=t.transactionHash)||void 0===r?void 0:r.toString()}`, "Receipt missing or blockHash null"), this.code = 427
      }
    }
    class Vm extends Cb {
      constructor(t) {
        super("receipt: " + JSON.stringify(t.receipt), "Receipt missing block number"), this.code = 428
      }
    }
    class Zm extends Wb {
      constructor(t) {
        super(`Invalid signature. "${t}"`), this.code = 433
      }
    }
    class qm extends Cb {
      constructor() {
        super("LocalWalletNotAvailableError", "Attempted to index account in local wallet, but no wallet is available"), this.code = 429
      }
    }
    class Jm extends Wb {
      constructor(t, e) {
        const r = [];
        t.forEach(t => r.push(t.keyword)), super(`The following properties are invalid for the transaction type ${e}: ${r.join(", ")}`), this.code = 439
      }
    }
    class Ym extends Cb {
      constructor(t) {
        super(t, "can not parse as byte data"), this.code = 1002
      }
    }
    class Qm extends Cb {
      constructor(t) {
        super(t, "can not parse as number data"), this.code = 1003
      }
    }
    class Xm extends Cb {
      constructor(t) {
        super(t, "invalid ethereum address"), this.code = 1005
      }
    }
    class ty extends Cb {
      constructor(t) {
        super(t, "not a valid string"), this.code = 1001
      }
    }
    class ey extends Cb {
      constructor(t) {
        super(t, "invalid unit"), this.code = 1004
      }
    }
    class ry extends Cb {
      constructor(t) {
        super(t, "not a valid unit. Must be a positive integer"), this.code = 1015
      }
    }
    class ny extends Cb {
      constructor(t) {
        super(t, "can not be converted to hex"), this.code = 1006
      }
    }
    class iy extends Cb {
      constructor(t) {
        super(t, "value greater than the nibble width"), this.code = 1014
      }
    }
    class oy extends Cb {
      constructor(t) {
        super(t, "not a valid boolean."), this.code = 1008
      }
    }
    class sy extends Cb {
      constructor(t) {
        super(t, "not a valid unsigned integer."), this.code = 1009
      }
    }
    class ay extends Cb {
      constructor(t) {
        super(t, "invalid size given."), this.code = 1010
      }
    }
    class uy extends Cb {
      constructor(t) {
        super(t, "value is larger than size."), this.code = 1011
      }
    }
    class cy extends Cb {
      constructor(t) {
        super(t, "invalid string given"), this.code = 1012
      }
    }
    const fy = t => (t => !(Array.isArray(t) || "2.0" !== t.jsonrpc || !t || void 0 !== t.result && null !== t.result || !("error" in t) || "number" != typeof t.id && "string" != typeof t.id))(t) ? t.error.message : "";
    class ly extends Wb {
      constructor(t, e, r, n) {
        var i;
        let o;
        super(e ?? "Returned error: " + (Array.isArray(t) ? t.map(t => fy(t)).join(",") : fy(t))), this.code = 100, e || (this.data = Array.isArray(t) ? t.map(t => {
          var e;
          return null === (e = t.error) || void 0 === e ? void 0 : e.data
        }) : null === (i = t?.error) || void 0 === i ? void 0 : i.data), this.statusCode = n, this.request = r, "error" in t ? o = t.error : t instanceof Array && (o = t.filter(t => t.error).map(t => t.error)), Array.isArray(o) && o.length > 0 ? this.cause = new Mb(o) : this.cause = o
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          data: this.data,
          request: this.request,
          statusCode: this.statusCode
        })
      }
    }
    class hy extends ly {
      constructor(t, e) {
        let r;
        super(t, void 0, e), this.code = 101, "error" in t ? r = t.error : t instanceof Array && (r = t.map(t => t.error)), this.cause = Array.isArray(r) ? new Mb(r) : r
      }
    }
    class dy extends Wb {
      constructor(t, e) {
        super(`Web3Config hardfork doesnt match in defaultHardfork ${t} and common.hardfork ${e}`), this.code = 1101
      }
    }
    class py extends Wb {
      constructor(t, e) {
        super(`Web3Config chain doesnt match in defaultHardfork ${t} and common.hardfork ${e}`), this.code = 1101
      }
    }
    const by = "An Rpc error has occured with a code of *code*",
      my = {
        [vb]: {
          message: "Parse error",
          description: "Invalid JSON"
        },
        [wb]: {
          message: "Invalid request",
          description: "JSON is not a valid request object\t"
        },
        [Ab]: {
          message: "Method not found",
          description: "Method does not exist\t"
        },
        [Tb]: {
          message: "Invalid params",
          description: "Invalid method parameters"
        },
        [Eb]: {
          message: "Internal error",
          description: "Internal JSON-RPC error"
        },
        [Pb]: {
          message: "Invalid input",
          description: "Missing or invalid parameters"
        },
        [kb]: {
          message: "Resource not found",
          description: "Requested resource not found"
        },
        [xb]: {
          message: "Resource unavailable",
          description: "Requested resource not available"
        },
        [Ib]: {
          message: "Transaction rejected",
          description: "Transaction creation failed"
        },
        [Sb]: {
          message: "Method not supported",
          description: "Method is not implemented"
        },
        [Ob]: {
          message: "Limit exceeded",
          description: "Request exceeds defined limit"
        },
        [Bb]: {
          message: "JSON-RPC version not supported",
          description: "Version of JSON-RPC protocol is not supported"
        },
        [pb]: {
          name: "User Rejected Request",
          message: "The user rejected the request."
        },
        [bb]: {
          name: "Unauthorized",
          message: "The requested method and/or account has not been authorized by the user."
        },
        [mb]: {
          name: "Unsupported Method",
          message: "The Provider does not support the requested method."
        },
        [yb]: {
          name: "Disconnected",
          message: "The Provider is disconnected from all chains."
        },
        [gb]: {
          name: "Chain Disconnected",
          message: "The Provider is not connected to the requested chain."
        },
        "0-999": {
          name: "",
          message: "Not used."
        },
        1e3: {
          name: "Normal Closure",
          message: "The connection successfully completed the purpose for which it was created."
        },
        1001: {
          name: "Going Away",
          message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
        },
        1002: {
          name: "Protocol error",
          message: "The endpoint is terminating the connection due to a protocol error."
        },
        1003: {
          name: "Unsupported Data",
          message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
        },
        1004: {
          name: "Reserved",
          message: "Reserved. A meaning might be defined in the future."
        },
        1005: {
          name: "No Status Rcvd",
          message: "Reserved. Indicates that no status code was provided even though one was expected."
        },
        1006: {
          name: "Abnormal Closure",
          message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
        },
        1007: {
          name: "Invalid frame payload data",
          message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
        },
        1008: {
          name: "Policy Violation",
          message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
        },
        1009: {
          name: "Message Too Big",
          message: "The endpoint is terminating the connection because a data frame was received that is too large."
        },
        1010: {
          name: "Mandatory Ext.",
          message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
        },
        1011: {
          name: "Internal Error",
          message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
        },
        1012: {
          name: "Service Restart",
          message: "The server is terminating the connection because it is restarting."
        },
        1013: {
          name: "Try Again Later",
          message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
        },
        1014: {
          name: "Bad Gateway",
          message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
        },
        1015: {
          name: "TLS handshake",
          message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
        },
        "1016-2999": {
          name: "",
          message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
        },
        "3000-3999": {
          name: "",
          message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
        },
        "4000-4999": {
          name: "",
          message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
        }
      };
    class yy extends Wb {
      constructor(t, e) {
        super(e ?? by.replace("*code*", t.error.code.toString())), this.code = t.error.code, this.id = t.id, this.jsonrpc = t.jsonrpc, this.jsonRpcError = t.error
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          error: this.jsonRpcError,
          id: this.id,
          jsonRpc: this.jsonrpc
        })
      }
    }
    class gy extends Wb {
      constructor(t, e) {
        var r, n, i, o;
        if (t)
          if (null !== (r = my[t]) && void 0 !== r && r.message) super(my[t].message);
          else {
            const e = Object.keys(my).find(e => "string" == typeof e && t >= parseInt(e.split("-")[0], 10) && t <= parseInt(e.split("-")[1], 10));
            super(null !== (i = null === (n = my[e ?? ""]) || void 0 === n ? void 0 : n.message) && void 0 !== i ? i : by.replace("*code*", null !== (o = t?.toString()) && void 0 !== o ? o : '""'))
          }
        else super();
        this.code = t, this.data = e
      }
    }
    const vy = new Map;
    vy.set(vb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[vb].message), this.code = vb
        }
      }
    }), vy.set(wb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[wb].message), this.code = wb
        }
      }
    }), vy.set(Ab, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Ab].message), this.code = Ab
        }
      }
    }), vy.set(Tb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Tb].message), this.code = Tb
        }
      }
    }), vy.set(Eb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Eb].message), this.code = Eb
        }
      }
    }), vy.set(Pb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Pb].message), this.code = Pb
        }
      }
    }), vy.set(Sb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Sb].message), this.code = Sb
        }
      }
    }), vy.set(xb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[xb].message), this.code = xb
        }
      }
    }), vy.set(Ib, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Ib].message), this.code = Ib
        }
      }
    }), vy.set(kb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[kb].message), this.code = kb
        }
      }
    }), vy.set(Bb, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Bb].message), this.code = Bb
        }
      }
    }), vy.set(Ob, {
      error: class extends yy {
        constructor(t) {
          super(t, my[Ob].message), this.code = Ob
        }
      }
    });
    class wy extends Wb {
      constructor(t) {
        super(`Format for the type ${t} is unsupported`), this.type = t, this.code = 1200
      }
      toJSON() {
        return Object.assign(Object.assign({}, super.toJSON()), {
          type: this.type
        })
      }
    }

    function Ay(t) {
      if (!Number.isSafeInteger(t) || 0 > t) throw Error("positive integer expected, not " + t)
    }

    function Ty(t, ...e) {
      if (! function(t) {
          return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
        }(t)) throw Error("Uint8Array expected");
      if (e.length > 0 && !e.includes(t.length)) throw Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)
    }

    function Ey(t) {
      if ("function" != typeof t || "function" != typeof t.create) throw Error("Hash should be wrapped by utils.wrapConstructor");
      Ay(t.outputLen), Ay(t.blockLen)
    }

    function Py(t, e = !0) {
      if (t.destroyed) throw Error("Hash instance has been destroyed");
      if (e && t.finished) throw Error("Hash#digest() has already been called")
    }

    function ky(t, e) {
      Ty(t);
      const r = e.outputLen;
      if (t.length < r) throw Error("digestInto() expects output buffer of length at least " + r)
    }
    const xy = {
        number: Ay,
        bool: function(t) {
          if ("boolean" != typeof t) throw Error("boolean expected, not " + t)
        },
        bytes: Ty,
        hash: Ey,
        exists: Py,
        output: ky
      },
      Iy = BigInt(2 ** 32 - 1),
      Sy = BigInt(32);

    function Oy(t, e = !1) {
      return e ? {
        h: +(t & Iy),
        l: +(t >> Sy & Iy)
      } : {
        h: 0 | +(t >> Sy & Iy),
        l: 0 | +(t & Iy)
      }
    }

    function By(t, e = !1) {
      let r = new Uint32Array(t.length),
        n = new Uint32Array(t.length);
      for (let i = 0; i < t.length; i++) {
        const {
          h: o,
          l: s
        } = Oy(t[i], e);
        [r[i], n[i]] = [o, s]
      }
      return [r, n]
    }
    const Wy = (t, e, r) => t << r | e >>> 32 - r,
      My = (t, e, r) => e << r | t >>> 32 - r,
      Cy = (t, e, r) => e << r - 32 | t >>> 64 - r,
      Ry = (t, e, r) => t << r - 32 | e >>> 64 - r,
      Ny = {
        fromBig: Oy,
        split: By,
        toBig: (t, e) => BigInt(t >>> 0) << Sy | BigInt(e >>> 0),
        shrSH: (t, e, r) => t >>> r,
        shrSL: (t, e, r) => t << 32 - r | e >>> r,
        rotrSH: (t, e, r) => t >>> r | e << 32 - r,
        rotrSL: (t, e, r) => t << 32 - r | e >>> r,
        rotrBH: (t, e, r) => t << 64 - r | e >>> r - 32,
        rotrBL: (t, e, r) => t >>> r - 32 | e << 64 - r,
        rotr32H: (t, e) => e,
        rotr32L: (t, e) => t,
        rotlSH: Wy,
        rotlSL: My,
        rotlBH: Cy,
        rotlBL: Ry,
        add: function(t, e, r, n) {
          const i = (e >>> 0) + (n >>> 0);
          return {
            h: t + r + (i / 2 ** 32 | 0) | 0,
            l: 0 | i
          }
        },
        add3L: (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
        add3H: (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
        add4L: (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
        add4H: (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
        add5H: (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0,
        add5L: (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0)
      },
      jy = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
      _y = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
      Dy = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
      Uy = (t, e) => t << 32 - e | t >>> e,
      Ly = (t, e) => t << e | t >>> 32 - e >>> 0,
      Fy = 68 === new Uint8Array(new Uint32Array([287454020]).buffer)[0],
      $y = t => t << 24 & 4278190080 | t << 8 & 16711680 | t >>> 8 & 65280 | t >>> 24 & 255;

    function zy(t) {
      for (let e = 0; e < t.length; e++) t[e] = $y(t[e])
    }

    function Hy(t) {
      if ("string" != typeof t) throw Error("utf8ToBytes expected string, got " + typeof t);
      return new Uint8Array((new TextEncoder).encode(t))
    }

    function Gy(t) {
      return "string" == typeof t && (t = Hy(t)), Ty(t), t
    }

    function Ky(...t) {
      let e = 0;
      for (let r = 0; r < t.length; r++) {
        const n = t[r];
        Ty(n), e += n.length
      }
      const r = new Uint8Array(e);
      for (let e = 0, n = 0; e < t.length; e++) {
        const i = t[e];
        r.set(i, n), n += i.length
      }
      return r
    }
    Array.from({
      length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));
    class Vy {
      clone() {
        return this.jt()
      }
    }
    const Zy = {}.toString;

    function qy(t, e) {
      if (void 0 !== e && "[object Object]" !== Zy.call(e)) throw Error("Options should be object or undefined");
      return Object.assign(t, e)
    }

    function Jy(t) {
      const e = e => t().update(Gy(e)).digest(),
        r = t();
      return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
    }

    function Yy(t = 32) {
      if (jy && "function" == typeof jy.getRandomValues) return jy.getRandomValues(new Uint8Array(t));
      throw Error("crypto.getRandomValues must be defined")
    }
    const Qy = [],
      Xy = [],
      tg = [],
      eg = BigInt(0),
      rg = BigInt(1),
      ng = BigInt(2),
      ig = BigInt(7),
      og = BigInt(256),
      sg = BigInt(113);
    for (let t = 0, e = rg, r = 1, n = 0; 24 > t; t++) {
      [r, n] = [n, (2 * r + 3 * n) % 5], Qy.push(2 * (5 * n + r)), Xy.push((t + 1) * (t + 2) / 2 % 64);
      let i = eg;
      for (let t = 0; 7 > t; t++) e = (e << rg ^ (e >> ig) * sg) % og, e & ng && (i ^= rg << (rg << BigInt(t)) - rg);
      tg.push(i)
    }
    const [ag, ug] = By(tg, !0), cg = (t, e, r) => r > 32 ? Cy(t, e, r) : Wy(t, e, r), fg = (t, e, r) => r > 32 ? Ry(t, e, r) : My(t, e, r);
    class lg extends Vy {
      constructor(t, e, r, n = !1, i = 24) {
        if (super(), this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = n, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, Ay(r), 0 >= this.blockLen || this.blockLen >= 200) throw Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = _y(this.state)
      }
      keccak() {
        Fy || zy(this.state32),
          function(t, e = 24) {
            const r = new Uint32Array(10);
            for (let n = 24 - e; 24 > n; n++) {
              for (let e = 0; 10 > e; e++) r[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
              for (let e = 0; 10 > e; e += 2) {
                const n = (e + 8) % 10,
                  i = (e + 2) % 10,
                  o = r[i],
                  s = r[i + 1],
                  a = cg(o, s, 1) ^ r[n],
                  u = fg(o, s, 1) ^ r[n + 1];
                for (let r = 0; 50 > r; r += 10) t[e + r] ^= a, t[e + r + 1] ^= u
              }
              let e = t[2],
                i = t[3];
              for (let r = 0; 24 > r; r++) {
                const n = Xy[r],
                  o = cg(e, i, n),
                  s = fg(e, i, n),
                  a = Qy[r];
                e = t[a], i = t[a + 1], t[a] = o, t[a + 1] = s
              }
              for (let e = 0; 50 > e; e += 10) {
                for (let n = 0; 10 > n; n++) r[n] = t[e + n];
                for (let n = 0; 10 > n; n++) t[e + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10]
              }
              t[0] ^= ag[n], t[1] ^= ug[n]
            }
            r.fill(0)
          }(this.state32, this.rounds), Fy || zy(this.state32), this.posOut = 0, this.pos = 0
      }
      update(t) {
        Py(this);
        const {
          blockLen: e,
          state: r
        } = this, n = (t = Gy(t)).length;
        for (let i = 0; n > i;) {
          const o = Math.min(e - this.pos, n - i);
          for (let e = 0; o > e; e++) r[this.pos++] ^= t[i++];
          this.pos === e && this.keccak()
        }
        return this
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
          state: t,
          suffix: e,
          pos: r,
          blockLen: n
        } = this;
        t[r] ^= e, !!(128 & e) && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak()
      }
      writeInto(t) {
        Py(this, !1), Ty(t), this.finish();
        const e = this.state,
          {
            blockLen: r
          } = this;
        for (let n = 0, i = t.length; i > n;) {
          this.posOut >= r && this.keccak();
          const o = Math.min(r - this.posOut, i - n);
          t.set(e.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o
        }
        return t
      }
      xofInto(t) {
        if (!this.enableXOF) throw Error("XOF is not possible for this instance");
        return this.writeInto(t)
      }
      xof(t) {
        return Ay(t), this.xofInto(new Uint8Array(t))
      }
      digestInto(t) {
        if (ky(t, this), this.finished) throw Error("digest() was already called");
        return this.writeInto(t), this.destroy(), t
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
      }
      destroy() {
        this.destroyed = !0, this.state.fill(0)
      }
      jt(t) {
        const {
          blockLen: e,
          suffix: r,
          outputLen: n,
          rounds: i,
          enableXOF: o
        } = this;
        return t || (t = new lg(e, r, n, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = r, t.outputLen = n, t.enableXOF = o, t.destroyed = this.destroyed, t
      }
    }
    const hg = (t, e, r) => Jy(() => new lg(e, t, r)),
      dg = hg(1, 144, 28),
      pg = hg(1, 136, 32),
      bg = hg(1, 104, 48),
      mg = hg(1, 72, 64),
      yg = (xy.bool, xy.bytes);

    function gg(t) {
      if (!(t instanceof Uint8Array)) throw new TypeError("bytesToUtf8 expected Uint8Array, got " + typeof t);
      return (new TextDecoder).decode(t)
    }

    function vg(t) {
      return e => (xy.bytes(e), t(e))
    }(() => {
      const t = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
        e = "u" > typeof module && "function" == typeof module.require && module.require.bind(module);
      e && !t && e("crypto")
    })(), vg(dg);
    const wg = (() => {
      const t = vg(pg);
      return t.create = pg.create, t
    })();
    var Ag, Tg;
    vg(bg), vg(mg),
      function(t) {
        t.assertEqual = t => {}, t.assertIs = function(t) {}, t.assertNever = function(t) {
          throw Error()
        }, t.arrayToEnum = t => {
          const e = {};
          for (const r of t) e[r] = r;
          return e
        }, t.getValidEnumValues = e => {
          const r = t.objectKeys(e).filter(t => "number" != typeof e[e[t]]),
            n = {};
          for (const t of r) n[t] = e[t];
          return t.objectValues(n)
        }, t.objectValues = e => t.objectKeys(e).map(function(t) {
          return e[t]
        }), t.objectKeys = "function" == typeof Object.keys ? t => Object.keys(t) : t => {
          const e = [];
          for (const r in t)({}).hasOwnProperty.call(t, r) && e.push(r);
          return e
        }, t.find = (t, e) => {
          for (const r of t)
            if (e(r)) return r
        }, t.isInteger = "function" == typeof Number.isInteger ? t => Number.isInteger(t) : t => "number" == typeof t && Number.isFinite(t) && Math.floor(t) === t, t.joinValues = function(t, e = " | ") {
          return t.map(t => "string" == typeof t ? `'${t}'` : t).join(e)
        }, t.jsonStringifyReplacer = (t, e) => "bigint" == typeof e ? e.toString() : e
      }(Ag || (Ag = {})),
      function(t) {
        t.mergeShapes = (t, e) => ({
          ...t,
          ...e
        })
      }(Tg || (Tg = {}));
    const Eg = Ag.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]),
      Pg = t => {
        switch (typeof t) {
          case "undefined":
            return Eg.undefined;
          case "string":
            return Eg.string;
          case "number":
            return Number.isNaN(t) ? Eg.nan : Eg.number;
          case "boolean":
            return Eg.boolean;
          case "function":
            return Eg.function;
          case "bigint":
            return Eg.bigint;
          case "symbol":
            return Eg.symbol;
          case "object":
            return Array.isArray(t) ? Eg.array : null === t ? Eg.null : t.then && "function" == typeof t.then && t.catch && "function" == typeof t.catch ? Eg.promise : "u" > typeof Map && t instanceof Map ? Eg.map : "u" > typeof Set && t instanceof Set ? Eg.set : "u" > typeof Date && t instanceof Date ? Eg.date : Eg.object;
          default:
            return Eg.unknown
        }
      },
      kg = Ag.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]),
      xg = t => JSON.stringify(t, null, 2).replace(/"([^"]+)":/g, "$1:");
    class Ig extends Error {
      get errors() {
        return this.issues
      }
      constructor(t) {
        super(), this.issues = [], this.addIssue = t => {
          this.issues = [...this.issues, t]
        }, this.addIssues = (t = []) => {
          this.issues = [...this.issues, ...t]
        };
        const e = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, e) : this.__proto__ = e, this.name = "ZodError", this.issues = t
      }
      format(t) {
        const e = t || function(t) {
            return t.message
          },
          r = {
            Te: []
          },
          n = t => {
            for (const i of t.issues)
              if ("invalid_union" === i.code) i.unionErrors.map(n);
              else if ("invalid_return_type" === i.code) n(i.returnTypeError);
            else if ("invalid_arguments" === i.code) n(i.argumentsError);
            else if (0 === i.path.length) r.Te.push(e(i));
            else {
              let t = r,
                n = 0;
              for (; n < i.path.length;) {
                const r = i.path[n];
                n === i.path.length - 1 ? (t[r] = t[r] || {
                  Te: []
                }, t[r].Te.push(e(i))) : t[r] = t[r] || {
                  Te: []
                }, t = t[r], n++
              }
            }
          };
        return n(this), r
      }
      static assert(t) {
        if (!(t instanceof Ig)) throw Error("Not a ZodError: " + t)
      }
      toString() {
        return this.message
      }
      get message() {
        return JSON.stringify(this.issues, Ag.jsonStringifyReplacer, 2)
      }
      get isEmpty() {
        return 0 === this.issues.length
      }
      flatten(t = t => t.message) {
        const e = {},
          r = [];
        for (const n of this.issues)
          if (n.path.length > 0) {
            const r = n.path[0];
            e[r] = e[r] || [], e[r].push(t(n))
          } else r.push(t(n));
        return {
          formErrors: r,
          fieldErrors: e
        }
      }
      get formErrors() {
        return this.flatten()
      }
    }
    Ig.create = t => new Ig(t);
    const Sg = (t, e) => {
      let r;
      switch (t.code) {
        case kg.invalid_type:
          r = t.received === Eg.undefined ? "Required" : `Expected ${t.expected}, received ${t.received}`;
          break;
        case kg.invalid_literal:
          r = "Invalid literal value, expected " + JSON.stringify(t.expected, Ag.jsonStringifyReplacer);
          break;
        case kg.unrecognized_keys:
          r = "Unrecognized key(s) in object: " + Ag.joinValues(t.keys, ", ");
          break;
        case kg.invalid_union:
          r = "Invalid input";
          break;
        case kg.invalid_union_discriminator:
          r = "Invalid discriminator value. Expected " + Ag.joinValues(t.options);
          break;
        case kg.invalid_enum_value:
          r = `Invalid enum value. Expected ${Ag.joinValues(t.options)}, received '${t.received}'`;
          break;
        case kg.invalid_arguments:
          r = "Invalid function arguments";
          break;
        case kg.invalid_return_type:
          r = "Invalid function return type";
          break;
        case kg.invalid_date:
          r = "Invalid date";
          break;
        case kg.invalid_string:
          "object" == typeof t.validation ? "includes" in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`, "number" == typeof t.validation.position && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith" in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith" in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : Ag.assertNever(t.validation) : r = "regex" !== t.validation ? "Invalid " + t.validation : "Invalid";
          break;
        case kg.too_small:
          r = "array" === t.type ? `Array must contain ${t.exact?"exactly":t.inclusive?"at least":"more than"} ${t.minimum} element(s)` : "string" === t.type ? `String must contain ${t.exact?"exactly":t.inclusive?"at least":"over"} ${t.minimum} character(s)` : "number" === t.type || "bigint" === t.type ? `Number must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${t.minimum}` : "date" === t.type ? `Date must be ${t.exact?"exactly equal to ":t.inclusive?"greater than or equal to ":"greater than "}${new Date(+t.minimum)}` : "Invalid input";
          break;
        case kg.too_big:
          r = "array" === t.type ? `Array must contain ${t.exact?"exactly":t.inclusive?"at most":"less than"} ${t.maximum} element(s)` : "string" === t.type ? `String must contain ${t.exact?"exactly":t.inclusive?"at most":"under"} ${t.maximum} character(s)` : "number" === t.type ? `Number must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : "bigint" === t.type ? `BigInt must be ${t.exact?"exactly":t.inclusive?"less than or equal to":"less than"} ${t.maximum}` : "date" === t.type ? `Date must be ${t.exact?"exactly":t.inclusive?"smaller than or equal to":"smaller than"} ${new Date(+t.maximum)}` : "Invalid input";
          break;
        case kg.custom:
          r = "Invalid input";
          break;
        case kg.invalid_intersection_types:
          r = "Intersection results could not be merged";
          break;
        case kg.not_multiple_of:
          r = "Number must be a multiple of " + t.multipleOf;
          break;
        case kg.not_finite:
          r = "Number must be finite";
          break;
        default:
          r = e.defaultError, Ag.assertNever(t)
      }
      return {
        message: r
      }
    };
    let Og = Sg;

    function Bg(t) {
      Og = t
    }

    function Wg() {
      return Og
    }
    var Mg;
    ! function(t) {
      t.errToObj = t => "string" == typeof t ? {
        message: t
      } : t || {}, t.toString = t => "string" == typeof t ? t : t?.message
    }(Mg || (Mg = {}));
    const Cg = t => {
        const {
          data: e,
          path: r,
          errorMaps: n,
          issueData: i
        } = t, o = [...r, ...i.path || []], s = {
          ...i,
          path: o
        };
        if (void 0 !== i.message) return {
          ...i,
          path: o,
          message: i.message
        };
        let a = "";
        const u = n.filter(t => !!t).slice().reverse();
        for (const t of u) a = t(s, {
          data: e,
          defaultError: a
        }).message;
        return {
          ...i,
          path: o,
          message: a
        }
      },
      Rg = [];

    function Ng(t, e) {
      const r = Wg(),
        n = Cg({
          issueData: e,
          data: t.data,
          path: t.path,
          errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, r, r === Sg ? void 0 : Sg].filter(t => !!t)
        });
      t.common.issues.push(n)
    }
    class jg {
      constructor() {
        this.value = "valid"
      }
      dirty() {
        "valid" === this.value && (this.value = "dirty")
      }
      abort() {
        "aborted" !== this.value && (this.value = "aborted")
      }
      static mergeArray(t, e) {
        const r = [];
        for (const n of e) {
          if ("aborted" === n.status) return _g;
          "dirty" === n.status && t.dirty(), r.push(n.value)
        }
        return {
          status: t.value,
          value: r
        }
      }
      static async mergeObjectAsync(t, e) {
        const r = [];
        for (const t of e) {
          const e = await t.key,
            n = await t.value;
          r.push({
            key: e,
            value: n
          })
        }
        return jg.mergeObjectSync(t, r)
      }
      static mergeObjectSync(t, e) {
        const r = {};
        for (const n of e) {
          const {
            key: e,
            value: i
          } = n;
          if ("aborted" === e.status || "aborted" === i.status) return _g;
          "dirty" === e.status && t.dirty(), "dirty" === i.status && t.dirty(), "__proto__" !== e.value && ("u" > typeof i.value || n.alwaysSet) && (r[e.value] = i.value)
        }
        return {
          status: t.value,
          value: r
        }
      }
    }
    const _g = Object.freeze({
        status: "aborted"
      }),
      Dg = t => ({
        status: "dirty",
        value: t
      }),
      Ug = t => ({
        status: "valid",
        value: t
      }),
      Lg = t => "aborted" === t.status,
      Fg = t => "dirty" === t.status,
      $g = t => "valid" === t.status,
      zg = t => "u" > typeof Promise && t instanceof Promise;
    class Hg {
      constructor(t, e, r, n) {
        this.vn = [], this.parent = t, this.data = e, this.wn = r, this.An = n
      }
      get path() {
        return this.vn.length || (Array.isArray(this.An) ? this.vn.push(...this.wn, ...this.An) : this.vn.push(...this.wn, this.An)), this.vn
      }
    }
    const Gg = (t, e) => {
      if ($g(e)) return {
        success: !0,
        data: e.value
      };
      if (!t.common.issues.length) throw Error("Validation failed but no issues detected.");
      return {
        success: !1,
        get error() {
          if (this.ft) return this.ft;
          const e = new Ig(t.common.issues);
          return this.ft = e, this.ft
        }
      }
    };

    function Kg(t) {
      if (!t) return {};
      const {
        errorMap: e,
        invalid_type_error: r,
        required_error: n,
        description: i
      } = t;
      if (e && (r || n)) throw Error('Can\'t use "invalid_type_error" or "required_error" in conjunction with custom error map.');
      return e ? {
        errorMap: e,
        description: i
      } : {
        errorMap: (e, i) => {
          const {
            message: o
          } = t;
          return "invalid_enum_value" === e.code ? {
            message: o ?? i.defaultError
          } : typeof i.data > "u" ? {
            message: o ?? n ?? i.defaultError
          } : "invalid_type" !== e.code ? {
            message: i.defaultError
          } : {
            message: o ?? r ?? i.defaultError
          }
        },
        description: i
      }
    }
    class Vg {
      get description() {
        return this.Tn.description
      }
      En(t) {
        return Pg(t.data)
      }
      Pn(t, e) {
        return e || {
          common: t.parent.common,
          data: t.data,
          parsedType: Pg(t.data),
          schemaErrorMap: this.Tn.errorMap,
          path: t.path,
          parent: t.parent
        }
      }
      kn(t) {
        return {
          status: new jg,
          ctx: {
            common: t.parent.common,
            data: t.data,
            parsedType: Pg(t.data),
            schemaErrorMap: this.Tn.errorMap,
            path: t.path,
            parent: t.parent
          }
        }
      }
      xn(t) {
        const e = this.In(t);
        if (zg(e)) throw Error("Synchronous parse encountered promise.");
        return e
      }
      Sn(t) {
        const e = this.In(t);
        return Promise.resolve(e)
      }
      parse(t, e) {
        const r = this.safeParse(t, e);
        if (r.success) return r.data;
        throw r.error
      }
      safeParse(t, e) {
        const r = {
            common: {
              issues: [],
              async: e?.async ?? !1,
              contextualErrorMap: e?.errorMap
            },
            path: e?.path || [],
            schemaErrorMap: this.Tn.errorMap,
            parent: null,
            data: t,
            parsedType: Pg(t)
          },
          n = this.xn({
            data: t,
            path: r.path,
            parent: r
          });
        return Gg(r, n)
      }
      "~validate"(t) {
        const e = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this.Tn.errorMap,
          parent: null,
          data: t,
          parsedType: Pg(t)
        };
        if (!this["~standard"].async) try {
          const r = this.xn({
            data: t,
            path: [],
            parent: e
          });
          return $g(r) ? {
            value: r.value
          } : {
            issues: e.common.issues
          }
        } catch (t) {
          t?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), e.common = {
            issues: [],
            async: !0
          }
        }
        return this.Sn({
          data: t,
          path: [],
          parent: e
        }).then(t => $g(t) ? {
          value: t.value
        } : {
          issues: e.common.issues
        })
      }
      async parseAsync(t, e) {
        const r = await this.safeParseAsync(t, e);
        if (r.success) return r.data;
        throw r.error
      }
      async safeParseAsync(t, e) {
        const r = {
            common: {
              issues: [],
              contextualErrorMap: e?.errorMap,
              async: !0
            },
            path: e?.path || [],
            schemaErrorMap: this.Tn.errorMap,
            parent: null,
            data: t,
            parsedType: Pg(t)
          },
          n = this.In({
            data: t,
            path: r.path,
            parent: r
          }),
          i = await (zg(n) ? n : Promise.resolve(n));
        return Gg(r, i)
      }
      refine(t, e) {
        const r = t => "string" == typeof e || typeof e > "u" ? {
          message: e
        } : "function" == typeof e ? e(t) : e;
        return this.On((e, n) => {
          const i = t(e),
            o = () => n.addIssue({
              code: kg.custom,
              ...r(e)
            });
          return "u" > typeof Promise && i instanceof Promise ? i.then(t => !!t || (o(), !1)) : !!i || (o(), !1)
        })
      }
      refinement(t, e) {
        return this.On((r, n) => !!t(r) || (n.addIssue("function" == typeof e ? e(r, n) : e), !1))
      }
      On(t) {
        return new qv({
          schema: this,
          typeName: uw.ZodEffects,
          effect: {
            type: "refinement",
            refinement: t
          }
        })
      }
      superRefine(t) {
        return this.On(t)
      }
      constructor(t) {
        this.spa = this.safeParseAsync, this.Tn = t, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: t => this["~validate"](t)
        }
      }
      optional() {
        return Jv.create(this, this.Tn)
      }
      nullable() {
        return Yv.create(this, this.Tn)
      }
      nullish() {
        return this.nullable().optional()
      }
      array() {
        return Bv.create(this)
      }
      promise() {
        return Zv.create(this, this.Tn)
      }
      or(t) {
        return Cv.create([this, t], this.Tn)
      }
      and(t) {
        return _v.create(this, t, this.Tn)
      }
      transform(t) {
        return new qv({
          ...Kg(this.Tn),
          schema: this,
          typeName: uw.ZodEffects,
          effect: {
            type: "transform",
            transform: t
          }
        })
      }
      default (t) {
        const e = "function" == typeof t ? t : () => t;
        return new Qv({
          ...Kg(this.Tn),
          innerType: this,
          defaultValue: e,
          typeName: uw.ZodDefault
        })
      }
      brand() {
        return new rw({
          typeName: uw.ZodBranded,
          type: this,
          ...Kg(this.Tn)
        })
      } catch (t) {
        const e = "function" == typeof t ? t : () => t;
        return new Xv({
          ...Kg(this.Tn),
          innerType: this,
          catchValue: e,
          typeName: uw.ZodCatch
        })
      }
      describe(t) {
        return new(0, this.constructor)({
          ...this.Tn,
          description: t
        })
      }
      pipe(t) {
        return nw.create(this, t)
      }
      readonly() {
        return iw.create(this)
      }
      isOptional() {
        return this.safeParse(void 0).success
      }
      isNullable() {
        return this.safeParse(null).success
      }
    }
    const Zg = /^c[^\s-]{8,}$/i,
      qg = /^[0-9a-z]+$/,
      Jg = /^[0-9A-HJKMNP-TV-Z]{26}$/i,
      Yg = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i,
      Qg = /^[a-z0-9_-]{21}$/i,
      Xg = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/,
      tv = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/,
      ev = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    let rv;
    const nv = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
      iv = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
      ov = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/,
      sv = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
      av = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
      uv = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
      cv = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))",
      fv = RegExp(`^${cv}$`);

    function lv(t) {
      let e = "[0-5]\\d";
      return t.precision ? e = `${e}\\.\\d{${t.precision}}` : null == t.precision && (e += "(\\.\\d+)?"), `([01]\\d|2[0-3]):[0-5]\\d(:${e})${t.precision?"+":"?"}`
    }

    function hv(t) {
      return RegExp(`^${lv(t)}$`)
    }

    function dv(t) {
      let e = `${cv}T${lv(t)}`;
      const r = [];
      return r.push(t.local ? "Z?" : "Z"), t.offset && r.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${r.join("|")})`, RegExp(`^${e}$`)
    }

    function pv(t, e) {
      return !(("v4" !== e && e || !nv.test(t)) && ("v6" !== e && e || !ov.test(t)))
    }

    function bv(t, e) {
      if (!Xg.test(t)) return !1;
      try {
        const [r] = t.split(".");
        if (!r) return !1;
        const n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "="),
          i = JSON.parse(atob(n));
        return !("object" != typeof i || null === i || "typ" in i && "JWT" !== i?.typ || !i.alg || e && i.alg !== e)
      } catch {
        return !1
      }
    }

    function mv(t, e) {
      return !(("v4" !== e && e || !iv.test(t)) && ("v6" !== e && e || !sv.test(t)))
    }
    class yv extends Vg {
      In(t) {
        if (this.Tn.coerce && (t.data = t.data + ""), this.En(t) !== Eg.string) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.string,
            received: e.parsedType
          }), _g
        }
        const e = new jg;
        let r;
        for (const n of this.Tn.checks)
          if ("min" === n.kind) t.data.length < n.value && (r = this.Pn(t, r), Ng(r, {
            code: kg.too_small,
            minimum: n.value,
            type: "string",
            inclusive: !0,
            exact: !1,
            message: n.message
          }), e.dirty());
          else if ("max" === n.kind) t.data.length > n.value && (r = this.Pn(t, r), Ng(r, {
          code: kg.too_big,
          maximum: n.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: n.message
        }), e.dirty());
        else if ("length" === n.kind) {
          const i = t.data.length > n.value,
            o = t.data.length < n.value;
          (i || o) && (r = this.Pn(t, r), i ? Ng(r, {
            code: kg.too_big,
            maximum: n.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: n.message
          }) : o && Ng(r, {
            code: kg.too_small,
            minimum: n.value,
            type: "string",
            inclusive: !0,
            exact: !0,
            message: n.message
          }), e.dirty())
        } else if ("email" === n.kind) ev.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "email",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("emoji" === n.kind) rv || (rv = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u")), rv.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "emoji",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("uuid" === n.kind) Yg.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "uuid",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("nanoid" === n.kind) Qg.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "nanoid",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("cuid" === n.kind) Zg.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "cuid",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("cuid2" === n.kind) qg.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "cuid2",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("ulid" === n.kind) Jg.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "ulid",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty());
        else if ("url" === n.kind) try {
          new URL(t.data)
        } catch {
          r = this.Pn(t, r), Ng(r, {
            validation: "url",
            code: kg.invalid_string,
            message: n.message
          }), e.dirty()
        } else "regex" === n.kind ? (n.regex.lastIndex = 0, n.regex.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "regex",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty())) : "trim" === n.kind ? t.data = t.data.trim() : "includes" === n.kind ? t.data.includes(n.value, n.position) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: {
            includes: n.value,
            position: n.position
          },
          message: n.message
        }), e.dirty()) : "toLowerCase" === n.kind ? t.data = t.data.toLowerCase() : "toUpperCase" === n.kind ? t.data = t.data.toUpperCase() : "startsWith" === n.kind ? t.data.startsWith(n.value) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: {
            startsWith: n.value
          },
          message: n.message
        }), e.dirty()) : "endsWith" === n.kind ? t.data.endsWith(n.value) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: {
            endsWith: n.value
          },
          message: n.message
        }), e.dirty()) : "datetime" === n.kind ? dv(n).test(t.data) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: "datetime",
          message: n.message
        }), e.dirty()) : "date" === n.kind ? fv.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: "date",
          message: n.message
        }), e.dirty()) : "time" === n.kind ? hv(n).test(t.data) || (r = this.Pn(t, r), Ng(r, {
          code: kg.invalid_string,
          validation: "time",
          message: n.message
        }), e.dirty()) : "duration" === n.kind ? tv.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "duration",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : "ip" === n.kind ? pv(t.data, n.version) || (r = this.Pn(t, r), Ng(r, {
          validation: "ip",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : "jwt" === n.kind ? bv(t.data, n.alg) || (r = this.Pn(t, r), Ng(r, {
          validation: "jwt",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : "cidr" === n.kind ? mv(t.data, n.version) || (r = this.Pn(t, r), Ng(r, {
          validation: "cidr",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : "base64" === n.kind ? av.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "base64",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : "base64url" === n.kind ? uv.test(t.data) || (r = this.Pn(t, r), Ng(r, {
          validation: "base64url",
          code: kg.invalid_string,
          message: n.message
        }), e.dirty()) : Ag.assertNever(n);
        return {
          status: e.value,
          value: t.data
        }
      }
      Bn(t, e, r) {
        return this.refinement(e => t.test(e), {
          validation: e,
          code: kg.invalid_string,
          ...Mg.errToObj(r)
        })
      }
      Wn(t) {
        return new yv({
          ...this.Tn,
          checks: [...this.Tn.checks, t]
        })
      }
      email(t) {
        return this.Wn({
          kind: "email",
          ...Mg.errToObj(t)
        })
      }
      url(t) {
        return this.Wn({
          kind: "url",
          ...Mg.errToObj(t)
        })
      }
      emoji(t) {
        return this.Wn({
          kind: "emoji",
          ...Mg.errToObj(t)
        })
      }
      uuid(t) {
        return this.Wn({
          kind: "uuid",
          ...Mg.errToObj(t)
        })
      }
      nanoid(t) {
        return this.Wn({
          kind: "nanoid",
          ...Mg.errToObj(t)
        })
      }
      cuid(t) {
        return this.Wn({
          kind: "cuid",
          ...Mg.errToObj(t)
        })
      }
      cuid2(t) {
        return this.Wn({
          kind: "cuid2",
          ...Mg.errToObj(t)
        })
      }
      ulid(t) {
        return this.Wn({
          kind: "ulid",
          ...Mg.errToObj(t)
        })
      }
      base64(t) {
        return this.Wn({
          kind: "base64",
          ...Mg.errToObj(t)
        })
      }
      base64url(t) {
        return this.Wn({
          kind: "base64url",
          ...Mg.errToObj(t)
        })
      }
      jwt(t) {
        return this.Wn({
          kind: "jwt",
          ...Mg.errToObj(t)
        })
      }
      ip(t) {
        return this.Wn({
          kind: "ip",
          ...Mg.errToObj(t)
        })
      }
      cidr(t) {
        return this.Wn({
          kind: "cidr",
          ...Mg.errToObj(t)
        })
      }
      datetime(t) {
        return "string" == typeof t ? this.Wn({
          kind: "datetime",
          precision: null,
          offset: !1,
          local: !1,
          message: t
        }) : this.Wn({
          kind: "datetime",
          precision: typeof t?.precision > "u" ? null : t?.precision,
          offset: t?.offset ?? !1,
          local: t?.local ?? !1,
          ...Mg.errToObj(t?.message)
        })
      }
      date(t) {
        return this.Wn({
          kind: "date",
          message: t
        })
      }
      time(t) {
        return "string" == typeof t ? this.Wn({
          kind: "time",
          precision: null,
          message: t
        }) : this.Wn({
          kind: "time",
          precision: typeof t?.precision > "u" ? null : t?.precision,
          ...Mg.errToObj(t?.message)
        })
      }
      duration(t) {
        return this.Wn({
          kind: "duration",
          ...Mg.errToObj(t)
        })
      }
      regex(t, e) {
        return this.Wn({
          kind: "regex",
          regex: t,
          ...Mg.errToObj(e)
        })
      }
      includes(t, e) {
        return this.Wn({
          kind: "includes",
          value: t,
          position: e?.position,
          ...Mg.errToObj(e?.message)
        })
      }
      startsWith(t, e) {
        return this.Wn({
          kind: "startsWith",
          value: t,
          ...Mg.errToObj(e)
        })
      }
      endsWith(t, e) {
        return this.Wn({
          kind: "endsWith",
          value: t,
          ...Mg.errToObj(e)
        })
      }
      min(t, e) {
        return this.Wn({
          kind: "min",
          value: t,
          ...Mg.errToObj(e)
        })
      }
      max(t, e) {
        return this.Wn({
          kind: "max",
          value: t,
          ...Mg.errToObj(e)
        })
      }
      length(t, e) {
        return this.Wn({
          kind: "length",
          value: t,
          ...Mg.errToObj(e)
        })
      }
      nonempty(t) {
        return this.min(1, Mg.errToObj(t))
      }
      trim() {
        return new yv({
          ...this.Tn,
          checks: [...this.Tn.checks, {
            kind: "trim"
          }]
        })
      }
      toLowerCase() {
        return new yv({
          ...this.Tn,
          checks: [...this.Tn.checks, {
            kind: "toLowerCase"
          }]
        })
      }
      toUpperCase() {
        return new yv({
          ...this.Tn,
          checks: [...this.Tn.checks, {
            kind: "toUpperCase"
          }]
        })
      }
      get isDatetime() {
        return !!this.Tn.checks.find(t => "datetime" === t.kind)
      }
      get isDate() {
        return !!this.Tn.checks.find(t => "date" === t.kind)
      }
      get isTime() {
        return !!this.Tn.checks.find(t => "time" === t.kind)
      }
      get isDuration() {
        return !!this.Tn.checks.find(t => "duration" === t.kind)
      }
      get isEmail() {
        return !!this.Tn.checks.find(t => "email" === t.kind)
      }
      get isURL() {
        return !!this.Tn.checks.find(t => "url" === t.kind)
      }
      get isEmoji() {
        return !!this.Tn.checks.find(t => "emoji" === t.kind)
      }
      get isUUID() {
        return !!this.Tn.checks.find(t => "uuid" === t.kind)
      }
      get isNANOID() {
        return !!this.Tn.checks.find(t => "nanoid" === t.kind)
      }
      get isCUID() {
        return !!this.Tn.checks.find(t => "cuid" === t.kind)
      }
      get isCUID2() {
        return !!this.Tn.checks.find(t => "cuid2" === t.kind)
      }
      get isULID() {
        return !!this.Tn.checks.find(t => "ulid" === t.kind)
      }
      get isIP() {
        return !!this.Tn.checks.find(t => "ip" === t.kind)
      }
      get isCIDR() {
        return !!this.Tn.checks.find(t => "cidr" === t.kind)
      }
      get isBase64() {
        return !!this.Tn.checks.find(t => "base64" === t.kind)
      }
      get isBase64url() {
        return !!this.Tn.checks.find(t => "base64url" === t.kind)
      }
      get minLength() {
        let t = null;
        for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
        return t
      }
      get maxLength() {
        let t = null;
        for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
        return t
      }
    }

    function gv(t, e) {
      const r = (t.toString().split(".")[1] || "").length,
        n = (e.toString().split(".")[1] || "").length,
        i = r > n ? r : n;
      return Number.parseInt(t.toFixed(i).replace(".", "")) % Number.parseInt(e.toFixed(i).replace(".", "")) / 10 ** i
    }
    yv.create = t => new yv({
      checks: [],
      typeName: uw.ZodString,
      coerce: t?.coerce ?? !1,
      ...Kg(t)
    });
    class vv extends Vg {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf
      }
      In(t) {
        if (this.Tn.coerce && (t.data = +t.data), this.En(t) !== Eg.number) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.number,
            received: e.parsedType
          }), _g
        }
        let e;
        const r = new jg;
        for (const n of this.Tn.checks) "int" === n.kind ? Ag.isInteger(t.data) || (e = this.Pn(t, e), Ng(e, {
          code: kg.invalid_type,
          expected: "integer",
          received: "float",
          message: n.message
        }), r.dirty()) : "min" === n.kind ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (e = this.Pn(t, e), Ng(e, {
          code: kg.too_small,
          minimum: n.value,
          type: "number",
          inclusive: n.inclusive,
          exact: !1,
          message: n.message
        }), r.dirty()) : "max" === n.kind ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (e = this.Pn(t, e), Ng(e, {
          code: kg.too_big,
          maximum: n.value,
          type: "number",
          inclusive: n.inclusive,
          exact: !1,
          message: n.message
        }), r.dirty()) : "multipleOf" === n.kind ? 0 !== gv(t.data, n.value) && (e = this.Pn(t, e), Ng(e, {
          code: kg.not_multiple_of,
          multipleOf: n.value,
          message: n.message
        }), r.dirty()) : "finite" === n.kind ? Number.isFinite(t.data) || (e = this.Pn(t, e), Ng(e, {
          code: kg.not_finite,
          message: n.message
        }), r.dirty()) : Ag.assertNever(n);
        return {
          status: r.value,
          value: t.data
        }
      }
      gte(t, e) {
        return this.setLimit("min", t, !0, Mg.toString(e))
      }
      gt(t, e) {
        return this.setLimit("min", t, !1, Mg.toString(e))
      }
      lte(t, e) {
        return this.setLimit("max", t, !0, Mg.toString(e))
      }
      lt(t, e) {
        return this.setLimit("max", t, !1, Mg.toString(e))
      }
      setLimit(t, e, r, n) {
        return new vv({
          ...this.Tn,
          checks: [...this.Tn.checks, {
            kind: t,
            value: e,
            inclusive: r,
            message: Mg.toString(n)
          }]
        })
      }
      Wn(t) {
        return new vv({
          ...this.Tn,
          checks: [...this.Tn.checks, t]
        })
      }
      int(t) {
        return this.Wn({
          kind: "int",
          message: Mg.toString(t)
        })
      }
      positive(t) {
        return this.Wn({
          kind: "min",
          value: 0,
          inclusive: !1,
          message: Mg.toString(t)
        })
      }
      negative(t) {
        return this.Wn({
          kind: "max",
          value: 0,
          inclusive: !1,
          message: Mg.toString(t)
        })
      }
      nonpositive(t) {
        return this.Wn({
          kind: "max",
          value: 0,
          inclusive: !0,
          message: Mg.toString(t)
        })
      }
      nonnegative(t) {
        return this.Wn({
          kind: "min",
          value: 0,
          inclusive: !0,
          message: Mg.toString(t)
        })
      }
      multipleOf(t, e) {
        return this.Wn({
          kind: "multipleOf",
          value: t,
          message: Mg.toString(e)
        })
      }
      finite(t) {
        return this.Wn({
          kind: "finite",
          message: Mg.toString(t)
        })
      }
      safe(t) {
        return this.Wn({
          kind: "min",
          inclusive: !0,
          value: Number.MIN_SAFE_INTEGER,
          message: Mg.toString(t)
        }).Wn({
          kind: "max",
          inclusive: !0,
          value: Number.MAX_SAFE_INTEGER,
          message: Mg.toString(t)
        })
      }
      get minValue() {
        let t = null;
        for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
        return t
      }
      get maxValue() {
        let t = null;
        for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
        return t
      }
      get isInt() {
        return !!this.Tn.checks.find(t => "int" === t.kind || "multipleOf" === t.kind && Ag.isInteger(t.value))
      }
      get isFinite() {
        let t = null,
          e = null;
        for (const r of this.Tn.checks) {
          if ("finite" === r.kind || "int" === r.kind || "multipleOf" === r.kind) return !0;
          "min" === r.kind ? (null === e || r.value > e) && (e = r.value) : "max" === r.kind && (null === t || r.value < t) && (t = r.value)
        }
        return Number.isFinite(e) && Number.isFinite(t)
      }
    }
    vv.create = t => new vv({
      checks: [],
      typeName: uw.ZodNumber,
      coerce: t?.coerce || !1,
      ...Kg(t)
    });
    class wv extends Vg {
      constructor() {
        super(...arguments), this.min = this.gte, this.max = this.lte
      }
      In(t) {
        if (this.Tn.coerce) try {
          t.data = BigInt(t.data)
        } catch {
          return this.Mn(t)
        }
        if (this.En(t) !== Eg.bigint) return this.Mn(t);
        let e;
        const r = new jg;
        for (const n of this.Tn.checks) "min" === n.kind ? (n.inclusive ? t.data < n.value : t.data <= n.value) && (e = this.Pn(t, e), Ng(e, {
          code: kg.too_small,
          type: "bigint",
          minimum: n.value,
          inclusive: n.inclusive,
          message: n.message
        }), r.dirty()) : "max" === n.kind ? (n.inclusive ? t.data > n.value : t.data >= n.value) && (e = this.Pn(t, e), Ng(e, {
          code: kg.too_big,
          type: "bigint",
          maximum: n.value,
          inclusive: n.inclusive,
          message: n.message
        }), r.dirty()) : "multipleOf" === n.kind ? t.data % n.value !== BigInt(0) && (e = this.Pn(t, e), Ng(e, {
          code: kg.not_multiple_of,
          multipleOf: n.value,
          message: n.message
        }), r.dirty()) : Ag.assertNever(n);
        return {
          status: r.value,
          value: t.data
        }
      }
      Mn(t) {
        const e = this.Pn(t);
        return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.bigint,
          received: e.parsedType
        }), _g
      }
      gte(t, e) {
        return this.setLimit("min", t, !0, Mg.toString(e))
      }
      gt(t, e) {
        return this.setLimit("min", t, !1, Mg.toString(e))
      }
      lte(t, e) {
        return this.setLimit("max", t, !0, Mg.toString(e))
      }
      lt(t, e) {
        return this.setLimit("max", t, !1, Mg.toString(e))
      }
      setLimit(t, e, r, n) {
        return new wv({
          ...this.Tn,
          checks: [...this.Tn.checks, {
            kind: t,
            value: e,
            inclusive: r,
            message: Mg.toString(n)
          }]
        })
      }
      Wn(t) {
        return new wv({
          ...this.Tn,
          checks: [...this.Tn.checks, t]
        })
      }
      positive(t) {
        return this.Wn({
          kind: "min",
          value: BigInt(0),
          inclusive: !1,
          message: Mg.toString(t)
        })
      }
      negative(t) {
        return this.Wn({
          kind: "max",
          value: BigInt(0),
          inclusive: !1,
          message: Mg.toString(t)
        })
      }
      nonpositive(t) {
        return this.Wn({
          kind: "max",
          value: BigInt(0),
          inclusive: !0,
          message: Mg.toString(t)
        })
      }
      nonnegative(t) {
        return this.Wn({
          kind: "min",
          value: BigInt(0),
          inclusive: !0,
          message: Mg.toString(t)
        })
      }
      multipleOf(t, e) {
        return this.Wn({
          kind: "multipleOf",
          value: t,
          message: Mg.toString(e)
        })
      }
      get minValue() {
        let t = null;
        for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
        return t
      }
      get maxValue() {
        let t = null;
        for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
        return t
      }
    }
    wv.create = t => new wv({
      checks: [],
      typeName: uw.ZodBigInt,
      coerce: t?.coerce ?? !1,
      ...Kg(t)
    });
    class Av extends Vg {
      In(t) {
        if (this.Tn.coerce && (t.data = !!t.data), this.En(t) !== Eg.boolean) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.boolean,
            received: e.parsedType
          }), _g
        }
        return Ug(t.data)
      }
    }
    Av.create = t => new Av({
      typeName: uw.ZodBoolean,
      coerce: t?.coerce || !1,
      ...Kg(t)
    });
    class Tv extends Vg {
      In(t) {
        if (this.Tn.coerce && (t.data = new Date(t.data)), this.En(t) !== Eg.date) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.date,
            received: e.parsedType
          }), _g
        }
        if (Number.isNaN(t.data.getTime())) return Ng(this.Pn(t), {
          code: kg.invalid_date
        }), _g;
        const e = new jg;
        let r;
        for (const n of this.Tn.checks) "min" === n.kind ? t.data.getTime() < n.value && (r = this.Pn(t, r), Ng(r, {
          code: kg.too_small,
          message: n.message,
          inclusive: !0,
          exact: !1,
          minimum: n.value,
          type: "date"
        }), e.dirty()) : "max" === n.kind ? t.data.getTime() > n.value && (r = this.Pn(t, r), Ng(r, {
          code: kg.too_big,
          message: n.message,
          inclusive: !0,
          exact: !1,
          maximum: n.value,
          type: "date"
        }), e.dirty()) : Ag.assertNever(n);
        return {
          status: e.value,
          value: new Date(t.data.getTime())
        }
      }
      Wn(t) {
        return new Tv({
          ...this.Tn,
          checks: [...this.Tn.checks, t]
        })
      }
      min(t, e) {
        return this.Wn({
          kind: "min",
          value: t.getTime(),
          message: Mg.toString(e)
        })
      }
      max(t, e) {
        return this.Wn({
          kind: "max",
          value: t.getTime(),
          message: Mg.toString(e)
        })
      }
      get minDate() {
        let t = null;
        for (const e of this.Tn.checks) "min" === e.kind && (null === t || e.value > t) && (t = e.value);
        return null != t ? new Date(t) : null
      }
      get maxDate() {
        let t = null;
        for (const e of this.Tn.checks) "max" === e.kind && (null === t || e.value < t) && (t = e.value);
        return null != t ? new Date(t) : null
      }
    }
    Tv.create = t => new Tv({
      checks: [],
      coerce: t?.coerce || !1,
      typeName: uw.ZodDate,
      ...Kg(t)
    });
    class Ev extends Vg {
      In(t) {
        if (this.En(t) !== Eg.symbol) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.symbol,
            received: e.parsedType
          }), _g
        }
        return Ug(t.data)
      }
    }
    Ev.create = t => new Ev({
      typeName: uw.ZodSymbol,
      ...Kg(t)
    });
    class Pv extends Vg {
      In(t) {
        if (this.En(t) !== Eg.undefined) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.undefined,
            received: e.parsedType
          }), _g
        }
        return Ug(t.data)
      }
    }
    Pv.create = t => new Pv({
      typeName: uw.ZodUndefined,
      ...Kg(t)
    });
    class kv extends Vg {
      In(t) {
        if (this.En(t) !== Eg.null) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.null,
            received: e.parsedType
          }), _g
        }
        return Ug(t.data)
      }
    }
    kv.create = t => new kv({
      typeName: uw.ZodNull,
      ...Kg(t)
    });
    class xv extends Vg {
      constructor() {
        super(...arguments), this.Cn = !0
      }
      In(t) {
        return Ug(t.data)
      }
    }
    xv.create = t => new xv({
      typeName: uw.ZodAny,
      ...Kg(t)
    });
    class Iv extends Vg {
      constructor() {
        super(...arguments), this.Rn = !0
      }
      In(t) {
        return Ug(t.data)
      }
    }
    Iv.create = t => new Iv({
      typeName: uw.ZodUnknown,
      ...Kg(t)
    });
    class Sv extends Vg {
      In(t) {
        const e = this.Pn(t);
        return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.never,
          received: e.parsedType
        }), _g
      }
    }
    Sv.create = t => new Sv({
      typeName: uw.ZodNever,
      ...Kg(t)
    });
    class Ov extends Vg {
      In(t) {
        if (this.En(t) !== Eg.undefined) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.void,
            received: e.parsedType
          }), _g
        }
        return Ug(t.data)
      }
    }
    Ov.create = t => new Ov({
      typeName: uw.ZodVoid,
      ...Kg(t)
    });
    class Bv extends Vg {
      In(t) {
        const {
          ctx: e,
          status: r
        } = this.kn(t), n = this.Tn;
        if (e.parsedType !== Eg.array) return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.array,
          received: e.parsedType
        }), _g;
        if (null !== n.exactLength) {
          const t = e.data.length > n.exactLength.value,
            i = e.data.length < n.exactLength.value;
          (t || i) && (Ng(e, {
            code: t ? kg.too_big : kg.too_small,
            minimum: i ? n.exactLength.value : void 0,
            maximum: t ? n.exactLength.value : void 0,
            type: "array",
            inclusive: !0,
            exact: !0,
            message: n.exactLength.message
          }), r.dirty())
        }
        if (null !== n.minLength && e.data.length < n.minLength.value && (Ng(e, {
            code: kg.too_small,
            minimum: n.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n.minLength.message
          }), r.dirty()), null !== n.maxLength && e.data.length > n.maxLength.value && (Ng(e, {
            code: kg.too_big,
            maximum: n.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: n.maxLength.message
          }), r.dirty()), e.common.async) return Promise.all([...e.data].map((t, r) => n.type.Sn(new Hg(e, t, e.path, r)))).then(t => jg.mergeArray(r, t));
        const i = [...e.data].map((t, r) => n.type.xn(new Hg(e, t, e.path, r)));
        return jg.mergeArray(r, i)
      }
      get element() {
        return this.Tn.type
      }
      min(t, e) {
        return new Bv({
          ...this.Tn,
          minLength: {
            value: t,
            message: Mg.toString(e)
          }
        })
      }
      max(t, e) {
        return new Bv({
          ...this.Tn,
          maxLength: {
            value: t,
            message: Mg.toString(e)
          }
        })
      }
      length(t, e) {
        return new Bv({
          ...this.Tn,
          exactLength: {
            value: t,
            message: Mg.toString(e)
          }
        })
      }
      nonempty(t) {
        return this.min(1, t)
      }
    }

    function Wv(t) {
      if (t instanceof Mv) {
        const e = {};
        for (const r in t.shape) {
          const n = t.shape[r];
          e[r] = Jv.create(Wv(n))
        }
        return new Mv({
          ...t.Tn,
          shape: () => e
        })
      }
      return t instanceof Bv ? new Bv({
        ...t.Tn,
        type: Wv(t.element)
      }) : t instanceof Jv ? Jv.create(Wv(t.unwrap())) : t instanceof Yv ? Yv.create(Wv(t.unwrap())) : t instanceof Dv ? Dv.create(t.items.map(t => Wv(t))) : t
    }
    Bv.create = (t, e) => new Bv({
      type: t,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: uw.ZodArray,
      ...Kg(e)
    });
    class Mv extends Vg {
      constructor() {
        super(...arguments), this.Nn = null, this.nonstrict = this.passthrough, this.augment = this.extend
      }
      jn() {
        if (null !== this.Nn) return this.Nn;
        const t = this.Tn.shape(),
          e = Ag.objectKeys(t);
        return this.Nn = {
          shape: t,
          keys: e
        }, this.Nn
      }
      In(t) {
        if (this.En(t) !== Eg.object) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.object,
            received: e.parsedType
          }), _g
        }
        const {
          status: e,
          ctx: r
        } = this.kn(t), {
          shape: n,
          keys: i
        } = this.jn(), o = [];
        if (!(this.Tn.catchall instanceof Sv && "strip" === this.Tn.unknownKeys))
          for (const t in r.data) i.includes(t) || o.push(t);
        const s = [];
        for (const t of i) {
          const e = n[t],
            i = r.data[t];
          s.push({
            key: {
              status: "valid",
              value: t
            },
            value: e.In(new Hg(r, i, r.path, t)),
            alwaysSet: t in r.data
          })
        }
        if (this.Tn.catchall instanceof Sv) {
          const t = this.Tn.unknownKeys;
          if ("passthrough" === t)
            for (const t of o) s.push({
              key: {
                status: "valid",
                value: t
              },
              value: {
                status: "valid",
                value: r.data[t]
              }
            });
          else if ("strict" === t) o.length > 0 && (Ng(r, {
            code: kg.unrecognized_keys,
            keys: o
          }), e.dirty());
          else if ("strip" !== t) throw Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
          const t = this.Tn.catchall;
          for (const e of o) {
            const n = r.data[e];
            s.push({
              key: {
                status: "valid",
                value: e
              },
              value: t.In(new Hg(r, n, r.path, e)),
              alwaysSet: e in r.data
            })
          }
        }
        return r.common.async ? Promise.resolve().then(async () => {
          const t = [];
          for (const e of s) {
            const r = await e.key,
              n = await e.value;
            t.push({
              key: r,
              value: n,
              alwaysSet: e.alwaysSet
            })
          }
          return t
        }).then(t => jg.mergeObjectSync(e, t)) : jg.mergeObjectSync(e, s)
      }
      get shape() {
        return this.Tn.shape()
      }
      strict(t) {
        return Mg.errToObj, new Mv({
          ...this.Tn,
          unknownKeys: "strict",
          ...void 0 !== t ? {
            errorMap: (e, r) => {
              const n = this.Tn.errorMap?.(e, r).message ?? r.defaultError;
              return "unrecognized_keys" === e.code ? {
                message: Mg.errToObj(t).message ?? n
              } : {
                message: n
              }
            }
          } : {}
        })
      }
      strip() {
        return new Mv({
          ...this.Tn,
          unknownKeys: "strip"
        })
      }
      passthrough() {
        return new Mv({
          ...this.Tn,
          unknownKeys: "passthrough"
        })
      }
      extend(t) {
        return new Mv({
          ...this.Tn,
          shape: () => ({
            ...this.Tn.shape(),
            ...t
          })
        })
      }
      merge(t) {
        return new Mv({
          unknownKeys: t.Tn.unknownKeys,
          catchall: t.Tn.catchall,
          shape: () => ({
            ...this.Tn.shape(),
            ...t.Tn.shape()
          }),
          typeName: uw.ZodObject
        })
      }
      setKey(t, e) {
        return this.augment({
          [t]: e
        })
      }
      catchall(t) {
        return new Mv({
          ...this.Tn,
          catchall: t
        })
      }
      pick(t) {
        const e = {};
        for (const r of Ag.objectKeys(t)) t[r] && this.shape[r] && (e[r] = this.shape[r]);
        return new Mv({
          ...this.Tn,
          shape: () => e
        })
      }
      omit(t) {
        const e = {};
        for (const r of Ag.objectKeys(this.shape)) t[r] || (e[r] = this.shape[r]);
        return new Mv({
          ...this.Tn,
          shape: () => e
        })
      }
      deepPartial() {
        return Wv(this)
      }
      partial(t) {
        const e = {};
        for (const r of Ag.objectKeys(this.shape)) {
          const n = this.shape[r];
          t && !t[r] ? e[r] = n : e[r] = n.optional()
        }
        return new Mv({
          ...this.Tn,
          shape: () => e
        })
      }
      required(t) {
        const e = {};
        for (const r of Ag.objectKeys(this.shape))
          if (t && !t[r]) e[r] = this.shape[r];
          else {
            let t = this.shape[r];
            for (; t instanceof Jv;) t = t.Tn.innerType;
            e[r] = t
          } return new Mv({
          ...this.Tn,
          shape: () => e
        })
      }
      keyof() {
        return Gv(Ag.objectKeys(this.shape))
      }
    }
    Mv.create = (t, e) => new Mv({
      shape: () => t,
      unknownKeys: "strip",
      catchall: Sv.create(),
      typeName: uw.ZodObject,
      ...Kg(e)
    }), Mv.strictCreate = (t, e) => new Mv({
      shape: () => t,
      unknownKeys: "strict",
      catchall: Sv.create(),
      typeName: uw.ZodObject,
      ...Kg(e)
    }), Mv.lazycreate = (t, e) => new Mv({
      shape: t,
      unknownKeys: "strip",
      catchall: Sv.create(),
      typeName: uw.ZodObject,
      ...Kg(e)
    });
    class Cv extends Vg {
      In(t) {
        const {
          ctx: e
        } = this.kn(t), r = this.Tn.options;
        if (e.common.async) return Promise.all(r.map(async t => {
          const r = {
            ...e,
            common: {
              ...e.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await t.Sn({
              data: e.data,
              path: e.path,
              parent: r
            }),
            ctx: r
          }
        })).then(function(t) {
          for (const e of t)
            if ("valid" === e.result.status) return e.result;
          for (const r of t)
            if ("dirty" === r.result.status) return e.common.issues.push(...r.ctx.common.issues), r.result;
          const r = t.map(t => new Ig(t.ctx.common.issues));
          return Ng(e, {
            code: kg.invalid_union,
            unionErrors: r
          }), _g
        });
        {
          let t;
          const n = [];
          for (const i of r) {
            const r = {
                ...e,
                common: {
                  ...e.common,
                  issues: []
                },
                parent: null
              },
              o = i.xn({
                data: e.data,
                path: e.path,
                parent: r
              });
            if ("valid" === o.status) return o;
            "dirty" === o.status && !t && (t = {
              result: o,
              ctx: r
            }), r.common.issues.length && n.push(r.common.issues)
          }
          if (t) return e.common.issues.push(...t.ctx.common.issues), t.result;
          const i = n.map(t => new Ig(t));
          return Ng(e, {
            code: kg.invalid_union,
            unionErrors: i
          }), _g
        }
      }
      get options() {
        return this.Tn.options
      }
    }
    Cv.create = (t, e) => new Cv({
      options: t,
      typeName: uw.ZodUnion,
      ...Kg(e)
    });
    const Rv = t => t instanceof zv ? Rv(t.schema) : t instanceof qv ? Rv(t.innerType()) : t instanceof Hv ? [t.value] : t instanceof Kv ? t.options : t instanceof Vv ? Ag.objectValues(t.enum) : t instanceof Qv ? Rv(t.Tn.innerType) : t instanceof Pv ? [void 0] : t instanceof kv ? [null] : t instanceof Jv ? [void 0, ...Rv(t.unwrap())] : t instanceof Yv ? [null, ...Rv(t.unwrap())] : t instanceof rw || t instanceof iw ? Rv(t.unwrap()) : t instanceof Xv ? Rv(t.Tn.innerType) : [];
    class Nv extends Vg {
      In(t) {
        const {
          ctx: e
        } = this.kn(t);
        if (e.parsedType !== Eg.object) return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.object,
          received: e.parsedType
        }), _g;
        const r = this.discriminator,
          n = e.data[r],
          i = this.optionsMap.get(n);
        return i ? e.common.async ? i.Sn({
          data: e.data,
          path: e.path,
          parent: e
        }) : i.xn({
          data: e.data,
          path: e.path,
          parent: e
        }) : (Ng(e, {
          code: kg.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [r]
        }), _g)
      }
      get discriminator() {
        return this.Tn.discriminator
      }
      get options() {
        return this.Tn.options
      }
      get optionsMap() {
        return this.Tn.optionsMap
      }
      static create(t, e, r) {
        const n = new Map;
        for (const r of e) {
          const e = Rv(r.shape[t]);
          if (!e.length) throw Error(`A discriminator value for key \`${t}\` could not be extracted from all schema options`);
          for (const i of e) {
            if (n.has(i)) throw Error(`Discriminator property ${t+""} has duplicate value ${i+""}`);
            n.set(i, r)
          }
        }
        return new Nv({
          typeName: uw.ZodDiscriminatedUnion,
          discriminator: t,
          options: e,
          optionsMap: n,
          ...Kg(r)
        })
      }
    }

    function jv(t, e) {
      const r = Pg(t),
        n = Pg(e);
      if (t === e) return {
        valid: !0,
        data: t
      };
      if (r === Eg.object && n === Eg.object) {
        const r = Ag.objectKeys(e),
          n = Ag.objectKeys(t).filter(t => -1 !== r.indexOf(t)),
          i = {
            ...t,
            ...e
          };
        for (const r of n) {
          const n = jv(t[r], e[r]);
          if (!n.valid) return {
            valid: !1
          };
          i[r] = n.data
        }
        return {
          valid: !0,
          data: i
        }
      }
      if (r === Eg.array && n === Eg.array) {
        if (t.length !== e.length) return {
          valid: !1
        };
        const r = [];
        for (let n = 0; n < t.length; n++) {
          const i = jv(t[n], e[n]);
          if (!i.valid) return {
            valid: !1
          };
          r.push(i.data)
        }
        return {
          valid: !0,
          data: r
        }
      }
      return r === Eg.date && n === Eg.date && +t == +e ? {
        valid: !0,
        data: t
      } : {
        valid: !1
      }
    }
    class _v extends Vg {
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t), n = (t, n) => {
          if (Lg(t) || Lg(n)) return _g;
          const i = jv(t.value, n.value);
          return i.valid ? ((Fg(t) || Fg(n)) && e.dirty(), {
            status: e.value,
            value: i.data
          }) : (Ng(r, {
            code: kg.invalid_intersection_types
          }), _g)
        };
        return r.common.async ? Promise.all([this.Tn.left.Sn({
          data: r.data,
          path: r.path,
          parent: r
        }), this.Tn.right.Sn({
          data: r.data,
          path: r.path,
          parent: r
        })]).then(([t, e]) => n(t, e)) : n(this.Tn.left.xn({
          data: r.data,
          path: r.path,
          parent: r
        }), this.Tn.right.xn({
          data: r.data,
          path: r.path,
          parent: r
        }))
      }
    }
    _v.create = (t, e, r) => new _v({
      left: t,
      right: e,
      typeName: uw.ZodIntersection,
      ...Kg(r)
    });
    class Dv extends Vg {
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t);
        if (r.parsedType !== Eg.array) return Ng(r, {
          code: kg.invalid_type,
          expected: Eg.array,
          received: r.parsedType
        }), _g;
        if (r.data.length < this.Tn.items.length) return Ng(r, {
          code: kg.too_small,
          minimum: this.Tn.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), _g;
        !this.Tn.rest && r.data.length > this.Tn.items.length && (Ng(r, {
          code: kg.too_big,
          maximum: this.Tn.items.length,
          inclusive: !0,
          exact: !1,
          type: "array"
        }), e.dirty());
        const n = [...r.data].map((t, e) => {
          const n = this.Tn.items[e] || this.Tn.rest;
          return n ? n.In(new Hg(r, t, r.path, e)) : null
        }).filter(t => !!t);
        return r.common.async ? Promise.all(n).then(t => jg.mergeArray(e, t)) : jg.mergeArray(e, n)
      }
      get items() {
        return this.Tn.items
      }
      rest(t) {
        return new Dv({
          ...this.Tn,
          rest: t
        })
      }
    }
    Dv.create = (t, e) => {
      if (!Array.isArray(t)) throw Error("You must pass an array of schemas to z.tuple([ ... ])");
      return new Dv({
        items: t,
        typeName: uw.ZodTuple,
        rest: null,
        ...Kg(e)
      })
    };
    class Uv extends Vg {
      get keySchema() {
        return this.Tn.keyType
      }
      get valueSchema() {
        return this.Tn.valueType
      }
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t);
        if (r.parsedType !== Eg.object) return Ng(r, {
          code: kg.invalid_type,
          expected: Eg.object,
          received: r.parsedType
        }), _g;
        const n = [],
          i = this.Tn.keyType,
          o = this.Tn.valueType;
        for (const t in r.data) n.push({
          key: i.In(new Hg(r, t, r.path, t)),
          value: o.In(new Hg(r, r.data[t], r.path, t)),
          alwaysSet: t in r.data
        });
        return r.common.async ? jg.mergeObjectAsync(e, n) : jg.mergeObjectSync(e, n)
      }
      get element() {
        return this.Tn.valueType
      }
      static create(t, e, r) {
        return new Uv(e instanceof Vg ? {
          keyType: t,
          valueType: e,
          typeName: uw.ZodRecord,
          ...Kg(r)
        } : {
          keyType: yv.create(),
          valueType: t,
          typeName: uw.ZodRecord,
          ...Kg(e)
        })
      }
    }
    class Lv extends Vg {
      get keySchema() {
        return this.Tn.keyType
      }
      get valueSchema() {
        return this.Tn.valueType
      }
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t);
        if (r.parsedType !== Eg.map) return Ng(r, {
          code: kg.invalid_type,
          expected: Eg.map,
          received: r.parsedType
        }), _g;
        const n = this.Tn.keyType,
          i = this.Tn.valueType,
          o = [...r.data.entries()].map(([t, e], o) => ({
            key: n.In(new Hg(r, t, r.path, [o, "key"])),
            value: i.In(new Hg(r, e, r.path, [o, "value"]))
          }));
        if (r.common.async) {
          const t = new Map;
          return Promise.resolve().then(async () => {
            for (const r of o) {
              const n = await r.key,
                i = await r.value;
              if ("aborted" === n.status || "aborted" === i.status) return _g;
              ("dirty" === n.status || "dirty" === i.status) && e.dirty(), t.set(n.value, i.value)
            }
            return {
              status: e.value,
              value: t
            }
          })
        } {
          const t = new Map;
          for (const r of o) {
            const n = r.key,
              i = r.value;
            if ("aborted" === n.status || "aborted" === i.status) return _g;
            ("dirty" === n.status || "dirty" === i.status) && e.dirty(), t.set(n.value, i.value)
          }
          return {
            status: e.value,
            value: t
          }
        }
      }
    }
    Lv.create = (t, e, r) => new Lv({
      valueType: e,
      keyType: t,
      typeName: uw.ZodMap,
      ...Kg(r)
    });
    class Fv extends Vg {
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t);
        if (r.parsedType !== Eg.set) return Ng(r, {
          code: kg.invalid_type,
          expected: Eg.set,
          received: r.parsedType
        }), _g;
        const n = this.Tn;
        null !== n.minSize && r.data.size < n.minSize.value && (Ng(r, {
          code: kg.too_small,
          minimum: n.minSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: n.minSize.message
        }), e.dirty()), null !== n.maxSize && r.data.size > n.maxSize.value && (Ng(r, {
          code: kg.too_big,
          maximum: n.maxSize.value,
          type: "set",
          inclusive: !0,
          exact: !1,
          message: n.maxSize.message
        }), e.dirty());
        const i = this.Tn.valueType;

        function o(t) {
          const r = new Set;
          for (const n of t) {
            if ("aborted" === n.status) return _g;
            "dirty" === n.status && e.dirty(), r.add(n.value)
          }
          return {
            status: e.value,
            value: r
          }
        }
        const s = [...r.data.values()].map((t, e) => i.In(new Hg(r, t, r.path, e)));
        return r.common.async ? Promise.all(s).then(t => o(t)) : o(s)
      }
      min(t, e) {
        return new Fv({
          ...this.Tn,
          minSize: {
            value: t,
            message: Mg.toString(e)
          }
        })
      }
      max(t, e) {
        return new Fv({
          ...this.Tn,
          maxSize: {
            value: t,
            message: Mg.toString(e)
          }
        })
      }
      size(t, e) {
        return this.min(t, e).max(t, e)
      }
      nonempty(t) {
        return this.min(1, t)
      }
    }
    Fv.create = (t, e) => new Fv({
      valueType: t,
      minSize: null,
      maxSize: null,
      typeName: uw.ZodSet,
      ...Kg(e)
    });
    class $v extends Vg {
      constructor() {
        super(...arguments), this.validate = this.implement
      }
      In(t) {
        const {
          ctx: e
        } = this.kn(t);
        if (e.parsedType !== Eg.function) return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.function,
          received: e.parsedType
        }), _g;

        function r(t, r) {
          return Cg({
            data: t,
            path: e.path,
            errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Wg(), Sg].filter(t => !!t),
            issueData: {
              code: kg.invalid_arguments,
              argumentsError: r
            }
          })
        }

        function n(t, r) {
          return Cg({
            data: t,
            path: e.path,
            errorMaps: [e.common.contextualErrorMap, e.schemaErrorMap, Wg(), Sg].filter(t => !!t),
            issueData: {
              code: kg.invalid_return_type,
              returnTypeError: r
            }
          })
        }
        const i = {
            errorMap: e.common.contextualErrorMap
          },
          o = e.data;
        if (this.Tn.returns instanceof Zv) {
          const t = this;
          return Ug(async function(...e) {
            const s = new Ig([]),
              a = await t.Tn.args.parseAsync(e, i).catch(t => {
                throw s.addIssue(r(e, t)), s
              }),
              u = await Reflect.apply(o, this, a);
            return await t.Tn.returns.Tn.type.parseAsync(u, i).catch(t => {
              throw s.addIssue(n(u, t)), s
            })
          })
        } {
          const t = this;
          return Ug(function(...e) {
            const s = t.Tn.args.safeParse(e, i);
            if (!s.success) throw new Ig([r(e, s.error)]);
            const a = Reflect.apply(o, this, s.data),
              u = t.Tn.returns.safeParse(a, i);
            if (!u.success) throw new Ig([n(a, u.error)]);
            return u.data
          })
        }
      }
      parameters() {
        return this.Tn.args
      }
      returnType() {
        return this.Tn.returns
      }
      args(...t) {
        return new $v({
          ...this.Tn,
          args: Dv.create(t).rest(Iv.create())
        })
      }
      returns(t) {
        return new $v({
          ...this.Tn,
          returns: t
        })
      }
      implement(t) {
        return this.parse(t)
      }
      strictImplement(t) {
        return this.parse(t)
      }
      static create(t, e, r) {
        return new $v({
          args: t || Dv.create([]).rest(Iv.create()),
          returns: e || Iv.create(),
          typeName: uw.ZodFunction,
          ...Kg(r)
        })
      }
    }
    class zv extends Vg {
      get schema() {
        return this.Tn.getter()
      }
      In(t) {
        const {
          ctx: e
        } = this.kn(t);
        return this.Tn.getter().In({
          data: e.data,
          path: e.path,
          parent: e
        })
      }
    }
    zv.create = (t, e) => new zv({
      getter: t,
      typeName: uw.ZodLazy,
      ...Kg(e)
    });
    class Hv extends Vg {
      In(t) {
        if (t.data !== this.Tn.value) {
          const e = this.Pn(t);
          return Ng(e, {
            received: e.data,
            code: kg.invalid_literal,
            expected: this.Tn.value
          }), _g
        }
        return {
          status: "valid",
          value: t.data
        }
      }
      get value() {
        return this.Tn.value
      }
    }

    function Gv(t, e) {
      return new Kv({
        values: t,
        typeName: uw.ZodEnum,
        ...Kg(e)
      })
    }
    Hv.create = (t, e) => new Hv({
      value: t,
      typeName: uw.ZodLiteral,
      ...Kg(e)
    });
    class Kv extends Vg {
      In(t) {
        if ("string" != typeof t.data) {
          const e = this.Pn(t),
            r = this.Tn.values;
          return Ng(e, {
            expected: Ag.joinValues(r),
            received: e.parsedType,
            code: kg.invalid_type
          }), _g
        }
        if (this._n || (this._n = new Set(this.Tn.values)), !this._n.has(t.data)) {
          const e = this.Pn(t),
            r = this.Tn.values;
          return Ng(e, {
            received: e.data,
            code: kg.invalid_enum_value,
            options: r
          }), _g
        }
        return Ug(t.data)
      }
      get options() {
        return this.Tn.values
      }
      get enum() {
        const t = {};
        for (const e of this.Tn.values) t[e] = e;
        return t
      }
      get Values() {
        const t = {};
        for (const e of this.Tn.values) t[e] = e;
        return t
      }
      get Enum() {
        const t = {};
        for (const e of this.Tn.values) t[e] = e;
        return t
      }
      extract(t, e = this.Tn) {
        return Kv.create(t, {
          ...this.Tn,
          ...e
        })
      }
      exclude(t, e = this.Tn) {
        return Kv.create(this.options.filter(e => !t.includes(e)), {
          ...this.Tn,
          ...e
        })
      }
    }
    Kv.create = Gv;
    class Vv extends Vg {
      In(t) {
        const e = Ag.getValidEnumValues(this.Tn.values),
          r = this.Pn(t);
        if (r.parsedType !== Eg.string && r.parsedType !== Eg.number) {
          const t = Ag.objectValues(e);
          return Ng(r, {
            expected: Ag.joinValues(t),
            received: r.parsedType,
            code: kg.invalid_type
          }), _g
        }
        if (this._n || (this._n = new Set(Ag.getValidEnumValues(this.Tn.values))), !this._n.has(t.data)) {
          const t = Ag.objectValues(e);
          return Ng(r, {
            received: r.data,
            code: kg.invalid_enum_value,
            options: t
          }), _g
        }
        return Ug(t.data)
      }
      get enum() {
        return this.Tn.values
      }
    }
    Vv.create = (t, e) => new Vv({
      values: t,
      typeName: uw.ZodNativeEnum,
      ...Kg(e)
    });
    class Zv extends Vg {
      unwrap() {
        return this.Tn.type
      }
      In(t) {
        const {
          ctx: e
        } = this.kn(t);
        if (e.parsedType !== Eg.promise && !1 === e.common.async) return Ng(e, {
          code: kg.invalid_type,
          expected: Eg.promise,
          received: e.parsedType
        }), _g;
        const r = e.parsedType === Eg.promise ? e.data : Promise.resolve(e.data);
        return Ug(r.then(t => this.Tn.type.parseAsync(t, {
          path: e.path,
          errorMap: e.common.contextualErrorMap
        })))
      }
    }
    Zv.create = (t, e) => new Zv({
      type: t,
      typeName: uw.ZodPromise,
      ...Kg(e)
    });
    class qv extends Vg {
      innerType() {
        return this.Tn.schema
      }
      sourceType() {
        return this.Tn.schema.Tn.typeName === uw.ZodEffects ? this.Tn.schema.sourceType() : this.Tn.schema
      }
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t), n = this.Tn.effect || null, i = {
          addIssue: t => {
            Ng(r, t), t.fatal ? e.abort() : e.dirty()
          },
          get path() {
            return r.path
          }
        };
        if (i.addIssue = i.addIssue.bind(i), "preprocess" === n.type) {
          const t = n.transform(r.data, i);
          if (r.common.async) return Promise.resolve(t).then(async t => {
            if ("aborted" === e.value) return _g;
            const n = await this.Tn.schema.Sn({
              data: t,
              path: r.path,
              parent: r
            });
            return "aborted" === n.status ? _g : "dirty" === n.status || "dirty" === e.value ? Dg(n.value) : n
          });
          {
            if ("aborted" === e.value) return _g;
            const n = this.Tn.schema.xn({
              data: t,
              path: r.path,
              parent: r
            });
            return "aborted" === n.status ? _g : "dirty" === n.status || "dirty" === e.value ? Dg(n.value) : n
          }
        }
        if ("refinement" === n.type) {
          const t = t => {
            const e = n.refinement(t, i);
            if (r.common.async) return Promise.resolve(e);
            if (e instanceof Promise) throw Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            return t
          };
          if (!1 === r.common.async) {
            const n = this.Tn.schema.xn({
              data: r.data,
              path: r.path,
              parent: r
            });
            return "aborted" === n.status ? _g : ("dirty" === n.status && e.dirty(), t(n.value), {
              status: e.value,
              value: n.value
            })
          }
          return this.Tn.schema.Sn({
            data: r.data,
            path: r.path,
            parent: r
          }).then(r => "aborted" === r.status ? _g : ("dirty" === r.status && e.dirty(), t(r.value).then(() => ({
            status: e.value,
            value: r.value
          }))))
        }
        if ("transform" === n.type) {
          if (!1 === r.common.async) {
            const t = this.Tn.schema.xn({
              data: r.data,
              path: r.path,
              parent: r
            });
            if (!$g(t)) return _g;
            const o = n.transform(t.value, i);
            if (o instanceof Promise) throw Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
            return {
              status: e.value,
              value: o
            }
          }
          return this.Tn.schema.Sn({
            data: r.data,
            path: r.path,
            parent: r
          }).then(t => $g(t) ? Promise.resolve(n.transform(t.value, i)).then(t => ({
            status: e.value,
            value: t
          })) : _g)
        }
        Ag.assertNever(n)
      }
    }
    qv.create = (t, e, r) => new qv({
      schema: t,
      typeName: uw.ZodEffects,
      effect: e,
      ...Kg(r)
    }), qv.createWithPreprocess = (t, e, r) => new qv({
      schema: e,
      effect: {
        type: "preprocess",
        transform: t
      },
      typeName: uw.ZodEffects,
      ...Kg(r)
    });
    class Jv extends Vg {
      In(t) {
        return this.En(t) === Eg.undefined ? Ug(void 0) : this.Tn.innerType.In(t)
      }
      unwrap() {
        return this.Tn.innerType
      }
    }
    Jv.create = (t, e) => new Jv({
      innerType: t,
      typeName: uw.ZodOptional,
      ...Kg(e)
    });
    class Yv extends Vg {
      In(t) {
        return this.En(t) === Eg.null ? Ug(null) : this.Tn.innerType.In(t)
      }
      unwrap() {
        return this.Tn.innerType
      }
    }
    Yv.create = (t, e) => new Yv({
      innerType: t,
      typeName: uw.ZodNullable,
      ...Kg(e)
    });
    class Qv extends Vg {
      In(t) {
        const {
          ctx: e
        } = this.kn(t);
        let r = e.data;
        return e.parsedType === Eg.undefined && (r = this.Tn.defaultValue()), this.Tn.innerType.In({
          data: r,
          path: e.path,
          parent: e
        })
      }
      removeDefault() {
        return this.Tn.innerType
      }
    }
    Qv.create = (t, e) => new Qv({
      innerType: t,
      typeName: uw.ZodDefault,
      defaultValue: "function" == typeof e.default ? e.default : () => e.default,
      ...Kg(e)
    });
    class Xv extends Vg {
      In(t) {
        const {
          ctx: e
        } = this.kn(t), r = {
          ...e,
          common: {
            ...e.common,
            issues: []
          }
        }, n = this.Tn.innerType.In({
          data: r.data,
          path: r.path,
          parent: {
            ...r
          }
        });
        return zg(n) ? n.then(t => ({
          status: "valid",
          value: "valid" === t.status ? t.value : this.Tn.catchValue({
            get error() {
              return new Ig(r.common.issues)
            },
            input: r.data
          })
        })) : {
          status: "valid",
          value: "valid" === n.status ? n.value : this.Tn.catchValue({
            get error() {
              return new Ig(r.common.issues)
            },
            input: r.data
          })
        }
      }
      removeCatch() {
        return this.Tn.innerType
      }
    }
    Xv.create = (t, e) => new Xv({
      innerType: t,
      typeName: uw.ZodCatch,
      catchValue: "function" == typeof e.catch ? e.catch : () => e.catch,
      ...Kg(e)
    });
    class tw extends Vg {
      In(t) {
        if (this.En(t) !== Eg.nan) {
          const e = this.Pn(t);
          return Ng(e, {
            code: kg.invalid_type,
            expected: Eg.nan,
            received: e.parsedType
          }), _g
        }
        return {
          status: "valid",
          value: t.data
        }
      }
    }
    tw.create = t => new tw({
      typeName: uw.ZodNaN,
      ...Kg(t)
    });
    const ew = Symbol("zod_brand");
    class rw extends Vg {
      In(t) {
        const {
          ctx: e
        } = this.kn(t), r = e.data;
        return this.Tn.type.In({
          data: r,
          path: e.path,
          parent: e
        })
      }
      unwrap() {
        return this.Tn.type
      }
    }
    class nw extends Vg {
      In(t) {
        const {
          status: e,
          ctx: r
        } = this.kn(t);
        if (r.common.async) return (async () => {
          const t = await this.Tn.in.Sn({
            data: r.data,
            path: r.path,
            parent: r
          });
          return "aborted" === t.status ? _g : "dirty" === t.status ? (e.dirty(), Dg(t.value)) : this.Tn.out.Sn({
            data: t.value,
            path: r.path,
            parent: r
          })
        })();
        {
          const t = this.Tn.in.xn({
            data: r.data,
            path: r.path,
            parent: r
          });
          return "aborted" === t.status ? _g : "dirty" === t.status ? (e.dirty(), {
            status: "dirty",
            value: t.value
          }) : this.Tn.out.xn({
            data: t.value,
            path: r.path,
            parent: r
          })
        }
      }
      static create(t, e) {
        return new nw({
          in: t,
          out: e,
          typeName: uw.ZodPipeline
        })
      }
    }
    class iw extends Vg {
      In(t) {
        const e = this.Tn.innerType.In(t),
          r = t => ($g(t) && (t.value = Object.freeze(t.value)), t);
        return zg(e) ? e.then(t => r(t)) : r(e)
      }
      unwrap() {
        return this.Tn.innerType
      }
    }

    function ow(t, e) {
      const r = "function" == typeof t ? t(e) : "string" == typeof t ? {
        message: t
      } : t;
      return "string" == typeof r ? {
        message: r
      } : r
    }

    function sw(t, e = {}, r) {
      return t ? xv.create().superRefine((n, i) => {
        const o = t(n);
        if (o instanceof Promise) return o.then(t => {
          if (!t) {
            const t = ow(e, n),
              o = t.fatal ?? r ?? !0;
            i.addIssue({
              code: "custom",
              ...t,
              fatal: o
            })
          }
        });
        if (!o) {
          const t = ow(e, n),
            o = t.fatal ?? r ?? !0;
          i.addIssue({
            code: "custom",
            ...t,
            fatal: o
          })
        }
      }) : xv.create()
    }
    iw.create = (t, e) => new iw({
      innerType: t,
      typeName: uw.ZodReadonly,
      ...Kg(e)
    });
    const aw = {
      object: Mv.lazycreate
    };
    var uw;
    ! function(t) {
      t.ZodString = "ZodString", t.ZodNumber = "ZodNumber", t.ZodNaN = "ZodNaN", t.ZodBigInt = "ZodBigInt", t.ZodBoolean = "ZodBoolean", t.ZodDate = "ZodDate", t.ZodSymbol = "ZodSymbol", t.ZodUndefined = "ZodUndefined", t.ZodNull = "ZodNull", t.ZodAny = "ZodAny", t.ZodUnknown = "ZodUnknown", t.ZodNever = "ZodNever", t.ZodVoid = "ZodVoid", t.ZodArray = "ZodArray", t.ZodObject = "ZodObject", t.ZodUnion = "ZodUnion", t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", t.ZodIntersection = "ZodIntersection", t.ZodTuple = "ZodTuple", t.ZodRecord = "ZodRecord", t.ZodMap = "ZodMap", t.ZodSet = "ZodSet", t.ZodFunction = "ZodFunction", t.ZodLazy = "ZodLazy", t.ZodLiteral = "ZodLiteral", t.ZodEnum = "ZodEnum", t.ZodEffects = "ZodEffects", t.ZodNativeEnum = "ZodNativeEnum", t.ZodOptional = "ZodOptional", t.ZodNullable = "ZodNullable", t.ZodDefault = "ZodDefault", t.ZodCatch = "ZodCatch", t.ZodPromise = "ZodPromise", t.ZodBranded = "ZodBranded", t.ZodPipeline = "ZodPipeline", t.ZodReadonly = "ZodReadonly"
    }(uw || (uw = {}));
    const cw = (t, e = {
        message: "Input not instance of " + t.name
      }) => sw(e => e instanceof t, e),
      fw = yv.create,
      lw = vv.create,
      hw = tw.create,
      dw = wv.create,
      pw = Av.create,
      bw = Tv.create,
      mw = Ev.create,
      yw = Pv.create,
      gw = kv.create,
      vw = xv.create,
      ww = Iv.create,
      Aw = Sv.create,
      Tw = Ov.create,
      Ew = Bv.create,
      Pw = Mv.create,
      kw = Mv.strictCreate,
      xw = Cv.create,
      Iw = Nv.create,
      Sw = _v.create,
      Ow = Dv.create,
      Bw = Uv.create,
      Ww = Lv.create,
      Mw = Fv.create,
      Cw = $v.create,
      Rw = zv.create,
      Nw = Hv.create,
      jw = Kv.create,
      _w = Vv.create,
      Dw = Zv.create,
      Uw = qv.create,
      Lw = Jv.create,
      Fw = Yv.create,
      $w = qv.createWithPreprocess,
      zw = nw.create,
      Hw = () => fw().optional(),
      Gw = () => lw().optional(),
      Kw = () => pw().optional(),
      Vw = {
        string: t => yv.create({
          ...t,
          coerce: !0
        }),
        number: t => vv.create({
          ...t,
          coerce: !0
        }),
        boolean: t => Av.create({
          ...t,
          coerce: !0
        }),
        bigint: t => wv.create({
          ...t,
          coerce: !0
        }),
        date: t => Tv.create({
          ...t,
          coerce: !0
        })
      },
      Zw = _g,
      qw = t => t.message ? t.message : "unspecified error";
    class Jw extends Wb {
      constructor(t) {
        super(), this.code = 1100, this.errors = t, super.message = `Web3 validator found ${t.length} error[s]:\n${this.ho().join("\n")}`
      }
      ho() {
        return this.errors.map(qw)
      }
    }
    const Yw = ["bool", "int", "uint", "bytes", "string", "address", "tuple"],
      Qw = t => "object" == typeof t && "type" in t && "name" in t,
      Xw = t => "string" == typeof t,
      tA = t => "string" == typeof t && /^((-)?0x[0-9a-f]+|(0x))$/i.test(t);

    function eA(t, e) {
      return !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/) || "u" > typeof e && e > 0 && t.length !== 2 + 2 * e)
    }
    const rA = t => "number" == typeof t || "bigint" == typeof t || "string" == typeof t && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(t);

    function nA(t) {
      if ("string" != typeof t) throw Error("[isHexPrefixed] input must be type 'string', received type " + typeof t);
      return t.startsWith("0x")
    }
    const iA = function(t) {
        for (const [e, r] of Object.entries(t))
          if (void 0 !== r && r.length > 0 && 0 === r[0]) throw Error(`${e} cannot have leading zeroes, received: ${r.toString()}`)
      },
      oA = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"],
      sA = t => {
        let e, r = t.replace(/ /, ""),
          n = !1,
          i = [];
        if (t.includes("[") && (r = r.slice(0, r.indexOf("[")), i = [...t.matchAll(/(?:\[(\d*)\])/g)].map(t => parseInt(t[1], 10)).map(t => Number.isNaN(t) ? -1 : t), n = i.length > 0), Yw.includes(r)) return {
          baseType: r,
          isArray: n,
          baseTypeSize: e,
          arraySizes: i
        };
        if (r.startsWith("int")) e = parseInt(r.substring(3), 10), r = "int";
        else if (r.startsWith("uint")) e = parseInt(t.substring(4), 10), r = "uint";
        else {
          if (!r.startsWith("bytes")) return {
            baseType: void 0,
            isArray: !1,
            baseTypeSize: void 0,
            arraySizes: i
          };
          e = parseInt(r.substring(5), 10), r = "bytes"
        }
        return {
          baseType: r,
          isArray: n,
          baseTypeSize: e,
          arraySizes: i
        }
      },
      aA = (t, e = {}) => {
        if (Object.keys(e).includes("type")) throw new Jw([{
          keyword: "eth",
          message: 'Either "eth" or "type" can be presented in schema',
          params: {
            eth: t
          },
          instancePath: "",
          schemaPath: ""
        }]);
        const {
          baseType: r,
          baseTypeSize: n
        } = sA(t);
        if (!r && !oA.includes(t)) throw new Jw([{
          keyword: "eth",
          message: `Eth data type "${t}" is not valid`,
          params: {
            eth: t
          },
          instancePath: "",
          schemaPath: ""
        }]);
        if (r) {
          if ("tuple" === r) throw Error('"tuple" type is not implemented directly.');
          return {
            format: `${r}${n??""}`,
            required: !0
          }
        }
        return t ? {
          format: t,
          required: !0
        } : {}
      },
      uA = (t, e = "/0") => {
        const r = {
          type: "array",
          items: [],
          maxItems: t.length,
          minItems: t.length
        };
        for (const [n, i] of t.entries()) {
          let t, o, s = [];
          Qw(i) ? (t = i.type, o = i.name || `${e}/${n}`, s = i.components) : "string" == typeof i ? (t = i, o = `${e}/${n}`) : Array.isArray(i) && (i[0] && "string" == typeof i[0] && i[0].startsWith("tuple") && !Array.isArray(i[0]) && i[1] && Array.isArray(i[1]) ? (t = i[0], o = `${e}/${n}`, s = i[1]) : (t = "tuple", o = `${e}/${n}`, s = i));
          const {
            baseType: a,
            isArray: u,
            arraySizes: c
          } = sA(t);
          let f, l = r;
          for (let t = c.length - 1; t > 0; t -= 1) f = {
            type: "array",
            $id: o,
            items: [],
            maxItems: c[t],
            minItems: c[t]
          }, 0 > c[t] && (delete f.maxItems, delete f.minItems), Array.isArray(l.items) ? 0 === l.items.length ? l.items = [f] : l.items.push(f) : l.items = [l.items, f], l = f;
          if ("tuple" !== a || u)
            if ("tuple" === a && u) {
              const t = c[0],
                e = Object.assign({
                  type: "array",
                  $id: o,
                  items: uA(s, o)
                }, t >= 0 && {
                  minItems: t,
                  maxItems: t
                });
              l.items.push(e)
            } else if (u) {
            const e = c[0],
              r = Object.assign({
                type: "array",
                $id: o,
                items: aA(t)
              }, e >= 0 && {
                minItems: e,
                maxItems: e
              });
            l.items.push(r)
          } else l.items, l.items.push(Object.assign({
            $id: o
          }, aA(t)));
          else {
            const t = uA(s, o);
            t.$id = o, l.items.push(t)
          }
          l = r
        }
        return r
      },
      cA = t => uA(t),
      fA = (t, e) => 1 === e ? t : fA(t[0], e - 1),
      lA = (t, e, r) => {
        const n = [];
        for (const [i, o] of t.entries()) {
          let t, s, a = [];
          Qw(o) ? (t = o.type, s = o.name, a = o.components) : "string" == typeof o ? t = o : Array.isArray(o) && (o[1] && Array.isArray(o[1]) ? (t = o[0], a = o[1]) : (t = "tuple", a = o));
          const {
            baseType: u,
            isArray: c,
            arraySizes: f
          } = sA(t), l = Array.isArray(e) ? e[i] : e[s];
          if ("tuple" !== u || c)
            if ("tuple" === u && c) {
              const t = [];
              for (const e of l)
                if (f.length > 1) {
                  const n = fA(e, f.length - 1),
                    i = [];
                  for (const t of n) i.push(lA(a, t, r));
                  t.push(i)
                } else t.push(lA(a, e, r));
              n.push(t)
            } else n.push(l);
          else n.push(lA(a, l, r))
        }
        return (r = r ?? []).push(...n), r
      },
      hA = t => {
        if (t >= 48 && 57 >= t) return t - 48;
        if (t >= 65 && 70 >= t) return t - 55;
        if (t >= 97 && 102 >= t) return t - 87;
        throw Error("Invalid code point: " + t)
      },
      dA = t => {
        if (!tA(t)) throw Error("Invalid hex string");
        const [e, r] = t.startsWith("-") ? [!0, t.slice(1)] : [!1, t], n = BigInt(r);
        return n > Number.MAX_SAFE_INTEGER ? e ? -n : n : Number.MIN_SAFE_INTEGER > n ? n : e ? -1 * +n : +n
      },
      pA = t => {
        if (("number" == typeof t || "bigint" == typeof t) && 0 > t) return "-0x" + t.toString(16).slice(1);
        if (("number" == typeof t || "bigint" == typeof t) && t >= 0) return "0x" + t.toString(16);
        if ("string" == typeof t && tA(t)) {
          const [e, r] = t.startsWith("-") ? [!0, t.slice(1)] : [!1, t];
          return `${e?"-":""}0x${r.split(/^(-)?0(x|X)/).slice(-1)[0].replace(/^0+/,"").toLowerCase()}`
        }
        if ("string" == typeof t && !tA(t)) return pA(BigInt(t));
        throw new Qm(t)
      },
      bA = (t, e, r = "0") => {
        if ("string" == typeof t && !tA(t)) return t.padStart(e, r);
        const n = "string" == typeof t && tA(t) ? t : pA(t),
          [i, o] = n.startsWith("-") ? ["-0x", n.slice(3)] : ["0x", n.slice(2)];
        return `${i}${o.padStart(e,r)}`
      };

    function mA(t) {
      let e = "0x";
      for (const r of t) {
        const t = r.toString(16);
        e += 1 === t.length ? "0" + t : t
      }
      return e
    }
    const yA = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };

    function gA(t) {
      return t < yA.zero || t > yA.nine ? t < yA.A || t > yA.F ? t < yA.a || t > yA.f ? void 0 : t - (yA.a - 10) : t - (yA.A - 10) : t - yA.zero
    }

    function vA(t) {
      let e = 0;
      if (t.startsWith("0") && ("x" === t[1] || "X" === t[1]) && (e = 2), t.length % 2 != 0) throw new Ym("hex string has odd length: " + t);
      const r = (t.length - e) / 2,
        n = new Uint8Array(r);
      for (let i = 0, o = e; r > i; i += 1) {
        const e = gA(t.charCodeAt(o++)),
          r = gA(t.charCodeAt(o++));
        if (void 0 === e || void 0 === r) throw new Ym(`Invalid byte sequence ("${t[o-2]}${t[o-1]}" in "${t}").`);
        n[i] = 16 * e + r
      }
      return n
    }

    function wA(t) {
      var e;
      return t instanceof Uint8Array || "Uint8Array" !== (null === (e = t?.constructor) || void 0 === e ? void 0 : e.name) ? t : Uint8Array.from(t)
    }
    const AA = t => {
        var e, r;
        return t instanceof Uint8Array || "Uint8Array" === (null === (e = t?.constructor) || void 0 === e ? void 0 : e.name) || "Buffer" === (null === (r = t?.constructor) || void 0 === r ? void 0 : r.name)
      },
      TA = (t, e = {
        abiType: "bytes"
      }) => {
        if ("string" != typeof t && !Array.isArray(t) && !AA(t) || "string" == typeof t && tA(t) && t.startsWith("-") || "string" == typeof t && !tA(t)) return !1;
        let r;
        if ("string" == typeof t) {
          if (t.length % 2 != 0) return !1;
          r = vA(t)
        } else if (Array.isArray(t)) {
          if (t.some(t => 0 > t || t > 255 || !Number.isInteger(t))) return !1;
          r = new Uint8Array(t)
        } else r = t;
        if (e?.abiType) {
          const {
            baseTypeSize: t
          } = sA(e.abiType);
          return !t || r.length === t
        }
        return !e?.size || r.length === e?.size
      },
      EA = t => {
        if (!/^(0x)?[0-9a-f]{40}$/i.test(t)) return !1;
        const e = t.slice(2),
          r = Hy(e.toLowerCase()),
          n = mA(wg(wA(r))).slice(2);
        for (let t = 0; 40 > t; t += 1)
          if (parseInt(n[t], 16) > 7 && e[t].toUpperCase() !== e[t] || 7 >= parseInt(n[t], 16) && e[t].toLowerCase() !== e[t]) return !1;
        return !0
      },
      PA = (t, e = !0) => {
        if ("string" != typeof t && !AA(t)) return !1;
        let r;
        return r = AA(t) ? mA(t) : "string" != typeof t || tA(t) || t.toLowerCase().startsWith("0x") ? t : "0x" + t, !!/^(0x)?[0-9a-f]{40}$/i.test(r) && (!(!/^(0x|0X)?[0-9a-f]{40}$/.test(r) && !/^(0x|0X)?[0-9A-F]{40}$/.test(r)) || !e || EA(r))
      },
      kA = (t, e) => {
        if (e === BigInt(0)) return BigInt(1);
        let r = t;
        for (let n = 1; e > n; n += 1) r *= t;
        return r
      },
      xA = (t, e = {
        abiType: "uint"
      }) => {
        if (!["number", "string", "bigint"].includes(typeof t) || "string" == typeof t && 0 === t.length) return !1;
        let r;
        if (e?.abiType) {
          const {
            baseTypeSize: t
          } = sA(e.abiType);
          t && (r = t)
        } else e.bitSize && (r = e.bitSize);
        const n = kA(BigInt(2), BigInt(r ?? 256)) - BigInt(1);
        try {
          const e = "string" == typeof t && tA(t) ? BigInt(dA(t)) : BigInt(t);
          return e >= 0 && n >= e
        } catch {
          return !1
        }
      },
      IA = (t, e = {
        abiType: "int"
      }) => {
        if (!["number", "string", "bigint"].includes(typeof t) || "number" == typeof t && t > Number.MAX_SAFE_INTEGER) return !1;
        let r;
        if (e?.abiType) {
          const {
            baseTypeSize: t,
            baseType: n
          } = sA(e.abiType);
          if ("int" !== n) return !1;
          t && (r = t)
        } else e.bitSize && (r = e.bitSize);
        const n = kA(BigInt(2), BigInt((r ?? 256) - 1)),
          i = BigInt(-1) * kA(BigInt(2), BigInt((r ?? 256) - 1));
        try {
          const e = "string" == typeof t && tA(t) ? BigInt(dA(t)) : BigInt(t);
          return e >= i && n >= e
        } catch {
          return !1
        }
      },
      SA = t => !!(IA(t) || "string" == typeof t && /[0-9.]/.test(t) && t.indexOf(".") === t.lastIndexOf(".") || "number" == typeof t),
      OA = t => xA(t),
      BA = t => Object.values(ab).includes(t),
      WA = t => BA(t) || OA(t),
      MA = t => !("string" != typeof t || !/^(0x)?[0-9a-f]{512}$/i.test(t) || !/^(0x)?[0-9a-f]{512}$/.test(t) && !/^(0x)?[0-9A-F]{512}$/.test(t)),
      CA = (t, e) => {
        if ("string" == typeof e && !tA(e) || !MA(t)) return !1;
        const r = "string" == typeof e ? vA(e) : e,
          n = mA(wg(r)).slice(2);
        for (let e = 0; 12 > e; e += 4) {
          const r = (parseInt(n.slice(e, e + 2), 16) << 8) + parseInt(n.slice(e + 2, e + 4), 16) & 2047,
            i = 1 << r % 4;
          if ((hA(t.charCodeAt(t.length - 1 - Math.floor(r / 4))) & i) !== i) return !1
        }
        return !0
      },
      RA = t => null == t,
      NA = t => !("object" != typeof t || RA(t) || Array.isArray(t) || t instanceof cb),
      jA = t => !("string" != typeof t || !/^(0x)?[0-9a-f]{64}$/i.test(t) || !/^(0x)?[0-9a-f]{64}$/.test(t) && !/^(0x)?[0-9A-F]{64}$/.test(t)),
      _A = {
        address: t => PA(t),
        bloom: t => MA(t),
        blockNumber: t => OA(t),
        blockTag: t => BA(t),
        blockNumberOrTag: t => WA(t),
        bool: t => (t => !!["number", "string", "boolean"].includes(typeof t) && ("boolean" == typeof t || ("string" != typeof t || tA(t) ? "string" == typeof t && tA(t) ? "0x1" === t || "0x0" === t : 1 === t || 0 === t : "1" === t || "0" === t)))(t),
        bytes: t => TA(t),
        filter: t => (t => {
          const e = ["fromBlock", "toBlock", "address", "topics", "blockHash"];
          if (RA(t) || "object" != typeof t || !Object.keys(t).every(t => e.includes(t)) || !RA(t.fromBlock) && !WA(t.fromBlock) || !RA(t.toBlock) && !WA(t.toBlock)) return !1;
          if (!RA(t.address))
            if (Array.isArray(t.address)) {
              if (!t.address.every(t => PA(t))) return !1
            } else if (!PA(t.address)) return !1;
          return !(!RA(t.topics) && !t.topics.every(t => !!RA(t) || (Array.isArray(t) ? t.every(t => jA(t)) : !!jA(t))))
        })(t),
        hex: t => tA(t),
        uint: t => xA(t),
        int: t => IA(t),
        number: t => SA(t),
        string: t => Xw(t)
      };
    for (let t = 8; 256 >= t; t += 8) _A["int" + t] = e => IA(e, {
      bitSize: t
    }), _A["uint" + t] = e => xA(e, {
      bitSize: t
    });
    for (let t = 1; 32 >= t; t += 1) _A["bytes" + t] = e => TA(e, {
      size: t
    });
    _A.bytes256 = _A.bytes;
    const DA = _A,
      UA = e => {
        if ((!e?.type || "object" === e?.type) && e?.properties) {
          const t = {};
          for (const r of Object.keys(e.properties)) {
            const n = UA(e.properties[r]);
            n && (t[r] = n)
          }
          return Array.isArray(e.required) ? Pw(t).partial().required(e.required.reduce((t, e) => Object.assign(Object.assign({}, t), {
            [e]: !0
          }), {})) : Pw(t).partial()
        }
        if ("array" === e?.type && e?.items) {
          if (Array.isArray(e.items) && e.items.length > 1 && void 0 !== e.maxItems && new Set(e.items.map(t => t.$id)).size === e.items.length) {
            const t = [];
            for (const r of e.items) {
              const e = UA(r);
              e && t.push(e)
            }
            return Ow(t)
          }
          const t = Array.isArray(e.items) ? e.items[0] : e.items;
          let r = Ew(UA(t));
          return r = void 0 !== e.minItems ? r.min(e.minItems) : r, r = void 0 !== e.maxItems ? r.max(e.maxItems) : r, r
        }
        if (e.oneOf && Array.isArray(e.oneOf)) return xw(e.oneOf.map(t => UA(t)));
        if (e?.format) {
          if (!DA[e.format]) throw new wy(e.format);
          return vw().refine(DA[e.format], t => ({
            params: {
              value: t,
              format: e.format
            }
          }))
        }
        return e?.type && "object" !== e?.type && "function" == typeof t[e.type + ""] ? t[e.type + ""]() : Pw({
          data: vw()
        }).partial()
      };
    class LA {
      static factory() {
        return LA.validatorInstance || (LA.validatorInstance = new LA), LA.validatorInstance
      }
      validate(t, e, r) {
        var n, i;
        const o = UA(t).safeParse(e);
        if (!o.success) {
          const t = this.convertErrors(null !== (i = null === (n = o.error) || void 0 === n ? void 0 : n.issues) && void 0 !== i ? i : []);
          if (t) {
            if (r?.silent) return t;
            throw new Jw(t)
          }
        }
      }
      convertErrors(t) {
        if (t && Array.isArray(t) && t.length > 0) return t.map(t => {
          var e;
          let r, n, i, o;
          o = t.path.join("/");
          const s = t.path[t.path.length - 1] + "",
            a = t.path.join("/");
          if (t.code === kg.too_big) n = "maxItems", o = a + "/maxItems", i = {
            limit: t.maximum
          }, r = `must NOT have more than ${t.maximum} items`;
          else if (t.code === kg.too_small) n = "minItems", o = a + "/minItems", i = {
            limit: t.minimum
          }, r = `must NOT have fewer than ${t.minimum} items`;
          else if (t.code === kg.custom) {
            const {
              value: n,
              format: s
            } = null !== (e = t.params) && void 0 !== e ? e : {};
            r = typeof n > "u" ? `value at "/${o}" is required` : `value "${"object"==typeof n?JSON.stringify(n):n}" at "/${o}" must pass "${s}" validation`, i = {
              value: n
            }
          }
          return {
            keyword: n ?? s,
            instancePath: a ? "/" + a : "",
            schemaPath: o ? "#" + o : "#",
            params: i ?? {
              value: t.message
            },
            message: r ?? t.message
          }
        })
      }
    }
    const FA = new class {
      constructor() {
        this.do = LA.factory()
      }
      validateJSONSchema(t, e, r) {
        return this.do.validate(t, e, r)
      }
      validate(t, e, r = {
        silent: !1
      }) {
        var n, i;
        const o = cA(t);
        if (!Array.isArray(o.items) || 0 !== (null === (n = o.items) || void 0 === n ? void 0 : n.length) || 0 !== e.length) {
          if (Array.isArray(o.items) && 0 === (null === (i = o.items) || void 0 === i ? void 0 : i.length) && 0 !== e.length) throw new Jw([{
            instancePath: "/0",
            schemaPath: "/",
            keyword: "required",
            message: "empty schema against data can not be validated",
            params: e
          }]);
          return this.do.validate(o, e, r)
        }
      }
    };

    function $A(t) {
      var e, r;
      return t instanceof Uint8Array || "Uint8Array" === (null === (e = t?.constructor) || void 0 === e ? void 0 : e.name) || "Buffer" === (null === (r = t?.constructor) || void 0 === r ? void 0 : r.name)
    }

    function zA(...t) {
      const e = t.reduce((t, e) => t + e.length, 0),
        r = new Uint8Array(e);
      let n = 0;
      for (const e of t) r.set(e, n), n += e.length;
      return r
    }

    function HA(t, e) {
      if (t === e) return !0;
      if (t.byteLength !== e.byteLength) return !1;
      for (let r = 0; r < t.byteLength; r += 1)
        if (t[r] !== e[r]) return !1;
      return !0
    }
    const GA = {
        noether: BigInt(0),
        wei: BigInt(1),
        kwei: BigInt(1e3),
        Kwei: BigInt(1e3),
        babbage: BigInt(1e3),
        femtoether: BigInt(1e3),
        mwei: BigInt(1e6),
        Mwei: BigInt(1e6),
        lovelace: BigInt(1e6),
        picoether: BigInt(1e6),
        gwei: BigInt(1e9),
        Gwei: BigInt(1e9),
        shannon: BigInt(1e9),
        nanoether: BigInt(1e9),
        nano: BigInt(1e9),
        szabo: BigInt(1e12),
        microether: BigInt(1e12),
        micro: BigInt(1e12),
        finney: BigInt(1e15),
        milliether: BigInt(1e15),
        milli: BigInt(1e15),
        ether: BigInt("1000000000000000000"),
        kether: BigInt("1000000000000000000000"),
        grand: BigInt("1000000000000000000000"),
        mether: BigInt("1000000000000000000000000"),
        gether: BigInt("1000000000000000000000000000"),
        tether: BigInt("1000000000000000000000000000000")
      },
      KA = "Warning: Using type `number` with values that are large or contain many decimals may cause loss of precision, it is recommended to use type `string` or `BigInt` when using conversion methods",
      VA = t => {
        if (FA.validate(["bytes"], [t]), $A(t)) return t;
        if (Array.isArray(t)) return new Uint8Array(t);
        if ("string" == typeof t) return vA(t);
        throw new Ym(t)
      },
      {
        uint8ArrayToHexString: ZA
      } = e,
      qA = t => ZA(VA(t)),
      JA = t => "string" == typeof t && "0x" !== t.slice(0, 2).toLowerCase() ? VA("0x" + t) : VA(t),
      YA = t => (FA.validate(["hex"], [t]), dA(t)),
      QA = YA,
      XA = (t, e) => {
        "bigint" != typeof t && FA.validate(["int"], [t]);
        let r = pA(t);
        return e && (r.startsWith("-") || r.length % 2 != 1 ? r.length % 2 == 0 && r.startsWith("-") && (r = "-0x0".concat(r.slice(3))) : r = "0x0".concat(r.slice(2))), r
      },
      tT = XA,
      eT = t => YA(t).toString(),
      rT = t => {
        FA.validate(["string"], [t]);
        let e = t.replace(/^(?:\u0000)/, "");
        return e = e.replace(/(?:\u0000)$/, ""), qA((new TextEncoder).encode(e))
      },
      nT = rT,
      iT = rT,
      oT = t => gg(JA(t)),
      sT = t => "string" == typeof t ? oT(t) : (FA.validate(["bytes"], [t]), gg(t)),
      aT = Hy,
      uT = oT,
      cT = t => {
        FA.validate(["string"], [t]);
        let e = "";
        for (let r = 0; r < t.length; r += 1) {
          const n = t.charCodeAt(r).toString(16);
          e += n.length % 2 != 0 ? "0" + n : n
        }
        return "0x" + e
      },
      fT = cT,
      lT = t => new TextDecoder("ascii").decode(JA(t)),
      hT = lT,
      dT = (t, e) => {
        if ("string" == typeof t && PA(t)) return e ? "address" : "0x" + t.toLowerCase().replace(/^0x/i, "");
        if ("boolean" == typeof t) return e ? "bool" : t ? "0x01" : "0x00";
        if ("number" == typeof t) return e ? 0 > t ? "int256" : "uint256" : XA(t);
        if ("bigint" == typeof t) return e ? "bigint" : XA(t);
        if ($A(t)) return e ? "bytes" : qA(t);
        if ("object" == typeof t && t) return e ? "string" : rT(JSON.stringify(t));
        if ("string" == typeof t) {
          if (t.startsWith("-0x") || t.startsWith("-0X")) return e ? "int256" : XA(t);
          if (tA(t)) return e ? "bytes" : t;
          if (rA(t) && !IA(t) && !xA(t)) return e ? "bytes" : "0x" + t;
          if (rA(t) && !IA(t) && xA(t)) return e ? "uint" : XA(t);
          if (!Number.isFinite(t)) return e ? "string" : rT(t)
        }
        throw new ny(t)
      },
      pT = t => {
        if ("number" == typeof t) return t > 1e20 ? (console.warn(KA), BigInt(t)) : t;
        if ("bigint" == typeof t) return Number.MIN_SAFE_INTEGER > t || t > Number.MAX_SAFE_INTEGER ? t : +t;
        if ("string" == typeof t && tA(t)) return YA(t);
        try {
          return pT(BigInt(t))
        } catch {
          throw new Qm(t)
        }
      },
      bT = t => {
        if ("number" == typeof t) return BigInt(t);
        if ("bigint" == typeof t) return t;
        if ("string" == typeof t && rA(t)) return t.startsWith("-") ? -BigInt(t.substring(1)) : BigInt(t);
        throw new Qm(t)
      },
      mT = (t, e) => {
        let r;
        if ("string" == typeof e) {
          if (r = GA[e], !r) throw new ey(e)
        } else {
          if (0 > e || !Number.isInteger(e)) throw new ry(e);
          r = kA(BigInt(10), BigInt(e))
        }
        const n = pT(t) + "",
          i = r.toString().length - 1;
        if (0 >= i) return n.toString();
        const o = n.padStart(i, "0"),
          s = o.slice(0, -i),
          a = o.slice(-i).replace(/\.?0+$/, "");
        return "" === s ? a ? "0." + a : "0" : "" === a ? s : `${s}.${a}`.slice(0, s.length + i + 1)
      },
      yT = (t, e) => {
        let r;
        if (FA.validate(["number"], [t]), "string" == typeof e) {
          if (r = GA[e], !r) throw new ey(e)
        } else {
          if (0 > e || !Number.isInteger(e)) throw new ry(e);
          r = kA(BigInt(10), BigInt(e))
        }
        let n = t;
        "number" == typeof n && (1e-15 > n && console.warn(KA), n > 1e20 ? (console.warn(KA), n = BigInt(n)) : n = n.toLocaleString("fullwide", {
          useGrouping: !1,
          maximumFractionDigits: 20
        }));
        const [i, o] = (("string" != typeof n || tA(n) ? pT(n) : n) + "").split(".").concat(""), s = BigInt(`${i}${o}`) * r, a = o.length;
        return 0 === a ? s.toString() : s.toString().slice(0, -a)
      },
      gT = t => {
        if (!PA(t, !1)) throw new Xm(t);
        const e = t.toLowerCase().replace(/^0x/i, ""),
          r = mA(wg(wA(aT(e))));
        if (RA(r) || "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470" === r) return "";
        let n = "0x";
        const i = r.replace(/^0x/i, "");
        for (let t = 0; t < e.length; t += 1) parseInt(i[t], 16) > 7 ? n += e[t].toUpperCase() : n += e[t];
        return n
      },
      vT = t => {
        if ("boolean" == typeof t) return t;
        if ("number" == typeof t && (0 === t || 1 === t) || "bigint" == typeof t && (t === BigInt(0) || t === BigInt(1))) return !!t;
        if ("string" == typeof t && !tA(t) && ("1" === t || "0" === t || "false" === t || "true" === t)) return "true" === t || "false" !== t && !!+t;
        if ("string" == typeof t && tA(t) && ("0x1" === t || "0x0" === t)) return !!pT(t);
        throw new oy(t)
      };
    var wT = i(39597);
    const AT = wT;
    class TT extends AT {
      constructor() {
        super(...arguments), this.maxListeners = Number.MAX_SAFE_INTEGER
      }
      setMaxListeners(t) {
        return this.maxListeners = t, this
      }
      getMaxListeners() {
        return this.maxListeners
      }
    }
    const ET = tA,
      PT = rA,
      kT = EA,
      xT = PA,
      IT = MA,
      ST = CA,
      OT = (t, e) => {
        if (!MA(t) || !PA(e)) return !1;
        const r = bA(e, 64);
        return CA(t, r)
      },
      BT = (t, e) => !(!MA(t) || !PA(e)) && CA(t, e),
      WT = jA,
      MT = (t, e) => !(!MA(t) || !jA(e)) && CA(t, e),
      CT = (t, e) => {
        const r = "string" == typeof t && BA(t),
          n = "string" == typeof e && BA(e);
        if (t === e || ("earliest" === t || 0 === t) && ("earliest" === e || 0 === e)) return 0;
        if ("earliest" === t) return -1;
        if ("earliest" === e) return 1;
        if (r && n) {
          const r = {
            [ab.EARLIEST]: 1,
            [ab.FINALIZED]: 2,
            [ab.SAFE]: 3,
            [ab.LATEST]: 4,
            [ab.PENDING]: 5
          };
          return r[t] < r[e] ? -1 : 1
        }
        if (r && !n || !r && n) throw new cy("Cannot compare blocktag with provided non-blocktag input.");
        const i = BigInt(t),
          o = BigInt(e);
        return o > i ? -1 : i === o ? 0 : 1
      },
      RT = t => "object" == typeof t && !RA(t) && 0 !== Object.keys(t).length && ["input", "data", "from", "gas", "gasPrice", "gasLimit", "address", "jsonInterface", "syncWithContext", "dataInputFill"].some(e => e in t),
      NT = RA,
      jT = t => !("object" != typeof t || RA(t) || Array.isArray(t) || t instanceof cb),
      _T = (t, ...e) => {
        if (!jT(t)) return t;
        const r = Object.assign({}, t);
        for (const t of e)
          for (const e in t) jT(t[e]) ? (r[e] || (r[e] = {}), r[e] = _T(r[e], t[e])) : !RA(t[e]) && Object.hasOwnProperty.call(t, e) && (Array.isArray(t[e]) || t[e] instanceof cb ? r[e] = t[e].slice(0) : r[e] = t[e]);
        return r
      },
      DT = (t, e, r = "0") => "string" == typeof t ? tA(t) ? bA(t, e, r) : t.padStart(e, r) : (FA.validate(["int"], [t]), bA(t, e, r)),
      UT = (t, e, r = "0") => {
        if ("string" == typeof t && !tA(t)) return t.padEnd(e, r);
        const n = "string" == typeof t && tA(t) ? t : XA(t),
          i = n.startsWith("-") ? 3 : 2;
        return FA.validate([n.startsWith("-") ? "int" : "uint"], [t]), n.padEnd(e + i, r)
      },
      LT = UT,
      FT = DT,
      $T = (t, e = 64) => {
        FA.validate(["int"], [t]);
        const r = pT(t);
        if (r >= 0) return DT(dT(r), e);
        const n = kA(BigInt(2), BigInt(4 * e));
        if (-r >= n) throw new iy(`value: ${t}, nibbleWidth: ${e}`);
        const i = BigInt(r) + n;
        return DT(XA(i), e)
      },
      zT = (t, e = 64) => {
        FA.validate(["int"], [t]);
        const r = pT(t);
        if (0 > r) return r;
        const n = Math.ceil(Math.log(+r) / Math.log(2));
        if (n > 4 * e) throw new iy(`value: "${t}", nibbleWidth: "${e}"`);
        if (4 * e !== n) return r;
        const i = kA(BigInt(2), BigInt(e) * BigInt(4));
        return pT(BigInt(r) - i)
      },
      {
        parseBaseType: HT
      } = e,
      GT = t => "object" == typeof t && !RA(t) && "number" in t && "bytes" in t,
      KT = (t, e, r = []) => {
        let n, i = Object.assign({}, t);
        for (const t of e) {
          if (i.oneOf && n) {
            const t = n,
              e = r.find(([e]) => e === t);
            e && e[0] === n && (i = i.oneOf[e[1]])
          }
          if (!i.properties && !i.items) return;
          i.properties ? i = i.properties[t] : i.items && i.items.properties ? i = i.items.properties[t] : i.items && NA(i.items) ? i = i.items : i.items && Array.isArray(i.items) && (i = i.items[parseInt(t, 10)]), i && t && (n = t)
        }
        return i
      },
      VT = (t, e, r) => {
        try {
          const {
            baseType: n,
            baseTypeSize: i
          } = HT(e);
          if ("int" === n || "uint" === n) switch (r.number) {
            case nb.NUMBER:
              return +bT(t);
            case nb.HEX:
              return XA(bT(t));
            case nb.STR:
              return bT(t).toString();
            case nb.BIGINT:
              return bT(t);
            default:
              throw new rm("Invalid format: " + r.number)
          }
          if ("bytes" === n) {
            let e;
            switch (i ? "string" == typeof t ? e = DT(t, 2 * i) : $A(t) && (e = zA(new Uint8Array(i - t.length), t)) : e = t, r.bytes) {
              case ib.HEX:
                return qA(VA(e));
              case ib.UINT8ARRAY:
                return VA(e);
              default:
                throw new rm("Invalid format: " + r.bytes)
            }
          }
          if ("string" === n) return t + ""
        } catch {
          return t
        }
        return t
      },
      ZT = ({
        value: t,
        schemaProp: e,
        schema: r,
        object: n,
        key: i,
        dataPath: o,
        format: s,
        oneOfPath: a = []
      }) => {
        var u, c;
        if (Array.isArray(t)) {
          let f = e;
          if (void 0 !== e?.oneOf && e.oneOf.forEach((r, n) => {
              var o, s;
              !Array.isArray(e?.items) && ("object" == typeof t[0] && "object" === (null === (o = r?.items) || void 0 === o ? void 0 : o.type) || "string" == typeof t[0] && "object" !== (null === (s = r?.items) || void 0 === s ? void 0 : s.type)) && (f = r, a.push([i, n]))
            }), RA(f?.items)) return delete n[i], o.pop(), !0;
          if (NA(f.items) && !RA(f.items.format)) {
            for (let e = 0; e < t.length; e += 1) n[i][e] = VT(t[e], null === (u = f?.items) || void 0 === u ? void 0 : u.format, s);
            return o.pop(), !0
          }
          if (!Array.isArray(f?.items) && "object" === (null === (c = f?.items) || void 0 === c ? void 0 : c.type)) {
            for (const e of t) qT(e, r, o, s, a);
            return o.pop(), !0
          }
          if (Array.isArray(f?.items)) {
            for (let e = 0; e < t.length; e += 1) n[i][e] = VT(t[e], f.items[e].format, s);
            return o.pop(), !0
          }
        }
        return !1
      },
      qT = (t, e, r, n, i = []) => {
        var o;
        if (!NA(t) && !Array.isArray(t)) return VT(t, e?.format, n);
        const s = t;
        if (Array.isArray(s) && "array" === e?.type && "object" === (null === (o = e?.items) || void 0 === o ? void 0 : o.type)) ZT({
          value: s,
          schemaProp: e,
          schema: e,
          object: s,
          key: "",
          dataPath: r,
          format: n,
          oneOfPath: i
        });
        else
          for (const [t, o] of Object.entries(s)) {
            r.push(t);
            let a = KT(e, r, i);
            if (RA(a)) delete s[t], r.pop();
            else if (NA(o)) qT(o, e, r, n, i), r.pop();
            else if (!ZT({
                value: o,
                schemaProp: a,
                schema: e,
                object: s,
                key: t,
                dataPath: r,
                format: n,
                oneOfPath: i
              })) {
              if (void 0 === a?.format && void 0 !== a?.oneOf)
                for (const [t, e] of a.oneOf.entries())
                  if (void 0 !== e?.format) {
                    a = e;
                    break
                  } s[t] = VT(o, a.format, n), r.pop()
            }
          }
        return s
      },
      JT = (t, e, r = ob) => {
        let n;
        n = NA(e) ? _T({}, e) : Array.isArray(e) ? [...e] : e;
        const i = NA(t) ? t : cA(t);
        if (!i.properties && !i.items && !i.format) throw new rm("Invalid json schema for formatting");
        return qT(n, i, [], r)
      },
      YT = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",
      QT = t => {
        let e;
        return e = "bigint" == typeof t || "number" == typeof t ? Hy(t.toString()) : Array.isArray(t) ? new Uint8Array(t) : "string" != typeof t || tA(t) ? VA(t) : Hy(t), qA(wg(wA(e)))
      },
      XT = t => {
        let e;
        e = "string" == typeof t ? t.startsWith("0x") && tA(t) ? JA(t) : Hy(t) : t;
        const r = QT(e);
        return r === YT ? void 0 : r
      },
      tE = t => {
        const e = XT(t);
        return RA(e) ? YT : e
      },
      eE = (t, e) => {
        const r = /^(\d+).*$/.exec(t.slice(e));
        return r ? parseInt(r[1], 10) : 0
      },
      rE = t => t.toString(2).length,
      nE = (t, e) => {
        const r = e.toString();
        if ("string" === t) {
          if ("string" == typeof e) return rT(e);
          throw new ty(e)
        }
        if ("bool" === t || "boolean" === t) {
          if ("boolean" == typeof e) return e ? "01" : "00";
          throw new oy(e)
        }
        if ("address" === t) {
          if (!PA(r)) throw new Xm(r);
          return r
        }
        const n = (t => t.startsWith("int[") ? "int256" + t.slice(3) : "int" === t ? "int256" : t.startsWith("uint[") ? "uint256'" + t.slice(4) : "uint" === t ? "uint256" : t)(t);
        if (t.startsWith("uint")) {
          const t = eE(n, 4);
          if (t % 8 || 8 > t || t > 256) throw new ay(r);
          const e = pT(r);
          if (rE(e) > t) throw new uy(r);
          if (e < BigInt(0)) throw new sy(r);
          return t ? FT(e.toString(16), t / 8 * 2) : e.toString(16)
        }
        if (t.startsWith("int")) {
          const e = eE(n, 3);
          if (e % 8 || 8 > e || e > 256) throw new ay(t);
          const i = pT(r);
          if (rE(i) > e) throw new uy(r);
          return i < BigInt(0) ? $T(i.toString(), e / 8 * 2) : e ? FT(i.toString(16), e / 4) : i.toString(16)
        }
        if ("bytes" === n) {
          if (r.replace(/^0x/i, "").length % 2 != 0) throw new Ym(r);
          return r
        }
        if (t.startsWith("bytes")) {
          if (r.replace(/^0x/i, "").length % 2 != 0) throw new Ym(r);
          const e = eE(t, 5);
          if (!e || 1 > e || e > 64 || e < r.replace(/^0x/i, "").length / 2) throw new Ym(r);
          return LT(r, 2 * e)
        }
        return ""
      },
      iE = t => {
        const [e, r] = (t => {
          if (Array.isArray(t)) throw Error("Autodetection of array types is not supported.");
          let e, r;
          if ("object" == typeof t && ("t" in t || "type" in t) && ("v" in t || "value" in t)) e = "t" in t ? t.t : t.type, r = "v" in t ? t.v : t.value, e = "bigint" === e.toLowerCase() ? "int" : e;
          else {
            if ("bigint" == typeof t) return ["int", t];
            e = dT(t, !0), r = dT(t), !e.startsWith("int") && !e.startsWith("uint") && (e = "bytes")
          }
          return (e.startsWith("int") || e.startsWith("uint")) && "string" == typeof r && !/^(-)?0x/i.test(r) && (r = bT(r)), [e, r]
        })(t);
        return Array.isArray(r) ? r.map(t => nE(e, t).replace("0x", "")).join("") : nE(e, r).replace("0x", "")
      },
      oE = (...t) => "0x" + t.map(iE).join("").toLowerCase(),
      sE = (...t) => XT(oE(...t)),
      aE = (...t) => tE(oE(...t)),
      uE = t => XT("0x" + ("number" == typeof t ? t.toString() : t).padStart(64, "0")),
      cE = t => function(t) {
        return Yy(t)
      }(t),
      fE = t => qA(cE(t));
    var lE = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function hE(t) {
      return ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then
    }

    function dE(t, e, r) {
      return lE(this, void 0, void 0, function*() {
        let n;
        const i = yield Promise.race([t instanceof Promise ? t : t(), new Promise((t, i) => {
          n = setTimeout(() => r ? i(r) : t(void 0), e)
        })]);
        if (n && clearTimeout(n), i instanceof Error) throw i;
        return i
      })
    }

    function pE(t, e) {
      let r;
      return [new Promise((n, i) => {
        r = setInterval(function o() {
          return lE(this, void 0, void 0, function*() {
            try {
              const i = yield dE(t, e);
              RA(i) || (clearInterval(r), n(i))
            } catch (t) {
              clearInterval(r), i(t)
            }
          }), o
        }(), e)
      }), r]
    }

    function bE(t, e) {
      return lE(this, void 0, void 0, function*() {
        return pE(t, e)[0]
      })
    }

    function mE(t, e) {
      let r;
      const n = new Promise((n, i) => {
        r = setTimeout(() => {
          i(e)
        }, t)
      });
      return [r, n]
    }

    function yE(t, e) {
      let r;
      const n = new Promise((n, i) => {
        r = setInterval(() => {
          lE(this, void 0, void 0, function*() {
            const e = yield t();
            e && (clearInterval(r), i(e))
          })
        }, e)
      });
      return [r, n]
    }
    const gE = () => {
        const t = cE(16);
        t[6] = 15 & t[6] | 64, t[8] = 63 & t[8] | 128;
        const e = qA(t);
        return [e.substring(2, 10), e.substring(10, 14), e.substring(14, 18), e.substring(18, 22), e.substring(22, 34)].join("-")
      },
      vE = t => {
        const e = t.error.code;
        return vy.has(e) || e >= -32099 && -32e3 >= e
      },
      wE = t => !Array.isArray(t) && !!t && "2.0" === t.jsonrpc && "result" in t && RA(t.error) && ("number" == typeof t.id || "string" == typeof t.id),
      AE = t => !Array.isArray(t) && "2.0" === t.jsonrpc && !!t && RA(t.result) && "error" in t && ("number" == typeof t.id || "string" == typeof t.id),
      TE = t => !(Array.isArray(t) || !t || "2.0" !== t.jsonrpc || RA(t.params) || RA(t.method)),
      EE = t => !Array.isArray(t) && !!t && "2.0" === t.jsonrpc && "id" in t && "result" in t,
      PE = t => wE(t) || AE(t),
      kE = t => Array.isArray(t) ? t.every(PE) : PE(t),
      xE = t => Array.isArray(t) && t.length > 0 && kE(t);
    let IE;
    const SE = t => {
        IE = t
      },
      OE = t => {
        var e, r, n, i;
        return "u" > typeof IE && (IE += 1), {
          jsonrpc: null !== (e = t.jsonrpc) && void 0 !== e ? e : "2.0",
          id: null !== (n = null !== (r = t.id) && void 0 !== r ? r : IE) && void 0 !== n ? n : gE(),
          method: t.method,
          params: null !== (i = t.params) && void 0 !== i ? i : void 0
        }
      },
      BE = t => t.map(t => OE(t)),
      WE = t => Array.isArray(t) && t.length > 0;
    var ME, CE = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class RE {
      constructor({
        timeout: t,
        eagerStart: e,
        timeoutMessage: r
      } = {
        timeout: 0,
        eagerStart: !1,
        timeoutMessage: "DeferredPromise timed out"
      }) {
        this[ME] = "Promise", this.ni = "pending", this.po = new Promise((t, e) => {
          this.bo = t, this.mo = e
        }), this.yo = r, this.vo = t, e && this.startTimer()
      }
      get state() {
        return this.ni
      }
      then(t, e) {
        return CE(this, void 0, void 0, function*() {
          return this.po.then(t, e)
        })
      } catch (t) {
        return CE(this, void 0, void 0, function*() {
          return this.po.catch(t)
        })
      } finally(t) {
        return CE(this, void 0, void 0, function*() {
          return this.po.finally(t)
        })
      }
      resolve(t) {
        this.bo(t), this.ni = "fulfilled", this.wo()
      }
      reject(t) {
        this.mo(t), this.ni = "rejected", this.wo()
      }
      startTimer() {
        this.vo && this.vo > 0 && (this.Ao = setTimeout(this.To.bind(this), this.vo))
      }
      To() {
        "pending" === this.ni && this.Ao && this.reject(new im(this.yo))
      }
      wo() {
        this.Ao && clearTimeout(this.Ao)
      }
    }
    ME = Symbol.toStringTag;
    class NE {
      constructor(t, e) {
        this.eventEmitter = t, this.autoReconnect = e, this.chunkTimeout = 15e3
      }
      clearQueues() {
        "function" == typeof this.Eo && this.Eo()
      }
      onError(t) {
        this.Eo = t
      }
      parseResponse(t) {
        const e = [];
        return t.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|").forEach(t => {
          let r, n = t;
          this.lastChunk && (n = this.lastChunk + n);
          try {
            r = JSON.parse(n)
          } catch {
            return this.lastChunk = n, this.lastChunkTimeout && clearTimeout(this.lastChunkTimeout), void(this.lastChunkTimeout = setTimeout(() => {
              this.autoReconnect || (this.clearQueues(), this.eventEmitter.emit("error", new hy({
                id: 1,
                jsonrpc: "2.0",
                error: {
                  code: 2,
                  message: "Chunk timeout"
                }
              })))
            }, this.chunkTimeout))
          }
          clearTimeout(this.lastChunkTimeout), this.lastChunk = void 0, r && e.push(r)
        }), e
      }
    }
    var jE = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class _E extends hb {
      constructor() {
        super(...arguments), this.Po = new wT, this.ko = "", this.xo = []
      }
      Io() {
        return jE(this, void 0, void 0, function*() {
          var t;
          const e = yield this.request(OE({
            method: "eth_chainId",
            params: []
          }));
          return null !== (t = e?.result) && void 0 !== t ? t : ""
        })
      }
      So() {
        return jE(this, void 0, void 0, function*() {
          var t;
          const e = yield this.request(OE({
            method: "eth_accounts",
            params: []
          }));
          return null !== (t = e?.result) && void 0 !== t ? t : []
        })
      }
      Oo() {
        Promise.all([this.Io().then(t => {
          t !== this.ko && (this.ko = t, this.Po.emit("chainChanged", this.ko))
        }).catch(t => {
          console.error(t)
        }), this.So().then(t => {
          this.xo.length === t.length && t.every(e => t.includes(e)) || (this.xo = t, this.Bo())
        }).catch(t => {
          console.error(t)
        })]).then(() => this.Po.emit("connect", {
          chainId: this.ko
        })).catch(t => {
          console.error(t)
        })
      }
      Wo(t, e) {
        this.Po.emit("disconnect", new gy(t, e))
      }
      Bo() {
        this.Po.emit("accountsChanged", this.xo)
      }
    }
    var DE = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const UE = {
      autoReconnect: !0,
      delay: 5e3,
      maxAttempts: 5
    };
    class LE extends _E {
      get SocketConnection() {
        return this.Mo
      }
      constructor(t, e, r) {
        if (super(), this.Co = "connecting", this.Ro = this.No.bind(this), this.jo = this.Oo.bind(this), this._o = this.Do.bind(this), this.Uo = this.Lo.bind(this), !this.Fo(t)) throw new cm(t);
        this.$o = t, this.zo = e, this.Ho = Object.assign(Object.assign({}, UE), r ?? {}), this.Go = new Map, this.Ko = new Map, this.ht(), this.connect(), this.chunkResponseParser = new NE(this.Po, this.Ho.autoReconnect), this.chunkResponseParser.onError(() => {
          this.Eo()
        }), this.isReconnecting = !1
      }
      ht() {
        this.Vo = 0
      }
      connect() {
        try {
          this.Zo(), this.Co = "connecting", this.qo()
        } catch (t) {
          if (!this.isReconnecting) throw this.Co = "disconnected", t && t.message ? new zb(`Error while connecting to ${this.$o}. Reason: ${t.message}`) : new cm(this.$o);
          setImmediate(() => {
            this.Jo()
          })
        }
      }
      Fo(t) {
        return !!t
      }
      getPendingRequestQueueSize() {
        return this.Go.size
      }
      getSentRequestsQueueSize() {
        return this.Ko.size
      }
      supportsSubscriptions() {
        return !0
      }
      on(t, e) {
        this.Po.on(t, e)
      }
      once(t, e) {
        this.Po.once(t, e)
      }
      removeListener(t, e) {
        this.Po.removeListener(t, e)
      }
      Wo(t, e) {
        this.Co = "disconnected", super.Wo(t, e)
      }
      disconnect(t, e) {
        const r = t ?? 1e3;
        this.Yo(), "disconnected" !== this.getStatus() && this.Qo(r, e), this.Wo(r, e)
      }
      safeDisconnect(t, e) {
        return DE(this, arguments, void 0, function*(t, e, r = !1, n = 1e3) {
          let i = 0;
          yield DE(this, void 0, void 0, function*() {
            return new Promise(t => {
              const e = setInterval(() => {
                r && i >= 5 && this.clearQueues(), 0 === this.getPendingRequestQueueSize() && 0 === this.getSentRequestsQueueSize() && (clearInterval(e), t(!0)), i += 1
              }, n)
            })
          }), this.disconnect(t, e)
        })
      }
      removeAllListeners(t) {
        this.Po.removeAllListeners(t)
      }
      Lo(t) {
        this.isReconnecting ? this.Jo() : this.Po.emit("error", t)
      }
      reset() {
        this.Ko.clear(), this.Go.clear(), this.ht(), this.Yo(), this.qo()
      }
      Jo() {
        this.isReconnecting || (this.isReconnecting = !0, this.Ko.size > 0 && this.Ko.forEach((t, e) => {
          t.deferredPromise.reject(new Kb), this.Ko.delete(e)
        }), this.Vo < this.Ho.maxAttempts ? (this.Vo += 1, setTimeout(() => {
          this.Yo(), this.connect(), this.isReconnecting = !1
        }, this.Ho.delay)) : (this.isReconnecting = !1, this.Eo(), this.Yo(), this.Po.emit("error", new Gb(this.Ho.maxAttempts))))
      }
      request(t) {
        return DE(this, void 0, void 0, function*() {
          if (NT(this.Mo)) throw Error("Connection is undefined");
          "disconnected" === this.getStatus() && this.connect();
          const e = WE(t) ? t[0].id : t.id;
          if (!e) throw new lm("Request Id not defined");
          if (this.Ko.has(e)) throw new Vb(e);
          const r = new RE;
          r.catch(t => {
            this.Po.emit("error", t)
          });
          const n = {
            payload: t,
            deferredPromise: r
          };
          if ("connecting" === this.getStatus()) return this.Go.set(e, n), n.deferredPromise;
          this.Ko.set(e, n);
          try {
            this.Xo(n.payload)
          } catch (t) {
            this.Ko.delete(e), this.Po.emit("error", t)
          }
          return r
        })
      }
      Oo() {
        this.Co = "connected", this.Vo = 0, super.Oo(), this.ts()
      }
      ts() {
        for (const [t, e] of this.Go.entries()) try {
          this.Xo(e.payload), this.Go.delete(t), this.Ko.set(t, e)
        } catch (e) {
          this.Go.delete(t), this.Po.emit("error", e)
        }
      }
      No(t) {
        const e = this.es(t);
        if (!NT(e) && 0 !== e.length)
          for (const t of e) {
            if (TE(t) && t.method.endsWith("_subscription")) return void this.Po.emit("message", t);
            const e = xE(t) ? t[0].id : t.id,
              r = this.Ko.get(e);
            if (!r) return;
            (xE(t) || wE(t) || AE(t)) && (this.Po.emit("message", t), r.deferredPromise.resolve(t)), this.Ko.delete(e)
          }
      }
      clearQueues(t) {
        this.Eo(t)
      }
      Eo(t) {
        this.Go.size > 0 && this.Go.forEach((e, r) => {
          e.deferredPromise.reject(new Hb(t)), this.Go.delete(r)
        }), this.Ko.size > 0 && this.Ko.forEach((e, r) => {
          e.deferredPromise.reject(new Hb(t)), this.Ko.delete(r)
        }), this.Yo()
      }
    }
    class FE {
      constructor() {
        this.rs = new TT
      }
      on(t, e) {
        this.rs.on(t, e)
      }
      once(t, e) {
        this.rs.once(t, e)
      }
      off(t, e) {
        this.rs.off(t, e)
      }
      emit(t, e) {
        this.rs.emit(t, e)
      }
      listenerCount(t) {
        return this.rs.listenerCount(t)
      }
      listeners(t) {
        return this.rs.listeners(t)
      }
      eventNames() {
        return this.rs.eventNames()
      }
      removeAllListeners() {
        return this.rs.removeAllListeners()
      }
      setMaxListenerWarningThreshold(t) {
        this.rs.setMaxListeners(t)
      }
      getMaxListeners() {
        return this.rs.getMaxListeners()
      }
    }
    var $E;
    ! function(t) {
      t.CONFIG_CHANGE = "CONFIG_CHANGE"
    }($E || ($E = {}));
    class zE extends FE {
      constructor(t) {
        super(), this.config = {
          handleRevert: !1,
          defaultAccount: void 0,
          defaultBlock: "latest",
          transactionBlockTimeout: 50,
          transactionConfirmationBlocks: 24,
          transactionPollingInterval: 1e3,
          transactionPollingTimeout: 75e4,
          transactionReceiptPollingInterval: void 0,
          transactionSendTimeout: 75e4,
          transactionConfirmationPollingInterval: void 0,
          blockHeaderTimeout: 10,
          maxListenersWarningThreshold: 100,
          contractDataInputFill: "data",
          defaultNetworkId: void 0,
          defaultChain: "mainnet",
          defaultHardfork: "london",
          defaultCommon: void 0,
          defaultTransactionType: "0x2",
          defaultMaxPriorityFeePerGas: dT(25e8),
          enableExperimentalFeatures: {
            useSubscriptionWhenCheckingBlockTimeout: !1,
            useRpcCallSpecification: !1
          },
          transactionBuilder: void 0,
          transactionTypeParser: void 0,
          customTransactionSchema: void 0,
          defaultReturnFormat: ob,
          ignoreGasPricing: !1
        }, this.setConfig(t ?? {})
      }
      setConfig(t) {
        const e = Object.keys(t);
        for (const r of e) this.ns(r, t[r]), !NT(t[r]) && "number" == typeof t[r] && "maxListenersWarningThreshold" === r && this.setMaxListenerWarningThreshold(+t[r]);
        Object.assign(this.config, t)
      }
      get handleRevert() {
        return this.config.handleRevert
      }
      set handleRevert(t) {
        this.ns("handleRevert", t), this.config.handleRevert = t
      }
      get contractDataInputFill() {
        return this.config.contractDataInputFill
      }
      set contractDataInputFill(t) {
        this.ns("contractDataInputFill", t), this.config.contractDataInputFill = t
      }
      get defaultAccount() {
        return this.config.defaultAccount
      }
      set defaultAccount(t) {
        this.ns("defaultAccount", t), this.config.defaultAccount = t
      }
      get defaultBlock() {
        return this.config.defaultBlock
      }
      set defaultBlock(t) {
        this.ns("defaultBlock", t), this.config.defaultBlock = t
      }
      get transactionSendTimeout() {
        return this.config.transactionSendTimeout
      }
      set transactionSendTimeout(t) {
        this.ns("transactionSendTimeout", t), this.config.transactionSendTimeout = t
      }
      get transactionBlockTimeout() {
        return this.config.transactionBlockTimeout
      }
      set transactionBlockTimeout(t) {
        this.ns("transactionBlockTimeout", t), this.config.transactionBlockTimeout = t
      }
      get transactionConfirmationBlocks() {
        return this.config.transactionConfirmationBlocks
      }
      set transactionConfirmationBlocks(t) {
        this.ns("transactionConfirmationBlocks", t), this.config.transactionConfirmationBlocks = t
      }
      get transactionPollingInterval() {
        return this.config.transactionPollingInterval
      }
      set transactionPollingInterval(t) {
        this.ns("transactionPollingInterval", t), this.config.transactionPollingInterval = t, this.transactionReceiptPollingInterval = t, this.transactionConfirmationPollingInterval = t
      }
      get transactionPollingTimeout() {
        return this.config.transactionPollingTimeout
      }
      set transactionPollingTimeout(t) {
        this.ns("transactionPollingTimeout", t), this.config.transactionPollingTimeout = t
      }
      get transactionReceiptPollingInterval() {
        return this.config.transactionReceiptPollingInterval
      }
      set transactionReceiptPollingInterval(t) {
        this.ns("transactionReceiptPollingInterval", t), this.config.transactionReceiptPollingInterval = t
      }
      get transactionConfirmationPollingInterval() {
        return this.config.transactionConfirmationPollingInterval
      }
      set transactionConfirmationPollingInterval(t) {
        this.ns("transactionConfirmationPollingInterval", t), this.config.transactionConfirmationPollingInterval = t
      }
      get blockHeaderTimeout() {
        return this.config.blockHeaderTimeout
      }
      set blockHeaderTimeout(t) {
        this.ns("blockHeaderTimeout", t), this.config.blockHeaderTimeout = t
      }
      get enableExperimentalFeatures() {
        return this.config.enableExperimentalFeatures
      }
      set enableExperimentalFeatures(t) {
        this.ns("enableExperimentalFeatures", t), this.config.enableExperimentalFeatures = t
      }
      get maxListenersWarningThreshold() {
        return this.config.maxListenersWarningThreshold
      }
      set maxListenersWarningThreshold(t) {
        this.ns("maxListenersWarningThreshold", t), this.setMaxListenerWarningThreshold(t), this.config.maxListenersWarningThreshold = t
      }
      get defaultReturnFormat() {
        return this.config.defaultReturnFormat
      }
      set defaultReturnFormat(t) {
        this.ns("defaultReturnFormat", t), this.config.defaultReturnFormat = t
      }
      get defaultNetworkId() {
        return this.config.defaultNetworkId
      }
      set defaultNetworkId(t) {
        this.ns("defaultNetworkId", t), this.config.defaultNetworkId = t
      }
      get defaultChain() {
        return this.config.defaultChain
      }
      set defaultChain(t) {
        if (!NT(this.config.defaultCommon) && !NT(this.config.defaultCommon.baseChain) && t !== this.config.defaultCommon.baseChain) throw new py(this.config.defaultChain, t);
        this.ns("defaultChain", t), this.config.defaultChain = t
      }
      get defaultHardfork() {
        return this.config.defaultHardfork
      }
      set defaultHardfork(t) {
        if (!NT(this.config.defaultCommon) && !NT(this.config.defaultCommon.hardfork) && t !== this.config.defaultCommon.hardfork) throw new dy(this.config.defaultCommon.hardfork, t);
        this.ns("defaultHardfork", t), this.config.defaultHardfork = t
      }
      get defaultCommon() {
        return this.config.defaultCommon
      }
      set defaultCommon(t) {
        if (!NT(this.config.defaultHardfork) && !NT(t) && !NT(t.hardfork) && this.config.defaultHardfork !== t.hardfork) throw new dy(this.config.defaultHardfork, t.hardfork);
        if (!NT(this.config.defaultChain) && !NT(t) && !NT(t.baseChain) && this.config.defaultChain !== t.baseChain) throw new py(this.config.defaultChain, t.baseChain);
        this.ns("defaultCommon", t), this.config.defaultCommon = t
      }
      get ignoreGasPricing() {
        return this.config.ignoreGasPricing
      }
      set ignoreGasPricing(t) {
        this.ns("ignoreGasPricing", t), this.config.ignoreGasPricing = t
      }
      get defaultTransactionType() {
        return this.config.defaultTransactionType
      }
      set defaultTransactionType(t) {
        this.ns("defaultTransactionType", t), this.config.defaultTransactionType = t
      }
      get defaultMaxPriorityFeePerGas() {
        return this.config.defaultMaxPriorityFeePerGas
      }
      set defaultMaxPriorityFeePerGas(t) {
        this.ns("defaultMaxPriorityFeePerGas", t), this.config.defaultMaxPriorityFeePerGas = t
      }
      get transactionBuilder() {
        return this.config.transactionBuilder
      }
      set transactionBuilder(t) {
        this.ns("transactionBuilder", t), this.config.transactionBuilder = t
      }
      get transactionTypeParser() {
        return this.config.transactionTypeParser
      }
      set transactionTypeParser(t) {
        this.ns("transactionTypeParser", t), this.config.transactionTypeParser = t
      }
      get customTransactionSchema() {
        return this.config.customTransactionSchema
      }
      set customTransactionSchema(t) {
        this.ns("customTransactionSchema", t), this.config.customTransactionSchema = t
      }
      ns(t, e) {
        this.emit($E.CONFIG_CHANGE, {
          name: t,
          oldValue: this.config[t],
          newValue: e
        })
      }
    }
    var HE = i(29094);
    class GE extends hb {
      constructor(t, e) {
        if (super(), !GE.validateClientUrl(t)) throw new cm(t);
        this.clientUrl = t, this.httpProviderOptions = e
      }
      static validateClientUrl(t) {
        return "string" == typeof t && /^http(s)?:\/\//i.test(t)
      }
      getStatus() {
        throw new nm
      }
      supportsSubscriptions() {
        return !1
      }
      request(t, e) {
        var r;
        return function(t, e, r, n) {
          return new(r || (r = Promise))(function(e, i) {
            function o(t) {
              try {
                a(n.next(t))
              } catch (t) {
                i(t)
              }
            }

            function s(t) {
              try {
                a(n.throw(t))
              } catch (t) {
                i(t)
              }
            }

            function a(t) {
              t.done ? e(t.value) : function(t) {
                return t instanceof r ? t : new r(function(e) {
                  e(t)
                })
              }(t.value).then(o, s)
            }
            a((n = n.call(t)).next())
          })
        }(this, 0, void 0, function*() {
          const n = Object.assign(Object.assign({}, null === (r = this.httpProviderOptions) || void 0 === r ? void 0 : r.providerOptions), e),
            i = yield HE(this.clientUrl, Object.assign(Object.assign({}, n), {
              method: "POST",
              headers: Object.assign(Object.assign({}, n.headers), {
                "Content-Type": "application/json"
              }),
              body: JSON.stringify(t)
            }));
          if (!i.ok) throw new ly(yield i.json(), void 0, void 0, i.status);
          return yield i.json()
        })
      }
      on() {
        throw new nm
      }
      removeListener() {
        throw new nm
      }
      once() {
        throw new nm
      }
      removeAllListeners() {
        throw new nm
      }
      connect() {
        throw new nm
      }
      disconnect() {
        throw new nm
      }
      reset() {
        throw new nm
      }
      reconnect() {
        throw new nm
      }
    }
    var KE = null;
    "u" > typeof WebSocket ? KE = WebSocket : "u" > typeof MozWebSocket ? KE = MozWebSocket : "u" > typeof i.g ? KE = i.g.WebSocket || i.g.MozWebSocket : "u" > typeof window ? KE = window.WebSocket || window.MozWebSocket : "u" > typeof self && (KE = self.WebSocket || self.MozWebSocket);
    const VE = KE;
    class ZE extends LE {
      constructor(t, e, r) {
        super(t, e, r)
      }
      Fo(t) {
        return "string" == typeof t && /^ws(s)?:\/\//i.test(t)
      }
      getStatus() {
        if (this.Mo && !NT(this.Mo)) switch (this.Mo.readyState) {
          case this.Mo.CONNECTING:
            return "connecting";
          case this.Mo.OPEN:
            return "connected";
          default:
            return "disconnected"
        }
        return "disconnected"
      }
      Zo() {
        this.Mo = new VE(this.$o, void 0, this.zo && 0 === Object.keys(this.zo).length ? void 0 : this.zo)
      }
      Qo(t, e) {
        var r;
        null === (r = this.Mo) || void 0 === r || r.close(t, e)
      }
      Xo(t) {
        var e;
        if ("disconnected" === this.getStatus()) throw new Hb;
        null === (e = this.Mo) || void 0 === e || e.send(JSON.stringify(t))
      }
      es(t) {
        return this.chunkResponseParser.parseResponse(t.data)
      }
      qo() {
        var t, e, r, n;
        null === (t = this.Mo) || void 0 === t || t.addEventListener("open", this.jo), null === (e = this.Mo) || void 0 === e || e.addEventListener("message", this.Ro), null === (r = this.Mo) || void 0 === r || r.addEventListener("close", t => this._o(t)), null === (n = this.Mo) || void 0 === n || n.addEventListener("error", this.Uo)
      }
      Yo() {
        var t, e, r;
        null === (t = this.Mo) || void 0 === t || t.removeEventListener("message", this.Ro), null === (e = this.Mo) || void 0 === e || e.removeEventListener("open", this.jo), null === (r = this.Mo) || void 0 === r || r.removeEventListener("close", this._o)
      }
      Do(t) {
        var e;
        !this.Ho.autoReconnect || [1e3, 1001].includes(t.code) && t.wasClean ? (this.Eo(t), this.Yo(), this.Wo(t.code, t.reason), null === (e = this.Mo) || void 0 === e || e.removeEventListener("error", this.Uo)) : this.Jo()
      }
    }
    const qE = t => hb.isWeb3Provider(t),
      JE = t => "string" != typeof t && "request" in t && "Function" === t.request.constructor.name,
      YE = t => "string" != typeof t && "request" in t && "AsyncFunction" === t.request.constructor.name,
      QE = t => "string" != typeof t && "send" in t,
      XE = t => "string" != typeof t && "sendAsync" in t,
      tP = t => t && (qE(t) || YE(t) || JE(t) || XE(t) || QE(t));
    var eP, rP = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    ! function(t) {
      t.PROVIDER_CHANGED = "PROVIDER_CHANGED", t.BEFORE_PROVIDER_CHANGE = "BEFORE_PROVIDER_CHANGE"
    }(eP || (eP = {}));
    const nP = {
      HttpProvider: GE,
      WebsocketProvider: ZE
    };
    class iP extends FE {
      constructor(t, e, r) {
        super(), NT(t) || this.setProvider(t), this.useRpcCallSpecification = e, NT(r) || (this.middleware = r)
      }
      static get providers() {
        return nP
      }
      get provider() {
        return this.ss
      }
      get providers() {
        return nP
      }
      setProvider(t) {
        let e;
        if (t && "string" == typeof t && this.providers)
          if (/^http(s)?:\/\//i.test(t)) e = new this.providers.HttpProvider(t);
          else {
            if (!/^ws(s)?:\/\//i.test(t)) throw new um(`Can't autodetect provider for "${t}"`);
            e = new this.providers.WebsocketProvider(t)
          }
        else e = NT(t) ? void 0 : t;
        return this.emit(eP.BEFORE_PROVIDER_CHANGE, this.ss), this.ss = e, this.emit(eP.PROVIDER_CHANGED, this.ss), !0
      }
      setMiddleware(t) {
        this.middleware = t
      }
      send(t) {
        return rP(this, void 0, void 0, function*() {
          const e = Object.assign({}, t);
          let r = yield this.us(e);
          if (NT(this.middleware) || (r = yield this.middleware.processResponse(r)), wE(r)) return r.result;
          throw new ly(r)
        })
      }
      sendBatch(t) {
        return rP(this, void 0, void 0, function*() {
          return yield this.us(t)
        })
      }
      us(t) {
        return rP(this, void 0, void 0, function*() {
          const {
            provider: e
          } = this;
          if (NT(e)) throw new um("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
          let r = WE(t) ? BE(t) : OE(t);
          if (NT(this.middleware) || (r = yield this.middleware.processRequest(r)), qE(e)) {
            let t;
            try {
              t = yield e.request(r)
            } catch (e) {
              t = e
            }
            return this.cs(r, t, {
              legacy: !1,
              error: !1
            })
          }
          if (YE(e)) return e.request(r).then(t => this.cs(r, t, {
            legacy: !0,
            error: !1
          })).catch(t => this.cs(r, t, {
            legacy: !0,
            error: !0
          }));
          if (JE(e)) return new Promise((t, n) => {
            const i = t => {
                n(this.cs(r, t, {
                  legacy: !0,
                  error: !0
                }))
              },
              o = e => t(this.cs(r, e, {
                legacy: !0,
                error: !1
              })),
              s = e.request(r, (t, e) => t ? i(t) : o(e));
            hE(s) && s.then(o).catch(t => {
              try {
                const e = this.cs(r, t, {
                  legacy: !0,
                  error: !0
                });
                n(e)
              } catch (t) {
                n(t)
              }
            })
          });
          if (QE(e)) return new Promise((t, n) => {
            e.send(r, (e, i) => {
              if (e) return n(this.cs(r, e, {
                legacy: !0,
                error: !0
              }));
              if (NT(i)) throw new ly({}, 'Got a "nullish" response from provider.');
              return t(this.cs(r, i, {
                legacy: !0,
                error: !1
              }))
            })
          });
          if (XE(e)) return e.sendAsync(r).then(t => this.cs(r, t, {
            legacy: !0,
            error: !1
          })).catch(t => this.cs(r, t, {
            legacy: !0,
            error: !0
          }));
          throw new um("Provider does not have a request or send method to use.")
        })
      }
      cs(t, e, {
        legacy: r,
        error: n
      }) {
        if (NT(e)) return this.fs(t, null, n);
        if (AE(e)) {
          if (this.useRpcCallSpecification && vE(e)) {
            const t = e;
            if (vy.get(t.error.code)) throw new(0, vy.get(t.error.code).error)(t);
            throw new yy(t)
          }
          if (!iP.ls(e)) throw new hy(e, t)
        }
        if (wE(e)) return e;
        if (e instanceof Error) throw iP.ls(e), e;
        if (!r && WE(t) && xE(e) || r && !n && WE(t)) return e;
        if (r && n && WE(t)) throw e;
        if (r && !AE(e) && !wE(e)) return this.fs(t, e, n);
        throw WE(t) && !Array.isArray(e) ? new ly(e, "Got normal response for a batch request.") : !WE(t) && Array.isArray(e) ? new ly(e, "Got batch response for a normal request.") : new ly(e, "Invalid response")
      }
      static ls(t) {
        let e;
        if (AE(t) ? e = t.error : t instanceof Error && (e = t), e?.message.includes("revert")) throw new Yb(e);
        return !1
      }
      fs(t, e, r) {
        const n = {
          jsonrpc: "2.0",
          id: WE(t) ? t[0].id : "id" in t ? t.id : null
        };
        return Object.assign(Object.assign({}, n), r ? {
          error: e
        } : {
          result: e
        })
      }
    }
    var oP = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class sP {
      constructor(t, e, r = !1) {
        this.requestManager = t, this.registeredSubscriptions = e, this.tolerateUnlinkedSubscription = r, this.hs = new Map, this.requestManager.on(eP.BEFORE_PROVIDER_CHANGE, () => oP(this, void 0, void 0, function*() {
          yield this.unsubscribe()
        })), this.requestManager.on(eP.PROVIDER_CHANGED, () => {
          this.clear(), this.listenToProviderEvents()
        }), this.listenToProviderEvents()
      }
      listenToProviderEvents() {
        const t = this.requestManager.provider;
        !this.requestManager.provider || "function" == typeof t?.supportsSubscriptions && !t?.supportsSubscriptions() || "function" == typeof this.requestManager.provider.on && ("function" == typeof this.requestManager.provider.request ? this.requestManager.provider.on("message", t => this.messageListener(t)) : t.on("data", t => this.messageListener(t)))
      }
      messageListener(t) {
        var e, r, n;
        if (!t) throw new fm("Should not call messageListener with no data. Type was");
        const i = (null === (e = t.params) || void 0 === e ? void 0 : e.subscription) || (null === (r = t.data) || void 0 === r ? void 0 : r.subscription) || (null === (n = t.id) || void 0 === n ? void 0 : n.toString(16));
        if (i) {
          const e = this.hs.get(i);
          e?.processSubscriptionData(t)
        }
      }
      subscribe(t, e) {
        return oP(this, arguments, void 0, function*(t, e, r = ob) {
          const n = this.registeredSubscriptions[t];
          if (!n) throw new fm("Invalid subscription type");
          const i = new n(e ?? void 0, {
            subscriptionManager: this,
            returnFormat: r
          });
          return yield this.addSubscription(i), i
        })
      }
      get subscriptions() {
        return this.hs
      }
      addSubscription(t) {
        return oP(this, void 0, void 0, function*() {
          if (!this.requestManager.provider) throw new um("Provider not available");
          if (!this.supportsSubscriptions()) throw new fm("The current provider does not support subscriptions");
          if (t.id && this.hs.has(t.id)) throw new fm(`Subscription with id "${t.id}" already exists`);
          if (yield t.sendSubscriptionRequest(), NT(t.id)) throw new fm("Subscription is not subscribed yet.");
          return this.hs.set(t.id, t), t.id
        })
      }
      removeSubscription(t) {
        return oP(this, void 0, void 0, function*() {
          const {
            id: e
          } = t;
          if (NT(e)) throw new fm("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
          if (!this.hs.has(e) && !this.tolerateUnlinkedSubscription) throw new fm(`Subscription with id "${e.toString()}" does not exists`);
          return yield t.sendUnsubscribeRequest(), this.hs.delete(e), e
        })
      }
      unsubscribe(t) {
        return oP(this, void 0, void 0, function*() {
          const e = [];
          for (const [r, n] of this.subscriptions.entries())(!t || "function" == typeof t && t({
            id: r,
            sub: n
          })) && e.push(this.removeSubscription(n));
          return Promise.all(e)
        })
      }
      clear() {
        this.hs.clear()
      }
      supportsSubscriptions() {
        return !NT(this.requestManager.provider) && (t => t && "supportsSubscriptions" in t ? t.supportsSubscriptions() : !(!t || "string" == typeof t || !("on" in t)))(this.requestManager.provider)
      }
    }
    var aP = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class uP extends FE {
      constructor(t, e) {
        var r;
        super(), this.args = t;
        const {
          requestManager: n
        } = e, {
          subscriptionManager: i
        } = e;
        this.ds = n ? new sP(n, {}, !0) : i, this.ps = null !== (r = e?.returnFormat) && void 0 !== r ? r : ob
      }
      get id() {
        return this.bs
      }
      get lastBlock() {
        return this.ys
      }
      subscribe() {
        return aP(this, void 0, void 0, function*() {
          return this.ds.addSubscription(this)
        })
      }
      processSubscriptionData(t) {
        var e, r;
        t?.data ? this.gs(null !== (r = null === (e = t?.data) || void 0 === e ? void 0 : e.result) && void 0 !== r ? r : t?.data) : t && TE(t) && this.gs(t?.params.result)
      }
      sendSubscriptionRequest() {
        return aP(this, void 0, void 0, function*() {
          return this.bs = yield this.ds.requestManager.send({
            method: "eth_subscribe",
            params: this.vs()
          }), this.emit("connected", this.bs), this.bs
        })
      }
      get returnFormat() {
        return this.ps
      }
      get subscriptionManager() {
        return this.ds
      }
      resubscribe() {
        return aP(this, void 0, void 0, function*() {
          yield this.unsubscribe(), yield this.subscribe()
        })
      }
      unsubscribe() {
        return aP(this, void 0, void 0, function*() {
          this.id && (yield this.ds.removeSubscription(this))
        })
      }
      sendUnsubscribeRequest() {
        return aP(this, void 0, void 0, function*() {
          yield this.ds.requestManager.send({
            method: "eth_unsubscribe",
            params: [this.id]
          }), this.bs = void 0
        })
      }
      formatSubscriptionResult(t) {
        return t
      }
      gs(t) {
        this.emit("data", this.formatSubscriptionResult(t))
      }
      ws(t) {
        this.emit("error", t)
      }
      vs() {
        throw Error("Implement in the child class")
      }
    }
    var cP = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class fP extends db {
      constructor() {
        super(...arguments), this.As = new Map, this.Ts = "web3js_wallet"
      }
      static getStorage() {
        let t;
        try {
          t = window.localStorage;
          const e = "__storage_test__";
          return t.setItem(e, e), t.removeItem(e), t
        } catch (e) {
          return !e || 22 !== e.code && 1014 !== e.code && "QuotaExceededError" !== e.name && "NS_ERROR_DOM_QUOTA_REACHED" !== e.name || RA(t) || 0 === t.length ? void 0 : t
        }
      }
      create(t) {
        for (let e = 0; t > e; e += 1) this.add(this.fo.create());
        return this
      }
      add(t) {
        var e;
        if ("string" == typeof t) return this.add(this.fo.privateKeyToAccount(t));
        let r = this.length;
        return this.get(t.address) && (console.warn(`Account ${t.address.toLowerCase()} already exists.`), r = null !== (e = this.As.get(t.address.toLowerCase())) && void 0 !== e ? e : r), this.As.set(t.address.toLowerCase(), r), this[r] = t, this
      }
      get(t) {
        if ("string" == typeof t) {
          const e = this.As.get(t.toLowerCase());
          return RA(e) ? void 0 : this[e]
        }
        return this[t]
      }
      remove(t) {
        if ("string" == typeof t) {
          const e = this.As.get(t.toLowerCase());
          return !RA(e) && (this.As.delete(t.toLowerCase()), this.splice(e, 1), !0)
        }
        return !!this[t] && (this.splice(t, 1), !0)
      }
      clear() {
        return this.As.clear(), this.length = 0, this
      }
      encrypt(t, e) {
        return cP(this, void 0, void 0, function*() {
          return Promise.all(this.map(r => cP(this, void 0, void 0, function*() {
            return r.encrypt(t, e)
          })))
        })
      }
      decrypt(t, e, r) {
        return cP(this, void 0, void 0, function*() {
          const n = yield Promise.all(t.map(t => cP(this, void 0, void 0, function*() {
            return this.fo.decrypt(t, e, r)
          })));
          for (const t of n) this.add(t);
          return this
        })
      }
      save(t, e) {
        return cP(this, void 0, void 0, function*() {
          const r = fP.getStorage();
          if (!r) throw Error("Local storage not available.");
          return r.setItem(e ?? this.Ts, JSON.stringify(yield this.encrypt(t))), !0
        })
      }
      load(t, e) {
        return cP(this, void 0, void 0, function*() {
          const r = fP.getStorage();
          if (!r) throw Error("Local storage not available.");
          const n = r.getItem(e ?? this.Ts);
          return n && (yield this.decrypt(JSON.parse(n) || [], t)), this
        })
      }
    }
    const lP = {
      web: jy
    };

    function hP(t, e, r) {
      if (!r.startsWith("aes-")) throw Error("AES submodule doesn't support mode " + r);
      if (16 !== e.length) throw Error("AES: wrong IV length");
      if (r.startsWith("aes-128") && 16 !== t.length || r.startsWith("aes-256") && 32 !== t.length) throw Error("AES: wrong key length")
    }
    async function dP(t, e, r) {
      if (!lP.web) throw Error("Browser crypto not available.");
      let n;
      if (["aes-128-cbc", "aes-256-cbc"].includes(t) && (n = "cbc"), ["aes-128-ctr", "aes-256-ctr"].includes(t) && (n = "ctr"), !n) throw Error("AES: unsupported mode");
      return [await lP.web.subtle.importKey("raw", e, {
        name: "AES-" + n.toUpperCase(),
        length: 8 * e.length
      }, !0, ["encrypt", "decrypt"]), {
        name: "aes-" + n,
        iv: r,
        counter: r,
        length: 128
      }]
    }
    async function pP(t, e, r, n = "aes-128-ctr", i = !0) {
      if (hP(e, r, n), lP.web) {
        const [o, s] = await dP(n, e, r), a = await lP.web.subtle.encrypt(s, o, t);
        let u = new Uint8Array(a);
        return !i && "aes-cbc" === s.name && !(t.length % 16) && (u = u.slice(0, -16)), u
      }
      if (lP.node) {
        const o = lP.node.createCipheriv(n, e, r);
        return o.setAutoPadding(i), Ky(o.update(t), o.final())
      }
      throw Error("The environment doesn't have AES module")
    }
    class bP extends Vy {
      constructor(t, e) {
        super(), this.finished = !1, this.destroyed = !1, Ey(t);
        const r = Gy(e);
        if (this.iHash = t.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n = this.blockLen,
          i = new Uint8Array(n);
        i.set(r.length > n ? t.create().update(r).digest() : r);
        for (let t = 0; t < i.length; t++) i[t] ^= 54;
        this.iHash.update(i), this.oHash = t.create();
        for (let t = 0; t < i.length; t++) i[t] ^= 106;
        this.oHash.update(i), i.fill(0)
      }
      update(t) {
        return Py(this), this.iHash.update(t), this
      }
      digestInto(t) {
        Py(this), Ty(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
      }
      digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t
      }
      jt(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: e,
          iHash: r,
          finished: n,
          destroyed: i,
          blockLen: o,
          outputLen: s
        } = this;
        return t.finished = n, t.destroyed = i, t.blockLen = o, t.outputLen = s, t.oHash = e.jt(t.oHash), t.iHash = r.jt(t.iHash), t
      }
      destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
      }
    }
    const mP = (t, e, r) => new bP(t, e).update(r).digest();

    function yP(t, e, r, n) {
      const {
        c: i,
        dkLen: o,
        DK: s,
        PRF: a,
        PRFSalt: u
      } = function(t, e, r, n) {
        Ey(t);
        const i = qy({
            dkLen: 32,
            asyncTick: 10
          }, n),
          {
            c: o,
            dkLen: s,
            asyncTick: a
          } = i;
        if (Ay(o), Ay(s), Ay(a), 1 > o) throw Error("PBKDF2: iterations (c) should be >= 1");
        const u = Gy(e),
          c = Gy(r),
          f = new Uint8Array(s),
          l = mP.create(t, u),
          h = l.jt().update(c);
        return {
          c: o,
          dkLen: s,
          asyncTick: a,
          DK: f,
          PRF: l,
          PRFSalt: h
        }
      }(t, e, r, n);
      let c;
      const f = new Uint8Array(4),
        l = Dy(f),
        h = new Uint8Array(a.outputLen);
      for (let t = 1, e = 0; o > e; t++, e += a.outputLen) {
        const r = s.subarray(e, e + a.outputLen);
        l.setInt32(0, t, !1), (c = u.jt(c)).update(f).digestInto(h), r.set(h.subarray(0, r.length));
        for (let t = 1; i > t; t++) {
          a.jt(c).update(h).digestInto(h);
          for (let t = 0; t < r.length; t++) r[t] ^= h[t]
        }
      }
      return function(t, e, r, n, i) {
        return t.destroy(), e.destroy(), n && n.destroy(), i.fill(0), r
      }(a, u, s, c, h)
    }
    mP.create = (t, e) => new bP(t, e);
    const gP = (t, e, r) => t & e ^ ~t & r,
      vP = (t, e, r) => t & e ^ t & r ^ e & r;
    class wP extends Vy {
      constructor(t, e, r, n) {
        super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = Dy(this.buffer)
      }
      update(t) {
        Py(this);
        const {
          view: e,
          buffer: r,
          blockLen: n
        } = this, i = (t = Gy(t)).length;
        for (let o = 0; i > o;) {
          const s = Math.min(n - this.pos, i - o);
          if (s === n) {
            const e = Dy(t);
            for (; i - o >= n; o += n) this.process(e, o);
            continue
          }
          r.set(t.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === n && (this.process(e, 0), this.pos = 0)
        }
        return this.length += t.length, this.roundClean(), this
      }
      digestInto(t) {
        Py(this), ky(t, this), this.finished = !0;
        const {
          buffer: e,
          view: r,
          blockLen: n,
          isLE: i
        } = this;
        let {
          pos: o
        } = this;
        e[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for (let t = o; n > t; t++) e[t] = 0;
        (function(t, e, r, n) {
          if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, r, n);
          const i = BigInt(32),
            o = BigInt(4294967295),
            s = +(r >> i & o),
            a = +(r & o),
            u = n ? 4 : 0,
            c = n ? 0 : 4;
          t.setUint32(e + u, s, n), t.setUint32(e + c, a, n)
        })(r, n - 8, BigInt(8 * this.length), i), this.process(r, 0);
        const s = Dy(t),
          a = this.outputLen;
        if (a % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
        const u = a / 4,
          c = this.get();
        if (u > c.length) throw Error("_sha2: outputLen bigger than state");
        for (let t = 0; u > t; t++) s.setUint32(4 * t, c[t], i)
      }
      digest() {
        const {
          buffer: t,
          outputLen: e
        } = this;
        this.digestInto(t);
        const r = t.slice(0, e);
        return this.destroy(), r
      }
      jt(t) {
        t || (t = new this.constructor), t.set(...this.get());
        const {
          blockLen: e,
          buffer: r,
          length: n,
          finished: i,
          destroyed: o,
          pos: s
        } = this;
        return t.length = n, t.pos = s, t.finished = i, t.destroyed = o, n % e && t.buffer.set(r), t
      }
    }
    const AP = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
      TP = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
      EP = new Uint32Array(64);
    class PP extends wP {
      constructor() {
        super(64, 32, 8, !1), this.A = 0 | TP[0], this.B = 0 | TP[1], this.C = 0 | TP[2], this.D = 0 | TP[3], this.E = 0 | TP[4], this.F = 0 | TP[5], this.G = 0 | TP[6], this.H = 0 | TP[7]
      }
      get() {
        const {
          A: t,
          B: e,
          C: r,
          D: n,
          E: i,
          F: o,
          G: s,
          H: a
        } = this;
        return [t, e, r, n, i, o, s, a]
      }
      set(t, e, r, n, i, o, s, a) {
        this.A = 0 | t, this.B = 0 | e, this.C = 0 | r, this.D = 0 | n, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) EP[r] = t.getUint32(e, !1);
        for (let t = 16; 64 > t; t++) {
          const e = EP[t - 15],
            r = EP[t - 2],
            n = Uy(e, 7) ^ Uy(e, 18) ^ e >>> 3,
            i = Uy(r, 17) ^ Uy(r, 19) ^ r >>> 10;
          EP[t] = i + EP[t - 7] + n + EP[t - 16] | 0
        }
        let {
          A: r,
          B: n,
          C: i,
          D: o,
          E: s,
          F: a,
          G: u,
          H: c
        } = this;
        for (let t = 0; 64 > t; t++) {
          const e = c + (Uy(s, 6) ^ Uy(s, 11) ^ Uy(s, 25)) + gP(s, a, u) + AP[t] + EP[t] | 0,
            f = (Uy(r, 2) ^ Uy(r, 13) ^ Uy(r, 22)) + vP(r, n, i) | 0;
          c = u, u = a, a = s, s = o + e | 0, o = i, i = n, n = r, r = e + f | 0
        }
        r = r + this.A | 0, n = n + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, u = u + this.G | 0, c = c + this.H | 0, this.set(r, n, i, o, s, a, u, c)
      }
      roundClean() {
        EP.fill(0)
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
      }
    }
    const kP = Jy(() => new PP),
      [xP, IP] = Ny.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
      SP = new Uint32Array(80),
      OP = new Uint32Array(80);
    class BP extends wP {
      constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
      }
      get() {
        const {
          Ah: t,
          Al: e,
          Bh: r,
          Bl: n,
          Ch: i,
          Cl: o,
          Dh: s,
          Dl: a,
          Eh: u,
          El: c,
          Fh: f,
          Fl: l,
          Gh: h,
          Gl: d,
          Hh: p,
          Hl: b
        } = this;
        return [t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b]
      }
      set(t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b) {
        this.Ah = 0 | t, this.Al = 0 | e, this.Bh = 0 | r, this.Bl = 0 | n, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | u, this.El = 0 | c, this.Fh = 0 | f, this.Fl = 0 | l, this.Gh = 0 | h, this.Gl = 0 | d, this.Hh = 0 | p, this.Hl = 0 | b
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) SP[r] = t.getUint32(e), OP[r] = t.getUint32(e += 4);
        for (let t = 16; 80 > t; t++) {
          const e = 0 | SP[t - 15],
            r = 0 | OP[t - 15],
            n = Ny.rotrSH(e, r, 1) ^ Ny.rotrSH(e, r, 8) ^ Ny.shrSH(e, r, 7),
            i = Ny.rotrSL(e, r, 1) ^ Ny.rotrSL(e, r, 8) ^ Ny.shrSL(e, r, 7),
            o = 0 | SP[t - 2],
            s = 0 | OP[t - 2],
            a = Ny.rotrSH(o, s, 19) ^ Ny.rotrBH(o, s, 61) ^ Ny.shrSH(o, s, 6),
            u = Ny.rotrSL(o, s, 19) ^ Ny.rotrBL(o, s, 61) ^ Ny.shrSL(o, s, 6),
            c = Ny.add4L(i, u, OP[t - 7], OP[t - 16]),
            f = Ny.add4H(c, n, a, SP[t - 7], SP[t - 16]);
          SP[t] = 0 | f, OP[t] = 0 | c
        }
        let {
          Ah: r,
          Al: n,
          Bh: i,
          Bl: o,
          Ch: s,
          Cl: a,
          Dh: u,
          Dl: c,
          Eh: f,
          El: l,
          Fh: h,
          Fl: d,
          Gh: p,
          Gl: b,
          Hh: m,
          Hl: y
        } = this;
        for (let t = 0; 80 > t; t++) {
          const e = Ny.rotrSH(f, l, 14) ^ Ny.rotrSH(f, l, 18) ^ Ny.rotrBH(f, l, 41),
            g = Ny.rotrSL(f, l, 14) ^ Ny.rotrSL(f, l, 18) ^ Ny.rotrBL(f, l, 41),
            v = f & h ^ ~f & p,
            w = l & d ^ ~l & b,
            A = Ny.add5L(y, g, w, IP[t], OP[t]),
            T = Ny.add5H(A, m, e, v, xP[t], SP[t]),
            E = 0 | A,
            P = Ny.rotrSH(r, n, 28) ^ Ny.rotrBH(r, n, 34) ^ Ny.rotrBH(r, n, 39),
            k = Ny.rotrSL(r, n, 28) ^ Ny.rotrBL(r, n, 34) ^ Ny.rotrBL(r, n, 39),
            x = r & i ^ r & s ^ i & s,
            I = n & o ^ n & a ^ o & a;
          m = 0 | p, y = 0 | b, p = 0 | h, b = 0 | d, h = 0 | f, d = 0 | l, ({
            h: f,
            l: l
          } = Ny.add(0 | u, 0 | c, 0 | T, 0 | E)), u = 0 | s, c = 0 | a, s = 0 | i, a = 0 | o, i = 0 | r, o = 0 | n;
          const S = Ny.add3L(E, k, I);
          r = Ny.add3H(S, T, P, x), n = 0 | S
        }({
          h: r,
          l: n
        } = Ny.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)), ({
          h: i,
          l: o
        } = Ny.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({
          h: s,
          l: a
        } = Ny.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({
          h: u,
          l: c
        } = Ny.add(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)), ({
          h: f,
          l: l
        } = Ny.add(0 | this.Eh, 0 | this.El, 0 | f, 0 | l)), ({
          h: h,
          l: d
        } = Ny.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)), ({
          h: p,
          l: b
        } = Ny.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | b)), ({
          h: m,
          l: y
        } = Ny.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y)
      }
      roundClean() {
        SP.fill(0), OP.fill(0)
      }
      destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
      }
    }
    const WP = Jy(() => new BP);

    function MP(t, e, r, n, i) {
      if (!["sha256", "sha512"].includes(i)) throw Error("Only sha256 and sha512 are supported");
      return yg(t), yg(e), yP("sha256" === i ? kP : WP, t, e, {
        c: r,
        dkLen: n
      })
    }

    function CP(t, e, r, n, i, o) {
      let s = t[e++] ^ r[n++],
        a = t[e++] ^ r[n++],
        u = t[e++] ^ r[n++],
        c = t[e++] ^ r[n++],
        f = t[e++] ^ r[n++],
        l = t[e++] ^ r[n++],
        h = t[e++] ^ r[n++],
        d = t[e++] ^ r[n++],
        p = t[e++] ^ r[n++],
        b = t[e++] ^ r[n++],
        m = t[e++] ^ r[n++],
        y = t[e++] ^ r[n++],
        g = t[e++] ^ r[n++],
        v = t[e++] ^ r[n++],
        w = t[e++] ^ r[n++],
        A = t[e++] ^ r[n++],
        T = s,
        E = a,
        P = u,
        k = c,
        x = f,
        I = l,
        S = h,
        O = d,
        B = p,
        W = b,
        M = m,
        C = y,
        R = g,
        N = v,
        j = w,
        _ = A;
      for (let t = 0; 8 > t; t += 2) x ^= Ly(T + R | 0, 7), B ^= Ly(x + T | 0, 9), R ^= Ly(B + x | 0, 13), T ^= Ly(R + B | 0, 18), W ^= Ly(I + E | 0, 7), N ^= Ly(W + I | 0, 9), E ^= Ly(N + W | 0, 13), I ^= Ly(E + N | 0, 18), j ^= Ly(M + S | 0, 7), P ^= Ly(j + M | 0, 9), S ^= Ly(P + j | 0, 13), M ^= Ly(S + P | 0, 18), k ^= Ly(_ + C | 0, 7), O ^= Ly(k + _ | 0, 9), C ^= Ly(O + k | 0, 13), _ ^= Ly(C + O | 0, 18), E ^= Ly(T + k | 0, 7), P ^= Ly(E + T | 0, 9), k ^= Ly(P + E | 0, 13), T ^= Ly(k + P | 0, 18), S ^= Ly(I + x | 0, 7), O ^= Ly(S + I | 0, 9), x ^= Ly(O + S | 0, 13), I ^= Ly(x + O | 0, 18), C ^= Ly(M + W | 0, 7), B ^= Ly(C + M | 0, 9), W ^= Ly(B + C | 0, 13), M ^= Ly(W + B | 0, 18), R ^= Ly(_ + j | 0, 7), N ^= Ly(R + _ | 0, 9), j ^= Ly(N + R | 0, 13), _ ^= Ly(j + N | 0, 18);
      i[o++] = s + T | 0, i[o++] = a + E | 0, i[o++] = u + P | 0, i[o++] = c + k | 0, i[o++] = f + x | 0, i[o++] = l + I | 0, i[o++] = h + S | 0, i[o++] = d + O | 0, i[o++] = p + B | 0, i[o++] = b + W | 0, i[o++] = m + M | 0, i[o++] = y + C | 0, i[o++] = g + R | 0, i[o++] = v + N | 0, i[o++] = w + j | 0, i[o++] = A + _ | 0
    }

    function RP(t, e, r, n, i) {
      let o = n + 0,
        s = n + 16 * i;
      for (let n = 0; 16 > n; n++) r[s + n] = t[e + 16 * (2 * i - 1) + n];
      for (let n = 0; i > n; n++, o += 16, e += 16) CP(r, s, t, e, r, o), n > 0 && (s += 16), CP(r, o, t, e += 16, r, s)
    }

    function NP(t, e, r, n, i, o, s) {
      return yg(t), yg(e),
        function(t, e, r) {
          const {
            N: n,
            r: i,
            p: o,
            dkLen: s,
            blockSize32: a,
            V: u,
            B32: c,
            B: f,
            tmp: l,
            blockMixCb: h
          } = function(t, e, r) {
            const n = qy({
                dkLen: 32,
                asyncTick: 10,
                maxmem: 1073742848
              }, r),
              {
                N: i,
                r: o,
                p: s,
                dkLen: a,
                asyncTick: u,
                maxmem: c,
                onProgress: f
              } = n;
            if (Ay(i), Ay(o), Ay(s), Ay(a), Ay(u), Ay(c), void 0 !== f && "function" != typeof f) throw Error("progressCb should be function");
            const l = 128 * o,
              h = l / 4;
            if (1 >= i || i & i - 1 || i >= 2 ** (l / 8) || i > 2 ** 32) throw Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
            if (0 > s || s > 137438953440 / l) throw Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
            if (0 > a || a > 137438953440) throw Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
            const d = l * (i + s);
            if (d > c) throw Error(`Scrypt: parameters too large, ${d} (128 * r * (N + p)) > ${c} (maxmem)`);
            const p = yP(kP, t, e, {
                c: 1,
                dkLen: l * s
              }),
              b = _y(p),
              m = _y(new Uint8Array(l * i)),
              y = _y(new Uint8Array(l));
            let g = () => {};
            if (f) {
              const t = 2 * i * s,
                e = Math.max(Math.floor(t / 1e4), 1);
              let r = 0;
              g = () => {
                r++, f && (!(r % e) || r === t) && f(r / t)
              }
            }
            return {
              N: i,
              r: o,
              p: s,
              dkLen: a,
              blockSize32: h,
              V: m,
              B32: b,
              B: p,
              tmp: y,
              blockMixCb: g,
              asyncTick: u
            }
          }(t, e, r);
          Fy || zy(c);
          for (let t = 0; o > t; t++) {
            const e = a * t;
            for (let t = 0; a > t; t++) u[t] = c[e + t];
            for (let t = 0, e = 0; n - 1 > t; t++) RP(u, e, u, e += a, i), h();
            RP(u, (n - 1) * a, c, e, i), h();
            for (let t = 0; n > t; t++) {
              const t = c[e + a - 16] % n;
              for (let r = 0; a > r; r++) l[r] = c[e + r] ^ u[t * a + r];
              RP(l, 0, c, e, i), h()
            }
          }
          return Fy || zy(c),
            function(t, e, r, n, i) {
              const o = yP(kP, t, r, {
                c: 1,
                dkLen: e
              });
              return r.fill(0), n.fill(0), i.fill(0), o
            }(t, s, f, u, l)
        }(t, e, {
          N: r,
          r: i,
          p: n,
          dkLen: o,
          onProgress: s
        })
    }
    const jP = BigInt(1),
      _P = BigInt(2);

    function DP(t) {
      return t instanceof Uint8Array || null != t && "object" == typeof t && "Uint8Array" === t.constructor.name
    }

    function UP(t) {
      if (!DP(t)) throw Error("Uint8Array expected")
    }
    const LP = Array.from({
      length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));

    function FP(t) {
      UP(t);
      let e = "";
      for (let r = 0; r < t.length; r++) e += LP[t[r]];
      return e
    }

    function $P(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      return BigInt("" === t ? "0" : "0x" + t)
    }
    const zP = {
      _t: 48,
      Dt: 57,
      Ut: 65,
      Lt: 70,
      Ft: 97,
      $t: 102
    };

    function HP(t) {
      return t < zP._t || t > zP.Dt ? t < zP.Ut || t > zP.Lt ? t < zP.Ft || t > zP.$t ? void 0 : t - (zP.Ft - 10) : t - (zP.Ut - 10) : t - zP._t
    }

    function GP(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      const e = t.length,
        r = e / 2;
      if (e % 2) throw Error("padded hex string expected, got unpadded hex of length " + e);
      const n = new Uint8Array(r);
      for (let e = 0, i = 0; r > e; e++, i += 2) {
        const r = HP(t.charCodeAt(i)),
          o = HP(t.charCodeAt(i + 1));
        if (void 0 === r || void 0 === o) {
          const e = t[i] + t[i + 1];
          throw Error('hex string expected, got non-hex character "' + e + '" at index ' + i)
        }
        n[e] = 16 * r + o
      }
      return n
    }

    function KP(t) {
      return $P(FP(t))
    }

    function VP(t) {
      return UP(t), $P(FP(Uint8Array.from(t).reverse()))
    }

    function ZP(t, e) {
      return GP(t.toString(16).padStart(2 * e, "0"))
    }

    function qP(t, e) {
      return ZP(t, e).reverse()
    }

    function JP(t, e, r) {
      let n;
      if ("string" == typeof e) try {
        n = GP(e)
      } catch (r) {
        throw Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)
      } else {
        if (!DP(e)) throw Error(t + " must be hex string or Uint8Array");
        n = Uint8Array.from(e)
      }
      const i = n.length;
      if ("number" == typeof r && i !== r) throw Error(`${t} expected ${r} bytes, got ${i}`);
      return n
    }

    function YP(...t) {
      let e = 0;
      for (let r = 0; r < t.length; r++) {
        const n = t[r];
        UP(n), e += n.length
      }
      const r = new Uint8Array(e);
      for (let e = 0, n = 0; e < t.length; e++) {
        const i = t[e];
        r.set(i, n), n += i.length
      }
      return r
    }
    const QP = t => (_P << BigInt(t - 1)) - jP,
      XP = t => new Uint8Array(t),
      tk = t => Uint8Array.from(t);

    function ek(t, e, r) {
      if ("number" != typeof t || 2 > t) throw Error("hashLen must be a number");
      if ("number" != typeof e || 2 > e) throw Error("qByteLen must be a number");
      if ("function" != typeof r) throw Error("hmacFn must be a function");
      let n = XP(t),
        i = XP(t),
        o = 0;
      const s = () => {
          n.fill(1), i.fill(0), o = 0
        },
        a = (...t) => r(i, n, ...t),
        u = (t = XP()) => {
          i = a(tk([0]), t), n = a(), 0 !== t.length && (i = a(tk([1]), t), n = a())
        },
        c = () => {
          if (o++ >= 1e3) throw Error("drbg: tried 1000 values");
          let t = 0;
          const r = [];
          for (; e > t;) {
            n = a();
            const e = n.slice();
            r.push(e), t += n.length
          }
          return YP(...r)
        };
      return (t, e) => {
        let r;
        for (s(), u(t); !(r = e(c()));) u();
        return s(), r
      }
    }
    const rk = {
      bigint: t => "bigint" == typeof t,
      function: t => "function" == typeof t,
      boolean: t => "boolean" == typeof t,
      string: t => "string" == typeof t,
      stringOrUint8Array: t => "string" == typeof t || DP(t),
      isSafeInteger: t => Number.isSafeInteger(t),
      array: t => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: t => "function" == typeof t && Number.isSafeInteger(t.outputLen)
    };

    function nk(t, e, r = {}) {
      const n = (e, r, n) => {
        const i = rk[r];
        if ("function" != typeof i) throw Error(`Invalid validator "${r}", expected function`);
        const o = t[e];
        if (!(n && void 0 === o || i(o, t))) throw Error(`Invalid param ${e+""}=${o} (${typeof o}), expected ${r}`)
      };
      for (const [t, r] of Object.entries(e)) n(t, r, !1);
      for (const [t, e] of Object.entries(r)) n(t, e, !0);
      return t
    }
    const ik = BigInt(0),
      ok = BigInt(1),
      sk = BigInt(2),
      ak = BigInt(3),
      uk = BigInt(4),
      ck = BigInt(5),
      fk = BigInt(8);

    function lk(t, e) {
      const r = t % e;
      return ik > r ? e + r : r
    }

    function hk(t, e, r) {
      if (ik >= r || ik > e) throw Error("Expected power/modulo > 0");
      if (r === ok) return ik;
      let n = ok;
      for (; e > ik;) e & ok && (n = n * t % r), t = t * t % r, e >>= ok;
      return n
    }

    function dk(t, e, r) {
      let n = t;
      for (; e-- > ik;) n *= n, n %= r;
      return n
    }

    function pk(t, e) {
      if (t === ik || ik >= e) throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);
      let r = lk(t, e),
        n = e,
        i = ik,
        o = ok,
        s = ok,
        a = ik;
      for (; r !== ik;) {
        const t = n / r,
          e = n % r,
          u = i - s * t,
          c = o - a * t;
        n = r, r = e, i = s, o = a, s = u, a = c
      }
      if (n !== ok) throw Error("invert: does not exist");
      return lk(i, e)
    }
    BigInt(9), BigInt(16);
    const bk = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

    function mk(t, e) {
      const r = void 0 !== e ? e : t.toString(2).length;
      return {
        nBitLength: r,
        nByteLength: Math.ceil(r / 8)
      }
    }

    function yk(t) {
      if ("bigint" != typeof t) throw Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8)
    }

    function gk(t) {
      const e = yk(t);
      return e + Math.ceil(e / 2)
    }
    const vk = BigInt(0),
      wk = BigInt(1);

    function Ak(t) {
      return function(t) {
        nk(t, bk.reduce((t, e) => (t[e] = "function", t), {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        }))
      }(t.Fp), nk(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      }), Object.freeze({
        ...mk(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
      })
    }
    const {
      Ph: Tk,
      aT: Ek
    } = o, Pk = {
      Err: class extends Error {
        constructor(t = "") {
          super(t)
        }
      },
      Ht(t) {
        const {
          Err: e
        } = Pk;
        if (2 > t.length || 2 !== t[0]) throw new e("Invalid signature integer tag");
        const r = t[1],
          n = t.subarray(2, r + 2);
        if (!r || n.length !== r) throw new e("Invalid signature integer: wrong length");
        if (128 & n[0]) throw new e("Invalid signature integer: negative");
        if (0 === n[0] && !(128 & n[1])) throw new e("Invalid signature integer: unnecessary leading zero");
        return {
          d: Tk(n),
          l: t.subarray(r + 2)
        }
      },
      toSig(t) {
        const {
          Err: e
        } = Pk, r = "string" == typeof t ? Ek(t) : t;
        UP(r);
        let n = r.length;
        if (2 > n || 48 != r[0]) throw new e("Invalid signature tag");
        if (r[1] !== n - 2) throw new e("Invalid signature: incorrect length");
        const {
          d: i,
          l: o
        } = Pk.Ht(r.subarray(2)), {
          d: s,
          l: a
        } = Pk.Ht(o);
        if (a.length) throw new e("Invalid signature: left bytes after parsing");
        return {
          r: i,
          s: s
        }
      },
      hexFromSig(t) {
        const e = t => 8 & Number.parseInt(t[0], 16) ? "00" + t : t,
          r = t => {
            const e = t.toString(16);
            return 1 & e.length ? "0" + e : e
          },
          n = e(r(t.s)),
          i = e(r(t.r)),
          o = n.length / 2,
          s = i.length / 2,
          a = r(o),
          u = r(s);
        return `30${r(s+o+4)}02${u}${i}02${a}${n}`
      }
    }, kk = BigInt(0), xk = BigInt(1), Ik = (BigInt(2), BigInt(3));

    function Sk(t) {
      return {
        hash: t,
        hmac: (e, ...r) => mP(t, e, Ky(...r)),
        randomBytes: Yy
      }
    }
    BigInt(4);
    const Ok = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      Bk = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      Wk = BigInt(1),
      Mk = BigInt(2),
      Ck = (t, e) => (t + e / Mk) / e,
      Rk = function(t, e, r = !1, n = {}) {
        if (ik >= t) throw Error("Expected Field ORDER > 0, got " + t);
        const {
          nBitLength: i,
          nByteLength: o
        } = mk(t, e);
        if (o > 2048) throw Error("Field lengths over 2048 bytes are not supported");
        const s = function(t) {
            if (t % uk === ak) {
              const e = (t + ok) / uk;
              return function(t, r) {
                const n = t.pow(r, e);
                if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
                return n
              }
            }
            if (t % fk === ck) {
              const e = (t - ck) / fk;
              return function(t, r) {
                const n = t.mul(r, sk),
                  i = t.pow(n, e),
                  o = t.mul(r, i),
                  s = t.mul(t.mul(o, sk), i),
                  a = t.mul(o, t.sub(s, t.ONE));
                if (!t.eql(t.sqr(a), r)) throw Error("Cannot find square root");
                return a
              }
            }
            return function(t) {
              const e = (t - ok) / sk;
              let r, n, i;
              for (r = t - ok, n = 0; r % sk === ik; r /= sk, n++);
              for (i = sk; t > i && hk(i, e, t) !== t - ok; i++);
              if (1 === n) {
                const e = (t + ok) / uk;
                return function(t, r) {
                  const n = t.pow(r, e);
                  if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
                  return n
                }
              }
              const o = (r + ok) / sk;
              return function(t, s) {
                if (t.pow(s, e) === t.neg(t.ONE)) throw Error("Cannot find square root");
                let a = n,
                  u = t.pow(t.mul(t.ONE, i), r),
                  c = t.pow(s, o),
                  f = t.pow(s, r);
                for (; !t.eql(f, t.ONE);) {
                  if (t.eql(f, t.ZERO)) return t.ZERO;
                  let e = 1;
                  for (let r = t.sqr(f); a > e && !t.eql(r, t.ONE); e++) r = t.sqr(r);
                  const r = t.pow(u, ok << BigInt(a - e - 1));
                  u = t.sqr(r), c = t.mul(c, r), f = t.mul(f, u), a = e
                }
                return c
              }
            }(t)
          }(t),
          a = Object.freeze({
            ORDER: t,
            BITS: i,
            BYTES: o,
            MASK: QP(i),
            ZERO: ik,
            ONE: ok,
            create: e => lk(e, t),
            isValid: e => {
              if ("bigint" != typeof e) throw Error("Invalid field element: expected bigint, got " + typeof e);
              return e >= ik && t > e
            },
            is0: t => t === ik,
            isOdd: t => (t & ok) === ok,
            neg: e => lk(-e, t),
            eql: (t, e) => t === e,
            sqr: e => lk(e * e, t),
            add: (e, r) => lk(e + r, t),
            sub: (e, r) => lk(e - r, t),
            mul: (e, r) => lk(e * r, t),
            pow: (t, e) => function(t, e, r) {
              if (ik > r) throw Error("Expected power > 0");
              if (r === ik) return t.ONE;
              if (r === ok) return e;
              let n = t.ONE,
                i = e;
              for (; r > ik;) r & ok && (n = t.mul(n, i)), i = t.sqr(i), r >>= ok;
              return n
            }(a, t, e),
            div: (e, r) => lk(e * pk(r, t), t),
            sqrN: t => t * t,
            addN: (t, e) => t + e,
            subN: (t, e) => t - e,
            mulN: (t, e) => t * e,
            inv: e => pk(e, t),
            sqrt: n.sqrt || (t => s(a, t)),
            invertBatch: t => function(t, e) {
              const r = Array(e.length),
                n = e.reduce((e, n, i) => t.is0(n) ? e : (r[i] = e, t.mul(e, n)), t.ONE),
                i = t.inv(n);
              return e.reduceRight((e, n, i) => t.is0(n) ? e : (r[i] = t.mul(e, r[i]), t.mul(e, n)), i), r
            }(a, t),
            cmov: (t, e, r) => r ? e : t,
            toBytes: t => r ? qP(t, o) : ZP(t, o),
            fromBytes: t => {
              if (t.length !== o) throw Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);
              return r ? VP(t) : KP(t)
            }
          });
        return Object.freeze(a)
      }(Ok, void 0, void 0, {
        sqrt: function(t) {
          const e = Ok,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            a = BigInt(44),
            u = BigInt(88),
            c = t * t * t % e,
            f = c * c * t % e,
            l = dk(f, r, e) * f % e,
            h = dk(l, r, e) * f % e,
            d = dk(h, Mk, e) * c % e,
            p = dk(d, i, e) * d % e,
            b = dk(p, o, e) * p % e,
            m = dk(b, a, e) * b % e,
            y = dk(m, u, e) * m % e,
            g = dk(y, a, e) * b % e,
            v = dk(g, r, e) * f % e,
            w = dk(v, s, e) * p % e,
            A = dk(w, n, e) * c % e,
            T = dk(A, Mk, e);
          if (!Rk.eql(Rk.sqr(T), t)) throw Error("Cannot find square root");
          return T
        }
      }),
      Nk = function(t, e) {
        const r = e => function(t) {
          const e = function(t) {
              const e = Ak(t);
              return nk(e, {
                hash: "hash",
                hmac: "function",
                randomBytes: "function"
              }, {
                bits2int: "function",
                bits2int_modN: "function",
                lowS: "boolean"
              }), Object.freeze({
                lowS: !0,
                ...e
              })
            }(t),
            {
              Fp: r,
              n: n
            } = e,
            i = r.BYTES + 1,
            o = 2 * r.BYTES + 1;

          function s(t) {
            return lk(t, n)
          }

          function a(t) {
            return pk(t, n)
          }
          const {
            ProjectivePoint: u,
            normPrivateKeyToScalar: c,
            weierstrassEquation: f,
            isWithinCurveOrder: l
          } = function(t) {
            const e = function(t) {
                const e = Ak(t);
                nk(e, {
                  a: "field",
                  b: "field"
                }, {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                  fromBytes: "function",
                  toBytes: "function"
                });
                const {
                  endo: r,
                  Fp: n,
                  a: i
                } = e;
                if (r) {
                  if (!n.eql(i, n.ZERO)) throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                  if ("object" != typeof r || "bigint" != typeof r.beta || "function" != typeof r.splitScalar) throw Error("Expected endomorphism with beta: bigint and splitScalar: function")
                }
                return Object.freeze({
                  ...e
                })
              }(t),
              {
                Fp: r
              } = e,
              n = e.toBytes || ((t, e, n) => {
                const i = e.toAffine();
                return YP(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y))
              }),
              i = e.fromBytes || (t => {
                const e = t.subarray(1);
                return {
                  x: r.fromBytes(e.subarray(0, r.BYTES)),
                  y: r.fromBytes(e.subarray(r.BYTES, 2 * r.BYTES))
                }
              });

            function o(t) {
              const {
                a: n,
                b: i
              } = e, o = r.sqr(t), s = r.mul(o, t);
              return r.add(r.add(s, r.mul(t, n)), i)
            }
            if (!r.eql(r.sqr(e.Gy), o(e.Gx))) throw Error("bad generator point: equation left != right");

            function s(t) {
              return "bigint" == typeof t && t > kk && t < e.n
            }

            function a(t) {
              if (!s(t)) throw Error("Expected valid bigint: 0 < bigint < curve.n")
            }

            function u(t) {
              const {
                allowedPrivateKeyLengths: r,
                nByteLength: n,
                wrapPrivateKey: i,
                n: o
              } = e;
              if (r && "bigint" != typeof t) {
                if (DP(t) && (t = FP(t)), "string" != typeof t || !r.includes(t.length)) throw Error("Invalid key");
                t = t.padStart(2 * n, "0")
              }
              let s;
              try {
                s = "bigint" == typeof t ? t : KP(JP("private key", t, n))
              } catch {
                throw Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)
              }
              return i && (s = lk(s, o)), a(s), s
            }
            const c = new Map;

            function f(t) {
              if (!(t instanceof l)) throw Error("ProjectivePoint expected")
            }
            class l {
              constructor(t, e, n) {
                if (this.px = t, this.py = e, this.pz = n, null == t || !r.isValid(t)) throw Error("x required");
                if (null == e || !r.isValid(e)) throw Error("y required");
                if (null == n || !r.isValid(n)) throw Error("z required")
              }
              static fromAffine(t) {
                const {
                  x: e,
                  y: n
                } = t || {};
                if (!t || !r.isValid(e) || !r.isValid(n)) throw Error("invalid affine point");
                if (t instanceof l) throw Error("projective point not allowed");
                const i = t => r.eql(t, r.ZERO);
                return i(e) && i(n) ? l.ZERO : new l(e, n, r.ONE)
              }
              get x() {
                return this.toAffine().x
              }
              get y() {
                return this.toAffine().y
              }
              static normalizeZ(t) {
                const e = r.invertBatch(t.map(t => t.pz));
                return t.map((t, r) => t.toAffine(e[r])).map(l.fromAffine)
              }
              static fromHex(t) {
                const e = l.fromAffine(i(JP("pointHex", t)));
                return e.assertValidity(), e
              }
              static fromPrivateKey(t) {
                return l.BASE.multiply(u(t))
              }
              zt(t) {
                this.Gt = t, c.delete(this)
              }
              assertValidity() {
                if (this.is0()) {
                  if (e.allowInfinityPoint && !r.is0(this.py)) return;
                  throw Error("bad point: ZERO")
                }
                const {
                  x: t,
                  y: n
                } = this.toAffine();
                if (!r.isValid(t) || !r.isValid(n)) throw Error("bad point: x or y not FE");
                const i = r.sqr(n),
                  s = o(t);
                if (!r.eql(i, s)) throw Error("bad point: equation left != right");
                if (!this.isTorsionFree()) throw Error("bad point: not in prime-order subgroup")
              }
              hasEvenY() {
                const {
                  y: t
                } = this.toAffine();
                if (r.isOdd) return !r.isOdd(t);
                throw Error("Field doesn't support isOdd")
              }
              equals(t) {
                f(t);
                const {
                  px: e,
                  py: n,
                  pz: i
                } = this, {
                  px: o,
                  py: s,
                  pz: a
                } = t, u = r.eql(r.mul(e, a), r.mul(o, i)), c = r.eql(r.mul(n, a), r.mul(s, i));
                return u && c
              }
              negate() {
                return new l(this.px, r.neg(this.py), this.pz)
              }
              double() {
                const {
                  a: t,
                  b: n
                } = e, i = r.mul(n, Ik), {
                  px: o,
                  py: s,
                  pz: a
                } = this;
                let u = r.ZERO,
                  c = r.ZERO,
                  f = r.ZERO,
                  h = r.mul(o, o),
                  d = r.mul(s, s),
                  p = r.mul(a, a),
                  b = r.mul(o, s);
                return b = r.add(b, b), f = r.mul(o, a), f = r.add(f, f), u = r.mul(t, f), c = r.mul(i, p), c = r.add(u, c), u = r.sub(d, c), c = r.add(d, c), c = r.mul(u, c), u = r.mul(b, u), f = r.mul(i, f), p = r.mul(t, p), b = r.sub(h, p), b = r.mul(t, b), b = r.add(b, f), f = r.add(h, h), h = r.add(f, h), h = r.add(h, p), h = r.mul(h, b), c = r.add(c, h), p = r.mul(s, a), p = r.add(p, p), h = r.mul(p, b), u = r.sub(u, h), f = r.mul(p, d), f = r.add(f, f), f = r.add(f, f), new l(u, c, f)
              }
              add(t) {
                f(t);
                const {
                  px: n,
                  py: i,
                  pz: o
                } = this, {
                  px: s,
                  py: a,
                  pz: u
                } = t;
                let c = r.ZERO,
                  h = r.ZERO,
                  d = r.ZERO;
                const p = e.a,
                  b = r.mul(e.b, Ik);
                let m = r.mul(n, s),
                  y = r.mul(i, a),
                  g = r.mul(o, u),
                  v = r.add(n, i),
                  w = r.add(s, a);
                v = r.mul(v, w), w = r.add(m, y), v = r.sub(v, w), w = r.add(n, o);
                let A = r.add(s, u);
                return w = r.mul(w, A), A = r.add(m, g), w = r.sub(w, A), A = r.add(i, o), c = r.add(a, u), A = r.mul(A, c), c = r.add(y, g), A = r.sub(A, c), d = r.mul(p, w), c = r.mul(b, g), d = r.add(c, d), c = r.sub(y, d), d = r.add(y, d), h = r.mul(c, d), y = r.add(m, m), y = r.add(y, m), g = r.mul(p, g), w = r.mul(b, w), y = r.add(y, g), g = r.sub(m, g), g = r.mul(p, g), w = r.add(w, g), m = r.mul(y, w), h = r.add(h, m), m = r.mul(A, w), c = r.mul(v, c), c = r.sub(c, m), m = r.mul(v, y), d = r.mul(A, d), d = r.add(d, m), new l(c, h, d)
              }
              subtract(t) {
                return this.add(t.negate())
              }
              is0() {
                return this.equals(l.ZERO)
              }
              wNAF(t) {
                return d.wNAFCached(this, c, t, t => {
                  const e = r.invertBatch(t.map(t => t.pz));
                  return t.map((t, r) => t.toAffine(e[r])).map(l.fromAffine)
                })
              }
              multiplyUnsafe(t) {
                const n = l.ZERO;
                if (t === kk) return n;
                if (a(t), t === xk) return this;
                const {
                  endo: i
                } = e;
                if (!i) return d.unsafeLadder(this, t);
                let {
                  k1neg: o,
                  k1: s,
                  k2neg: u,
                  k2: c
                } = i.splitScalar(t), f = n, h = n, p = this;
                for (; s > kk || c > kk;) s & xk && (f = f.add(p)), c & xk && (h = h.add(p)), p = p.double(), s >>= xk, c >>= xk;
                return o && (f = f.negate()), u && (h = h.negate()), h = new l(r.mul(h.px, i.beta), h.py, h.pz), f.add(h)
              }
              multiply(t) {
                a(t);
                let n, i, o = t;
                const {
                  endo: s
                } = e;
                if (s) {
                  const {
                    k1neg: t,
                    k1: e,
                    k2neg: a,
                    k2: u
                  } = s.splitScalar(o);
                  let {
                    p: c,
                    f: f
                  } = this.wNAF(e), {
                    p: h,
                    f: p
                  } = this.wNAF(u);
                  c = d.constTimeNegate(t, c), h = d.constTimeNegate(a, h), h = new l(r.mul(h.px, s.beta), h.py, h.pz), n = c.add(h), i = f.add(p)
                } else {
                  const {
                    p: t,
                    f: e
                  } = this.wNAF(o);
                  n = t, i = e
                }
                return l.normalizeZ([n, i])[0]
              }
              multiplyAndAddUnsafe(t, e, r) {
                const n = l.BASE,
                  i = (t, e) => e !== kk && e !== xk && t.equals(n) ? t.multiply(e) : t.multiplyUnsafe(e),
                  o = i(this, e).add(i(t, r));
                return o.is0() ? void 0 : o
              }
              toAffine(t) {
                const {
                  px: e,
                  py: n,
                  pz: i
                } = this, o = this.is0();
                null == t && (t = o ? r.ONE : r.inv(i));
                const s = r.mul(e, t),
                  a = r.mul(n, t),
                  u = r.mul(i, t);
                if (o) return {
                  x: r.ZERO,
                  y: r.ZERO
                };
                if (!r.eql(u, r.ONE)) throw Error("invZ was invalid");
                return {
                  x: s,
                  y: a
                }
              }
              isTorsionFree() {
                const {
                  h: t,
                  isTorsionFree: r
                } = e;
                if (t === xk) return !0;
                if (r) return r(l, this);
                throw Error("isTorsionFree() has not been declared for the elliptic curve")
              }
              clearCofactor() {
                const {
                  h: t,
                  clearCofactor: r
                } = e;
                return t === xk ? this : r ? r(l, this) : this.multiplyUnsafe(e.h)
              }
              toRawBytes(t = !0) {
                return this.assertValidity(), n(l, this, t)
              }
              toHex(t = !0) {
                return FP(this.toRawBytes(t))
              }
            }
            l.BASE = new l(e.Gx, e.Gy, r.ONE), l.ZERO = new l(r.ZERO, r.ONE, r.ZERO);
            const h = e.nBitLength,
              d = function(t, e) {
                const r = (t, e) => {
                    const r = e.negate();
                    return t ? r : e
                  },
                  n = t => ({
                    windows: Math.ceil(e / t) + 1,
                    windowSize: 2 ** (t - 1)
                  });
                return {
                  constTimeNegate: r,
                  unsafeLadder(e, r) {
                    let n = t.ZERO,
                      i = e;
                    for (; r > vk;) r & wk && (n = n.add(i)), i = i.double(), r >>= wk;
                    return n
                  },
                  precomputeWindow(t, e) {
                    const {
                      windows: r,
                      windowSize: i
                    } = n(e), o = [];
                    let s = t,
                      a = s;
                    for (let t = 0; r > t; t++) {
                      a = s, o.push(a);
                      for (let t = 1; i > t; t++) a = a.add(s), o.push(a);
                      s = a.double()
                    }
                    return o
                  },
                  wNAF(e, i, o) {
                    const {
                      windows: s,
                      windowSize: a
                    } = n(e);
                    let u = t.ZERO,
                      c = t.BASE;
                    const f = BigInt(2 ** e - 1),
                      l = 2 ** e,
                      h = BigInt(e);
                    for (let t = 0; s > t; t++) {
                      const e = t * a;
                      let n = +(o & f);
                      o >>= h, n > a && (n -= l, o += wk);
                      const s = e,
                        d = e + Math.abs(n) - 1,
                        p = t % 2 != 0,
                        b = 0 > n;
                      0 === n ? c = c.add(r(p, i[s])) : u = u.add(r(b, i[d]))
                    }
                    return {
                      p: u,
                      f: c
                    }
                  },
                  wNAFCached(t, e, r, n) {
                    const i = t.Gt || 1;
                    let o = e.get(t);
                    return o || (o = this.precomputeWindow(t, i), 1 !== i && e.set(t, n(o))), this.wNAF(i, o, r)
                  }
                }
              }(l, e.endo ? Math.ceil(h / 2) : h);
            return {
              CURVE: e,
              ProjectivePoint: l,
              normPrivateKeyToScalar: u,
              weierstrassEquation: o,
              isWithinCurveOrder: s
            }
          }({
            ...e,
            toBytes(t, e, n) {
              const i = e.toAffine(),
                o = r.toBytes(i.x),
                s = YP;
              return n ? s(Uint8Array.from([e.hasEvenY() ? 2 : 3]), o) : s(Uint8Array.from([4]), o, r.toBytes(i.y))
            },
            fromBytes(t) {
              const e = t.length,
                n = t[0],
                s = t.subarray(1);
              if (e !== i || 2 !== n && 3 !== n) {
                if (e === o && 4 === n) return {
                  x: r.fromBytes(s.subarray(0, r.BYTES)),
                  y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES))
                };
                throw Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)
              } {
                const t = KP(s);
                if (! function(t) {
                    return t > kk && t < r.ORDER
                  }(t)) throw Error("Point is not on curve");
                const e = f(t);
                let i;
                try {
                  i = r.sqrt(e)
                } catch (t) {
                  const e = t instanceof Error ? ": " + t.message : "";
                  throw Error("Point is not on curve" + e)
                }
                return !(1 & ~n) != ((i & xk) === xk) && (i = r.neg(i)), {
                  x: t,
                  y: i
                }
              }
            }
          }), h = t => FP(ZP(t, e.nByteLength));

          function d(t) {
            return t > n >> xk
          }
          const p = (t, e, r) => KP(t.slice(e, r));
          class b {
            constructor(t, e, r) {
              this.r = t, this.s = e, this.recovery = r, this.assertValidity()
            }
            static fromCompact(t) {
              const r = e.nByteLength;
              return t = JP("compactSignature", t, 2 * r), new b(p(t, 0, r), p(t, r, 2 * r))
            }
            static fromDER(t) {
              const {
                r: e,
                s: r
              } = Pk.toSig(JP("DER", t));
              return new b(e, r)
            }
            assertValidity() {
              if (!l(this.r)) throw Error("r must be 0 < r < CURVE.n");
              if (!l(this.s)) throw Error("s must be 0 < s < CURVE.n")
            }
            addRecoveryBit(t) {
              return new b(this.r, this.s, t)
            }
            recoverPublicKey(t) {
              const {
                r: n,
                s: i,
                recovery: o
              } = this, c = v(JP("msgHash", t));
              if (null == o || ![0, 1, 2, 3].includes(o)) throw Error("recovery id invalid");
              const f = 2 === o || 3 === o ? n + e.n : n;
              if (f >= r.ORDER) throw Error("recovery id 2 or 3 invalid");
              const l = 1 & o ? "03" : "02",
                d = u.fromHex(l + h(f)),
                p = a(f),
                b = s(-c * p),
                m = s(i * p),
                y = u.BASE.multiplyAndAddUnsafe(d, b, m);
              if (!y) throw Error("point at infinify");
              return y.assertValidity(), y
            }
            hasHighS() {
              return d(this.s)
            }
            normalizeS() {
              return this.hasHighS() ? new b(this.r, s(-this.s), this.recovery) : this
            }
            toDERRawBytes() {
              return GP(this.toDERHex())
            }
            toDERHex() {
              return Pk.hexFromSig({
                r: this.r,
                s: this.s
              })
            }
            toCompactRawBytes() {
              return GP(this.toCompactHex())
            }
            toCompactHex() {
              return h(this.r) + h(this.s)
            }
          }
          const m = {
            isValidPrivateKey(t) {
              try {
                return c(t), !0
              } catch {
                return !1
              }
            },
            normPrivateKeyToScalar: c,
            randomPrivateKey: () => {
              const t = gk(e.n);
              return function(t, e, r = !1) {
                const n = t.length,
                  i = yk(e),
                  o = gk(e);
                if (16 > n || o > n || n > 1024) throw Error(`expected ${o}-1024 bytes of input, got ${n}`);
                const s = lk(r ? KP(t) : VP(t), e - ok) + ok;
                return r ? qP(s, i) : ZP(s, i)
              }(e.randomBytes(t), e.n)
            },
            precompute: (t = 8, e = u.BASE) => (e.zt(t), e.multiply(BigInt(3)), e)
          };

          function y(t) {
            const e = DP(t),
              r = "string" == typeof t,
              n = (e || r) && t.length;
            return e ? n === i || n === o : r ? n === 2 * i || n === 2 * o : t instanceof u
          }
          const g = e.bits2int || function(t) {
              const r = KP(t),
                n = 8 * t.length - e.nBitLength;
              return n > 0 ? r >> BigInt(n) : r
            },
            v = e.bits2int_modN || function(t) {
              return s(g(t))
            },
            w = QP(e.nBitLength);

          function A(t) {
            if ("bigint" != typeof t) throw Error("bigint expected");
            if (kk > t || t >= w) throw Error("bigint expected < 2^" + e.nBitLength);
            return ZP(t, e.nByteLength)
          }
          const T = {
              lowS: e.lowS,
              prehash: !1
            },
            E = {
              lowS: e.lowS,
              prehash: !1
            };
          return u.BASE.zt(8), {
            CURVE: e,
            getPublicKey: function(t, e = !0) {
              return u.fromPrivateKey(t).toRawBytes(e)
            },
            getSharedSecret: function(t, e, r = !0) {
              if (y(t)) throw Error("first arg must be private key");
              if (!y(e)) throw Error("second arg must be public key");
              return u.fromHex(e).multiply(c(t)).toRawBytes(r)
            },
            sign: function(t, n, i = T) {
              const {
                seed: o,
                k2sig: f
              } = function(t, n, i = T) {
                if (["recovered", "canonical"].some(t => t in i)) throw Error("sign() legacy options not supported");
                const {
                  hash: o,
                  randomBytes: f
                } = e;
                let {
                  lowS: h,
                  prehash: p,
                  extraEntropy: m
                } = i;
                null == h && (h = !0), t = JP("msgHash", t), p && (t = JP("prehashed msgHash", o(t)));
                const y = v(t),
                  w = c(n),
                  E = [A(w), A(y)];
                if (null != m && !1 !== m) {
                  const t = !0 === m ? f(r.BYTES) : m;
                  E.push(JP("extraEntropy", t))
                }
                const P = YP(...E),
                  k = y;
                return {
                  seed: P,
                  k2sig: function(t) {
                    const e = g(t);
                    if (!l(e)) return;
                    const r = a(e),
                      n = u.BASE.multiply(e).toAffine(),
                      i = s(n.x);
                    if (i === kk) return;
                    const o = s(r * s(k + i * w));
                    if (o === kk) return;
                    let c = (n.x === i ? 0 : 2) | +(n.y & xk),
                      f = o;
                    return h && d(o) && (f = function(t) {
                      return d(t) ? s(-t) : t
                    }(o), c ^= 1), new b(i, f, c)
                  }
                }
              }(t, n, i), h = e;
              return ek(h.hash.outputLen, h.nByteLength, h.hmac)(o, f)
            },
            verify: function(t, r, n, i = E) {
              const o = t;
              if (r = JP("msgHash", r), n = JP("publicKey", n), "strict" in i) throw Error("options.strict was renamed to lowS");
              const {
                lowS: c,
                prehash: f
              } = i;
              let l, h;
              try {
                if ("string" == typeof o || DP(o)) try {
                  l = b.fromDER(o)
                } catch (t) {
                  if (!(t instanceof Pk.Err)) throw t;
                  l = b.fromCompact(o)
                } else {
                  if ("object" != typeof o || "bigint" != typeof o.r || "bigint" != typeof o.s) throw Error("PARSE");
                  {
                    const {
                      r: t,
                      s: e
                    } = o;
                    l = new b(t, e)
                  }
                }
                h = u.fromHex(n)
              } catch (t) {
                if ("PARSE" === t.message) throw Error("signature must be Signature instance, Uint8Array or hex string");
                return !1
              }
              if (c && l.hasHighS()) return !1;
              f && (r = e.hash(r));
              const {
                r: d,
                s: p
              } = l, m = v(r), y = a(p), g = s(m * y), w = s(d * y), A = u.BASE.multiplyAndAddUnsafe(h, g, w)?.toAffine();
              return !!A && s(A.x) === d
            },
            ProjectivePoint: u,
            Signature: b,
            utils: m
          }
        }({
          ...t,
          ...Sk(e)
        });
        return Object.freeze({
          ...r(e),
          create: r
        })
      }({
        a: BigInt(0),
        b: BigInt(7),
        Fp: Rk,
        n: Bk,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: t => {
            const e = Bk,
              r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
              n = -Wk * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
              i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
              o = r,
              s = BigInt("0x100000000000000000000000000000000"),
              a = Ck(o * t, e),
              u = Ck(-n * t, e);
            let c = lk(t - a * r - u * i, e),
              f = lk(-a * n - u * o, e);
            const l = c > s,
              h = f > s;
            if (l && (c = e - c), h && (f = e - f), c > s || f > s) throw Error("splitScalar: Endomorphism failed, k=" + t);
            return {
              k1neg: l,
              k1: c,
              k2neg: h,
              k2: f
            }
          }
        }
      }, kP);
    var jk;
    BigInt(0), Nk.ProjectivePoint;
    const _k = null !== (jk = Nk) && void 0 !== jk ? jk : s,
      Dk = BigInt("0xffffffffffffffff"),
      Uk = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
      Lk = _k.CURVE.n / BigInt(2),
      Fk = {
        type: "object",
        required: ["crypto", "id", "version", "address"],
        properties: {
          crypto: {
            type: "object",
            required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
            properties: {
              cipher: {
                type: "string"
              },
              ciphertext: {
                type: "string"
              },
              cipherparams: {
                type: "object"
              },
              kdf: {
                type: "string"
              },
              kdfparams: {
                type: "object"
              },
              salt: {
                type: "string"
              },
              mac: {
                type: "string"
              }
            }
          },
          id: {
            type: "string"
          },
          version: {
            type: "number"
          },
          address: {
            type: "string"
          }
        }
      };
    var $k, zk, Hk, Gk, Kk, Vk;
    ! function(t) {
      t[t.Mainnet = 1] = "Mainnet", t[t.Goerli = 5] = "Goerli", t[t.Sepolia = 11155111] = "Sepolia"
    }($k || ($k = {})),
    function(t) {
      t.Chainstart = "chainstart", t.Homestead = "homestead", t.Dao = "dao", t.TangerineWhistle = "tangerineWhistle", t.SpuriousDragon = "spuriousDragon", t.Byzantium = "byzantium", t.Constantinople = "constantinople", t.Petersburg = "petersburg", t.Istanbul = "istanbul", t.MuirGlacier = "muirGlacier", t.Berlin = "berlin", t.London = "london", t.ArrowGlacier = "arrowGlacier", t.GrayGlacier = "grayGlacier", t.MergeForkIdTransition = "mergeForkIdTransition", t.Merge = "merge", t.Shanghai = "shanghai", t.ShardingForkDev = "shardingFork"
    }(zk || (zk = {})),
    function(t) {
      t.ProofOfStake = "pos", t.ProofOfWork = "pow", t.ProofOfAuthority = "poa"
    }(Hk || (Hk = {})),
    function(t) {
      t.Ethash = "ethash", t.Clique = "clique", t.Casper = "casper"
    }(Gk || (Gk = {})),
    function(t) {
      t.PolygonMainnet = "polygon-mainnet", t.PolygonMumbai = "polygon-mumbai", t.ArbitrumRinkebyTestnet = "arbitrum-rinkeby-testnet", t.ArbitrumOne = "arbitrum-one", t.xDaiChain = "x-dai-chain", t.OptimisticKovan = "optimistic-kovan", t.OptimisticEthereum = "optimistic-ethereum"
    }(Kk || (Kk = {})),
    function(t) {
      t[t.Number = 0] = "Number", t[t.BigInt = 1] = "BigInt", t[t.Uint8Array = 2] = "Uint8Array", t[t.PrefixedHexString = 3] = "PrefixedHexString"
    }(Vk || (Vk = {}));
    const Zk = t => {
        if ("string" != typeof t) throw Error("[stripHexPrefix] input must be type 'string', received " + typeof t);
        return nA(t) ? t.slice(2) : t
      },
      qk = function(t) {
        if (!Number.isSafeInteger(t) || 0 > t) throw Error("Received an invalid integer type: " + t);
        return "0x" + t.toString(16)
      };

    function Jk(t) {
      let e = t;
      if ("string" != typeof e) throw Error("[padToEven] value must be type 'string', received " + typeof e);
      return e.length % 2 && (e = "0" + e), e
    }
    const Yk = function(t) {
      var e;
      if (null == t) return new Uint8Array;
      if (t instanceof Uint8Array) return t;
      if ("Uint8Array" === (null === (e = t?.constructor) || void 0 === e ? void 0 : e.name) || Array.isArray(t)) return Uint8Array.from(t);
      if ("string" == typeof t) {
        if (!eA(t)) throw Error("Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: " + t);
        return JA(Jk(Zk(t)))
      }
      if ("number" == typeof t) return Yk(XA(t));
      if ("bigint" == typeof t) {
        if (t < BigInt(0)) throw Error("Cannot convert negative bigint to Uint8Array. Given: " + t);
        let e = t.toString(16);
        return e.length % 2 && (e = "0" + e), Yk("0x" + e)
      }
      if (t.toArray) return Uint8Array.from(t.toArray());
      throw Error("invalid type")
    };

    function Qk(t) {
      const e = qA(t);
      return BigInt("0x" === e ? 0 : e)
    }
    const Xk = function(t) {
      return new Uint8Array(t).fill(0)
    };

    function tx(t) {
      if (!$A(t)) throw Error("This method only supports Uint8Array but input was: " + t)
    }
    const ex = function(t, e) {
        return tx(t),
          function(t, e) {
            const r = Xk(e);
            return t.length < e ? (r.set(t, e - t.length), r) : t.subarray(-e)
          }(t, e)
      },
      rx = function(t) {
        return tx(t),
          function(t) {
            let e = t[0];
            for (; t.length > 0 && "0" === e.toString();) e = (t = t.slice(1))[0];
            return t
          }(t)
      },
      nx = t => "0x" + t.toString(16);

    function ix(t) {
      return rx(function(t) {
        return Yk("0x" + t.toString(16))
      }(t))
    }
    const ox = function(t, e, r, n, i) {
      const o = function(t, e) {
        return t === BigInt(0) || t === BigInt(1) ? t : void 0 === e ? t - BigInt(27) : t - (e * BigInt(2) + BigInt(35))
      }(e, i);
      if (! function(t) {
          return t === BigInt(0) || t === BigInt(1)
        }(o)) throw Error("Invalid signature v value");
      return new _k.Signature(Qk(r), Qk(n)).addRecoveryBit(+o).recoverPublicKey(t).toRawBytes(!1).slice(1)
    };

    function sx(t, e) {
      if (null === t) return null;
      if (void 0 === t) return;
      if ("string" == typeof t && !eA(t)) throw Error("A string must be provided with a 0x-prefix, given: " + t);
      if ("number" == typeof t && !Number.isSafeInteger(t)) throw Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
      const r = Yk(t);
      switch (e) {
        case Vk.Uint8Array:
          return r;
        case Vk.BigInt:
          return Qk(r);
        case Vk.Number: {
          const t = Qk(r);
          if (t > BigInt(Number.MAX_SAFE_INTEGER)) throw Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
          return +t
        }
        case Vk.PrefixedHexString:
          return qA(r);
        default:
          throw Error("unknown outputType")
      }
    }
    var ax = i(66289),
      ux = i(52566);
    const cx = {
        name: "goerli",
        chainId: 5,
        networkId: 5,
        defaultHardfork: "merge",
        consensus: {
          type: "poa",
          algorithm: "clique",
          clique: {
            period: 15,
            epoch: 3e4
          }
        },
        comment: "Cross-client PoA test network",
        url: "https://github.com/goerli/testnet",
        genesis: {
          timestamp: "0x5c51a607",
          gasLimit: 10485760,
          difficulty: 1,
          nonce: "0x0000000000000000",
          extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
        },
        hardforks: [{
          name: "chainstart",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "homestead",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "byzantium",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "constantinople",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "petersburg",
          block: 0,
          forkHash: "0xa3f5ab08"
        }, {
          name: "istanbul",
          block: 1561651,
          forkHash: "0xc25efa5c"
        }, {
          name: "berlin",
          block: 4460644,
          forkHash: "0x757a1c47"
        }, {
          name: "london",
          block: 5062605,
          forkHash: "0xb8c6299d"
        }, {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
          name: "merge",
          ttd: "10790000",
          block: 7382819,
          forkHash: "0xb8c6299d"
        }, {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        }, {
          name: "shanghai",
          block: null,
          forkHash: null
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]
      },
      fx = {
        name: "mainnet",
        chainId: 1,
        networkId: 1,
        defaultHardfork: "merge",
        consensus: {
          type: "pow",
          algorithm: "ethash",
          ethash: {}
        },
        comment: "The Ethereum main chain",
        url: "https://ethstats.net/",
        genesis: {
          gasLimit: 5e3,
          difficulty: 17179869184,
          nonce: "0x0000000000000042",
          extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
        },
        hardforks: [{
          name: "chainstart",
          block: 0,
          forkHash: "0xfc64ec04"
        }, {
          name: "homestead",
          block: 115e4,
          forkHash: "0x97c2c34c"
        }, {
          name: "dao",
          block: 192e4,
          forkHash: "0x91d1f948"
        }, {
          name: "tangerineWhistle",
          block: 2463e3,
          forkHash: "0x7a64da13"
        }, {
          name: "spuriousDragon",
          block: 2675e3,
          forkHash: "0x3edd5b10"
        }, {
          name: "byzantium",
          block: 437e4,
          forkHash: "0xa00bc324"
        }, {
          name: "constantinople",
          block: 728e4,
          forkHash: "0x668db0af"
        }, {
          name: "petersburg",
          block: 728e4,
          forkHash: "0x668db0af"
        }, {
          name: "istanbul",
          block: 9069e3,
          forkHash: "0x879d6e30"
        }, {
          name: "muirGlacier",
          block: 92e5,
          forkHash: "0xe029e991"
        }, {
          name: "berlin",
          block: 12244e3,
          forkHash: "0x0eb440f6"
        }, {
          name: "london",
          block: 12965e3,
          forkHash: "0xb715077d"
        }, {
          name: "arrowGlacier",
          block: 13773e3,
          forkHash: "0x20c327fc"
        }, {
          name: "grayGlacier",
          block: 1505e4,
          forkHash: "0xf0afd0e3"
        }, {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
          name: "merge",
          ttd: "58750000000000000000000",
          block: 15537394,
          forkHash: "0xf0afd0e3"
        }, {
          name: "mergeForkIdTransition",
          block: null,
          forkHash: null
        }, {
          name: "shanghai",
          block: null,
          forkHash: null
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]
      },
      lx = {
        name: "sepolia",
        chainId: 11155111,
        networkId: 11155111,
        defaultHardfork: "merge",
        consensus: {
          type: "pow",
          algorithm: "ethash",
          ethash: {}
        },
        comment: "PoW test network to replace Ropsten",
        url: "https://github.com/ethereum/go-ethereum/pull/23730",
        genesis: {
          timestamp: "0x6159af19",
          gasLimit: 3e7,
          difficulty: 131072,
          nonce: "0x0000000000000000",
          extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
        },
        hardforks: [{
          name: "chainstart",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "homestead",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "tangerineWhistle",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "spuriousDragon",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "byzantium",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "constantinople",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "petersburg",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "istanbul",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "muirGlacier",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "berlin",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          name: "london",
          block: 0,
          forkHash: "0xfe3366e7"
        }, {
          "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
          name: "merge",
          ttd: "17000000000000000",
          block: 1450409,
          forkHash: "0xfe3366e7"
        }, {
          name: "mergeForkIdTransition",
          block: 1735371,
          forkHash: "0xb96cbd13"
        }, {
          name: "shanghai",
          block: null,
          timestamp: "1677557088",
          forkHash: "0xf7f9bc08"
        }],
        bootstrapNodes: [],
        dnsNetworks: ["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]
      },
      hx = {
        1153: {
          name: "EIP-1153",
          number: 1153,
          comment: "Transient Storage",
          url: "https://eips.ethereum.org/EIPS/eip-1153",
          status: "Review",
          minimumHardfork: "chainstart",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {
            tstore: {
              v: 100,
              d: "Base fee of the TSTORE opcode"
            },
            tload: {
              v: 100,
              d: "Base fee of the TLOAD opcode"
            }
          },
          vm: {},
          pow: {}
        },
        1559: {
          name: "EIP-1559",
          number: 1559,
          comment: "Fee market change for ETH 1.0 chain",
          url: "https://eips.ethereum.org/EIPS/eip-1559",
          status: "Final",
          minimumHardfork: "berlin",
          requiredEIPs: [2930],
          gasConfig: {
            baseFeeMaxChangeDenominator: {
              v: 8,
              d: "Maximum base fee change denominator"
            },
            elasticityMultiplier: {
              v: 2,
              d: "Maximum block gas target elasticity"
            },
            initialBaseFee: {
              v: 1e9,
              d: "Initial base fee on first EIP1559 block"
            }
          },
          gasPrices: {},
          vm: {},
          pow: {}
        },
        2315: {
          name: "EIP-2315",
          number: 2315,
          comment: "Simple subroutines for the EVM",
          url: "https://eips.ethereum.org/EIPS/eip-2315",
          status: "Draft",
          minimumHardfork: "istanbul",
          gasConfig: {},
          gasPrices: {
            beginsub: {
              v: 2,
              d: "Base fee of the BEGINSUB opcode"
            },
            returnsub: {
              v: 5,
              d: "Base fee of the RETURNSUB opcode"
            },
            jumpsub: {
              v: 10,
              d: "Base fee of the JUMPSUB opcode"
            }
          },
          vm: {},
          pow: {}
        },
        2537: {
          name: "EIP-2537",
          number: 2537,
          comment: "BLS12-381 precompiles",
          url: "https://eips.ethereum.org/EIPS/eip-2537",
          status: "Draft",
          minimumHardfork: "chainstart",
          gasConfig: {},
          gasPrices: {
            Bls12381G1AddGas: {
              v: 600,
              d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
            },
            Bls12381G1MulGas: {
              v: 12e3,
              d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
            },
            Bls12381G2AddGas: {
              v: 4500,
              d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
            },
            Bls12381G2MulGas: {
              v: 55e3,
              d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
            },
            Bls12381PairingBaseGas: {
              v: 115e3,
              d: "Base gas cost of BLS12-381 pairing check"
            },
            Bls12381PairingPerPairGas: {
              v: 23e3,
              d: "Per-pair gas cost of BLS12-381 pairing check"
            },
            Bls12381MapG1Gas: {
              v: 5500,
              d: "Gas cost of BLS12-381 map field element to G1"
            },
            Bls12381MapG2Gas: {
              v: 11e4,
              d: "Gas cost of BLS12-381 map field element to G2"
            },
            Bls12381MultiExpGasDiscount: {
              v: [
                [1, 1200],
                [2, 888],
                [3, 764],
                [4, 641],
                [5, 594],
                [6, 547],
                [7, 500],
                [8, 453],
                [9, 438],
                [10, 423],
                [11, 408],
                [12, 394],
                [13, 379],
                [14, 364],
                [15, 349],
                [16, 334],
                [17, 330],
                [18, 326],
                [19, 322],
                [20, 318],
                [21, 314],
                [22, 310],
                [23, 306],
                [24, 302],
                [25, 298],
                [26, 294],
                [27, 289],
                [28, 285],
                [29, 281],
                [30, 277],
                [31, 273],
                [32, 269],
                [33, 268],
                [34, 266],
                [35, 265],
                [36, 263],
                [37, 262],
                [38, 260],
                [39, 259],
                [40, 257],
                [41, 256],
                [42, 254],
                [43, 253],
                [44, 251],
                [45, 250],
                [46, 248],
                [47, 247],
                [48, 245],
                [49, 244],
                [50, 242],
                [51, 241],
                [52, 239],
                [53, 238],
                [54, 236],
                [55, 235],
                [56, 233],
                [57, 232],
                [58, 231],
                [59, 229],
                [60, 228],
                [61, 226],
                [62, 225],
                [63, 223],
                [64, 222],
                [65, 221],
                [66, 220],
                [67, 219],
                [68, 219],
                [69, 218],
                [70, 217],
                [71, 216],
                [72, 216],
                [73, 215],
                [74, 214],
                [75, 213],
                [76, 213],
                [77, 212],
                [78, 211],
                [79, 211],
                [80, 210],
                [81, 209],
                [82, 208],
                [83, 208],
                [84, 207],
                [85, 206],
                [86, 205],
                [87, 205],
                [88, 204],
                [89, 203],
                [90, 202],
                [91, 202],
                [92, 201],
                [93, 200],
                [94, 199],
                [95, 199],
                [96, 198],
                [97, 197],
                [98, 196],
                [99, 196],
                [100, 195],
                [101, 194],
                [102, 193],
                [103, 193],
                [104, 192],
                [105, 191],
                [106, 191],
                [107, 190],
                [108, 189],
                [109, 188],
                [110, 188],
                [111, 187],
                [112, 186],
                [113, 185],
                [114, 185],
                [115, 184],
                [116, 183],
                [117, 182],
                [118, 182],
                [119, 181],
                [120, 180],
                [121, 179],
                [122, 179],
                [123, 178],
                [124, 177],
                [125, 176],
                [126, 176],
                [127, 175],
                [128, 174]
              ],
              d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
            }
          },
          vm: {},
          pow: {}
        },
        2565: {
          name: "EIP-2565",
          number: 2565,
          comment: "ModExp gas cost",
          url: "https://eips.ethereum.org/EIPS/eip-2565",
          status: "Final",
          minimumHardfork: "byzantium",
          gasConfig: {},
          gasPrices: {
            modexpGquaddivisor: {
              v: 3,
              d: "Gquaddivisor from modexp precompile for gas calculation"
            }
          },
          vm: {},
          pow: {}
        },
        2718: {
          name: "EIP-2718",
          comment: "Typed Transaction Envelope",
          url: "https://eips.ethereum.org/EIPS/eip-2718",
          status: "Final",
          minimumHardfork: "chainstart",
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        2929: {
          name: "EIP-2929",
          comment: "Gas cost increases for state access opcodes",
          url: "https://eips.ethereum.org/EIPS/eip-2929",
          status: "Final",
          minimumHardfork: "chainstart",
          gasConfig: {},
          gasPrices: {
            coldsload: {
              v: 2100,
              d: "Gas cost of the first read of storage from a given location (per transaction)"
            },
            coldaccountaccess: {
              v: 2600,
              d: "Gas cost of the first read of a given address (per transaction)"
            },
            warmstorageread: {
              v: 100,
              d: "Gas cost of reading storage locations which have already loaded 'cold'"
            },
            sstoreCleanGasEIP2200: {
              v: 2900,
              d: "Once per SSTORE operation from clean non-zero to something else"
            },
            sstoreNoopGasEIP2200: {
              v: 100,
              d: "Once per SSTORE operation if the value doesn't change"
            },
            sstoreDirtyGasEIP2200: {
              v: 100,
              d: "Once per SSTORE operation if a dirty value is changed"
            },
            sstoreInitRefundEIP2200: {
              v: 19900,
              d: "Once per SSTORE operation for resetting to the original zero value"
            },
            sstoreCleanRefundEIP2200: {
              v: 4900,
              d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            call: {
              v: 0,
              d: "Base fee of the CALL opcode"
            },
            callcode: {
              v: 0,
              d: "Base fee of the CALLCODE opcode"
            },
            delegatecall: {
              v: 0,
              d: "Base fee of the DELEGATECALL opcode"
            },
            staticcall: {
              v: 0,
              d: "Base fee of the STATICCALL opcode"
            },
            balance: {
              v: 0,
              d: "Base fee of the BALANCE opcode"
            },
            extcodesize: {
              v: 0,
              d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
              v: 0,
              d: "Base fee of the EXTCODECOPY opcode"
            },
            extcodehash: {
              v: 0,
              d: "Base fee of the EXTCODEHASH opcode"
            },
            sload: {
              v: 0,
              d: "Base fee of the SLOAD opcode"
            },
            sstore: {
              v: 0,
              d: "Base fee of the SSTORE opcode"
            }
          },
          vm: {},
          pow: {}
        },
        2930: {
          name: "EIP-2930",
          comment: "Optional access lists",
          url: "https://eips.ethereum.org/EIPS/eip-2930",
          status: "Final",
          minimumHardfork: "istanbul",
          requiredEIPs: [2718, 2929],
          gasConfig: {},
          gasPrices: {
            accessListStorageKeyCost: {
              v: 1900,
              d: "Gas cost per storage key in an Access List transaction"
            },
            accessListAddressCost: {
              v: 2400,
              d: "Gas cost per storage key in an Access List transaction"
            }
          },
          vm: {},
          pow: {}
        },
        3198: {
          name: "EIP-3198",
          number: 3198,
          comment: "BASEFEE opcode",
          url: "https://eips.ethereum.org/EIPS/eip-3198",
          status: "Final",
          minimumHardfork: "london",
          gasConfig: {},
          gasPrices: {
            basefee: {
              v: 2,
              d: "Gas cost of the BASEFEE opcode"
            }
          },
          vm: {},
          pow: {}
        },
        3529: {
          name: "EIP-3529",
          comment: "Reduction in refunds",
          url: "https://eips.ethereum.org/EIPS/eip-3529",
          status: "Final",
          minimumHardfork: "berlin",
          requiredEIPs: [2929],
          gasConfig: {
            maxRefundQuotient: {
              v: 5,
              d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
            }
          },
          gasPrices: {
            selfdestructRefund: {
              v: 0,
              d: "Refunded following a selfdestruct operation"
            },
            sstoreClearRefundEIP2200: {
              v: 4800,
              d: "Once per SSTORE operation for clearing an originally existing storage slot"
            }
          },
          vm: {},
          pow: {}
        },
        3540: {
          name: "EIP-3540",
          number: 3540,
          comment: "EVM Object Format (EOF) v1",
          url: "https://eips.ethereum.org/EIPS/eip-3540",
          status: "Review",
          minimumHardfork: "london",
          requiredEIPs: [3541],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3541: {
          name: "EIP-3541",
          comment: "Reject new contracts starting with the 0xEF byte",
          url: "https://eips.ethereum.org/EIPS/eip-3541",
          status: "Final",
          minimumHardfork: "berlin",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3554: {
          name: "EIP-3554",
          comment: "Reduction in refunds",
          url: "Difficulty Bomb Delay to December 1st 2021",
          status: "Final",
          minimumHardfork: "muirGlacier",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {
            difficultyBombDelay: {
              v: 95e5,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        3607: {
          name: "EIP-3607",
          number: 3607,
          comment: "Reject transactions from senders with deployed code",
          url: "https://eips.ethereum.org/EIPS/eip-3607",
          status: "Final",
          minimumHardfork: "chainstart",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3651: {
          name: "EIP-3651",
          number: 3198,
          comment: "Warm COINBASE",
          url: "https://eips.ethereum.org/EIPS/eip-3651",
          status: "Review",
          minimumHardfork: "london",
          requiredEIPs: [2929],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3670: {
          name: "EIP-3670",
          number: 3670,
          comment: "EOF - Code Validation",
          url: "https://eips.ethereum.org/EIPS/eip-3670",
          status: "Review",
          minimumHardfork: "london",
          requiredEIPs: [3540],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3675: {
          name: "EIP-3675",
          number: 3675,
          comment: "Upgrade consensus to Proof-of-Stake",
          url: "https://eips.ethereum.org/EIPS/eip-3675",
          status: "Final",
          minimumHardfork: "london",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        3855: {
          name: "EIP-3855",
          number: 3855,
          comment: "PUSH0 instruction",
          url: "https://eips.ethereum.org/EIPS/eip-3855",
          status: "Review",
          minimumHardfork: "chainstart",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {
            push0: {
              v: 2,
              d: "Base fee of the PUSH0 opcode"
            }
          },
          vm: {},
          pow: {}
        },
        3860: {
          name: "EIP-3860",
          number: 3860,
          comment: "Limit and meter initcode",
          url: "https://eips.ethereum.org/EIPS/eip-3860",
          status: "Review",
          minimumHardfork: "spuriousDragon",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {
            initCodeWordCost: {
              v: 2,
              d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
            }
          },
          vm: {
            maxInitCodeSize: {
              v: 49152,
              d: "Maximum length of initialization code when creating a contract"
            }
          },
          pow: {}
        },
        4345: {
          name: "EIP-4345",
          number: 4345,
          comment: "Difficulty Bomb Delay to June 2022",
          url: "https://eips.ethereum.org/EIPS/eip-4345",
          status: "Final",
          minimumHardfork: "london",
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {
            difficultyBombDelay: {
              v: 107e5,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        4399: {
          name: "EIP-4399",
          number: 4399,
          comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
          url: "https://eips.ethereum.org/EIPS/eip-4399",
          status: "Review",
          minimumHardfork: "london",
          requiredEIPs: [],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        5133: {
          name: "EIP-5133",
          number: 5133,
          comment: "Delaying Difficulty Bomb to mid-September 2022",
          url: "https://eips.ethereum.org/EIPS/eip-5133",
          status: "Draft",
          minimumHardfork: "grayGlacier",
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {
            difficultyBombDelay: {
              v: 114e5,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        }
      },
      dx = {
        chainstart: {
          name: "chainstart",
          comment: "Start of the Ethereum main chain",
          url: "",
          status: "",
          gasConfig: {
            minGasLimit: {
              v: 5e3,
              d: "Minimum the gas limit may ever be"
            },
            gasLimitBoundDivisor: {
              v: 1024,
              d: "The bound divisor of the gas limit, used in update calculations"
            },
            maxRefundQuotient: {
              v: 2,
              d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
            }
          },
          gasPrices: {
            base: {
              v: 2,
              d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
            },
            tierStep: {
              v: [0, 2, 3, 5, 8, 10, 20],
              d: "Once per operation, for a selection of them"
            },
            exp: {
              v: 10,
              d: "Base fee of the EXP opcode"
            },
            expByte: {
              v: 10,
              d: "Times ceil(log256(exponent)) for the EXP instruction"
            },
            sha3: {
              v: 30,
              d: "Base fee of the SHA3 opcode"
            },
            sha3Word: {
              v: 6,
              d: "Once per word of the SHA3 operation's data"
            },
            sload: {
              v: 50,
              d: "Base fee of the SLOAD opcode"
            },
            sstoreSet: {
              v: 2e4,
              d: "Once per SSTORE operation if the zeroness changes from zero"
            },
            sstoreReset: {
              v: 5e3,
              d: "Once per SSTORE operation if the zeroness does not change from zero"
            },
            sstoreRefund: {
              v: 15e3,
              d: "Once per SSTORE operation if the zeroness changes to zero"
            },
            jumpdest: {
              v: 1,
              d: "Base fee of the JUMPDEST opcode"
            },
            log: {
              v: 375,
              d: "Base fee of the LOG opcode"
            },
            logData: {
              v: 8,
              d: "Per byte in a LOG* operation's data"
            },
            logTopic: {
              v: 375,
              d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
            },
            create: {
              v: 32e3,
              d: "Base fee of the CREATE opcode"
            },
            call: {
              v: 40,
              d: "Base fee of the CALL opcode"
            },
            callStipend: {
              v: 2300,
              d: "Free gas given at beginning of call"
            },
            callValueTransfer: {
              v: 9e3,
              d: "Paid for CALL when the value transfor is non-zero"
            },
            callNewAccount: {
              v: 25e3,
              d: "Paid for CALL when the destination address didn't exist prior"
            },
            selfdestructRefund: {
              v: 24e3,
              d: "Refunded following a selfdestruct operation"
            },
            memory: {
              v: 3,
              d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
            },
            quadCoeffDiv: {
              v: 512,
              d: "Divisor for the quadratic particle of the memory cost equation"
            },
            createData: {
              v: 200,
              d: ""
            },
            tx: {
              v: 21e3,
              d: "Per transaction. NOTE: Not payable on data of calls between transactions"
            },
            txCreation: {
              v: 32e3,
              d: "The cost of creating a contract via tx"
            },
            txDataZero: {
              v: 4,
              d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
            },
            txDataNonZero: {
              v: 68,
              d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
            },
            copy: {
              v: 3,
              d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
            },
            ecRecover: {
              v: 3e3,
              d: ""
            },
            sha256: {
              v: 60,
              d: ""
            },
            sha256Word: {
              v: 12,
              d: ""
            },
            ripemd160: {
              v: 600,
              d: ""
            },
            ripemd160Word: {
              v: 120,
              d: ""
            },
            identity: {
              v: 15,
              d: ""
            },
            identityWord: {
              v: 3,
              d: ""
            },
            stop: {
              v: 0,
              d: "Base fee of the STOP opcode"
            },
            add: {
              v: 3,
              d: "Base fee of the ADD opcode"
            },
            mul: {
              v: 5,
              d: "Base fee of the MUL opcode"
            },
            sub: {
              v: 3,
              d: "Base fee of the SUB opcode"
            },
            div: {
              v: 5,
              d: "Base fee of the DIV opcode"
            },
            sdiv: {
              v: 5,
              d: "Base fee of the SDIV opcode"
            },
            mod: {
              v: 5,
              d: "Base fee of the MOD opcode"
            },
            smod: {
              v: 5,
              d: "Base fee of the SMOD opcode"
            },
            addmod: {
              v: 8,
              d: "Base fee of the ADDMOD opcode"
            },
            mulmod: {
              v: 8,
              d: "Base fee of the MULMOD opcode"
            },
            signextend: {
              v: 5,
              d: "Base fee of the SIGNEXTEND opcode"
            },
            lt: {
              v: 3,
              d: "Base fee of the LT opcode"
            },
            gt: {
              v: 3,
              d: "Base fee of the GT opcode"
            },
            slt: {
              v: 3,
              d: "Base fee of the SLT opcode"
            },
            sgt: {
              v: 3,
              d: "Base fee of the SGT opcode"
            },
            eq: {
              v: 3,
              d: "Base fee of the EQ opcode"
            },
            iszero: {
              v: 3,
              d: "Base fee of the ISZERO opcode"
            },
            and: {
              v: 3,
              d: "Base fee of the AND opcode"
            },
            or: {
              v: 3,
              d: "Base fee of the OR opcode"
            },
            xor: {
              v: 3,
              d: "Base fee of the XOR opcode"
            },
            not: {
              v: 3,
              d: "Base fee of the NOT opcode"
            },
            byte: {
              v: 3,
              d: "Base fee of the BYTE opcode"
            },
            address: {
              v: 2,
              d: "Base fee of the ADDRESS opcode"
            },
            balance: {
              v: 20,
              d: "Base fee of the BALANCE opcode"
            },
            origin: {
              v: 2,
              d: "Base fee of the ORIGIN opcode"
            },
            caller: {
              v: 2,
              d: "Base fee of the CALLER opcode"
            },
            callvalue: {
              v: 2,
              d: "Base fee of the CALLVALUE opcode"
            },
            calldataload: {
              v: 3,
              d: "Base fee of the CALLDATALOAD opcode"
            },
            calldatasize: {
              v: 2,
              d: "Base fee of the CALLDATASIZE opcode"
            },
            calldatacopy: {
              v: 3,
              d: "Base fee of the CALLDATACOPY opcode"
            },
            codesize: {
              v: 2,
              d: "Base fee of the CODESIZE opcode"
            },
            codecopy: {
              v: 3,
              d: "Base fee of the CODECOPY opcode"
            },
            gasprice: {
              v: 2,
              d: "Base fee of the GASPRICE opcode"
            },
            extcodesize: {
              v: 20,
              d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
              v: 20,
              d: "Base fee of the EXTCODECOPY opcode"
            },
            blockhash: {
              v: 20,
              d: "Base fee of the BLOCKHASH opcode"
            },
            coinbase: {
              v: 2,
              d: "Base fee of the COINBASE opcode"
            },
            timestamp: {
              v: 2,
              d: "Base fee of the TIMESTAMP opcode"
            },
            number: {
              v: 2,
              d: "Base fee of the NUMBER opcode"
            },
            difficulty: {
              v: 2,
              d: "Base fee of the DIFFICULTY opcode"
            },
            gaslimit: {
              v: 2,
              d: "Base fee of the GASLIMIT opcode"
            },
            pop: {
              v: 2,
              d: "Base fee of the POP opcode"
            },
            mload: {
              v: 3,
              d: "Base fee of the MLOAD opcode"
            },
            mstore: {
              v: 3,
              d: "Base fee of the MSTORE opcode"
            },
            mstore8: {
              v: 3,
              d: "Base fee of the MSTORE8 opcode"
            },
            sstore: {
              v: 0,
              d: "Base fee of the SSTORE opcode"
            },
            jump: {
              v: 8,
              d: "Base fee of the JUMP opcode"
            },
            jumpi: {
              v: 10,
              d: "Base fee of the JUMPI opcode"
            },
            pc: {
              v: 2,
              d: "Base fee of the PC opcode"
            },
            msize: {
              v: 2,
              d: "Base fee of the MSIZE opcode"
            },
            gas: {
              v: 2,
              d: "Base fee of the GAS opcode"
            },
            push: {
              v: 3,
              d: "Base fee of the PUSH opcode"
            },
            dup: {
              v: 3,
              d: "Base fee of the DUP opcode"
            },
            swap: {
              v: 3,
              d: "Base fee of the SWAP opcode"
            },
            callcode: {
              v: 40,
              d: "Base fee of the CALLCODE opcode"
            },
            return: {
              v: 0,
              d: "Base fee of the RETURN opcode"
            },
            invalid: {
              v: 0,
              d: "Base fee of the INVALID opcode"
            },
            selfdestruct: {
              v: 0,
              d: "Base fee of the SELFDESTRUCT opcode"
            }
          },
          vm: {
            stackLimit: {
              v: 1024,
              d: "Maximum size of VM stack allowed"
            },
            callCreateDepth: {
              v: 1024,
              d: "Maximum depth of call/create stack"
            },
            maxExtraDataSize: {
              v: 32,
              d: "Maximum size extra data may be after Genesis"
            }
          },
          pow: {
            minimumDifficulty: {
              v: 131072,
              d: "The minimum that the difficulty may ever be"
            },
            difficultyBoundDivisor: {
              v: 2048,
              d: "The bound divisor of the difficulty, used in the update calculations"
            },
            durationLimit: {
              v: 13,
              d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
            },
            epochDuration: {
              v: 3e4,
              d: "Duration between proof-of-work epochs"
            },
            timebombPeriod: {
              v: 1e5,
              d: "Exponential difficulty timebomb period"
            },
            minerReward: {
              v: "5000000000000000000",
              d: "the amount a miner get rewarded for mining a block"
            },
            difficultyBombDelay: {
              v: 0,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        homestead: {
          name: "homestead",
          comment: "Homestead hardfork with protocol and network changes",
          url: "https://eips.ethereum.org/EIPS/eip-606",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            delegatecall: {
              v: 40,
              d: "Base fee of the DELEGATECALL opcode"
            }
          },
          vm: {},
          pow: {}
        },
        dao: {
          name: "dao",
          comment: "DAO rescue hardfork",
          url: "https://eips.ethereum.org/EIPS/eip-779",
          status: "Final",
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        tangerineWhistle: {
          name: "tangerineWhistle",
          comment: "Hardfork with gas cost changes for IO-heavy operations",
          url: "https://eips.ethereum.org/EIPS/eip-608",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            sload: {
              v: 200,
              d: "Once per SLOAD operation"
            },
            call: {
              v: 700,
              d: "Once per CALL operation & message call transaction"
            },
            extcodesize: {
              v: 700,
              d: "Base fee of the EXTCODESIZE opcode"
            },
            extcodecopy: {
              v: 700,
              d: "Base fee of the EXTCODECOPY opcode"
            },
            balance: {
              v: 400,
              d: "Base fee of the BALANCE opcode"
            },
            delegatecall: {
              v: 700,
              d: "Base fee of the DELEGATECALL opcode"
            },
            callcode: {
              v: 700,
              d: "Base fee of the CALLCODE opcode"
            },
            selfdestruct: {
              v: 5e3,
              d: "Base fee of the SELFDESTRUCT opcode"
            }
          },
          vm: {},
          pow: {}
        },
        spuriousDragon: {
          name: "spuriousDragon",
          comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
          url: "https://eips.ethereum.org/EIPS/eip-607",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            expByte: {
              v: 50,
              d: "Times ceil(log256(exponent)) for the EXP instruction"
            }
          },
          vm: {
            maxCodeSize: {
              v: 24576,
              d: "Maximum length of contract code"
            }
          },
          pow: {}
        },
        byzantium: {
          name: "byzantium",
          comment: "Hardfork with new precompiles, instructions and other protocol changes",
          url: "https://eips.ethereum.org/EIPS/eip-609",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            modexpGquaddivisor: {
              v: 20,
              d: "Gquaddivisor from modexp precompile for gas calculation"
            },
            ecAdd: {
              v: 500,
              d: "Gas costs for curve addition precompile"
            },
            ecMul: {
              v: 4e4,
              d: "Gas costs for curve multiplication precompile"
            },
            ecPairing: {
              v: 1e5,
              d: "Base gas costs for curve pairing precompile"
            },
            ecPairingWord: {
              v: 8e4,
              d: "Gas costs regarding curve pairing precompile input length"
            },
            revert: {
              v: 0,
              d: "Base fee of the REVERT opcode"
            },
            staticcall: {
              v: 700,
              d: "Base fee of the STATICCALL opcode"
            },
            returndatasize: {
              v: 2,
              d: "Base fee of the RETURNDATASIZE opcode"
            },
            returndatacopy: {
              v: 3,
              d: "Base fee of the RETURNDATACOPY opcode"
            }
          },
          vm: {},
          pow: {
            minerReward: {
              v: "3000000000000000000",
              d: "the amount a miner get rewarded for mining a block"
            },
            difficultyBombDelay: {
              v: 3e6,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        constantinople: {
          name: "constantinople",
          comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
          url: "https://eips.ethereum.org/EIPS/eip-1013",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            netSstoreNoopGas: {
              v: 200,
              d: "Once per SSTORE operation if the value doesn't change"
            },
            netSstoreInitGas: {
              v: 2e4,
              d: "Once per SSTORE operation from clean zero"
            },
            netSstoreCleanGas: {
              v: 5e3,
              d: "Once per SSTORE operation from clean non-zero"
            },
            netSstoreDirtyGas: {
              v: 200,
              d: "Once per SSTORE operation from dirty"
            },
            netSstoreClearRefund: {
              v: 15e3,
              d: "Once per SSTORE operation for clearing an originally existing storage slot"
            },
            netSstoreResetRefund: {
              v: 4800,
              d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            netSstoreResetClearRefund: {
              v: 19800,
              d: "Once per SSTORE operation for resetting to the original zero value"
            },
            shl: {
              v: 3,
              d: "Base fee of the SHL opcode"
            },
            shr: {
              v: 3,
              d: "Base fee of the SHR opcode"
            },
            sar: {
              v: 3,
              d: "Base fee of the SAR opcode"
            },
            extcodehash: {
              v: 400,
              d: "Base fee of the EXTCODEHASH opcode"
            },
            create2: {
              v: 32e3,
              d: "Base fee of the CREATE2 opcode"
            }
          },
          vm: {},
          pow: {
            minerReward: {
              v: "2000000000000000000",
              d: "The amount a miner gets rewarded for mining a block"
            },
            difficultyBombDelay: {
              v: 5e6,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        petersburg: {
          name: "petersburg",
          comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
          url: "https://eips.ethereum.org/EIPS/eip-1716",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            netSstoreNoopGas: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreInitGas: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreCleanGas: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreDirtyGas: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreClearRefund: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreResetRefund: {
              v: null,
              d: "Removed along EIP-1283"
            },
            netSstoreResetClearRefund: {
              v: null,
              d: "Removed along EIP-1283"
            }
          },
          vm: {},
          pow: {}
        },
        istanbul: {
          name: "istanbul",
          comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
          url: "https://eips.ethereum.org/EIPS/eip-1679",
          status: "Final",
          gasConfig: {},
          gasPrices: {
            blake2Round: {
              v: 1,
              d: "Gas cost per round for the Blake2 F precompile"
            },
            ecAdd: {
              v: 150,
              d: "Gas costs for curve addition precompile"
            },
            ecMul: {
              v: 6e3,
              d: "Gas costs for curve multiplication precompile"
            },
            ecPairing: {
              v: 45e3,
              d: "Base gas costs for curve pairing precompile"
            },
            ecPairingWord: {
              v: 34e3,
              d: "Gas costs regarding curve pairing precompile input length"
            },
            txDataNonZero: {
              v: 16,
              d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
            },
            sstoreSentryGasEIP2200: {
              v: 2300,
              d: "Minimum gas required to be present for an SSTORE call, not consumed"
            },
            sstoreNoopGasEIP2200: {
              v: 800,
              d: "Once per SSTORE operation if the value doesn't change"
            },
            sstoreDirtyGasEIP2200: {
              v: 800,
              d: "Once per SSTORE operation if a dirty value is changed"
            },
            sstoreInitGasEIP2200: {
              v: 2e4,
              d: "Once per SSTORE operation from clean zero to non-zero"
            },
            sstoreInitRefundEIP2200: {
              v: 19200,
              d: "Once per SSTORE operation for resetting to the original zero value"
            },
            sstoreCleanGasEIP2200: {
              v: 5e3,
              d: "Once per SSTORE operation from clean non-zero to something else"
            },
            sstoreCleanRefundEIP2200: {
              v: 4200,
              d: "Once per SSTORE operation for resetting to the original non-zero value"
            },
            sstoreClearRefundEIP2200: {
              v: 15e3,
              d: "Once per SSTORE operation for clearing an originally existing storage slot"
            },
            balance: {
              v: 700,
              d: "Base fee of the BALANCE opcode"
            },
            extcodehash: {
              v: 700,
              d: "Base fee of the EXTCODEHASH opcode"
            },
            chainid: {
              v: 2,
              d: "Base fee of the CHAINID opcode"
            },
            selfbalance: {
              v: 5,
              d: "Base fee of the SELFBALANCE opcode"
            },
            sload: {
              v: 800,
              d: "Base fee of the SLOAD opcode"
            }
          },
          vm: {},
          pow: {}
        },
        muirGlacier: {
          name: "muirGlacier",
          comment: "HF to delay the difficulty bomb",
          url: "https://eips.ethereum.org/EIPS/eip-2384",
          status: "Final",
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {
            difficultyBombDelay: {
              v: 9e6,
              d: "the amount of blocks to delay the difficulty bomb with"
            }
          }
        },
        berlin: {
          name: "berlin",
          comment: "HF targeted for July 2020 following the Muir Glacier HF",
          url: "https://eips.ethereum.org/EIPS/eip-2070",
          status: "Final",
          eips: [2565, 2929, 2718, 2930]
        },
        london: {
          name: "london",
          comment: "HF targeted for July 2021 following the Berlin fork",
          url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
          status: "Final",
          eips: [1559, 3198, 3529, 3541]
        },
        shanghai: {
          name: "shanghai",
          comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
          url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
          status: "Final",
          eips: [3651, 3855, 3860, 4895]
        },
        arrowGlacier: {
          name: "arrowGlacier",
          comment: "HF to delay the difficulty bomb",
          url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
          status: "Final",
          eips: [4345],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        grayGlacier: {
          name: "grayGlacier",
          comment: "Delaying the difficulty bomb to Mid September 2022",
          url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
          status: "Draft",
          eips: [5133],
          gasConfig: {},
          gasPrices: {},
          vm: {},
          pow: {}
        },
        mergeForkIdTransition: {
          name: "mergeForkIdTransition",
          comment: "Pre-merge hardfork to fork off non-upgraded clients",
          url: "https://eips.ethereum.org/EIPS/eip-3675",
          status: "Draft",
          eips: []
        },
        merge: {
          name: "merge",
          comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
          url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
          status: "Final",
          consensus: {
            type: "pos",
            algorithm: "casper",
            casper: {}
          },
          eips: [3675, 4399]
        }
      },
      {
        buf: px
      } = ux;
    class bx extends TT {
      static custom(t, e = {}) {
        var r;
        const n = null !== (r = e.baseChain) && void 0 !== r ? r : "mainnet",
          i = Object.assign({}, bx.Es(n));
        if (i.name = "custom-chain", "string" != typeof t) return new bx(Object.assign({
          chain: Object.assign(Object.assign({}, i), t)
        }, e));
        if (t === Kk.PolygonMainnet) return bx.custom({
          name: Kk.PolygonMainnet,
          chainId: 137,
          networkId: 137
        }, e);
        if (t === Kk.PolygonMumbai) return bx.custom({
          name: Kk.PolygonMumbai,
          chainId: 80001,
          networkId: 80001
        }, e);
        if (t === Kk.ArbitrumRinkebyTestnet) return bx.custom({
          name: Kk.ArbitrumRinkebyTestnet,
          chainId: 421611,
          networkId: 421611
        }, e);
        if (t === Kk.ArbitrumOne) return bx.custom({
          name: Kk.ArbitrumOne,
          chainId: 42161,
          networkId: 42161
        }, e);
        if (t === Kk.xDaiChain) return bx.custom({
          name: Kk.xDaiChain,
          chainId: 100,
          networkId: 100
        }, e);
        if (t === Kk.OptimisticKovan) return bx.custom({
          name: Kk.OptimisticKovan,
          chainId: 69,
          networkId: 69
        }, Object.assign({
          hardfork: zk.Berlin
        }, e));
        if (t === Kk.OptimisticEthereum) return bx.custom({
          name: Kk.OptimisticEthereum,
          chainId: 10,
          networkId: 10
        }, Object.assign({
          hardfork: zk.Berlin
        }, e));
        throw Error(`Custom chain ${t} not supported`)
      }
      static fromGethGenesis(t, {
        chain: e,
        eips: r,
        genesisHash: n,
        hardfork: i,
        mergeForkIdPostMerge: o
      }) {
        var s;
        const a = function(t, e, r) {
            try {
              if (["config", "difficulty", "gasLimit", "alloc"].some(e => !(e in t))) throw Error("Invalid format, expected geth genesis fields missing");
              return void 0 !== e && (t.name = e),
                function(t, e = !0) {
                  var r, n;
                  const {
                    name: i,
                    config: o,
                    difficulty: s,
                    mixHash: a,
                    gasLimit: u,
                    coinbase: c,
                    baseFeePerGas: f
                  } = t;
                  let {
                    extraData: l,
                    timestamp: h,
                    nonce: d
                  } = t;
                  const p = +h,
                    {
                      chainId: b
                    } = o;
                  if ("" === l && (l = "0x"), nA(h) || (h = qk(parseInt(h))), 18 !== d.length && (d = function(t) {
                      return t && "0x0" !== t ? nA(t) ? "0x" + Zk(t).padStart(16, "0") : "0x" + t.padStart(16, "0") : "0x0000000000000000"
                    }(d)), o.eip155Block !== o.eip158Block) throw Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
                  const m = {
                      name: i,
                      chainId: b,
                      networkId: b,
                      genesis: {
                        timestamp: h,
                        gasLimit: parseInt(u),
                        difficulty: parseInt(s),
                        nonce: d,
                        extraData: l,
                        mixHash: a,
                        coinbase: c,
                        baseFeePerGas: f
                      },
                      hardfork: void 0,
                      hardforks: [],
                      bootstrapNodes: [],
                      consensus: void 0 !== o.clique ? {
                        type: "poa",
                        algorithm: "clique",
                        clique: {
                          period: null !== (r = o.clique.period) && void 0 !== r ? r : o.clique.blockperiodseconds,
                          epoch: null !== (n = o.clique.epoch) && void 0 !== n ? n : o.clique.epochlength
                        }
                      } : {
                        type: "pow",
                        algorithm: "ethash",
                        ethash: {}
                      }
                    },
                    y = {
                      [zk.Homestead]: {
                        name: "homesteadBlock"
                      },
                      [zk.Dao]: {
                        name: "daoForkBlock"
                      },
                      [zk.TangerineWhistle]: {
                        name: "eip150Block"
                      },
                      [zk.SpuriousDragon]: {
                        name: "eip155Block"
                      },
                      [zk.Byzantium]: {
                        name: "byzantiumBlock"
                      },
                      [zk.Constantinople]: {
                        name: "constantinopleBlock"
                      },
                      [zk.Petersburg]: {
                        name: "petersburgBlock"
                      },
                      [zk.Istanbul]: {
                        name: "istanbulBlock"
                      },
                      [zk.MuirGlacier]: {
                        name: "muirGlacierBlock"
                      },
                      [zk.Berlin]: {
                        name: "berlinBlock"
                      },
                      [zk.London]: {
                        name: "londonBlock"
                      },
                      [zk.MergeForkIdTransition]: {
                        name: "mergeForkBlock",
                        postMerge: e
                      },
                      [zk.Shanghai]: {
                        name: "shanghaiTime",
                        postMerge: !0,
                        isTimestamp: !0
                      },
                      [zk.ShardingForkDev]: {
                        name: "shardingForkTime",
                        postMerge: !0,
                        isTimestamp: !0
                      }
                    },
                    g = Object.keys(y).reduce((t, e) => (t[y[e].name] = e, t), {}),
                    v = Object.keys(o).filter(t => void 0 !== g[t] && void 0 !== o[t] && null !== o[t]);
                  if (m.hardforks = v.map(t => ({
                      name: g[t],
                      block: !0 === y[g[t]].isTimestamp || "number" != typeof o[t] ? null : o[t],
                      timestamp: !0 === y[g[t]].isTimestamp && "number" == typeof o[t] ? o[t] : void 0
                    })).filter(t => null !== t.block || void 0 !== t.timestamp), m.hardforks.sort((t, e) => {
                      var r, n;
                      return (null !== (r = t.block) && void 0 !== r ? r : 1 / 0) - (null !== (n = e.block) && void 0 !== n ? n : 1 / 0)
                    }), m.hardforks.sort((t, e) => {
                      var r, n;
                      return (null !== (r = t.timestamp) && void 0 !== r ? r : p) - (null !== (n = e.timestamp) && void 0 !== n ? n : p)
                    }), void 0 !== o.terminalTotalDifficulty) {
                    const t = {
                        name: zk.Merge,
                        ttd: o.terminalTotalDifficulty,
                        block: null
                      },
                      e = m.hardforks.findIndex(t => {
                        var e;
                        return !0 === (null === (e = y[t.name]) || void 0 === e ? void 0 : e.postMerge)
                      }); - 1 !== e ? m.hardforks.splice(e, 0, t) : m.hardforks.push(t)
                  }
                  const w = m.hardforks.length > 0 ? m.hardforks.slice(-1)[0] : void 0;
                  return m.hardfork = w?.name, m.hardforks.unshift({
                    name: zk.Chainstart,
                    block: 0
                  }), m
                }(t, r)
            } catch (t) {
              throw Error("Error parsing parameters file: " + t.message)
            }
          }(t, e, o),
          u = new bx({
            chain: null !== (s = a.name) && void 0 !== s ? s : "custom",
            customChains: [a],
            eips: r,
            hardfork: i ?? a.hardfork
          });
        return void 0 !== n && u.setForkHashes(n), u
      }
      static isSupportedChainId(t) {
        return !!this.Ps().names[t.toString()]
      }
      static Es(t, e) {
        let r = t;
        const n = this.Ps(e);
        if ("number" == typeof r || "bigint" == typeof r) {
          if (r = r.toString(), n.names[r]) return n[n.names[r]];
          throw Error(`Chain with ID ${r} not supported`)
        }
        if (void 0 !== n[r]) return n[r];
        throw Error(`Chain with name ${r} not supported`)
      }
      constructor(t) {
        var e, r;
        super(), this.ks = [], this.xs = null !== (e = t.customChains) && void 0 !== e ? e : [], this.Is = this.setChain(t.chain), this.DEFAULT_HARDFORK = null !== (r = this.Is.defaultHardfork) && void 0 !== r ? r : zk.Merge, this.HARDFORK_CHANGES = this.hardforks().map(t => [t.name, dx[t.name]]), this.Ss = this.DEFAULT_HARDFORK, void 0 !== t.hardfork && this.setHardfork(t.hardfork), t.eips && this.setEIPs(t.eips)
      }
      setChain(t) {
        if ("number" == typeof t || "bigint" == typeof t || "string" == typeof t) this.Is = bx.Es(t, this.xs);
        else {
          if ("object" != typeof t) throw Error("Wrong input format");
          {
            if (this.xs.length > 0) throw Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
            const e = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
            for (const r of e)
              if (!(r in t)) throw Error("Missing required chain parameter: " + r);
            this.Is = t
          }
        }
        for (const t of this.hardforks())
          if (void 0 === t.block) throw Error("Hardfork cannot have undefined block number");
        return this.Is
      }
      setHardfork(t) {
        let e = !1;
        for (const r of this.HARDFORK_CHANGES) r[0] === t && (this.Ss !== t && (this.Ss = t, this.emit("hardforkChanged", t)), e = !0);
        if (!e) throw Error(`Hardfork with name ${t} not supported`)
      }
      getHardforkByBlockNumber(t, e, r) {
        const n = sx(t, Vk.BigInt),
          i = sx(e, Vk.BigInt),
          o = sx(r, Vk.Number),
          s = this.hardforks().filter(t => null !== t.block || null !== t.ttd && void 0 !== t.ttd || void 0 !== t.timestamp),
          a = s.findIndex(t => null !== t.ttd && void 0 !== t.ttd);
        if (s.slice(a + 1).findIndex(t => null !== t.ttd && void 0 !== t.ttd) >= 0) throw Error("More than one merge hardforks found with ttd specified");
        let u = s.findIndex(t => null !== t.block && t.block > n || void 0 !== o && +t.timestamp > o);
        if (-1 === u) u = s.length;
        else if (0 === u) throw Error("Must have at least one hardfork at block 0");
        if (void 0 === o && (u -= s.slice(0, u).reverse().findIndex(t => null !== t.block || void 0 !== t.ttd)), u -= 1, null === s[u].block && void 0 === s[u].timestamp)(null == i || BigInt(s[u].ttd) > i) && (u -= 1);
        else if (a >= 0 && null != i) {
          if (u >= a && BigInt(s[a].ttd) > i) throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
          if (a > u && BigInt(s[a].ttd) <= i) throw Error("HF determined by block number is lower than the minimum total difficulty HF")
        }
        const c = u;
        for (; u < s.length - 1 && s[u].block === s[u + 1].block && s[u].timestamp === s[u + 1].timestamp; u += 1);
        if (o) {
          if (s.slice(0, c).reduce((t, e) => {
              var r;
              return Math.max(+(null !== (r = e.timestamp) && void 0 !== r ? r : "0"), t)
            }, 0) > o) throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");
          if (s.slice(u + 1).reduce((t, e) => {
              var r;
              return Math.min(+(null !== (r = e.timestamp) && void 0 !== r ? r : o), t)
            }, o) < o) throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")
        }
        return s[u].name
      }
      setHardforkByBlockNumber(t, e, r) {
        const n = this.getHardforkByBlockNumber(t, e, r);
        return this.setHardfork(n), n
      }
      Os(t) {
        const e = this.hardforks();
        for (const r of e)
          if (r.name === t) return r;
        return null
      }
      setEIPs(t = []) {
        for (const e of t) {
          if (!(e in hx)) throw Error(e + " not supported");
          const r = this.gteHardfork(hx[e].minimumHardfork);
          if (!r) throw Error(`${e} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`);
          if (void 0 !== hx[e].requiredEIPs)
            for (const r of hx[e].requiredEIPs)
              if (!t.includes(r) && !this.isActivatedEIP(r)) throw Error(`${e} requires EIP ${r}, but is not included in the EIP list`)
        }
        this.ks = t
      }
      param(t, e) {
        let r;
        for (const n of this.ks)
          if (r = this.paramByEIP(t, e, n), void 0 !== r) return r;
        return this.paramByHardfork(t, e, this.Ss)
      }
      paramByHardfork(t, e, r) {
        let n = null;
        for (const i of this.HARDFORK_CHANGES) {
          if ("eips" in i[1]) {
            const r = i[1].eips;
            for (const i of r) {
              const r = this.paramByEIP(t, e, i);
              n = "bigint" == typeof r ? r : n
            }
          } else {
            if (void 0 === i[1][t]) throw Error(`Topic ${t} not defined`);
            void 0 !== i[1][t][e] && (n = i[1][t][e].v)
          }
          if (i[0] === r) break
        }
        return BigInt(n ?? 0)
      }
      paramByEIP(t, e, r) {
        if (!(r in hx)) throw Error(r + " not supported");
        const n = hx[r];
        if (!(t in n)) throw Error(`Topic ${t} not defined`);
        if (void 0 === n[t][e]) return;
        const i = n[t][e].v;
        return BigInt(i)
      }
      paramByBlock(t, e, r, n, i) {
        const o = this.getHardforkByBlockNumber(r, n, i);
        return this.paramByHardfork(t, e, o)
      }
      isActivatedEIP(t) {
        if (this.eips().includes(t)) return !0;
        for (const e of this.HARDFORK_CHANGES) {
          const r = e[1];
          if (this.gteHardfork(r.name) && "eips" in r && r.eips.includes(t)) return !0
        }
        return !1
      }
      hardforkIsActiveOnBlock(t, e) {
        const r = sx(e, Vk.BigInt),
          n = t ?? this.Ss,
          i = this.hardforkBlock(n);
        return "bigint" == typeof i && i !== BigInt(0) && r >= i
      }
      activeOnBlock(t) {
        return this.hardforkIsActiveOnBlock(null, t)
      }
      hardforkGteHardfork(t, e) {
        const r = t ?? this.Ss,
          n = this.hardforks();
        let i = -1,
          o = -1,
          s = 0;
        for (const t of n) t.name === r && (i = s), t.name === e && (o = s), s += 1;
        return i >= o && -1 !== o
      }
      gteHardfork(t) {
        return this.hardforkGteHardfork(null, t)
      }
      hardforkBlock(t) {
        var e;
        const r = t ?? this.Ss,
          n = null === (e = this.Os(r)) || void 0 === e ? void 0 : e.block;
        return null == n ? null : BigInt(n)
      }
      hardforkTimestamp(t) {
        var e;
        const r = t ?? this.Ss,
          n = null === (e = this.Os(r)) || void 0 === e ? void 0 : e.timestamp;
        return null == n ? null : BigInt(n)
      }
      eipBlock(t) {
        for (const e of this.HARDFORK_CHANGES) {
          const r = e[1];
          if ("eips" in r && r.eips.includes(t)) return this.hardforkBlock("number" == typeof e[0] ? e[0] + "" : e[0])
        }
        return null
      }
      hardforkTTD(t) {
        var e;
        const r = t ?? this.Ss,
          n = null === (e = this.Os(r)) || void 0 === e ? void 0 : e.ttd;
        return null == n ? null : BigInt(n)
      }
      isHardforkBlock(t, e) {
        const r = sx(t, Vk.BigInt),
          n = e ?? this.Ss,
          i = this.hardforkBlock(n);
        return "bigint" == typeof i && i !== BigInt(0) && i === r
      }
      nextHardforkBlockOrTimestamp(t) {
        var e, r, n;
        const i = null !== (e = t) && void 0 !== e ? e : this.Ss,
          o = this.hardforks();
        let s = o.findIndex(t => t.name === i);
        if (i === zk.Merge && (s -= 1), 0 > s) return null;
        let a = null !== (r = o[s].timestamp) && void 0 !== r ? r : o[s].block;
        a = null != a ? +a : null;
        const u = o.slice(s + 1).find(t => {
          var e;
          let r = null !== (e = t.timestamp) && void 0 !== e ? e : t.block;
          return r = null != r ? +r : null, t.name !== zk.Merge && null != r && r !== a
        });
        if (void 0 === u) return null;
        const c = null !== (n = u.timestamp) && void 0 !== n ? n : u.block;
        return null == c ? null : BigInt(c)
      }
      nextHardforkBlock(t) {
        var e;
        const r = null !== (e = t) && void 0 !== e ? e : this.Ss;
        let n = this.hardforkBlock(r);
        if (null === n && r === zk.Merge) {
          const t = this.hardforks(),
            e = t.findIndex(t => null !== t.ttd && void 0 !== t.ttd);
          if (0 > e) throw Error("Merge hardfork should have been found");
          n = this.hardforkBlock(t[e - 1].name)
        }
        return null === n ? null : this.hardforks().reduce((t, e) => {
          const r = BigInt(null === e.block || void 0 !== e.ttd && null !== e.ttd ? 0 : e.block);
          return r > n && null === t ? r : t
        }, null)
      }
      isNextHardforkBlock(t, e) {
        const r = sx(t, Vk.BigInt),
          n = e ?? this.Ss,
          i = this.nextHardforkBlock(n);
        return null !== i && i === r
      }
      Bs(t, e) {
        let r = new Uint8Array,
          n = 0;
        for (const e of this.hardforks()) {
          const {
            block: i,
            timestamp: o,
            name: s
          } = e;
          let a = o ?? i;
          if (a = null !== a ? +a : null, "number" == typeof a && 0 !== a && a !== n && s !== zk.Merge && (r = zA(r, JA(a.toString(16).padStart(16, "0"))), n = a), e.name === t) break
        }
        const i = zA(e, r);
        return qA(function(t) {
          const e = qk(t);
          return JA("0x" + Jk(e.slice(2)))
        }(px(i) >>> 0))
      }
      forkHash(t, e) {
        const r = t ?? this.Ss,
          n = this.Os(r);
        if (null === n || null === n?.block && void 0 === n?.timestamp && void 0 === n?.ttd) throw Error("No fork hash calculation possible for future hardfork");
        if (null != n?.forkHash) return n.forkHash;
        if (!e) throw Error("genesisHash required for forkHash calculation");
        return this.Bs(r, e)
      }
      hardforkForForkHash(t) {
        const e = this.hardforks().filter(e => e.forkHash === t);
        return 1 > e.length ? null : e[e.length - 1]
      }
      setForkHashes(t) {
        var e;
        for (const r of this.hardforks()) {
          const n = null !== (e = r.timestamp) && void 0 !== e ? e : r.block;
          (null === r.forkHash || void 0 === r.forkHash) && (null != n || "u" > typeof r.ttd) && (r.forkHash = this.forkHash(r.name, t))
        }
      }
      genesis() {
        return this.Is.genesis
      }
      hardforks() {
        return this.Is.hardforks
      }
      bootstrapNodes() {
        return this.Is.bootstrapNodes
      }
      dnsNetworks() {
        return this.Is.dnsNetworks
      }
      hardfork() {
        return this.Ss
      }
      chainId() {
        return BigInt(this.Is.chainId)
      }
      chainName() {
        return this.Is.name
      }
      networkId() {
        return BigInt(this.Is.networkId)
      }
      eips() {
        return this.ks
      }
      consensusType() {
        const t = this.hardfork();
        let e;
        for (const r of this.HARDFORK_CHANGES)
          if ("consensus" in r[1] && (e = r[1].consensus.type), r[0] === t) break;
        return e ?? this.Is.consensus.type
      }
      consensusAlgorithm() {
        const t = this.hardfork();
        let e;
        for (const r of this.HARDFORK_CHANGES)
          if ("consensus" in r[1] && (e = r[1].consensus.algorithm), r[0] === t) break;
        return e ?? this.Is.consensus.algorithm
      }
      consensusConfig() {
        var t;
        const e = this.hardfork();
        let r;
        for (const t of this.HARDFORK_CHANGES)
          if ("consensus" in t[1] && (r = t[1].consensus[t[1].consensus.algorithm]), t[0] === e) break;
        return null !== (t = r ?? this.Is.consensus[this.consensusAlgorithm()]) && void 0 !== t ? t : {}
      }
      copy() {
        const t = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
        return t.removeAllListeners(), t
      }
      static Ps(t) {
        const e = {};
        for (const [t, r] of Object.entries($k)) e[r] = t.toLowerCase();
        const r = {
          mainnet: fx,
          goerli: cx,
          sepolia: lx
        };
        if (t)
          for (const n of t) {
            const {
              name: t
            } = n;
            e[n.chainId.toString()] = t, r[t] = n
          }
        return r.names = e, r
      }
    }
    var mx;
    ! function(t) {
      t[t.EIP155ReplayProtection = 155] = "EIP155ReplayProtection", t[t.EIP1559FeeMarket = 1559] = "EIP1559FeeMarket", t[t.EIP2718TypedTransaction = 2718] = "EIP2718TypedTransaction", t[t.EIP2930AccessLists = 2930] = "EIP2930AccessLists"
    }(mx || (mx = {}));
    class yx {
      constructor(t) {
        if (20 !== t.length) throw Error("Invalid address length");
        this.buf = t
      }
      static zero() {
        return new yx(Xk(20))
      }
      equals(t) {
        return HA(this.buf, t.buf)
      }
      isZero() {
        return this.equals(yx.zero())
      }
      toString() {
        return qA(this.buf)
      }
      toArray() {
        return this.buf
      }
      static publicToAddress(t, e = !1) {
        let r = t;
        if (tx(r), e && 64 !== r.length && (r = _k.ProjectivePoint.fromHex(r).toRawBytes(!1).slice(1)), 64 !== r.length) throw Error("Expected pubKey to be of length 64");
        return wg(r).slice(-20)
      }
    }
    const gx = t => {
        let e, r;
        if (function(t) {
            return ! function(t) {
              if (0 === t.length) return !0;
              const e = t[0];
              return !!Array.isArray(e)
            }(t)
          }(t)) {
          e = t;
          const n = [];
          for (let e = 0; e < t.length; e += 1) {
            const r = t[e],
              i = Yk(r.address),
              o = [];
            for (let t = 0; t < r.storageKeys.length; t += 1) o.push(Yk(r.storageKeys[t]));
            n.push([i, o])
          }
          r = n
        } else {
          r = t ?? [];
          const n = [];
          for (let t = 0; t < r.length; t += 1) {
            const e = r[t],
              i = qA(e[0]),
              o = [];
            for (let t = 0; t < e[1].length; t += 1) o.push(qA(e[1][t]));
            const s = {
              address: i,
              storageKeys: o
            };
            n.push(s)
          }
          e = n
        }
        return {
          AccessListJSON: e,
          accessList: r
        }
      },
      vx = t => {
        for (let e = 0; e < t.length; e += 1) {
          const r = t[e],
            n = r[0],
            i = r[1];
          if (void 0 !== r[2]) throw Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
          if (20 !== n.length) throw Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
          for (let t = 0; t < i.length; t += 1)
            if (32 !== i[t].length) throw Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")
        }
      },
      wx = t => {
        const e = [];
        for (let r = 0; r < t.length; r += 1) {
          const n = t[r],
            i = {
              address: qA(ex(n[0], 20)),
              storageKeys: []
            },
            o = n && n[1];
          for (let t = 0; t < o.length; t += 1) {
            const e = o[t];
            i.storageKeys.push(qA(ex(e, 32)))
          }
          e.push(i)
        }
        return e
      },
      Ax = (t, e) => {
        const r = e.param("gasPrices", "accessListStorageKeyCost"),
          n = e.param("gasPrices", "accessListAddressCost");
        let i = 0;
        for (let e = 0; e < t.length; e += 1) i += t[e][1].length;
        return t.length * +n + i * +r
      };
    class Tx {
      constructor(t, e) {
        var r, n;
        this.cache = {
          hash: void 0,
          dataFee: void 0
        }, this.activeCapabilities = [], this.DEFAULT_CHAIN = $k.Mainnet, this.DEFAULT_HARDFORK = zk.Merge;
        const {
          nonce: i,
          gasLimit: o,
          to: s,
          value: a,
          data: u,
          v: c,
          r: f,
          s: l,
          type: h
        } = t;
        this.Ws = +Qk(Yk(h)), this.txOptions = e;
        const d = Yk("" === s ? "0x" : s),
          p = Yk("" === c ? "0x" : c),
          b = Yk("" === f ? "0x" : f),
          m = Yk("" === l ? "0x" : l);
        this.nonce = Qk(Yk("" === i ? "0x" : i)), this.gasLimit = Qk(Yk("" === o ? "0x" : o)), this.to = d.length > 0 ? new yx(d) : void 0, this.value = Qk(Yk("" === a ? "0x" : a)), this.data = Yk("" === u ? "0x" : u), this.v = p.length > 0 ? Qk(p) : void 0, this.r = b.length > 0 ? Qk(b) : void 0, this.s = m.length > 0 ? Qk(m) : void 0, this.Ms({
          value: this.value,
          r: this.r,
          s: this.s
        }), this.Ms({
          gasLimit: this.gasLimit
        }, 64), this.Ms({
          nonce: this.nonce
        }, 64, !0);
        const y = void 0 === this.to || null === this.to,
          g = null !== (r = e.allowUnlimitedInitCodeSize) && void 0 !== r && r,
          v = null !== (n = e.common) && void 0 !== n ? n : this.Cs();
        y && v.isActivatedEIP(3860) && !g && ((t, e) => {
          const r = t.param("vm", "maxInitCodeSize");
          if (r && BigInt(e) > r) throw Error(`the initcode size of this transaction is too large: it is ${e} while the max is ${t.param("vm","maxInitCodeSize")}`)
        })(v, this.data.length)
      }
      get type() {
        return this.Ws
      }
      supports(t) {
        return this.activeCapabilities.includes(t)
      }
      validate(t = !1) {
        const e = [];
        return this.getBaseFee() > this.gasLimit && e.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`), this.isSigned() && !this.verifySignature() && e.push("Invalid Signature"), t ? e : 0 === e.length
      }
      Rs() {
        const {
          v: t
        } = this;
        if (void 0 !== t && t !== BigInt(0) && t !== BigInt(1)) {
          const t = this.Ns("The y-parity of the transaction should either be 0 or 1");
          throw Error(t)
        }
      }
      js() {
        const {
          s: t
        } = this;
        if (this.common.gteHardfork("homestead") && void 0 !== t && t > Lk) {
          const t = this.Ns("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
          throw Error(t)
        }
      }
      getBaseFee() {
        const t = this.common.param("gasPrices", "tx");
        let e = this.getDataFee();
        if (t && (e += t), this.common.gteHardfork("homestead") && this.toCreationAddress()) {
          const t = this.common.param("gasPrices", "txCreation");
          t && (e += t)
        }
        return e
      }
      getDataFee() {
        const t = this.common.param("gasPrices", "txDataZero"),
          e = this.common.param("gasPrices", "txDataNonZero");
        let r = BigInt(0);
        for (let n = 0; n < this.data.length; n += 1) 0 === this.data[n] ? r += t : r += e;
        if ((void 0 === this.to || null === this.to) && this.common.isActivatedEIP(3860)) {
          const t = BigInt(Math.ceil(this.data.length / 32));
          r += this.common.param("gasPrices", "initCodeWordCost") * t
        }
        return r
      }
      toCreationAddress() {
        return void 0 === this.to || 0 === this.to.buf.length
      }
      isSigned() {
        const {
          v: t,
          r: e,
          s: r
        } = this;
        return !(void 0 === t || void 0 === e || void 0 === r)
      }
      verifySignature() {
        try {
          const t = this.getSenderPublicKey();
          return 0 !== rx(t).length
        } catch {
          return !1
        }
      }
      getSenderAddress() {
        return new yx(yx.publicToAddress(this.getSenderPublicKey()))
      }
      sign(t) {
        if (32 !== t.length) {
          const t = this.Ns("Private key must be 32 bytes in length.");
          throw Error(t)
        }
        let e = !1;
        0 === this.type && this.common.gteHardfork("spuriousDragon") && !this.supports(mx.EIP155ReplayProtection) && (this.activeCapabilities.push(mx.EIP155ReplayProtection), e = !0);
        const r = this.getMessageToSign(!0),
          {
            v: n,
            r: i,
            s: o
          } = this._s(r, t),
          s = this.Ds(n, i, o);
        if (e) {
          const t = this.activeCapabilities.indexOf(mx.EIP155ReplayProtection);
          t > -1 && this.activeCapabilities.splice(t, 1)
        }
        return s
      }
      Cs(t, e) {
        var r, n, i, o;
        if (void 0 !== e) {
          const r = Qk(Yk(e));
          if (t) {
            if (t.chainId() !== r) {
              const t = this.Ns("The chain ID does not match the chain ID of Common");
              throw Error(t)
            }
            return t.copy()
          }
          return bx.isSupportedChainId(r) ? new bx({
            chain: r,
            hardfork: this.DEFAULT_HARDFORK
          }) : bx.custom({
            name: "custom-chain",
            networkId: r,
            chainId: r
          }, {
            baseChain: this.DEFAULT_CHAIN,
            hardfork: this.DEFAULT_HARDFORK
          })
        }
        if (t?.copy && "function" == typeof t?.copy) return t.copy();
        if (t) {
          const e = "function" == typeof t.hardfork ? t.hardfork() : t.hardfork;
          return bx.custom({
            name: "custom-chain",
            networkId: t.networkId ? t.networkId() : null !== (n = BigInt(null === (r = t.customChain) || void 0 === r ? void 0 : r.networkId)) && void 0 !== n ? n : void 0,
            chainId: t.chainId ? t.chainId() : null !== (o = BigInt(null === (i = t.customChain) || void 0 === i ? void 0 : i.chainId)) && void 0 !== o ? o : void 0
          }, {
            baseChain: this.DEFAULT_CHAIN,
            hardfork: e || this.DEFAULT_HARDFORK
          })
        }
        return new bx({
          chain: this.DEFAULT_CHAIN,
          hardfork: this.DEFAULT_HARDFORK
        })
      }
      Ms(t, e = 256, r = !1) {
        for (const [n, i] of Object.entries(t)) switch (e) {
          case 64:
            if (r) {
              if (void 0 !== i && i >= Dk) {
                const t = this.Ns(`${n} cannot equal or exceed MAX_UINT64 (2^64-1), given ${i}`);
                throw Error(t)
              }
            } else if (void 0 !== i && i > Dk) {
              const t = this.Ns(`${n} cannot exceed MAX_UINT64 (2^64-1), given ${i}`);
              throw Error(t)
            }
            break;
          case 256:
            if (r) {
              if (void 0 !== i && i >= Uk) {
                const t = this.Ns(`${n} cannot equal or exceed MAX_INTEGER (2^256-1), given ${i}`);
                throw Error(t)
              }
            } else if (void 0 !== i && i > Uk) {
              const t = this.Ns(`${n} cannot exceed MAX_INTEGER (2^256-1), given ${i}`);
              throw Error(t)
            }
            break;
          default: {
            const t = this.Ns("unimplemented bits value");
            throw Error(t)
          }
        }
      }
      static Us(t) {
        const e = ["nonce", "gasPrice", "gasLimit", "to", "value", "data", "v", "r", "s", "type", "baseFee", "maxFeePerGas", "chainId"];
        for (const [r, n] of Object.entries(t))
          if (e.includes(r) && Array.isArray(n)) throw Error(r + " cannot be an array")
      }
      Ls() {
        let t = "";
        try {
          t = this.isSigned() ? qA(this.hash()) : "not available (unsigned)"
        } catch {
          t = "error"
        }
        let e = "";
        try {
          e = this.isSigned().toString()
        } catch {
          t = "error"
        }
        let r = "";
        try {
          r = this.common.hardfork()
        } catch {
          r = "error"
        }
        let n = `tx type=${this.type} hash=${t} nonce=${this.nonce} value=${this.value} `;
        return n += `signed=${e} hf=${r}`, n
      }
      _s(t, e, r) {
        const n = _k.sign(t, e),
          i = n.toCompactRawBytes();
        return {
          r: i.subarray(0, 32),
          s: i.subarray(32, 64),
          v: void 0 === r ? BigInt(n.recovery + 27) : BigInt(n.recovery + 35) + BigInt(r) * BigInt(2)
        }
      }
      static fromSerializedTx(t, e = {}) {}
      static fromTxData(t, e = {}) {}
    }
    const Ex = JA("02");
    class Px extends Tx {
      static fromTxData(t, e = {}) {
        return new Px(t, e)
      }
      static fromSerializedTx(t, e = {}) {
        if (!HA(t.subarray(0, 1), Ex)) throw Error("Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: 2, received: " + qA(t.subarray(0, 1)));
        const r = ax.RLP.decode(t.subarray(1));
        if (!Array.isArray(r)) throw Error("Invalid serialized tx input: must be array");
        return Px.fromValuesArray(r, e)
      }
      static fromValuesArray(t, e = {}) {
        if (9 !== t.length && 12 !== t.length) throw Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
        const [r, n, i, o, s, a, u, c, f, l, h, d] = t;
        return this.Us({
          chainId: r,
          v: l
        }), iA({
          nonce: n,
          maxPriorityFeePerGas: i,
          maxFeePerGas: o,
          gasLimit: s,
          value: u,
          v: l,
          r: h,
          s: d
        }), new Px({
          chainId: Qk(r),
          nonce: n,
          maxPriorityFeePerGas: i,
          maxFeePerGas: o,
          gasLimit: s,
          to: a,
          value: u,
          data: c,
          accessList: f ?? [],
          v: void 0 !== l ? Qk(l) : void 0,
          r: h,
          s: d
        }, e)
      }
      constructor(t, e = {}) {
        var r;
        super(Object.assign(Object.assign({}, t), {
          type: 2
        }), e), this.DEFAULT_HARDFORK = "london";
        const {
          chainId: n,
          accessList: i,
          maxFeePerGas: o,
          maxPriorityFeePerGas: s
        } = t;
        if (this.common = this.Cs(e.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(1559)) throw Error("EIP-1559 not enabled on Common");
        this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
        const a = gx(i ?? []);
        if (this.accessList = a.accessList, this.AccessListJSON = a.AccessListJSON, vx(this.accessList), this.maxFeePerGas = Qk(Yk("" === o ? "0x" : o)), this.maxPriorityFeePerGas = Qk(Yk("" === s ? "0x" : s)), this.Ms({
            maxFeePerGas: this.maxFeePerGas,
            maxPriorityFeePerGas: this.maxPriorityFeePerGas
          }), Tx.Us(t), this.gasLimit * this.maxFeePerGas > Uk) {
          const t = this.Ns("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
          throw Error(t)
        }
        if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
          const t = this.Ns("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
          throw Error(t)
        }
        this.Rs(), this.js(), (null === (r = e?.freeze) || void 0 === r || r) && Object.freeze(this)
      }
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
        let t = super.getDataFee();
        return t += BigInt(Ax(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
          value: t,
          hardfork: this.common.hardfork()
        }), t
      }
      getUpfrontCost(t = BigInt(0)) {
        const e = this.maxPriorityFeePerGas,
          r = this.maxFeePerGas - t,
          n = (r > e ? e : r) + t;
        return this.gasLimit * n + this.value
      }
      raw() {
        return [ix(this.chainId), ix(this.nonce), ix(this.maxPriorityFeePerGas), ix(this.maxFeePerGas), ix(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), ix(this.value), this.data, this.accessList, void 0 !== this.v ? ix(this.v) : Uint8Array.from([]), void 0 !== this.r ? ix(this.r) : Uint8Array.from([]), void 0 !== this.s ? ix(this.s) : Uint8Array.from([])]
      }
      serialize() {
        const t = this.raw();
        return zA(Ex, ax.RLP.encode(t))
      }
      getMessageToSign(t = !0) {
        const e = this.raw().slice(0, 9),
          r = zA(Ex, ax.RLP.encode(e));
        return t ? wg(r) : r
      }
      hash() {
        if (!this.isSigned()) {
          const t = this.Ns("Cannot call hash method if transaction is not signed");
          throw Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = wg(this.serialize())), this.cache.hash) : wg(this.serialize())
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign()
      }
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const t = this.Ns("Cannot call this method if transaction is not signed");
          throw Error(t)
        }
        const t = this.getMessageToVerifySignature(),
          {
            v: e,
            r: r,
            s: n
          } = this;
        this.js();
        try {
          return ox(t, e + BigInt(27), ix(r), ix(n))
        } catch {
          const t = this.Ns("Invalid Signature");
          throw Error(t)
        }
      }
      Ds(t, e, r) {
        const n = Object.assign(Object.assign({}, this.txOptions), {
          common: this.common
        });
        return Px.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          maxPriorityFeePerGas: this.maxPriorityFeePerGas,
          maxFeePerGas: this.maxFeePerGas,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: t - BigInt(27),
          r: Qk(e),
          s: Qk(r)
        }, n)
      }
      toJSON() {
        const t = wx(this.accessList);
        return {
          chainId: nx(this.chainId),
          nonce: nx(this.nonce),
          maxPriorityFeePerGas: nx(this.maxPriorityFeePerGas),
          maxFeePerGas: nx(this.maxFeePerGas),
          gasLimit: nx(this.gasLimit),
          to: void 0 !== this.to ? this.to.toString() : void 0,
          value: nx(this.value),
          data: qA(this.data),
          accessList: t,
          v: void 0 !== this.v ? nx(this.v) : void 0,
          r: void 0 !== this.r ? nx(this.r) : void 0,
          s: void 0 !== this.s ? nx(this.s) : void 0
        }
      }
      errorStr() {
        let t = this.Ls();
        return t += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`, t
      }
      Ns(t) {
        return `${t} (${this.errorStr()})`
      }
    }
    const kx = JA("01");
    class xx extends Tx {
      static fromTxData(t, e = {}) {
        return new xx(t, e)
      }
      static fromSerializedTx(t, e = {}) {
        if (!HA(t.subarray(0, 1), kx)) throw Error("Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: 1, received: " + qA(t.subarray(0, 1)));
        const r = ax.RLP.decode(Uint8Array.from(t.subarray(1)));
        if (!Array.isArray(r)) throw Error("Invalid serialized tx input: must be array");
        return xx.fromValuesArray(r, e)
      }
      static fromValuesArray(t, e = {}) {
        if (8 !== t.length && 11 !== t.length) throw Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
        const [r, n, i, o, s, a, u, c, f, l, h] = t;
        return this.Us({
          chainId: r,
          v: f
        }), iA({
          nonce: n,
          gasPrice: i,
          gasLimit: o,
          value: a,
          v: f,
          r: l,
          s: h
        }), new xx({
          chainId: Qk(r),
          nonce: n,
          gasPrice: i,
          gasLimit: o,
          to: s,
          value: a,
          data: u,
          accessList: c ?? [],
          v: void 0 !== f ? Qk(f) : void 0,
          r: l,
          s: h
        }, e)
      }
      constructor(t, e = {}) {
        var r;
        super(Object.assign(Object.assign({}, t), {
          type: 1
        }), e), this.DEFAULT_HARDFORK = "berlin";
        const {
          chainId: n,
          accessList: i,
          gasPrice: o
        } = t;
        if (this.common = this.Cs(e.common, n), this.chainId = this.common.chainId(), !this.common.isActivatedEIP(2930)) throw Error("EIP-2930 not enabled on Common");
        this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
        const s = gx(i ?? []);
        if (this.accessList = s.accessList, this.AccessListJSON = s.AccessListJSON, vx(this.accessList), this.gasPrice = Qk(Yk("" === o ? "0x" : o)), this.Ms({
            gasPrice: this.gasPrice
          }), Tx.Us(t), this.gasPrice * this.gasLimit > Uk) {
          const t = this.Ns("gasLimit * gasPrice cannot exceed MAX_INTEGER");
          throw Error(t)
        }
        this.Rs(), this.js(), (null === (r = e?.freeze) || void 0 === r || r) && Object.freeze(this)
      }
      getDataFee() {
        if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) return this.cache.dataFee.value;
        let t = super.getDataFee();
        return t += BigInt(Ax(this.accessList, this.common)), Object.isFrozen(this) && (this.cache.dataFee = {
          value: t,
          hardfork: this.common.hardfork()
        }), t
      }
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value
      }
      raw() {
        return [ix(this.chainId), ix(this.nonce), ix(this.gasPrice), ix(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), ix(this.value), this.data, this.accessList, void 0 !== this.v ? ix(this.v) : Uint8Array.from([]), void 0 !== this.r ? ix(this.r) : Uint8Array.from([]), void 0 !== this.s ? ix(this.s) : Uint8Array.from([])]
      }
      serialize() {
        const t = this.raw();
        return zA(kx, ax.RLP.encode(t))
      }
      getMessageToSign(t = !0) {
        const e = this.raw().slice(0, 8),
          r = zA(kx, ax.RLP.encode(e));
        return t ? wg(r) : r
      }
      hash() {
        if (!this.isSigned()) {
          const t = this.Ns("Cannot call hash method if transaction is not signed");
          throw Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = wg(this.serialize())), this.cache.hash) : wg(this.serialize())
      }
      getMessageToVerifySignature() {
        return this.getMessageToSign()
      }
      getSenderPublicKey() {
        if (!this.isSigned()) {
          const t = this.Ns("Cannot call this method if transaction is not signed");
          throw Error(t)
        }
        const t = this.getMessageToVerifySignature(),
          {
            v: e,
            r: r,
            s: n
          } = this;
        this.js();
        try {
          return ox(t, e + BigInt(27), ix(r), ix(n))
        } catch {
          const t = this.Ns("Invalid Signature");
          throw Error(t)
        }
      }
      Ds(t, e, r) {
        const n = Object.assign(Object.assign({}, this.txOptions), {
          common: this.common
        });
        return xx.fromTxData({
          chainId: this.chainId,
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          accessList: this.accessList,
          v: t - BigInt(27),
          r: Qk(e),
          s: Qk(r)
        }, n)
      }
      toJSON() {
        const t = wx(this.accessList);
        return {
          chainId: nx(this.chainId),
          nonce: nx(this.nonce),
          gasPrice: nx(this.gasPrice),
          gasLimit: nx(this.gasLimit),
          to: void 0 !== this.to ? this.to.toString() : void 0,
          value: nx(this.value),
          data: qA(this.data),
          accessList: t,
          v: void 0 !== this.v ? nx(this.v) : void 0,
          r: void 0 !== this.r ? nx(this.r) : void 0,
          s: void 0 !== this.s ? nx(this.s) : void 0
        }
      }
      errorStr() {
        var t, e;
        let r = this.Ls();
        return r += ` gasPrice=${this.gasPrice} accessListCount=${null!==(e=null===(t=this.accessList)||void 0===t?void 0:t.length)&&void 0!==e?e:0}`, r
      }
      Ns(t) {
        return `${t} (${this.errorStr()})`
      }
    }

    function Ix(t, e) {
      const r = +t,
        n = 2 * +e;
      return r === n + 35 || r === n + 36
    }
    class Sx extends Tx {
      static fromTxData(t, e = {}) {
        return new Sx(t, e)
      }
      static fromSerializedTx(t, e = {}) {
        const r = ax.RLP.decode(t);
        if (!Array.isArray(r)) throw Error("Invalid serialized tx input. Must be array");
        return this.fromValuesArray(r, e)
      }
      static fromValuesArray(t, e = {}) {
        if (6 !== t.length && 9 !== t.length) throw Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
        const [r, n, i, o, s, a, u, c, f] = t;
        return iA({
          nonce: r,
          gasPrice: n,
          gasLimit: i,
          value: s,
          v: u,
          r: c,
          s: f
        }), new Sx({
          nonce: r,
          gasPrice: n,
          gasLimit: i,
          to: o,
          value: s,
          data: a,
          v: u,
          r: c,
          s: f
        }, e)
      }
      constructor(t, e = {}) {
        var r;
        if (super(Object.assign(Object.assign({}, t), {
            type: 0
          }), e), this.common = this.Fs(this.v, e.common), this.gasPrice = Qk(Yk("" === t.gasPrice ? "0x" : t.gasPrice)), this.gasPrice * this.gasLimit > Uk) {
          const t = this.Ns("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
          throw Error(t)
        }
        this.Ms({
          gasPrice: this.gasPrice
        }), Tx.Us(t), this.common.gteHardfork("spuriousDragon") && (this.isSigned() ? Ix(this.v, this.common.chainId()) && this.activeCapabilities.push(mx.EIP155ReplayProtection) : this.activeCapabilities.push(mx.EIP155ReplayProtection)), (null === (r = e?.freeze) || void 0 === r || r) && Object.freeze(this)
      }
      raw() {
        return [ix(this.nonce), ix(this.gasPrice), ix(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), ix(this.value), this.data, void 0 !== this.v ? ix(this.v) : Uint8Array.from([]), void 0 !== this.r ? ix(this.r) : Uint8Array.from([]), void 0 !== this.s ? ix(this.s) : Uint8Array.from([])]
      }
      serialize() {
        return ax.RLP.encode(this.raw())
      }
      $s() {
        const t = [ix(this.nonce), ix(this.gasPrice), ix(this.gasLimit), void 0 !== this.to ? this.to.buf : Uint8Array.from([]), ix(this.value), this.data];
        return this.supports(mx.EIP155ReplayProtection) && (t.push(Yk(this.common.chainId())), t.push(rx(Yk(0))), t.push(rx(Yk(0)))), t
      }
      getMessageToSign(t = !0) {
        const e = this.$s();
        return t ? wg(ax.RLP.encode(e)) : e
      }
      getDataFee() {
        return this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork() ? this.cache.dataFee.value : (Object.isFrozen(this) && (this.cache.dataFee = {
          value: super.getDataFee(),
          hardfork: this.common.hardfork()
        }), super.getDataFee())
      }
      getUpfrontCost() {
        return this.gasLimit * this.gasPrice + this.value
      }
      hash() {
        if (!this.isSigned()) {
          const t = this.Ns("Cannot call hash method if transaction is not signed");
          throw Error(t)
        }
        return Object.isFrozen(this) ? (this.cache.hash || (this.cache.hash = wg(ax.RLP.encode(this.raw()))), this.cache.hash) : wg(ax.RLP.encode(this.raw()))
      }
      getMessageToVerifySignature() {
        if (!this.isSigned()) {
          const t = this.Ns("This transaction is not signed");
          throw Error(t)
        }
        const t = this.$s();
        return wg(ax.RLP.encode(t))
      }
      getSenderPublicKey() {
        const t = this.getMessageToVerifySignature(),
          {
            v: e,
            r: r,
            s: n
          } = this;
        this.js();
        try {
          return ox(t, e, ix(r), ix(n), this.supports(mx.EIP155ReplayProtection) ? this.common.chainId() : void 0)
        } catch {
          const t = this.Ns("Invalid Signature");
          throw Error(t)
        }
      }
      Ds(t, e, r) {
        let n = t;
        this.supports(mx.EIP155ReplayProtection) && (n += this.common.chainId() * BigInt(2) + BigInt(8));
        const i = Object.assign(Object.assign({}, this.txOptions), {
          common: this.common
        });
        return Sx.fromTxData({
          nonce: this.nonce,
          gasPrice: this.gasPrice,
          gasLimit: this.gasLimit,
          to: this.to,
          value: this.value,
          data: this.data,
          v: n,
          r: Qk(e),
          s: Qk(r)
        }, i)
      }
      toJSON() {
        return {
          nonce: nx(this.nonce),
          gasPrice: nx(this.gasPrice),
          gasLimit: nx(this.gasLimit),
          to: void 0 !== this.to ? this.to.toString() : void 0,
          value: nx(this.value),
          data: qA(this.data),
          v: void 0 !== this.v ? nx(this.v) : void 0,
          r: void 0 !== this.r ? nx(this.r) : void 0,
          s: void 0 !== this.s ? nx(this.s) : void 0
        }
      }
      Fs(t, e) {
        let r;
        const n = void 0 !== t ? +t : void 0;
        if (void 0 !== n && 37 > n && 27 !== n && 28 !== n) throw Error("Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = " + n);
        if (void 0 !== n && 0 !== n && (!e || e.gteHardfork("spuriousDragon")) && 27 !== n && 28 !== n)
          if (e) {
            if (!Ix(BigInt(n), e.chainId())) throw Error(`Incompatible EIP155-based V ${n} and chain id ${e.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)
          } else {
            let t;
            t = (n - 35) % 2 == 0 ? 35 : 36, r = BigInt(n - t) / BigInt(2)
          } return this.Cs(e, r)
      }
      errorStr() {
        let t = this.Ls();
        return t += " gasPrice=" + this.gasPrice, t
      }
      Ns(t) {
        return `${t} (${this.errorStr()})`
      }
    }
    const Ox = new Map;
    class Bx {
      constructor() {}
      static typeToInt(t) {
        return +Qk(Yk(t))
      }
      static registerTransactionType(t, e) {
        const r = Bx.typeToInt(t);
        Ox.set(r, e)
      }
      static fromTxData(t, e = {}) {
        if (!("type" in t) || void 0 === t.type) return Sx.fromTxData(t, e);
        const r = Bx.typeToInt(t.type);
        if (0 === r) return Sx.fromTxData(t, e);
        if (1 === r) return xx.fromTxData(t, e);
        if (2 === r) return Px.fromTxData(t, e);
        const n = Ox.get(r);
        if (n?.fromTxData) return n.fromTxData(t, e);
        throw Error(`Tx instantiation with type ${r} not supported`)
      }
      static fromSerializedData(t, e = {}) {
        if (t[0] > 127) return Sx.fromSerializedTx(t, e);
        switch (t[0]) {
          case 1:
            return xx.fromSerializedTx(t, e);
          case 2:
            return Px.fromSerializedTx(t, e);
          default: {
            const r = Ox.get(+t[0]);
            if (r?.fromSerializedTx) return r.fromSerializedTx(t, e);
            throw Error(`TypedTransaction with ID ${t[0]} unknown`)
          }
        }
      }
      static fromBlockBodyData(t, e = {}) {
        if ($A(t)) return this.fromSerializedData(t, e);
        if (Array.isArray(t)) return Sx.fromValuesArray(t, e);
        throw Error("Cannot decode transaction: unknown type input")
      }
    }
    var Wx = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const Mx = (t, e) => {
        let r;
        if (!e && "string" == typeof t && tA(t) && 66 !== t.length) throw new Rb;
        try {
          r = $A(t) ? t : VA(t)
        } catch {
          throw new Nb
        }
        if (!e && 32 !== r.byteLength) throw new Rb;
        return r
      },
      Cx = (t, e = !1) => {
        const r = tA(t) ? t : rT(t),
          n = JA(r),
          i = JA(nT("Ethereum Signed Message:\n" + n.byteLength)),
          o = e ? n : zA(i, n);
        return tE(o)
      },
      Rx = (t, e) => {
        const r = Cx(t),
          {
            messageHash: n,
            v: i,
            r: o,
            s: s,
            signature: a
          } = ((t, e) => {
            const r = Mx(e),
              n = _k.sign(t.substring(2), r),
              i = n.toCompactRawBytes(),
              o = n.r.toString(16).padStart(64, "0"),
              s = n.s.toString(16).padStart(64, "0"),
              a = n.recovery + 27;
            return {
              messageHash: t,
              v: XA(a),
              r: "0x" + o,
              s: "0x" + s,
              signature: `${qA(i)}${a.toString(16)}`
            }
          })(r, e);
        return {
          message: t,
          messageHash: n,
          v: i,
          r: o,
          s: s,
          signature: a
        }
      },
      Nx = t => {
        if (RA(t)) throw new ym;
        const e = Bx.fromSerializedData(JA(t));
        return gT(e.getSenderAddress().toString())
      },
      jx = (t, e, r, n, i) => {
        if ("object" == typeof t) {
          const e = `${t.r}${t.s.slice(2)}${t.v.slice(2)}`;
          return jx(t.messageHash, e, r)
        }
        if ("string" == typeof e && "string" == typeof r && !RA(n)) {
          const o = `${r}${n.slice(2)}${e.slice(2)}`;
          return jx(t, o, i)
        }
        if (RA(e)) throw new jb("signature string undefined");
        const o = r ? t : Cx(t);
        let s = parseInt(e.substring(130), 16);
        s > 26 && (s -= 27);
        const a = _k.Signature.fromCompact(e.slice(2, 130)).addRecoveryBit(s).recoverPublicKey(o.replace("0x", "")).toRawBytes(!1),
          u = tE(a.subarray(1));
        return gT("0x" + u.slice(-40))
      },
      _x = t => {
        const e = Mx(t),
          r = _k.getPublicKey(e, !1),
          n = tE(r.slice(1)).slice(-40);
        return gT("0x" + n)
      },
      Dx = (t, e) => {
        const r = Mx(t);
        return "0x" + qA(_k.getPublicKey(r, e)).slice(4)
      },
      Ux = (t, e, r) => Wx(void 0, void 0, void 0, function*() {
        var n, i, o, s, a, u, c;
        const f = Mx(t);
        let l;
        if (l = r?.salt ? "string" == typeof r.salt ? JA(r.salt) : r.salt : cE(32), !Xw(e) && !$A(e)) throw new Lb;
        const h = "string" == typeof e ? JA(rT(e)) : e;
        let d;
        if (r?.iv) {
          if (d = "string" == typeof r.iv ? JA(r.iv) : r.iv, 16 !== d.length) throw new Fb
        } else d = cE(16);
        const p = null !== (n = r?.kdf) && void 0 !== n ? n : "scrypt";
        let b, m;
        if ("pbkdf2" === p) {
          if (m = {
              dklen: null !== (i = r?.dklen) && void 0 !== i ? i : 32,
              salt: qA(l).replace("0x", ""),
              c: null !== (o = r?.c) && void 0 !== o ? o : 262144,
              prf: "hmac-sha256"
            }, 1e3 > m.c) throw new $b;
          b = MP(h, l, m.c, m.dklen, "sha256")
        } else {
          if ("scrypt" !== p) throw new _b;
          m = {
            n: null !== (s = r?.n) && void 0 !== s ? s : 8192,
            r: null !== (a = r?.r) && void 0 !== a ? a : 8,
            p: null !== (u = r?.p) && void 0 !== u ? u : 1,
            dklen: null !== (c = r?.dklen) && void 0 !== c ? c : 32,
            salt: qA(l).replace("0x", "")
          }, b = NP(h, l, m.n, m.p, m.r, m.dklen)
        }
        const y = yield pP(f, b.slice(0, 16), d, "aes-128-ctr"), g = qA(y).slice(2), v = tE(zA(b.slice(16, 32), y)).replace("0x", "");
        return {
          version: 3,
          id: gE(),
          address: _x(f).toLowerCase().replace("0x", ""),
          crypto: {
            ciphertext: g,
            cipherparams: {
              iv: qA(d).replace("0x", "")
            },
            cipher: "aes-128-ctr",
            kdf: p,
            kdfparams: m,
            mac: v
          }
        }
      }),
      Lx = (t, e) => {
        const r = Mx(t, e);
        return {
          address: _x(r),
          privateKey: qA(r),
          signTransaction: t => {
            throw new Zm("Do not have network access to sign the transaction")
          },
          sign: t => Rx("string" == typeof t ? t : JSON.stringify(t), r),
          encrypt: (t, e) => Wx(void 0, void 0, void 0, function*() {
            return Ux(r, t, e)
          })
        }
      };
    var Fx = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class $x {
      constructor(t) {
        this.zs = t, this.Hs = new Map
      }
      get requests() {
        return [...this.Hs.values()].map(t => t.payload)
      }
      add(t) {
        const e = OE(t),
          r = new RE;
        return this.Hs.set(e.id, {
          payload: e,
          promise: r
        }), r
      }
      execute(t) {
        return Fx(this, void 0, void 0, function*() {
          var e;
          if (0 === this.requests.length) return Promise.resolve([]);
          const r = new RE({
            timeout: null !== (e = t?.timeout) && void 0 !== e ? e : 1e3,
            eagerStart: !0,
            timeoutMessage: "Batch request timeout"
          });
          return this.Gs(r).catch(t => r.reject(t)), r.catch(t => {
            t instanceof im && this.Ks("Batch request timeout"), r.reject(t)
          }), r
        })
      }
      Gs(t) {
        return Fx(this, void 0, void 0, function*() {
          var e, r;
          const n = yield this.zs.sendBatch([...this.Hs.values()].map(t => t.payload));
          if (n.length !== this.Hs.size) throw this.Ks("Invalid batch response"), new ly(n, `Batch request size mismatch the results size. Requests: ${this.Hs.size}, Responses: ${n.length}`);
          const i = this.requests.map(t => t.id).map(Number).sort((t, e) => t - e),
            o = n.map(t => t.id).map(Number).sort((t, e) => t - e);
          if (JSON.stringify(i) !== JSON.stringify(o)) throw this.Ks("Invalid batch response"), new ly(n, `Batch request mismatch the results. Requests: [${i.join()}], Responses: [${o.join()}]`);
          for (const t of n) wE(t) ? null === (e = this.Hs.get(t.id)) || void 0 === e || e.promise.resolve(t.result) : AE(t) && (null === (r = this.Hs.get(t.id)) || void 0 === r || r.promise.reject(t.error));
          t.resolve(n)
        })
      }
      Ks(t) {
        for (const {
            promise: e
          }
          of this.Hs.values()) e.reject(new om(t))
      }
    }
    class zx extends zE {
      constructor(t) {
        var e;
        if (super(), this.providers = iP.providers, NT(t) || "string" == typeof t && "" !== t.trim() || tP(t)) return this.zs = new iP(t), void(this.ds = new sP(this.zs, {}));
        const {
          config: r,
          provider: n,
          requestManager: i,
          subscriptionManager: o,
          registeredSubscriptions: s,
          accountProvider: a,
          wallet: u,
          requestManagerMiddleware: c
        } = t;
        this.setConfig(r ?? {}), this.zs = i ?? new iP(n, null === (e = r?.enableExperimentalFeatures) || void 0 === e ? void 0 : e.useSubscriptionWhenCheckingBlockTimeout, c), this.ds = o || new sP(this.requestManager, s ?? {}), a && (this.fo = a), u && (this.Vs = u)
      }
      get requestManager() {
        return this.zs
      }
      get subscriptionManager() {
        return this.ds
      }
      get wallet() {
        return this.Vs
      }
      get accountProvider() {
        return this.fo
      }
      static fromContextObject(...t) {
        return new this(...t.reverse())
      }
      getContextObject() {
        var t;
        return {
          config: this.config,
          provider: this.provider,
          requestManager: this.requestManager,
          subscriptionManager: this.subscriptionManager,
          registeredSubscriptions: null === (t = this.subscriptionManager) || void 0 === t ? void 0 : t.registeredSubscriptions,
          providers: this.providers,
          wallet: this.wallet,
          accountProvider: this.accountProvider
        }
      }
      use(t, ...e) {
        const r = new t(...e, this.getContextObject());
        return this.on($E.CONFIG_CHANGE, t => {
          r.setConfig({
            [t.name]: t.newValue
          })
        }), this[t.name] = r, r
      }
      link(t) {
        this.setConfig(t.config), this.zs = t.requestManager, this.provider = t.provider, this.ds = t.subscriptionManager, this.Vs = t.wallet, this.fo = t.fo, t.on($E.CONFIG_CHANGE, t => {
          this.setConfig({
            [t.name]: t.newValue
          })
        })
      }
      registerPlugin(t) {
        if (void 0 !== this[t.pluginNamespace]) throw new am(t.pluginNamespace);
        const e = {
          [t.pluginNamespace]: t
        };
        e[t.pluginNamespace].link(this), Object.assign(this, e)
      }
      get provider() {
        return this.currentProvider
      }
      set provider(t) {
        this.requestManager.setProvider(t)
      }
      get currentProvider() {
        return this.requestManager.provider
      }
      set currentProvider(t) {
        this.requestManager.setProvider(t)
      }
      get givenProvider() {
        return zx.givenProvider
      }
      setProvider(t) {
        return this.provider = t, !0
      }
      setRequestManagerMiddleware(t) {
        this.requestManager.setMiddleware(t)
      }
      get BatchRequest() {
        return $x.bind(void 0, this.zs)
      }
      extend(t) {
        var e;
        return t.property && !this[t.property] && (this[t.property] = {}), null === (e = t.methods) || void 0 === e || e.forEach(e => {
          const r = (...t) => function(t, e, r, n) {
            return new(r || (r = Promise))(function(e, i) {
              function o(t) {
                try {
                  a(n.next(t))
                } catch (t) {
                  i(t)
                }
              }

              function s(t) {
                try {
                  a(n.throw(t))
                } catch (t) {
                  i(t)
                }
              }

              function a(t) {
                t.done ? e(t.value) : function(t) {
                  return t instanceof r ? t : new r(function(e) {
                    e(t)
                  })
                }(t.value).then(o, s)
              }
              a((n = n.call(t)).next())
            })
          }(this, 0, void 0, function*() {
            return this.requestManager.send({
              method: e.call,
              params: t
            })
          });
          t.property ? this[t.property][e.name] = r : this[e.name] = r
        }), this
      }
    }
    zx.providers = iP.providers;
    class Hx {
      constructor(t) {
        if (this.toAddress = () => {
            if (this.isDirect()) {
              const t = this.Zs.slice(4),
                e = Hx.Ht(t, 36),
                r = FT(e, 40);
              return gT(r)
            }
            throw Error("Iban is indirect and cannot be converted. Must be length of 34 or 35")
          }, !Hx.isIndirect(t) && !Hx.isDirect(t)) throw Error("Invalid IBAN was provided");
        this.Zs = t
      }
      static isDirect(t) {
        return 34 === t.length || 35 === t.length
      }
      isDirect() {
        return Hx.isDirect(this.Zs)
      }
      static isIndirect(t) {
        return 20 === t.length
      }
      isIndirect() {
        return Hx.isIndirect(this.Zs)
      }
      static isValid(t) {
        return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(t) && 1 === Hx.qs(Hx.Js(t))
      }
      isValid() {
        return Hx.isValid(this.Zs)
      }
      static fromBban(t) {
        const e = ("0" + (98 - this.qs(this.Js("XE00" + t)))).slice(-2);
        return new Hx(`XE${e}${t}`)
      }
      static createIndirect(t) {
        return Hx.fromBban(`ETH${t.institution}${t.identifier}`)
      }
      static fromAddress(t) {
        if (!PA(t)) throw new Xm(t);
        const e = BigInt(YA(t)).toString(36),
          r = FT(e, 15);
        return Hx.fromBban(r.toUpperCase())
      }
      static toIban(t) {
        return Hx.fromAddress(t).toString()
      }
      client() {
        return this.isIndirect() ? this.Zs.slice(11) : ""
      }
      checksum() {
        return this.Zs.slice(2, 4)
      }
      institution() {
        return this.isIndirect() ? this.Zs.slice(7, 11) : ""
      }
      toString() {
        return this.Zs
      }
    }
    Hx.Js = t => {
      const e = t.toUpperCase();
      return `${e.slice(4)}${e.slice(0,4)}`.split("").map(t => {
        const e = t.charCodeAt(0);
        return 65 > e || e > 90 ? t : e - 65 + 10
      }).join("")
    }, Hx.Ht = (t, e) => [...t].reduce((t, r) => BigInt(parseInt(r, e)) + BigInt(e) * t, BigInt(0)), Hx.qs = t => {
      let e, r = t;
      for (; r.length > 2;) e = r.slice(0, 9), r = `${""+parseInt(e,10)%97}${r.slice(e.length)}`;
      return parseInt(r, 10) % 97
    }, Hx.toAddress = t => new Hx(t).toAddress();
    var Gx, Kx = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class Vx extends FE {
      constructor(t) {
        super(), this[Gx] = "Promise", this.po = new Promise(t)
      }
      then(t, e) {
        return Kx(this, void 0, void 0, function*() {
          return this.po.then(t, e)
        })
      } catch (t) {
        return Kx(this, void 0, void 0, function*() {
          return this.po.catch(t)
        })
      } finally(t) {
        return Kx(this, void 0, void 0, function*() {
          return this.po.finally(t)
        })
      }
      on(t, e) {
        return super.on(t, e), this
      }
      once(t, e) {
        return super.once(t, e), this
      }
    }
    Gx = Symbol.toStringTag, i(42791);
    var Zx = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function qx(t) {
      return Zx(this, void 0, void 0, function*() {
        return t.send({
          method: "eth_syncing",
          params: []
        })
      })
    }

    function Jx(t, e) {
      return Zx(this, void 0, void 0, function*() {
        return FA.validate(["hex"], [e]), t.send({
          method: "eth_sendRawTransaction",
          params: [e]
        })
      })
    }

    function Yx(t, e, r) {
      return Zx(this, void 0, void 0, function*() {
        return FA.validate(["blockNumberOrTag", "bool"], [e, r]), t.send({
          method: "eth_getBlockByNumber",
          params: [e, r]
        })
      })
    }
    var Qx = function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              u(n.next(t))
            } catch (t) {
              o(t)
            }
          }

          function a(t) {
            try {
              u(n.throw(t))
            } catch (t) {
              o(t)
            }
          }

          function u(t) {
            t.done ? i(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(s, a)
          }
          u((n = n.apply(t, e || [])).next())
        })
      },
      Xx = function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              u(n.next(t))
            } catch (t) {
              o(t)
            }
          }

          function a(t) {
            try {
              u(n.throw(t))
            } catch (t) {
              o(t)
            }
          }

          function u(t) {
            t.done ? i(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(s, a)
          }
          u((n = n.apply(t, e || [])).next())
        })
      };
    const tI = {
        type: "object",
        properties: {
          accessList: {
            type: "null"
          },
          maxFeePerGas: {
            type: "null"
          },
          maxPriorityFeePerGas: {
            type: "null"
          }
        }
      },
      eI = {
        type: "object",
        properties: {
          maxFeePerGas: {
            type: "null"
          },
          maxPriorityFeePerGas: {
            type: "null"
          }
        }
      },
      rI = {
        type: "object",
        properties: {
          gasPrice: {
            type: "null"
          }
        }
      },
      nI = (t, e, r) => {
        try {
          FA.validateJSONSchema(t, e)
        } catch (t) {
          throw t instanceof Jw ? new Jm(t.errors, r) : t
        }
      },
      iI = t => {
        var e, r;
        const n = t;
        if (!RA(n.type)) {
          let t;
          switch (n.type) {
            case "0x0":
              t = tI;
              break;
            case "0x1":
              t = eI;
              break;
            case "0x2":
              t = rI;
              break;
            default:
              return JT({
                format: "uint"
              }, n.type, sb)
          }
          return nI(t, n, n.type), JT({
            format: "uint"
          }, n.type, sb)
        }
        if (!RA(n.maxFeePerGas) || !RA(n.maxPriorityFeePerGas)) return nI(rI, n, "0x2"), "0x2";
        if (!RA(n.accessList)) return nI(eI, n, "0x1"), "0x1";
        const i = null !== (e = n.hardfork) && void 0 !== e ? e : null === (r = n.common) || void 0 === r ? void 0 : r.hardfork;
        if (!RA(i)) {
          const t = Object.keys(ub).indexOf(i);
          if (t >= Object.keys(ub).indexOf("london")) return RA(n.gasPrice) ? "0x2" : "0x0";
          if (t === Object.keys(ub).indexOf("berlin")) return "0x0"
        }
        return RA(n.gasPrice) ? void 0 : (nI(tI, n, "0x0"), "0x0")
      },
      oI = (t, e) => {
        var r;
        return (null !== (r = e?.transactionTypeParser) && void 0 !== r ? r : iI)(t)
      },
      sI = t => t[0] > 127 ? "0x0" : dT(t[0]),
      aI = {
        type: "array",
        items: Object.assign({}, {
          type: "object",
          properties: {
            address: {
              format: "address"
            },
            storageKeys: {
              type: "array",
              items: {
                format: "bytes32"
              }
            }
          }
        })
      },
      uI = {
        type: "object",
        properties: {
          accessList: Object.assign({}, aI),
          gasUsed: {
            type: "string"
          }
        }
      },
      cI = {
        type: "string",
        enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
      },
      fI = {
        type: "string",
        enum: ["arrowGlacier", "berlin", "byzantium", "chainstart", "constantinople", "dao", "homestead", "istanbul", "london", "merge", "muirGlacier", "petersburg", "shanghai", "spuriousDragon", "tangerineWhistle"]
      },
      lI = {
        type: "object",
        properties: {
          from: {
            format: "address"
          },
          to: {
            oneOf: [{
              format: "address"
            }, {
              type: "null"
            }]
          },
          value: {
            format: "uint"
          },
          gas: {
            format: "uint"
          },
          gasPrice: {
            format: "uint"
          },
          effectiveGasPrice: {
            format: "uint"
          },
          type: {
            format: "uint"
          },
          maxFeePerGas: {
            format: "uint"
          },
          maxPriorityFeePerGas: {
            format: "uint"
          },
          accessList: Object.assign({}, aI),
          data: {
            format: "bytes"
          },
          input: {
            format: "bytes"
          },
          nonce: {
            format: "uint"
          },
          chain: Object.assign({}, cI),
          hardfork: Object.assign({}, fI),
          chainId: {
            format: "uint"
          },
          networkId: {
            format: "uint"
          },
          common: {
            type: "object",
            properties: {
              customChain: Object.assign({}, {
                type: "object",
                properties: {
                  name: {
                    format: "string"
                  },
                  networkId: {
                    format: "uint"
                  },
                  chainId: {
                    format: "uint"
                  }
                }
              }),
              baseChain: Object.assign({}, cI),
              hardfork: Object.assign({}, fI)
            }
          },
          gasLimit: {
            format: "uint"
          },
          v: {
            format: "uint"
          },
          r: {
            format: "bytes32"
          },
          s: {
            format: "bytes32"
          }
        }
      },
      hI = {
        type: "object",
        properties: Object.assign(Object.assign({}, lI.properties), {
          blockHash: {
            format: "bytes32"
          },
          blockNumber: {
            format: "uint"
          },
          hash: {
            format: "bytes32"
          },
          transactionIndex: {
            format: "uint"
          },
          from: {
            format: "address"
          },
          to: {
            oneOf: [{
              format: "address"
            }, {
              type: "null"
            }]
          },
          value: {
            format: "uint"
          },
          gas: {
            format: "uint"
          },
          gasPrice: {
            format: "uint"
          },
          effectiveGasPrice: {
            format: "uint"
          },
          type: {
            format: "uint"
          },
          maxFeePerGas: {
            format: "uint"
          },
          maxPriorityFeePerGas: {
            format: "uint"
          },
          accessList: Object.assign({}, aI),
          data: {
            format: "bytes"
          },
          input: {
            format: "bytes"
          },
          nonce: {
            format: "uint"
          },
          gasLimit: {
            format: "uint"
          },
          v: {
            format: "uint"
          },
          r: {
            format: "bytes32"
          },
          s: {
            format: "bytes32"
          }
        })
      },
      dI = {
        type: "object",
        properties: {
          index: {
            format: "uint"
          },
          validatorIndex: {
            format: "uint"
          },
          address: {
            format: "address"
          },
          amount: {
            format: "uint"
          }
        }
      },
      pI = {
        type: "object",
        properties: {
          baseFeePerGas: {
            format: "uint"
          },
          blobGasUsed: {
            format: "uint"
          },
          difficulty: {
            format: "uint"
          },
          excessBlobGas: {
            format: "uint"
          },
          extraData: {
            format: "bytes"
          },
          gasLimit: {
            format: "uint"
          },
          gasUsed: {
            format: "uint"
          },
          hash: {
            format: "bytes32"
          },
          logsBloom: {
            format: "bytes256"
          },
          miner: {
            format: "bytes"
          },
          mixHash: {
            format: "bytes32"
          },
          nonce: {
            format: "uint"
          },
          number: {
            format: "uint"
          },
          parentBeaconBlockRoot: {
            format: "bytes32"
          },
          parentHash: {
            format: "bytes32"
          },
          receiptsRoot: {
            format: "bytes32"
          },
          sha3Uncles: {
            format: "bytes32"
          },
          size: {
            format: "uint"
          },
          stateRoot: {
            format: "bytes32"
          },
          timestamp: {
            format: "uint"
          },
          totalDifficulty: {
            format: "uint"
          },
          transactions: {
            oneOf: [{
              type: "array",
              items: Object.assign({}, hI)
            }, {
              type: "array",
              items: {
                format: "bytes32"
              }
            }]
          },
          transactionsRoot: {
            format: "bytes32"
          },
          uncles: {
            type: "array",
            items: {
              format: "bytes32"
            }
          },
          withdrawals: {
            type: "array",
            items: Object.assign({}, dI)
          },
          withdrawalsRoot: {
            format: "bytes32"
          }
        }
      },
      bI = {
        type: "object",
        properties: {
          author: {
            format: "bytes32"
          },
          excessDataGas: {
            format: "uint"
          },
          baseFeePerGas: {
            format: "uint"
          },
          blobGasUsed: {
            format: "uint"
          },
          difficulty: {
            format: "uint"
          },
          excessBlobGas: {
            format: "uint"
          },
          extraData: {
            format: "bytes"
          },
          gasLimit: {
            format: "uint"
          },
          gasUsed: {
            format: "uint"
          },
          hash: {
            format: "bytes32"
          },
          logsBloom: {
            format: "bytes256"
          },
          miner: {
            format: "bytes"
          },
          mixHash: {
            format: "bytes32"
          },
          nonce: {
            format: "uint"
          },
          number: {
            format: "uint"
          },
          parentBeaconBlockRoot: {
            format: "bytes32"
          },
          parentHash: {
            format: "bytes32"
          },
          receiptsRoot: {
            format: "bytes32"
          },
          sha3Uncles: {
            format: "bytes32"
          },
          size: {
            format: "uint"
          },
          stateRoot: {
            format: "bytes32"
          },
          timestamp: {
            format: "uint"
          },
          totalDifficulty: {
            format: "uint"
          },
          transactions: {
            type: "array",
            items: {
              format: "bytes32"
            }
          },
          transactionsRoot: {
            format: "bytes32"
          },
          uncles: {
            type: "array",
            items: {
              format: "bytes32"
            }
          },
          withdrawals: {
            type: "array",
            items: Object.assign({}, dI)
          },
          withdrawalsRoot: {
            format: "bytes32"
          }
        }
      },
      mI = {
        type: "object",
        properties: {
          removed: {
            format: "bool"
          },
          logIndex: {
            format: "uint"
          },
          transactionIndex: {
            format: "uint"
          },
          transactionHash: {
            format: "bytes32"
          },
          blockHash: {
            format: "bytes32"
          },
          blockNumber: {
            format: "uint"
          },
          address: {
            format: "address"
          },
          data: {
            format: "bytes"
          },
          topics: {
            type: "array",
            items: {
              format: "bytes32"
            }
          }
        }
      },
      yI = {
        type: "object",
        properties: {
          startingBlock: {
            format: "string"
          },
          currentBlock: {
            format: "string"
          },
          highestBlock: {
            format: "string"
          },
          knownStates: {
            format: "string"
          },
          pulledStates: {
            format: "string"
          }
        }
      },
      gI = {
        type: "object",
        properties: {
          transactionHash: {
            format: "bytes32"
          },
          transactionIndex: {
            format: "uint"
          },
          blockHash: {
            format: "bytes32"
          },
          blockNumber: {
            format: "uint"
          },
          from: {
            format: "address"
          },
          to: {
            format: "address"
          },
          cumulativeGasUsed: {
            format: "uint"
          },
          gasUsed: {
            format: "uint"
          },
          effectiveGasPrice: {
            format: "uint"
          },
          contractAddress: {
            format: "address"
          },
          logs: {
            type: "array",
            items: Object.assign({}, mI)
          },
          logsBloom: {
            format: "bytes"
          },
          root: {
            format: "bytes"
          },
          status: {
            format: "uint"
          },
          type: {
            format: "uint"
          }
        }
      },
      vI = {
        type: "object",
        properties: {
          messageHash: {
            format: "bytes"
          },
          r: {
            format: "bytes32"
          },
          s: {
            format: "bytes32"
          },
          v: {
            format: "bytes"
          },
          message: {
            format: "bytes"
          },
          signature: {
            format: "bytes"
          }
        }
      },
      wI = {
        type: "object",
        properties: {
          oldestBlock: {
            format: "uint"
          },
          baseFeePerGas: {
            type: "array",
            items: {
              format: "uint"
            }
          },
          reward: {
            type: "array",
            items: {
              type: "array",
              items: {
                format: "uint"
              }
            }
          },
          gasUsedRatio: {
            type: "array",
            items: {
              type: "number"
            }
          }
        }
      },
      AI = {
        type: "object",
        properties: {
          balance: {
            format: "uint"
          },
          codeHash: {
            format: "bytes32"
          },
          nonce: {
            format: "uint"
          },
          storageHash: {
            format: "bytes32"
          },
          accountProof: {
            type: "array",
            items: {
              format: "bytes32"
            }
          },
          storageProof: {
            type: "array",
            items: Object.assign({}, {
              type: "object",
              properties: {
                key: {
                  format: "bytes32"
                },
                value: {
                  format: "uint"
                },
                proof: {
                  type: "array",
                  items: {
                    format: "bytes32"
                  }
                }
              }
            })
          }
        }
      };

    function TI(t, e = ob, r = {
      transactionSchema: hI,
      fillInputAndData: !1
    }) {
      var n, i;
      let o = _T({}, t);
      if (RA(t?.common) || (o.common = Object.assign({}, t.common), RA(null === (n = t.common) || void 0 === n ? void 0 : n.customChain) || (o.common.customChain = Object.assign({}, t.common.customChain))), o = JT(null !== (i = r.transactionSchema) && void 0 !== i ? i : hI, o, e), !RA(o.data) && !RA(o.input) && dT(o.data) !== dT(o.input)) throw new Fm({
        data: qA(o.data),
        input: qA(o.input)
      });
      return r.fillInputAndData && (RA(o.data) ? RA(o.input) || (o.data = o.input) : o.input = o.data), RA(o.gasLimit) || (o.gas = o.gasLimit, delete o.gasLimit), o
    }
    var EI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function PI(t, e) {
      return EI(this, void 0, void 0, function*() {
        const r = yield function(t) {
          return Qx(this, void 0, void 0, function*() {
            return t.send({
              method: "net_version",
              params: []
            })
          })
        }(t.requestManager);
        return JT({
          format: "uint"
        }, r, e)
      })
    }
    const kI = t => EI(void 0, void 0, void 0, function*() {
      return function(t) {
        return Qx(this, void 0, void 0, function*() {
          return t.send({
            method: "net_listening",
            params: []
          })
        })
      }(t.requestManager)
    });
    var xI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class II extends zx {
      getId(t = this.defaultReturnFormat) {
        return xI(this, void 0, void 0, function*() {
          return PI(this, t)
        })
      }
      getPeerCount(t = this.defaultReturnFormat) {
        return xI(this, void 0, void 0, function*() {
          return function(t, e) {
            return EI(this, void 0, void 0, function*() {
              const r = yield function(t) {
                return Qx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "net_peerCount",
                    params: []
                  })
                })
              }(t.requestManager);
              return JT({
                format: "uint"
              }, r, e)
            })
          }(this, t)
        })
      }
      isListening() {
        return xI(this, void 0, void 0, function*() {
          return kI(this)
        })
      }
    }
    const SI = "ALLEVENTS",
      OI = {
        name: SI,
        signature: "",
        type: "event",
        inputs: []
      },
      BI = {
        bytes: ib.HEX,
        number: nb.NUMBER
      };
    var WI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function MI(t, e, r) {
      return WI(this, void 0, void 0, function*() {
        const n = NI(t, e);
        if (!RA(n)) {
          if (n.startsWith("-")) throw new Lm(n);
          if (0 > +n || +n > 127) throw new Lm(n);
          if (RA(t.gasPrice) && ("0x0" === n || "0x1" === n)) return {
            gasPrice: yield iO(e, r),
            maxPriorityFeePerGas: void 0,
            maxFeePerGas: void 0
          };
          if ("0x2" === n) return Object.assign({
            gasPrice: void 0
          }, yield function(t, e, r) {
            return WI(this, void 0, void 0, function*() {
              var n, i, o, s;
              const a = yield sO(e, e.defaultBlock, !1, sb);
              if (RA(a.baseFeePerGas)) throw new Um;
              let u;
              if (RA(t.gasPrice) && BigInt(a.baseFeePerGas) === BigInt(0) && (u = yield iO(e, r)), !RA(t.gasPrice) || !RA(u)) {
                const e = JT({
                  format: "uint"
                }, null !== (n = t.gasPrice) && void 0 !== n ? n : u, r);
                return {
                  maxPriorityFeePerGas: e,
                  maxFeePerGas: e
                }
              }
              return {
                maxPriorityFeePerGas: JT({
                  format: "uint"
                }, null !== (i = t.maxPriorityFeePerGas) && void 0 !== i ? i : e.defaultMaxPriorityFeePerGas, r),
                maxFeePerGas: JT({
                  format: "uint"
                }, null !== (o = t.maxFeePerGas) && void 0 !== o ? o : BigInt(a.baseFeePerGas) * BigInt(2) + BigInt(null !== (s = t.maxPriorityFeePerGas) && void 0 !== s ? s : e.defaultMaxPriorityFeePerGas), r)
              }
            })
          }(t, e, r))
        }
      })
    }
    var CI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const RI = (t, e, r, n) => {
        if (void 0 !== r && t in r && void 0 !== r[t]) {
          if ("string" == typeof r[t] && PA(r[t])) return r[t];
          if (!tA(r[t]) && SA(r[t])) {
            if (e.wallet) {
              const n = e.wallet.get(JT({
                format: "uint"
              }, r[t], BI));
              if (!RA(n)) return n.address;
              throw new qm
            }
            throw new qm
          }
          throw "from" === t ? new vm(r.from) : new wm(r.to)
        }
        if ("from" === t) {
          if (!RA(n)) return _x(n);
          if (!RA(e.defaultAccount)) return e.defaultAccount
        }
      },
      NI = (t, e) => {
        const r = oI(t, e);
        return RA(r) ? RA(e.defaultTransactionType) ? void 0 : JT({
          format: "uint"
        }, e.defaultTransactionType, sb) : r
      };

    function jI(t) {
      return CI(this, void 0, void 0, function*() {
        var e, r;
        let n = JT(lI, t.transaction, t.web3Context.defaultReturnFormat);
        if (RA(n.from) && (n.from = RI("from", t.web3Context, void 0, t.privateKey)), RA(n.nonce) && (n.nonce = yield((t, e, ...r) => CI(void 0, [t, e, ...r], void 0, function*(t, e, r = t.defaultReturnFormat) {
            if (RA(e)) throw new Dm;
            return uO(t, e, t.defaultBlock, r)
          }))(t.web3Context, n.from, sb)), RA(n.value) && (n.value = "0x0"), RA(n.data)) RA(n.input) ? n.input = "0x" : n.input.startsWith("0x") || (n.input = "0x" + n.input);
        else {
          if (!RA(n.input) && n.data !== n.input) throw new Fm({
            data: qA(n.data),
            input: qA(n.input)
          });
          n.data.startsWith("0x") || (n.data = "0x" + n.data)
        }
        if (RA(n.common)) {
          if (t.web3Context.defaultCommon) {
            const e = t.web3Context.defaultCommon,
              r = e.customChain.chainId,
              i = e.customChain.networkId,
              o = e.customChain.name;
            n.common = Object.assign(Object.assign({}, e), {
              customChain: {
                chainId: r,
                networkId: i,
                name: o
              }
            })
          }
          RA(n.chain) && (n.chain = t.web3Context.defaultChain), RA(n.hardfork) && (n.hardfork = t.web3Context.defaultHardfork)
        }
        if (RA(n.chainId) && RA(null === (e = n.common) || void 0 === e ? void 0 : e.customChain.chainId) && (n.chainId = yield dO(t.web3Context, sb)), RA(n.networkId) && (n.networkId = null !== (r = t.web3Context.defaultNetworkId) && void 0 !== r ? r : yield PI(t.web3Context, sb)), RA(n.gasLimit) && !RA(n.gas) && (n.gasLimit = n.gas), n.type = NI(n, t.web3Context), RA(n.accessList) && ("0x1" === n.type || "0x2" === n.type) && (n.accessList = []), t.fillGasPrice && (n = Object.assign(Object.assign({}, n), yield MI(n, t.web3Context, sb))), RA(n.gas) && RA(n.gasLimit) && t.fillGasLimit) {
          const e = yield lO(t.web3Context, n, "latest", sb);
          n = Object.assign(Object.assign({}, n), {
            gas: JT({
              format: "uint"
            }, e, sb)
          })
        }
        return n
      })
    }
    var _I = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function DI(t, e, r) {
      const n = t.transactionPollingInterval,
        [i, o] = yE(() => _I(this, void 0, void 0, function*() {
          let n;
          try {
            n = yield oO(t, BI)
          } catch (t) {
            return void console.warn("An error happen while trying to get the block number", t)
          }
          const i = n - e;
          if (i >= t.transactionBlockTimeout) return new Gm({
            starterBlockNumber: e,
            numberOfBlocks: i,
            transactionHash: r
          })
        }), n);
      return [o, {
        clean: () => {
          clearInterval(i)
        }
      }]
    }

    function UI(t, e) {
      return _I(this, void 0, void 0, function*() {
        var r, n;
        const {
          provider: i
        } = t.requestManager;
        let o;
        const s = yield oO(t, BI);
        return o = null !== (n = (r = i).supportsSubscriptions) && void 0 !== n && n.call(r) && t.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout ? yield function(t, e, r) {
          return _I(this, void 0, void 0, function*() {
            var n;
            let i, o, s = !0;

            function a(n, i) {
              i && console.warn("error happened at subscription. So revert to polling...", i), o.clean(), s = !1;
              const [a, u] = DI(t, e, r);
              o.clean = u.clean, a.catch(t => n(t))
            }
            try {
              i = yield null === (n = t.subscriptionManager) || void 0 === n ? void 0 : n.subscribe("newHeads"), o = {
                clean: () => {
                  var e;
                  i.id && (null === (e = t.subscriptionManager) || void 0 === e || e.removeSubscription(i).then(() => {}).catch(() => {}))
                }
              }
            } catch {
              return DI(t, e, r)
            }
            return [new Promise((n, o) => {
              try {
                i.on("data", n => {
                  if (s = !1, !n?.number) return;
                  const i = +(BigInt(n.number) - BigInt(e));
                  i >= t.transactionBlockTimeout && o(new Gm({
                    starterBlockNumber: e,
                    numberOfBlocks: i,
                    transactionHash: r
                  }))
                }), i.on("error", t => {
                  a(o, t)
                })
              } catch (t) {
                a(o, t)
              }
              setTimeout(() => {
                s && a(o)
              }, 1e3 * t.blockHeaderTimeout)
            }), o]
          })
        }(t, s, e): DI(t, s, e), o
      })
    }

    function LI(t, e, r) {
      return function(t, e, r, n) {
        return new(r || (r = Promise))(function(e, i) {
          function o(t) {
            try {
              a(n.next(t))
            } catch (t) {
              i(t)
            }
          }

          function s(t) {
            try {
              a(n.throw(t))
            } catch (t) {
              i(t)
            }
          }

          function a(t) {
            t.done ? e(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(o, s)
          }
          a((n = n.call(t)).next())
        })
      }(this, 0, void 0, function*() {
        const [n, i] = mE(t.transactionSendTimeout, new $m({
          numberOfSeconds: t.transactionSendTimeout / 1e3,
          transactionHash: r
        })), [o, s] = yield UI(t, r);
        try {
          return yield Promise.race([e(), i, o])
        } finally {
          clearTimeout(n), s.clean()
        }
      })
    }
    var FI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function $I(t, e, r, n) {
      return FI(this, void 0, void 0, function*() {
        var i;
        const o = null !== (i = t.transactionReceiptPollingInterval) && void 0 !== i ? i : t.transactionPollingInterval,
          [s, a] = pE(() => FI(this, void 0, void 0, function*() {
            try {
              return (n ?? aO)(t, e, r)
            } catch (t) {
              return void console.warn("An error happen while trying to get the transaction receipt", t)
            }
          }), o),
          [u, c] = mE(t.transactionPollingTimeout, new Hm({
            numberOfSeconds: t.transactionPollingTimeout / 1e3,
            transactionHash: e
          })),
          [f, l] = yield UI(t, e);
        try {
          return yield Promise.race([s, c, f])
        } finally {
          u && clearTimeout(u), a && clearInterval(a), l.clean()
        }
      })
    }
    const zI = ({
      web3Context: t,
      transactionReceipt: e,
      transactionPromiEvent: r,
      customTransactionReceiptSchema: n,
      returnFormat: i
    }) => {
      var o;
      let s = 1;
      const a = setInterval(() => {
        ! function(t, e, r, n) {
          new(r || (r = Promise))(function(t, e) {
            function i(t) {
              try {
                s(n.next(t))
              } catch (t) {
                e(t)
              }
            }

            function o(t) {
              try {
                s(n.throw(t))
              } catch (t) {
                e(t)
              }
            }

            function s(e) {
              e.done ? t(e.value) : function(t) {
                return t instanceof r ? t : new r(function(e) {
                  e(t)
                })
              }(e.value).then(i, o)
            }
            s((n = n.call(undefined)).next())
          })
        }(0, 0, void 0, function*() {
          if (s >= t.transactionConfirmationBlocks) return void clearInterval(a);
          const o = yield Yx(t.requestManager, XA(BigInt(e.blockNumber) + BigInt(s)), !1);
          o?.hash && (s += 1, r.emit("confirmation", {
            confirmations: JT({
              format: "uint"
            }, s, i),
            receipt: JT(n ?? gI, e, i),
            latestBlockHash: JT({
              format: "bytes32"
            }, o.hash, i)
          }))
        })
      }, null !== (o = t.transactionReceiptPollingInterval) && void 0 !== o ? o : t.transactionPollingInterval)
    };
    var HI = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const GI = t => !NT(t) && "object" == typeof t && !NT(t.type) && "error" === t.type,
      KI = t => !NT(t) && "object" == typeof t && !NT(t.type) && "event" === t.type,
      VI = t => !NT(t) && "object" == typeof t && !NT(t.type) && "function" === t.type,
      ZI = t => t.includes("[]") ? {
        type: "tuple[]",
        name: t.slice(0, -2)
      } : {
        type: "tuple",
        name: t
      },
      qI = t => {
        const e = [];
        for (const r of Object.keys(t)) {
          const n = t[r];
          "object" == typeof n ? e.push(Object.assign(Object.assign({}, ZI(r)), {
            components: qI(n)
          })) : e.push({
            name: r,
            type: t[r]
          })
        }
        return e
      },
      JI = (t, e) => {
        const r = [];
        return e.forEach(e => {
          if ("object" == typeof e.components) {
            if (!e.type.startsWith("tuple")) throw new sm(`Invalid value given "${e.type}". Error: components found but type is not tuple.`);
            const n = e.type.indexOf("["),
              i = 0 > n ? "" : e.type.substring(n),
              o = JI(t, e.components);
            Array.isArray(o) && t ? r.push(`tuple(${o.join(",")})${i}`) : t ? r.push(`(${o.join()})`) : r.push(`(${o.join(",")})${i}`)
          } else r.push(e.type)
        }), r
      },
      YI = t => {
        var e, r, n, i;
        return GI(t) || KI(t) || VI(t) ? null !== (e = t.name) && void 0 !== e && e.includes("(") ? t.name : `${null!==(r=t.name)&&void 0!==r?r:""}(${JI(!1,null!==(n=t.inputs)&&void 0!==n?n:[]).join(",")})` : `(${JI(!1,null!==(i=t.inputs)&&void 0!==i?i:[]).join(",")})`
      },
      QI = t => {
        if ("string" != typeof t && !KI(t)) throw new sm("Invalid parameter value in encodeEventSignature");
        let e;
        return e = !t || "function" != typeof t && "object" != typeof t ? t : YI(t), tE(e)
      };

    function XI(t, e) {
      return t.exec(e)?.groups
    }
    var tS = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,
      eS = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/,
      rS = /^\(.+?\).*?$/,
      nS = Object.defineProperty,
      iS = (t, e, r) => (((t, e, r) => {
        e in t ? nS(t, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: r
        }) : t[e] = r
      })(t, "symbol" != typeof e ? e + "" : e, r), r),
      oS = class extends Error {
        constructor(t, e = {}) {
          const r = e.cause instanceof oS ? e.cause.details : e.cause?.message ? e.cause.message : e.details,
            n = e.cause instanceof oS && e.cause.docsPath || e.docsPath;
          super([t || "An error occurred.", "", ...e.metaMessages ? [...e.metaMessages, ""] : [], ...n ? ["Docs: https://abitype.dev" + n] : [], ...r ? ["Details: " + r] : [], "Version: abitype@0.7.1"].join("\n")), iS(this, "details"), iS(this, "docsPath"), iS(this, "metaMessages"), iS(this, "shortMessage"), iS(this, "name", "AbiTypeError"), e.cause && (this.cause = e.cause), this.details = r, this.docsPath = n, this.metaMessages = e.metaMessages, this.shortMessage = t
        }
      },
      sS = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;

    function aS(t) {
      return sS.test(t)
    }

    function uS(t) {
      return XI(sS, t)
    }
    var cS = new Set(["memory", "indexed", "storage", "calldata"]),
      fS = (new Set(["indexed"]), new Set(["calldata", "memory", "storage"])),
      lS = new Map([
        ["address", {
          type: "address"
        }],
        ["bool", {
          type: "bool"
        }],
        ["bytes", {
          type: "bytes"
        }],
        ["bytes32", {
          type: "bytes32"
        }],
        ["int", {
          type: "int256"
        }],
        ["int256", {
          type: "int256"
        }],
        ["string", {
          type: "string"
        }],
        ["uint", {
          type: "uint256"
        }],
        ["uint8", {
          type: "uint8"
        }],
        ["uint16", {
          type: "uint16"
        }],
        ["uint24", {
          type: "uint24"
        }],
        ["uint32", {
          type: "uint32"
        }],
        ["uint64", {
          type: "uint64"
        }],
        ["uint96", {
          type: "uint96"
        }],
        ["uint112", {
          type: "uint112"
        }],
        ["uint160", {
          type: "uint160"
        }],
        ["uint192", {
          type: "uint192"
        }],
        ["uint256", {
          type: "uint256"
        }],
        ["address owner", {
          type: "address",
          name: "owner"
        }],
        ["address to", {
          type: "address",
          name: "to"
        }],
        ["bool approved", {
          type: "bool",
          name: "approved"
        }],
        ["bytes _data", {
          type: "bytes",
          name: "_data"
        }],
        ["bytes data", {
          type: "bytes",
          name: "data"
        }],
        ["bytes signature", {
          type: "bytes",
          name: "signature"
        }],
        ["bytes32 hash", {
          type: "bytes32",
          name: "hash"
        }],
        ["bytes32 r", {
          type: "bytes32",
          name: "r"
        }],
        ["bytes32 root", {
          type: "bytes32",
          name: "root"
        }],
        ["bytes32 s", {
          type: "bytes32",
          name: "s"
        }],
        ["string name", {
          type: "string",
          name: "name"
        }],
        ["string symbol", {
          type: "string",
          name: "symbol"
        }],
        ["string tokenURI", {
          type: "string",
          name: "tokenURI"
        }],
        ["uint tokenId", {
          type: "uint256",
          name: "tokenId"
        }],
        ["uint8 v", {
          type: "uint8",
          name: "v"
        }],
        ["uint256 balance", {
          type: "uint256",
          name: "balance"
        }],
        ["uint256 tokenId", {
          type: "uint256",
          name: "tokenId"
        }],
        ["uint256 value", {
          type: "uint256",
          name: "value"
        }],
        ["event:address indexed from", {
          type: "address",
          name: "from",
          indexed: !0
        }],
        ["event:address indexed to", {
          type: "address",
          name: "to",
          indexed: !0
        }],
        ["event:uint indexed tokenId", {
          type: "uint256",
          name: "tokenId",
          indexed: !0
        }],
        ["event:uint256 indexed tokenId", {
          type: "uint256",
          name: "tokenId",
          indexed: !0
        }]
      ]),
      hS = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
      dS = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/,
      pS = /^u?int$/;

    function bS(t, e) {
      const r = function(t, e) {
        return e ? `${e}:${t}` : t
      }(t, e?.type);
      if (lS.has(r)) return lS.get(r);
      const n = rS.test(t),
        i = XI(n ? dS : hS, t);
      if (!i) throw new oS("Invalid ABI parameter.", {
        details: t
      });
      if (i.name && function(t) {
          return "address" === t || "bool" === t || "function" === t || "string" === t || "tuple" === t || tS.test(t) || eS.test(t) || gS.test(t)
        }(i.name)) throw new oS("Invalid ABI parameter.", {
        details: t,
        metaMessages: [`"${i.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`]
      });
      const o = i.name ? {
          name: i.name
        } : {},
        s = "indexed" === i.modifier ? {
          indexed: !0
        } : {},
        a = e?.structs ?? {};
      let u, c = {};
      if (n) {
        u = "tuple";
        const t = mS(i.type),
          e = [],
          r = t.length;
        for (let n = 0; r > n; n++) e.push(bS(t[n], {
          structs: a
        }));
        c = {
          components: e
        }
      } else if (i.type in a) u = "tuple", c = {
        components: a[i.type]
      };
      else if (pS.test(i.type)) u = i.type + "256";
      else if (u = i.type, "struct" !== e?.type && !yS(u)) throw new oS("Unknown type.", {
        metaMessages: [`Type "${u}" is not a valid ABI type.`]
      });
      if (i.modifier) {
        if (!e?.modifiers?.has?.(i.modifier)) throw new oS("Invalid ABI parameter.", {
          details: t,
          metaMessages: [`Modifier "${i.modifier}" not allowed${e?.type?` in "${e.type}" type`:""}.`]
        });
        if (fS.has(i.modifier) && ! function(t, e) {
            return e || "bytes" === t || "string" === t || "tuple" === t
          }(u, !!i.array)) throw new oS("Invalid ABI parameter.", {
          details: t,
          metaMessages: [`Modifier "${i.modifier}" not allowed${e?.type?` in "${e.type}" type`:""}.`, `Data location can only be specified for array, struct, or mapping types, but "${i.modifier}" was given.`]
        })
      }
      const f = {
        type: `${u}${i.array??""}`,
        ...o,
        ...s,
        ...c
      };
      return lS.set(r, f), f
    }

    function mS(t, e = [], r = "", n = 0) {
      if ("" === t) {
        if ("" === r) return e;
        if (0 !== n) throw new oS("Unbalanced parentheses.", {
          metaMessages: [`"${r.trim()}" has too many ${n>0?"opening":"closing"} parentheses.`],
          details: `Depth "${n}"`
        });
        return [...e, r.trim()]
      }
      const i = t.length;
      for (let o = 0; i > o; o++) {
        const i = t[o],
          s = t.slice(o + 1);
        switch (i) {
          case ",":
            return 0 === n ? mS(s, [...e, r.trim()]) : mS(s, e, `${r}${i}`, n);
          case "(":
            return mS(s, e, `${r}${i}`, n + 1);
          case ")":
            return mS(s, e, `${r}${i}`, n - 1);
          default:
            return mS(s, e, `${r}${i}`, n)
        }
      }
      return []
    }

    function yS(t) {
      return "address" === t || "bool" === t || "function" === t || "string" === t || tS.test(t) || eS.test(t)
    }
    var gS = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/,
      vS = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;

    function wS(t, e, r = new Set) {
      const n = [],
        i = t.length;
      for (let o = 0; i > o; o++) {
        const i = t[o];
        if (rS.test(i.type)) n.push(i);
        else {
          const t = XI(vS, i.type);
          if (!t?.type) throw new oS("Invalid ABI parameter.", {
            details: JSON.stringify(i, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
          const {
            array: o,
            type: s
          } = t;
          if (s in e) {
            if (r.has(s)) throw new oS("Circular reference detected.", {
              metaMessages: [`Struct "${s}" is a circular reference.`]
            });
            n.push({
              ...i,
              type: "tuple" + (o ?? ""),
              components: wS(e[s] ?? [], e, new Set([...r, s]))
            })
          } else {
            if (!yS(s)) throw new oS("Unknown type.", {
              metaMessages: [`Type "${s}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`]
            });
            n.push(i)
          }
        }
      }
      return n
    }
    const AS = 32;

    function TS(t = 0) {
      var e;
      if (void 0 !== (null === (e = globalThis.Buffer) || void 0 === e ? void 0 : e.alloc)) {
        const e = globalThis.Buffer.alloc(t);
        return new Uint8Array(e.buffer, e.byteOffset, e.byteLength)
      }
      return new Uint8Array(t)
    }

    function ES(t) {
      var e, r;
      return Object.assign(Object.assign({}, t), {
        name: null !== (e = t.name) && void 0 !== e ? e : "",
        components: null === (r = t.components) || void 0 === r ? void 0 : r.map(t => ES(t))
      })
    }

    function PS(t) {
      return t.map(t => {
        var e;
        if (function(t) {
            return !NT(t) && "object" == typeof t && !NT(t.type) && "string" == typeof t.type
          }(t)) return t;
        if ("string" == typeof t) return ES(function(t) {
          let e;
          if ("string" == typeof t) e = bS(t, {
            modifiers: cS
          });
          else {
            const r = function(t) {
                const e = {},
                  r = t.length;
                for (let n = 0; r > n; n++) {
                  const r = t[n];
                  if (!aS(r)) continue;
                  const i = uS(r);
                  if (!i) throw new oS("Invalid struct signature.", {
                    details: r
                  });
                  const o = i.properties.split(";"),
                    s = [],
                    a = o.length;
                  for (let t = 0; a > t; t++) {
                    const e = o[t].trim();
                    if (!e) continue;
                    const r = bS(e, {
                      type: "struct"
                    });
                    s.push(r)
                  }
                  if (!s.length) throw new oS("Invalid struct signature.", {
                    details: r,
                    metaMessages: ["No properties exist."]
                  });
                  e[i.name] = s
                }
                const n = {},
                  i = Object.entries(e),
                  o = i.length;
                for (let t = 0; o > t; t++) {
                  const [r, o] = i[t];
                  n[r] = wS(o, e)
                }
                return n
              }(t),
              n = t.length;
            for (let i = 0; n > i; i++) {
              const n = t[i];
              if (!aS(n)) {
                e = bS(n, {
                  modifiers: cS,
                  structs: r
                });
                break
              }
            }
          }
          if (!e) throw new oS("Failed to parse ABI parameter.", {
            details: `parseAbiParameter(${JSON.stringify(t,null,2)})`,
            docsPath: "/api/human.html#parseabiparameter-1"
          });
          return e
        }(t.replace(/tuple/, "")));
        if ((t => "object" == typeof t && typeof t.components > "u" && typeof t.name > "u")(t)) {
          const r = Object.keys(t)[0],
            n = ZI(r);
          return n.name = null !== (e = n.name) && void 0 !== e ? e : "", Object.assign(Object.assign({}, n), {
            components: qI(t[r])
          })
        }
        throw new sm("Invalid abi")
      })
    }

    function kS(t) {
      const e = t.type.lastIndexOf("["),
        r = t.type.substring(0, e),
        n = t.type.substring(e);
      let i = -1;
      if ("[]" !== n && (i = +n.slice(1, -1), isNaN(i))) throw new sm("Invalid fixed array size", {
        size: n
      });
      return {
        param: {
          type: r,
          name: "",
          components: t.components
        },
        size: i
      }
    }

    function xS(t) {
      var e, r;
      return !("string" !== t.type && "bytes" !== t.type && !t.type.endsWith("[]")) || ("tuple" === t.type ? null !== (r = null === (e = t.components) || void 0 === e ? void 0 : e.some(xS)) && void 0 !== r && r : !!t.type.endsWith("]") && xS(kS(t).param))
    }
    const IS = new Map;
    let SS = BigInt(256);
    for (let t = 8; 256 >= t; t += 8) IS.set("uint" + t, {
      min: BigInt(0),
      max: SS - BigInt(1)
    }), IS.set("int" + t, {
      min: -SS / BigInt(2),
      max: SS / BigInt(2) - BigInt(1)
    }), SS *= BigInt(256);
    IS.set("int", IS.get("int256")), IS.set("uint", IS.get("uint256"));
    const OS = BigInt(1) << BigInt(256);

    function BS(t, e = 32) {
      let r;
      return r = 0 > t ? (OS + t).toString(16) : t.toString(16), r = DT(r, 2 * e), vA(r)
    }

    function WS(t, e) {
      let r;
      try {
        r = bT(e)
      } catch {
        throw new sm("provided input is not number value", {
          type: t.type,
          value: e,
          name: t.name
        })
      }
      const n = IS.get(t.type);
      if (!n) throw new sm("provided abi contains invalid number datatype", {
        type: t.type
      });
      if (r < n.min) throw new sm("provided input is less then minimum for given type", {
        type: t.type,
        value: e,
        name: t.name,
        minimum: n.min.toString()
      });
      if (r > n.max) throw new sm("provided input is greater then maximum for given type", {
        type: t.type,
        value: e,
        name: t.name,
        maximum: n.max.toString()
      });
      return {
        dynamic: !1,
        encoded: BS(r)
      }
    }

    function MS(t, e) {
      if (e.length < AS) throw new sm("Not enough bytes left to decode", {
        param: t,
        bytesLeft: e.length
      });
      const r = e.subarray(0, AS),
        n = IS.get(t.type);
      if (!n) throw new sm("provided abi contains invalid number datatype", {
        type: t.type
      });
      const i = function(t, e) {
        const r = mA(t),
          n = BigInt(r);
        return n > e ? n - OS : n
      }(r, n.max);
      if (i < n.min) throw new sm("decoded value is less then minimum for given type", {
        type: t.type,
        value: i,
        name: t.name,
        minimum: n.min.toString()
      });
      if (i > n.max) throw new sm("decoded value is greater then maximum for given type", {
        type: t.type,
        value: i,
        name: t.name,
        maximum: n.max.toString()
      });
      return {
        result: i,
        encoded: e.subarray(AS),
        consumed: AS
      }
    }

    function CS(t, e) {
      if ("string" == typeof e && e.length % 2 != 0 && (e += "0"), !TA(e)) throw new sm("provided input is not valid bytes value", {
        type: t.type,
        value: e,
        name: t.name
      });
      const r = VA(e),
        [, n] = t.type.split("bytes");
      if (n) {
        if (+n > 32 || 1 > +n) throw new sm("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
          type: t.type
        });
        if (+n < r.length) throw new sm("provided input size is different than type size", {
          type: t.type,
          value: e,
          name: t.name
        });
        const i = TS(AS);
        return i.set(r), {
          dynamic: !1,
          encoded: i
        }
      }
      const i = Math.ceil(r.length / AS),
        o = TS(AS + i * AS);
      return o.set(WS({
        type: "uint32",
        name: ""
      }, r.length).encoded), o.set(r, AS), {
        dynamic: !0,
        encoded: o
      }
    }

    function RS(t, e) {
      const [, r] = t.type.split("bytes");
      let n = +r,
        i = e,
        o = 1,
        s = 0;
      if (!n) {
        const t = MS({
          type: "uint32",
          name: ""
        }, i);
        n = +t.result, s += t.consumed, i = t.encoded, o = Math.ceil(n / AS)
      }
      if (n > e.length) throw new sm("there is not enough data to decode", {
        type: t.type,
        encoded: e,
        size: n
      });
      return {
        result: qA(i.subarray(0, n)),
        encoded: i.subarray(o * AS),
        consumed: s + o * AS
      }
    }

    function NS(t) {
      let e = 0,
        r = 0;
      const n = [],
        i = [];
      for (const r of t) r.dynamic ? e += AS : e += r.encoded.length;
      for (const o of t) o.dynamic ? (n.push(WS({
        type: "uint256",
        name: ""
      }, e + r)), i.push(o), r += o.encoded.length) : n.push(o);
      return zA(...n.map(t => t.encoded), ...i.map(t => t.encoded))
    }

    function jS(t, e) {
      if ("string" === t.type) return function(t, e) {
        if ("string" != typeof e) throw new sm("invalid input, should be string", {
          input: e
        });
        return CS({
          type: "bytes",
          name: ""
        }, aT(e))
      }(0, e);
      if ("bool" === t.type) return function(t, e) {
        let r;
        try {
          r = vT(e)
        } catch (r) {
          if (r instanceof oy) throw new sm("provided input is not valid boolean value", {
            type: t.type,
            value: e,
            name: t.name
          })
        }
        return WS({
          type: "uint8",
          name: ""
        }, +r)
      }(t, e);
      if ("address" === t.type) return function(t, e) {
        if ("string" != typeof e) throw new sm("address type expects string as input type", {
          value: e,
          name: t.name,
          type: t.type
        });
        let r = e.toLowerCase();
        if (r.startsWith("0x") || (r = "0x" + r), !PA(r)) throw new sm("provided input is not valid address", {
          value: e,
          name: t.name,
          type: t.type
        });
        const n = vA(r),
          i = TS(AS);
        return i.set(n, 12), {
          dynamic: !1,
          encoded: i
        }
      }(t, e);
      if ("tuple" === t.type) return DS(t, e);
      if (t.type.endsWith("]")) return function(t, e) {
        if (!Array.isArray(e)) throw new sm("Expected value to be array", {
          abi: t,
          values: e
        });
        const {
          size: r,
          param: n
        } = kS(t), i = e.map(t => jS(n, t)), o = -1 === r, s = i.length > 0 && i[0].dynamic;
        if (!o && e.length !== r) throw new sm("Given arguments count doesn't match array length", {
          arrayLength: r,
          argumentsLength: e.length
        });
        if (o || s) {
          const t = NS(i);
          if (o) {
            const e = WS({
              type: "uint256",
              name: ""
            }, i.length).encoded;
            return {
              dynamic: !0,
              encoded: i.length > 0 ? zA(e, t) : e
            }
          }
          return {
            dynamic: !0,
            encoded: t
          }
        }
        return {
          dynamic: !1,
          encoded: zA(...i.map(t => t.encoded))
        }
      }(t, e);
      if (t.type.startsWith("bytes")) return CS(t, e);
      if (t.type.startsWith("uint") || t.type.startsWith("int")) return WS(t, e);
      throw new sm("Unsupported", {
        param: t,
        value: e
      })
    }

    function _S(t, e) {
      if ("string" === t.type) return function(t, e) {
        const r = RS({
          type: "bytes",
          name: ""
        }, e);
        return {
          result: oT(r.result),
          encoded: r.encoded,
          consumed: r.consumed
        }
      }(0, e);
      if ("bool" === t.type) return function(t, e) {
        const r = MS({
          type: "uint8",
          name: ""
        }, e);
        if (r.result > 1 || 0 > r.result) throw new sm("Invalid boolean value encoded", {
          boolBytes: e.subarray(0, AS),
          numberResult: r
        });
        return {
          result: r.result === BigInt(1),
          encoded: r.encoded,
          consumed: AS
        }
      }(0, e);
      if ("address" === t.type) return function(t, e) {
        const r = e.subarray(12, AS);
        if (20 !== r.length) throw new sm("Invalid decoding input, not enough bytes to decode address", {
          bytes: e
        });
        const n = mA(r);
        return {
          result: gT(n),
          encoded: e.subarray(AS),
          consumed: AS
        }
      }(0, e);
      if ("tuple" === t.type) return US(t, e);
      if (t.type.endsWith("]")) return function(t, e) {
        let {
          size: r,
          param: n
        } = kS(t), i = 0;
        const o = [];
        let s = e;
        if (-1 === r) {
          const t = MS({
            type: "uint32",
            name: ""
          }, e);
          r = +t.result, i = t.consumed, s = t.encoded
        }
        if (xS(n)) {
          for (let t = 0; r > t; t += 1) {
            const e = MS({
              type: "uint32",
              name: ""
            }, s.subarray(t * AS));
            i += e.consumed;
            const r = _S(n, s.subarray(+e.result));
            i += r.consumed, o.push(r.result)
          }
          return {
            result: o,
            encoded: s.subarray(i),
            consumed: i
          }
        }
        for (let t = 0; r > t; t += 1) {
          const t = _S(n, e.subarray(i));
          i += t.consumed, o.push(t.result)
        }
        return {
          result: o,
          encoded: e.subarray(i),
          consumed: i
        }
      }(t, e);
      if (t.type.startsWith("bytes")) return RS(t, e);
      if (t.type.startsWith("uint") || t.type.startsWith("int")) return MS(t, e);
      throw new sm("Unsupported", {
        param: t,
        bytes: e
      })
    }

    function DS(t, e) {
      var r, n, i;
      let o = !1;
      if (!Array.isArray(e) && "object" != typeof e) throw new sm("param must be either Array or Object", {
        param: t,
        input: e
      });
      const s = e,
        a = [];
      for (let u = 0; u < (null !== (n = null === (r = t.components) || void 0 === r ? void 0 : r.length) && void 0 !== n ? n : 0); u += 1) {
        const r = t.components[u];
        let n;
        if (Array.isArray(s)) {
          if (u >= s.length) throw new sm("input param length missmatch", {
            param: t,
            input: e
          });
          n = jS(r, s[u])
        } else {
          const o = s[null !== (i = r.name) && void 0 !== i ? i : ""];
          if (null == o) throw new sm("missing input defined in abi", {
            param: t,
            input: e,
            paramName: r.name
          });
          n = jS(r, o)
        }
        n.dynamic && (o = !0), a.push(n)
      }
      return o ? {
        dynamic: !0,
        encoded: NS(a)
      } : {
        dynamic: !1,
        encoded: zA(...a.map(t => t.encoded))
      }
    }

    function US(t, e) {
      const r = {
        Ys: 0
      };
      let n = 0;
      if (!t.components) return {
        result: r,
        encoded: e,
        consumed: n
      };
      let i = 0;
      for (const [o, s] of t.components.entries()) {
        let t;
        if (xS(s)) {
          const r = MS({
            type: "uint32",
            name: ""
          }, e.subarray(n));
          t = _S(s, e.subarray(+r.result)), n += r.consumed, i += t.consumed
        } else t = _S(s, e.subarray(n)), n += t.consumed;
        r.Ys += 1, r[o] = t.result, s.name && "" !== s.name && (r[s.name] = t.result)
      }
      return {
        encoded: e.subarray(n + i),
        result: r,
        consumed: n + i
      }
    }

    function LS(t) {
      const e = [];
      return t.forEach(t => {
        if (Array.isArray(t)) {
          const r = LS(t);
          e.push({
            type: "tuple",
            components: r,
            name: ""
          })
        } else e.push({
          type: dT(t, !0)
        })
      }), e
    }

    function FS(t, e) {
      if (t?.length !== e.length) throw new sm("Invalid number of values received for given ABI", {
        expected: t?.length,
        received: e.length
      });
      return mA(DS({
        type: "tuple",
        name: "",
        components: PS(t)
      }, e).encoded)
    }
    const $S = (t, e) => FS([t], [e]),
      zS = (t, e, r) => {
        try {
          if (t.length > 0 && (!e || "0x" === e || "0X" === e)) throw new sm("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
          return function(t, e) {
            return US({
              type: "tuple",
              name: "",
              components: PS(t)
            }, vA(e)).result
          }(t, "0x" + e.replace(/0x/i, ""))
        } catch (t) {
          throw new sm("Parameter decoding error: " + t.message, {
            internalErr: t
          })
        }
      },
      HS = (t, e) => zS(t, e),
      GS = (t, e) => HS([t], e)[0],
      KS = t => {
        if ("string" != typeof t && !VI(t)) throw new sm("Invalid parameter value in encodeFunctionSignature");
        let e;
        return e = !t || "function" != typeof t && "object" != typeof t ? t : YI(t), tE(e).slice(0, 10)
      },
      VS = (t, e, r = !0) => {
        const n = r && e && e.length >= 10 && e.startsWith("0x") ? e.slice(10) : e;
        if (!t.inputs) throw new Zb("No inputs found in the ABI");
        const i = HS([...t.inputs], n);
        return Object.assign(Object.assign({}, i), {
          Qs: YI(t)
        })
      },
      ZS = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"],
      qS = (t, e, r) => {
        const n = Array.isArray(r) ? r : [r],
          i = {},
          o = {};
        for (const [e, r] of t.entries()) r.indexed ? i[e] = r : o[e] = r;
        const s = e ? zS(Object.values(o), e) : {
            Ys: 0
          },
          a = n.length - Object.keys(i).length,
          u = Object.values(i).map((t, e) => ZS.some(e => t.type.startsWith(e)) ? ((t, e) => "string" === t ? e : GS(t, e))(t.type, n[e + a]) : n[e + a]),
          c = {
            Ys: 0
          };
        let f = 0,
          l = 0;
        for (const [e, r] of t.entries()) c[e] = "string" === r.type ? "" : void 0, i[e] && (c[e] = u[f], f += 1), o[e] && (c[e] = s[l + ""], l += 1), r.name && (c[r.name] = c[e]), c.Ys += 1;
        return c
      },
      JS = (t, e) => {
        if (e?.data) {
          let r, n, i;
          try {
            const o = e.data.slice(0, 10),
              s = t.find(t => (t => {
                if ("string" != typeof t && !GI(t)) throw new sm("Invalid parameter value in encodeErrorSignature");
                let e;
                return e = !t || "function" != typeof t && "object" != typeof t ? t : YI(t), tE(e)
              })(t).startsWith(o));
            s?.inputs ? (r = s.name, n = YI(s), i = HS([...s.inputs], e.data.substring(10))) : e.data.startsWith("0x08c379a0") ? (r = "Error", n = "Error(string)", i = HS([{
              name: "message",
              type: "string"
            }], e.data.substring(10))) : e.data.startsWith("0x4e487b71") ? (r = "Panic", n = "Panic(uint256)", i = HS([{
              name: "code",
              type: "uint256"
            }], e.data.substring(10))) : console.error("No matching error abi found for error data", e.data)
          } catch (t) {
            console.error(t)
          }
          r && e.setDecodedProperties(r, n, i)
        }
      },
      YS = (t, e) => {
        var r, n, i, o, s;
        if (t instanceof Yb && t.cause instanceof Jb) {
          if (void 0 !== e) {
            const i = e.filter(t => GI(t));
            return JS(i, t.cause), {
              reason: t.cause.message,
              signature: null === (r = t.cause.data) || void 0 === r ? void 0 : r.slice(0, 10),
              data: null === (n = t.cause.data) || void 0 === n ? void 0 : n.substring(10),
              customErrorName: t.cause.errorName,
              customErrorDecodedSignature: t.cause.errorSignature,
              customErrorArguments: t.cause.errorArgs
            }
          }
          return {
            reason: t.cause.message,
            signature: null === (i = t.cause.data) || void 0 === i ? void 0 : i.slice(0, 10),
            data: null === (o = t.cause.data) || void 0 === o ? void 0 : o.substring(10)
          }
        }
        if (t instanceof hy && !Array.isArray(null === (s = t.cause) || void 0 === s ? void 0 : s.errors) && void 0 !== t.cause) return t.cause.message;
        throw t
      };

    function QS(t, e, r) {
      return function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              u(n.next(t))
            } catch (t) {
              o(t)
            }
          }

          function a(t) {
            try {
              u(n.throw(t))
            } catch (t) {
              o(t)
            }
          }

          function u(t) {
            t.done ? i(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(s, a)
          }
          u((n = n.apply(t, e || [])).next())
        })
      }(this, arguments, void 0, function*(t, e, r, n = t.defaultReturnFormat) {
        try {
          return void(yield fO(t, e, t.defaultBlock, n))
        } catch (t) {
          return YS(t, r)
        }
      })
    }

    function XS(t, e, r, n, i, o) {
      return function(t, e, r, n) {
        return new(r || (r = Promise))(function(e, i) {
          function o(t) {
            try {
              a(n.next(t))
            } catch (t) {
              i(t)
            }
          }

          function s(t) {
            try {
              a(n.throw(t))
            } catch (t) {
              i(t)
            }
          }

          function a(t) {
            t.done ? e(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(o, s)
          }
          a((n = n.call(t)).next())
        })
      }(this, 0, void 0, function*() {
        let s, a = o;
        if (void 0 === a && (void 0 !== n ? a = YS(n) : t.handleRevert && void 0 !== e && (a = yield QS(t, e, i))), void 0 === a) s = new mm(r);
        else if ("string" == typeof a) s = new pm(a, void 0, r);
        else if (void 0 !== a.customErrorName && void 0 !== a.customErrorDecodedSignature && void 0 !== a.customErrorArguments) {
          const t = a;
          s = new bm(t.reason, t.customErrorName, t.customErrorDecodedSignature, t.customErrorArguments, t.signature, r, t.data)
        } else s = new pm(a.reason, a.signature, r, a.data);
        return s
      })
    }
    const tO = (t, e, r, n = ob) => {
      var i, o, s, a, u, c;
      let f = Object.assign({}, t);
      const l = JT(mI, e, n);
      if ([SI, "allEvents"].includes(f.name) && (f = r.find(t => t.signature === e.topics[0]) || {
          anonymous: !0
        }), f.inputs = null !== (o = null !== (i = f.inputs) && void 0 !== i ? i : t.inputs) && void 0 !== o ? o : [], !f.anonymous) {
        let t = 0;
        (null !== (s = f.inputs) && void 0 !== s ? s : []).forEach(e => {
          e.indexed && (t += 1)
        }), t > 0 && e?.topics && e?.topics.length !== t + 1 && (f = Object.assign(Object.assign({}, f), {
          anonymous: !0,
          inputs: []
        }))
      }
      const h = f.anonymous ? e.topics : (null !== (a = e.topics) && void 0 !== a ? a : []).slice(1);
      return Object.assign(Object.assign({}, l), {
        returnValues: qS([...null !== (u = f.inputs) && void 0 !== u ? u : []], e.data, h),
        event: f.name,
        signature: !f.anonymous && (null === (c = e.topics) || void 0 === c ? void 0 : c.length) > 0 && e.topics[0] ? e.topics[0] : void 0,
        raw: {
          data: e.data,
          topics: e.topics
        }
      })
    };
    var eO = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class rO {
      constructor({
        options: t,
        web3Context: e,
        promiEvent: r,
        returnFormat: n
      }) {
        this.options = {
          checkRevertBeforeSending: !0
        }, this.options = t, this.web3Context = e, this.promiEvent = r, this.returnFormat = n
      }
      getReceiptWithEvents(t) {
        var e, r;
        const n = Object.assign({}, t ?? {});
        if (null !== (e = this.options) && void 0 !== e && e.contractAbi && n.logs && n.logs.length > 0) {
          n.events = {};
          for (const t of n.logs) {
            const e = tO(OI, t, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi, this.returnFormat);
            e.event && (n.events[e.event] = e)
          }
        }
        return n
      }
      checkRevertBeforeSending(t) {
        return eO(this, void 0, void 0, function*() {
          if (!1 !== this.options.checkRevertBeforeSending) {
            let e = t;
            RA(t.data) && RA(t.input) && RA(t.gas) && (e = Object.assign(Object.assign({}, t), {
              gas: 21e3
            }));
            const r = yield QS(this.web3Context, e, this.options.contractAbi);
            if (void 0 !== r) throw yield XS(this.web3Context, t, void 0, void 0, this.options.contractAbi, r)
          }
        })
      }
      emitSending(t) {
        this.promiEvent.listenerCount("sending") > 0 && this.promiEvent.emit("sending", t)
      }
      populateGasPrice(t) {
        return eO(this, arguments, void 0, function*({
          transactionFormatted: t,
          transaction: e
        }) {
          var r;
          let n = t;
          return !this.web3Context.config.ignoreGasPricing && !(null !== (r = this.options) && void 0 !== r && r.ignoreGasPricing) && RA(t.gasPrice) && (RA(e.maxPriorityFeePerGas) || RA(e.maxFeePerGas)) && (n = Object.assign(Object.assign({}, t), yield MI(t, this.web3Context, sb))), n
        })
      }
      signAndSend(t) {
        return eO(this, arguments, void 0, function*({
          wallet: t,
          tx: e
        }) {
          if (t) {
            const r = yield t.signTransaction(e);
            return LI(this.web3Context, () => eO(this, void 0, void 0, function*() {
              return Jx(this.web3Context.requestManager, r.rawTransaction)
            }), r.transactionHash)
          }
          return LI(this.web3Context, () => eO(this, void 0, void 0, function*() {
            return function(t, e) {
              return Zx(this, void 0, void 0, function*() {
                return t.send({
                  method: "eth_sendTransaction",
                  params: [e]
                })
              })
            }(this.web3Context.requestManager, e)
          }))
        })
      }
      emitSent(t) {
        this.promiEvent.listenerCount("sent") > 0 && this.promiEvent.emit("sent", t)
      }
      emitTransactionHash(t) {
        this.promiEvent.listenerCount("transactionHash") > 0 && this.promiEvent.emit("transactionHash", t)
      }
      emitReceipt(t) {
        this.promiEvent.listenerCount("receipt") > 0 && this.promiEvent.emit("receipt", t)
      }
      handleError(t) {
        return eO(this, arguments, void 0, function*({
          error: t,
          tx: e
        }) {
          var r;
          let n = t;
          return n instanceof Yb && this.web3Context.handleRevert && (n = yield XS(this.web3Context, e, void 0, void 0, null === (r = this.options) || void 0 === r ? void 0 : r.contractAbi)), (n instanceof hy || n instanceof Yb || n instanceof bm || n instanceof mm || n instanceof pm || n instanceof Hm) && this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", n), n
        })
      }
      emitConfirmation({
        receipt: t,
        transactionHash: e,
        customTransactionReceiptSchema: r
      }) {
        this.promiEvent.listenerCount("confirmation") > 0 && function(t, e, r, n, i, o) {
          if (RA(r) || RA(r.blockHash)) throw new Km({
            receipt: r,
            blockHash: JT({
              format: "bytes32"
            }, r?.blockHash, i),
            transactionHash: JT({
              format: "bytes32"
            }, n, i)
          });
          if (!r.blockNumber) throw new Vm({
            receipt: r
          });
          e.emit("confirmation", {
            confirmations: JT({
              format: "uint"
            }, 1, i),
            receipt: JT(o ?? gI, r, i),
            latestBlockHash: JT({
              format: "bytes32"
            }, r.blockHash, i)
          });
          const s = t.requestManager.provider;
          s && "supportsSubscriptions" in s && s.supportsSubscriptions() ? (({
            web3Context: t,
            transactionReceipt: e,
            transactionPromiEvent: r,
            customTransactionReceiptSchema: n,
            returnFormat: i
          }) => {
            let o, s = !0;
            setImmediate(() => {
              var a;
              null === (a = t.subscriptionManager) || void 0 === a || a.subscribe("newHeads").then(a => {
                a.on("data", u => HI(void 0, void 0, void 0, function*() {
                  var c;
                  if (s = !1, !u?.number || o === u?.parentHash) return;
                  o = u?.parentHash;
                  const f = BigInt(u.number) - BigInt(e.blockNumber) + BigInt(1);
                  r.emit("confirmation", {
                    confirmations: JT({
                      format: "uint"
                    }, f, i),
                    receipt: JT(n ?? gI, e, i),
                    latestBlockHash: JT({
                      format: "bytes32"
                    }, u.parentHash, i)
                  }), f >= t.transactionConfirmationBlocks && (yield null === (c = t.subscriptionManager) || void 0 === c ? void 0 : c.removeSubscription(a))
                })), a.on("error", () => HI(void 0, void 0, void 0, function*() {
                  var o;
                  yield null === (o = t.subscriptionManager) || void 0 === o ? void 0 : o.removeSubscription(a), s = !1, zI({
                    web3Context: t,
                    transactionReceipt: e,
                    transactionPromiEvent: r,
                    customTransactionReceiptSchema: n,
                    returnFormat: i
                  })
                }))
              }).catch(() => {
                s = !1, zI({
                  web3Context: t,
                  transactionReceipt: e,
                  customTransactionReceiptSchema: n,
                  transactionPromiEvent: r,
                  returnFormat: i
                })
              })
            }), setTimeout(() => {
              s && zI({
                web3Context: t,
                transactionReceipt: e,
                transactionPromiEvent: r,
                returnFormat: i
              })
            }, 1e3 * t.blockHeaderTimeout)
          })({
            web3Context: t,
            transactionReceipt: r,
            transactionPromiEvent: e,
            customTransactionReceiptSchema: o,
            returnFormat: i
          }) : zI({
            web3Context: t,
            transactionReceipt: r,
            transactionPromiEvent: e,
            customTransactionReceiptSchema: o,
            returnFormat: i
          })
        }(this.web3Context, this.promiEvent, t, e, this.returnFormat, r)
      }
      handleResolve(t) {
        return eO(this, arguments, void 0, function*({
          receipt: t,
          tx: e
        }) {
          var r, n, i;
          if (null !== (r = this.options) && void 0 !== r && r.transactionResolver) return null === (n = this.options) || void 0 === n ? void 0 : n.transactionResolver(t);
          if (t.status === BigInt(0)) {
            const r = yield XS(this.web3Context, e, t, void 0, null === (i = this.options) || void 0 === i ? void 0 : i.contractAbi);
            throw this.promiEvent.listenerCount("error") > 0 && this.promiEvent.emit("error", r), r
          }
          return t
        })
      }
    }
    var nO = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };

    function iO(t, e) {
      return nO(this, void 0, void 0, function*() {
        const r = yield function(t) {
          return Zx(this, void 0, void 0, function*() {
            return t.send({
              method: "eth_gasPrice",
              params: []
            })
          })
        }(t.requestManager);
        return JT({
          format: "uint"
        }, r, e ?? t.defaultReturnFormat)
      })
    }

    function oO(t, e) {
      return nO(this, void 0, void 0, function*() {
        const r = yield function(t) {
          return Zx(this, void 0, void 0, function*() {
            return t.send({
              method: "eth_blockNumber",
              params: []
            })
          })
        }(t.requestManager);
        return JT({
          format: "uint"
        }, r, e ?? t.defaultReturnFormat)
      })
    }

    function sO(t) {
      return nO(this, arguments, void 0, function*(t, e = t.defaultBlock, r = !1, n) {
        var i;
        let o;
        if (TA(e)) {
          const n = JT({
            format: "bytes32"
          }, e, sb);
          o = yield function(t, e, r) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["bytes32", "bool"], [e, r]), t.send({
                method: "eth_getBlockByHash",
                params: [e, r]
              })
            })
          }(t.requestManager, n, r)
        } else {
          const n = BA(e) ? e : JT({
            format: "uint"
          }, e, sb);
          o = yield Yx(t.requestManager, n, r)
        }
        const s = JT(pI, o, n ?? t.defaultReturnFormat);
        return RA(s) ? s : Object.assign(Object.assign({}, s), {
          transactions: null !== (i = s.transactions) && void 0 !== i ? i : []
        })
      })
    }

    function aO(t, e, r) {
      return nO(this, void 0, void 0, function*() {
        const n = JT({
          format: "bytes32"
        }, e, ob);
        let i;
        try {
          i = yield function(t, e) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["bytes32"], [e]), t.send({
                method: "eth_getTransactionReceipt",
                params: [e]
              })
            })
          }(t.requestManager, n)
        } catch (t) {
          if ("object" != typeof t || RA(t) || !("message" in t) || "transaction indexing is in progress" !== t.message) throw t;
          console.warn("Transaction indexing is in progress.")
        }
        return RA(i) ? i : JT(gI, i, r ?? t.defaultReturnFormat)
      })
    }

    function uO(t, e) {
      return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n) {
        const i = BA(r) ? r : JT({
            format: "uint"
          }, r, sb),
          o = yield function(t, e, r) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["address", "blockNumberOrTag"], [e, r]), t.send({
                method: "eth_getTransactionCount",
                params: [e, r]
              })
            })
          }(t.requestManager, e, i);
        return JT({
          format: "uint"
        }, o, n ?? t.defaultReturnFormat)
      })
    }

    function cO(t, e, r, n = {
      checkRevertBeforeSending: !0
    }, i) {
      const o = new Vx((s, a) => {
        setImmediate(() => {
          nO(this, void 0, void 0, function*() {
            const u = new rO({
              web3Context: t,
              promiEvent: o,
              options: n,
              returnFormat: r
            });
            let c = Object.assign({}, e);
            RA(i) || (c = yield i.processTransaction(c));
            let f = TI(Object.assign(Object.assign({}, c), {
              from: RI("from", t, c),
              to: RI("to", t, c)
            }), sb, {
              transactionSchema: t.config.customTransactionSchema
            });
            try {
              let e;
              f = yield u.populateGasPrice({
                transaction: c,
                transactionFormatted: f
              }), yield u.checkRevertBeforeSending(f), u.emitSending(f), t.wallet && !RA(f.from) && (e = t.wallet.get(f.from));
              const n = yield u.signAndSend({
                wallet: e,
                tx: f
              }), i = JT({
                format: "bytes32"
              }, n, r ?? t.defaultReturnFormat);
              u.emitSent(f), u.emitTransactionHash(i);
              const o = yield $I(t, n, r ?? t.defaultReturnFormat), a = u.getReceiptWithEvents(JT(gI, o, r ?? t.defaultReturnFormat));
              u.emitReceipt(a), s(yield u.handleResolve({
                receipt: a,
                tx: f
              })), u.emitConfirmation({
                receipt: a,
                transactionHash: n
              })
            } catch (t) {
              a(yield u.handleError({
                error: t,
                tx: f
              }))
            }
          })
        })
      });
      return o
    }

    function fO(t, e) {
      return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n = t.defaultReturnFormat) {
        const i = BA(r) ? r : JT({
            format: "uint"
          }, r, sb),
          o = yield function(t, e, r) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["blockNumberOrTag"], [r]), t.send({
                method: "eth_call",
                params: [e, r]
              })
            })
          }(t.requestManager, TI(e, sb, {
            transactionSchema: t.config.customTransactionSchema
          }), i);
        return JT({
          format: "bytes"
        }, o, n)
      })
    }

    function lO(t, e) {
      return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n) {
        const i = TI(e, sb, {
            transactionSchema: t.config.customTransactionSchema
          }),
          o = BA(r) ? r : JT({
            format: "uint"
          }, r, sb),
          s = yield function(t, e, r) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["blockNumberOrTag"], [r]), t.send({
                method: "eth_estimateGas",
                params: [e, r]
              })
            })
          }(t.requestManager, i, o);
        return JT({
          format: "uint"
        }, s, n ?? t.defaultReturnFormat)
      })
    }

    function hO(t, e, r) {
      return nO(this, void 0, void 0, function*() {
        let {
          toBlock: n,
          fromBlock: i
        } = e;
        RA(n) || ("number" == typeof n || "bigint" == typeof n) && (n = XA(n)), RA(i) || ("number" == typeof i || "bigint" == typeof i) && (i = XA(i));
        const o = Object.assign(Object.assign({}, e), {
          fromBlock: i,
          toBlock: n
        });
        return (yield function(t, e) {
          return Zx(this, void 0, void 0, function*() {
            return FA.validate(["filter"], [e]), t.send({
              method: "eth_getLogs",
              params: [e]
            })
          })
        }(t.requestManager, o)).map(e => "string" == typeof e ? e : JT(mI, e, r ?? t.defaultReturnFormat))
      })
    }

    function dO(t, e) {
      return nO(this, void 0, void 0, function*() {
        const r = yield function(t) {
          return Zx(this, void 0, void 0, function*() {
            return t.send({
              method: "eth_chainId",
              params: []
            })
          })
        }(t.requestManager);
        return JT({
          format: "uint"
        }, r, e ?? t.defaultReturnFormat)
      })
    }

    function pO(t, e) {
      return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n) {
        const i = BA(r) ? r : JT({
            format: "uint"
          }, r, sb),
          o = yield function(t, e, r) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["blockNumberOrTag"], [r]), t.send({
                method: "eth_createAccessList",
                params: [e, r]
              })
            })
          }(t.requestManager, TI(e, sb, {
            transactionSchema: t.config.customTransactionSchema
          }), i);
        return JT(uI, o, n ?? t.defaultReturnFormat)
      })
    }
    var bO = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class mO extends uP {
      vs() {
        return ["logs", this.args]
      }
      formatSubscriptionResult(t) {
        return JT(mI, t, super.returnFormat)
      }
    }
    class yO extends uP {
      vs() {
        return ["newPendingTransactions"]
      }
      formatSubscriptionResult(t) {
        return JT({
          format: "string"
        }, t, super.returnFormat)
      }
    }
    class gO extends uP {
      vs() {
        return ["newHeads"]
      }
      formatSubscriptionResult(t) {
        return JT(bI, t, super.returnFormat)
      }
    }
    class vO extends uP {
      vs() {
        return ["syncing"]
      }
      gs(t) {
        if ("boolean" == typeof t) this.emit("changed", t);
        else {
          const e = Object.fromEntries(Object.entries(t?.status || t).map(([t, e]) => [t.charAt(0).toLowerCase() + t.substring(1), e]));
          this.emit("changed", t.syncing), this.emit("data", JT(yI, e, super.returnFormat))
        }
      }
    }
    var wO = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const AO = {
      logs: mO,
      newPendingTransactions: yO,
      newHeads: gO,
      syncing: vO,
      pendingTransactions: yO,
      newBlockHeaders: gO
    };
    class TO extends zx {
      constructor(t) {
        "string" == typeof t || tP(t) ? super({
          provider: t,
          registeredSubscriptions: AO
        }) : t.registeredSubscriptions ? super(t) : (super(Object.assign(Object.assign({}, t), {
          registeredSubscriptions: AO
        })), this.getFeeData = this.calculateFeeData)
      }
      setTransactionMiddleware(t) {
        this.transactionMiddleware = t
      }
      getTransactionMiddleware() {
        return this.transactionMiddleware
      }
      getProtocolVersion() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_protocolVersion",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      isSyncing() {
        return wO(this, void 0, void 0, function*() {
          return qx(this.requestManager)
        })
      }
      getCoinbase() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_coinbase",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      isMining() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_mining",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      getHashrate(t) {
        return wO(this, void 0, void 0, function*() {
          var e;
          return void 0 === t && (t = null !== (e = this.defaultReturnFormat) && void 0 !== e ? e : ob), this.getHashRate(t)
        })
      }
      getHashRate() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, void 0, void 0, function*() {
              const r = yield function(t) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_hashrate",
                    params: []
                  })
                })
              }(t.requestManager);
              return JT({
                format: "uint"
              }, r, e ?? t.defaultReturnFormat)
            })
          }(this, t)
        })
      }
      getGasPrice() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return iO(this, t)
        })
      }
      getMaxPriorityFeePerGas() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, void 0, void 0, function*() {
              const r = yield function(t) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_maxPriorityFeePerGas",
                    params: []
                  })
                })
              }(t.requestManager);
              return JT({
                format: "uint"
              }, r, e ?? t.defaultReturnFormat)
            })
          }(this, t)
        })
      }
      calculateFeeData() {
        return wO(this, arguments, void 0, function*(t = BigInt(2), e = GA.Gwei) {
          var r;
          const n = yield this.getBlock(void 0, !1), i = null !== (r = n?.baseFeePerGas) && void 0 !== r ? r : void 0;
          let o, s, a;
          try {
            o = yield this.getGasPrice()
          } catch {}
          try {
            s = yield this.getMaxPriorityFeePerGas()
          } catch {}
          if (i) {
            let r;
            s = s ?? e, r = "number" == typeof t ? BigInt(Math.floor(1e3 * t)) / BigInt(1e3) : t, a = i * r + s
          }
          return {
            gasPrice: o,
            maxFeePerGas: a,
            maxPriorityFeePerGas: s,
            baseFeePerGas: i
          }
        })
      }
      getAccounts() {
        return wO(this, void 0, void 0, function*() {
          var t;
          return (null !== (t = yield function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_accounts",
                params: []
              })
            })
          }(this.requestManager)) && void 0 !== t ? t : []).map(t => gT(t))
        })
      }
      getBlockNumber() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return oO(this, t)
        })
      }
      getBalance(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n) {
              const i = BA(r) ? r : JT({
                  format: "uint"
                }, r, sb),
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["address", "blockNumberOrTag"], [e, r]), t.send({
                      method: "eth_getBalance",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, e, i);
              return JT({
                format: "uint"
              }, o, n ?? t.defaultReturnFormat)
            })
          }(this, t, e, r)
        })
      }
      getStorageAt(t, e) {
        return wO(this, arguments, void 0, function*(t, e, r = this.defaultBlock, n = this.defaultReturnFormat) {
          return function(t, e, r) {
            return nO(this, arguments, void 0, function*(t, e, r, n = t.defaultBlock, i) {
              const o = JT({
                  format: "uint"
                }, r, sb),
                s = BA(n) ? n : JT({
                  format: "uint"
                }, n, sb),
                a = yield function(t, e, r, n) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["address", "hex", "blockNumberOrTag"], [e, r, n]), t.send({
                      method: "eth_getStorageAt",
                      params: [e, r, n]
                    })
                  })
                }(t.requestManager, e, o, s);
              return JT({
                format: "bytes"
              }, a, i ?? t.defaultReturnFormat)
            })
          }(this, t, e, r, n)
        })
      }
      getCode(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n) {
              const i = BA(r) ? r : JT({
                  format: "uint"
                }, r, sb),
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["address", "blockNumberOrTag"], [e, r]), t.send({
                      method: "eth_getCode",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, e, i);
              return JT({
                format: "bytes"
              }, o, n ?? t.defaultReturnFormat)
            })
          }(this, t, e, r)
        })
      }
      getBlock() {
        return wO(this, arguments, void 0, function*(t = this.defaultBlock, e = !1, r = this.defaultReturnFormat) {
          return sO(this, t, e, r)
        })
      }
      getBlockTransactionCount() {
        return wO(this, arguments, void 0, function*(t = this.defaultBlock, e = this.defaultReturnFormat) {
          return function(t) {
            return nO(this, arguments, void 0, function*(t, e = t.defaultBlock, r) {
              let n;
              if (TA(e)) {
                const r = JT({
                  format: "bytes32"
                }, e, sb);
                n = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["bytes32"], [e]), t.send({
                      method: "eth_getBlockTransactionCountByHash",
                      params: [e]
                    })
                  })
                }(t.requestManager, r)
              } else {
                const r = BA(e) ? e : JT({
                  format: "uint"
                }, e, sb);
                n = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["blockNumberOrTag"], [e]), t.send({
                      method: "eth_getBlockTransactionCountByNumber",
                      params: [e]
                    })
                  })
                }(t.requestManager, r)
              }
              return JT({
                format: "uint"
              }, n, r ?? t.defaultReturnFormat)
            })
          }(this, t, e)
        })
      }
      getBlockUncleCount() {
        return wO(this, arguments, void 0, function*(t = this.defaultBlock, e = this.defaultReturnFormat) {
          return function(t) {
            return nO(this, arguments, void 0, function*(t, e = t.defaultBlock, r) {
              let n;
              if (TA(e)) {
                const r = JT({
                  format: "bytes32"
                }, e, sb);
                n = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["bytes32"], [e]), t.send({
                      method: "eth_getUncleCountByBlockHash",
                      params: [e]
                    })
                  })
                }(t.requestManager, r)
              } else {
                const r = BA(e) ? e : JT({
                  format: "uint"
                }, e, sb);
                n = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["blockNumberOrTag"], [e]), t.send({
                      method: "eth_getUncleCountByBlockNumber",
                      params: [e]
                    })
                  })
                }(t.requestManager, r)
              }
              return JT({
                format: "uint"
              }, n, r ?? t.defaultReturnFormat)
            })
          }(this, t, e)
        })
      }
      getUncle() {
        return wO(this, arguments, void 0, function*(t = this.defaultBlock, e, r = this.defaultReturnFormat) {
          return function(t) {
            return nO(this, arguments, void 0, function*(t, e = t.defaultBlock, r, n) {
              const i = JT({
                format: "uint"
              }, r, sb);
              let o;
              if (TA(e)) {
                const r = JT({
                  format: "bytes32"
                }, e, sb);
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["bytes32", "hex"], [e, r]), t.send({
                      method: "eth_getUncleByBlockHashAndIndex",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, r, i)
              } else {
                const r = BA(e) ? e : JT({
                  format: "uint"
                }, e, sb);
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["blockNumberOrTag", "hex"], [e, r]), t.send({
                      method: "eth_getUncleByBlockNumberAndIndex",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, r, i)
              }
              return JT(pI, o, n ?? t.defaultReturnFormat)
            })
          }(this, t, e, r)
        })
      }
      getTransaction(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          const r = yield function(t, e) {
            return nO(this, arguments, void 0, function*(t, e, r = t.defaultReturnFormat) {
              const n = JT({
                  format: "bytes32"
                }, e, ob),
                i = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["bytes32"], [e]), t.send({
                      method: "eth_getTransactionByHash",
                      params: [e]
                    })
                  })
                }(t.requestManager, n);
              return RA(i) ? i : TI(i, r, {
                transactionSchema: t.config.customTransactionSchema,
                fillInputAndData: !0
              })
            })
          }(this, t, e);
          if (!r) throw new gm;
          return r
        })
      }
      getPendingTransactions() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, void 0, void 0, function*() {
              return (yield function(t) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_pendingTransactions",
                    params: []
                  })
                })
              }(t.requestManager)).map(r => TI(r, e ?? t.defaultReturnFormat, {
                transactionSchema: t.config.customTransactionSchema,
                fillInputAndData: !0
              }))
            })
          }(this, t)
        })
      }
      getTransactionFromBlock() {
        return wO(this, arguments, void 0, function*(t = this.defaultBlock, e, r = this.defaultReturnFormat) {
          return function(t) {
            return nO(this, arguments, void 0, function*(t, e = t.defaultBlock, r, n) {
              const i = JT({
                format: "uint"
              }, r, sb);
              let o;
              if (TA(e)) {
                const r = JT({
                  format: "bytes32"
                }, e, sb);
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["bytes32", "hex"], [e, r]), t.send({
                      method: "eth_getTransactionByBlockHashAndIndex",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, r, i)
              } else {
                const r = BA(e) ? e : JT({
                  format: "uint"
                }, e, sb);
                o = yield function(t, e, r) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["blockNumberOrTag", "hex"], [e, r]), t.send({
                      method: "eth_getTransactionByBlockNumberAndIndex",
                      params: [e, r]
                    })
                  })
                }(t.requestManager, r, i)
              }
              return RA(o) ? o : TI(o, n ?? t.defaultReturnFormat, {
                transactionSchema: t.config.customTransactionSchema,
                fillInputAndData: !0
              })
            })
          }(this, t, e, r)
        })
      }
      getTransactionReceipt(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          const r = yield aO(this, t, e);
          if (!r) throw new gm;
          return r
        })
      }
      getTransactionCount(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return uO(this, t, e, r)
        })
      }
      sendTransaction(t, e = this.defaultReturnFormat, r) {
        return cO(this, t, e, r, this.transactionMiddleware)
      }
      sendSignedTransaction(t, e = this.defaultReturnFormat, r) {
        return function(t, e, r, n = {
          checkRevertBeforeSending: !0
        }) {
          const i = new Vx((o, s) => {
            setImmediate(() => {
              nO(this, void 0, void 0, function*() {
                const a = new rO({
                    web3Context: t,
                    promiEvent: i,
                    options: n,
                    returnFormat: r
                  }),
                  u = JT({
                    format: "bytes"
                  }, e, sb),
                  c = Bx.fromSerializedData(VA(JA(u))),
                  f = Object.assign(Object.assign({}, c.toJSON()), {
                    from: c.getSenderAddress().toString()
                  });
                try {
                  const {
                    v: e,
                    r: n,
                    s: i
                  } = f, s = function(t, e) {
                    var r = {};
                    for (var n in t)({}).hasOwnProperty.call(t, n) && 0 > e.indexOf(n) && (r[n] = t[n]);
                    if (null != t && "function" == typeof Object.getOwnPropertySymbols) {
                      var i = 0;
                      for (n = Object.getOwnPropertySymbols(t); i < n.length; i++) 0 > e.indexOf(n[i]) && {}.propertyIsEnumerable.call(t, n[i]) && (r[n[i]] = t[n[i]])
                    }
                    return r
                  }(f, ["v", "r", "s"]);
                  yield a.checkRevertBeforeSending(s), a.emitSending(u);
                  const c = yield LI(t, () => nO(this, void 0, void 0, function*() {
                    return Jx(t.requestManager, u)
                  }));
                  a.emitSent(u);
                  const l = JT({
                    format: "bytes32"
                  }, c, r ?? t.defaultReturnFormat);
                  a.emitTransactionHash(l);
                  const h = yield $I(t, c, r ?? t.defaultReturnFormat), d = a.getReceiptWithEvents(JT(gI, h, r ?? t.defaultReturnFormat));
                  a.emitReceipt(d), o(yield a.handleResolve({
                    receipt: d,
                    tx: f
                  })), a.emitConfirmation({
                    receipt: d,
                    transactionHash: c
                  })
                } catch (t) {
                  s(yield a.handleError({
                    error: t,
                    tx: f
                  }))
                }
              })
            })
          });
          return i
        }(this, t, e, r)
      }
      sign(t, e) {
        return wO(this, arguments, void 0, function*(t, e, r = this.defaultReturnFormat) {
          return function(t, e, r) {
            return nO(this, arguments, void 0, function*(t, e, r, n = t.defaultReturnFormat) {
              var i;
              const o = JT({
                format: "bytes"
              }, e, ob);
              if (null !== (i = t.wallet) && void 0 !== i && i.get(r)) {
                const e = t.wallet.get(r).sign(o);
                return JT(vI, e, n)
              }
              if ("number" == typeof r) throw new hm(e, 'RPC method "eth_sign" does not support index signatures');
              const s = yield function(t, e, r) {
                return Zx(this, void 0, void 0, function*() {
                  return FA.validate(["address", "hex"], [e, r]), t.send({
                    method: "eth_sign",
                    params: [e, r]
                  })
                })
              }(t.requestManager, r, o);
              return JT({
                format: "bytes"
              }, s, n)
            })
          }(this, t, e, r)
        })
      }
      signTransaction(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, arguments, void 0, function*(t, e, r = t.defaultReturnFormat) {
              const n = yield function(t, e) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_signTransaction",
                    params: [e]
                  })
                })
              }(t.requestManager, TI(e, sb, {
                transactionSchema: t.config.customTransactionSchema
              }));
              return Xw(n) ? function(t, e, r = {
                fillInputAndData: !1
              }) {
                return {
                  raw: JT({
                    format: "bytes"
                  }, t, e),
                  tx: TI(Object.assign(Object.assign({}, Bx.fromSerializedData(JA(t)).toJSON()), {
                    hash: qA(QT(JA(t))),
                    type: sI(JA(t))
                  }), e, {
                    fillInputAndData: r.fillInputAndData,
                    transactionSchema: r.transactionSchema
                  })
                }
              }(n, r, {
                fillInputAndData: !0
              }) : {
                raw: JT({
                  format: "bytes"
                }, n.raw, r),
                tx: TI(n.tx, r, {
                  transactionSchema: t.config.customTransactionSchema,
                  fillInputAndData: !0
                })
              }
            })
          }(this, t, e)
        })
      }
      call(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return fO(this, t, e, r)
        })
      }
      estimateGas(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return lO(this, t, e, r)
        })
      }
      getPastLogs(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          return hO(this, t, e)
        })
      }
      getWork() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_getWork",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      submitWork(t, e, r) {
        return wO(this, void 0, void 0, function*() {
          return function(t, e, r, n) {
            return Zx(this, void 0, void 0, function*() {
              return FA.validate(["bytes8", "bytes32", "bytes32"], [e, r, n]), t.send({
                method: "eth_submitWork",
                params: [e, r, n]
              })
            })
          }(this.requestManager, t, e, r)
        })
      }
      requestAccounts() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "eth_requestAccounts",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      getChainId() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return dO(this, t)
        })
      }
      getNodeInfo() {
        return wO(this, void 0, void 0, function*() {
          return function(t) {
            return Zx(this, void 0, void 0, function*() {
              return t.send({
                method: "web3_clientVersion",
                params: []
              })
            })
          }(this.requestManager)
        })
      }
      getProof(t, e) {
        return wO(this, arguments, void 0, function*(t, e, r = this.defaultBlock, n = this.defaultReturnFormat) {
          return function(t, e, r) {
            return nO(this, arguments, void 0, function*(t, e, r, n = t.defaultBlock, i) {
              const o = r.map(t => JT({
                  format: "bytes"
                }, t, sb)),
                s = BA(n) ? n : JT({
                  format: "uint"
                }, n, sb),
                a = yield function(t, e, r, n) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["address", "bytes32[]", "blockNumberOrTag"], [e, r, n]), t.send({
                      method: "eth_getProof",
                      params: [e, r, n]
                    })
                  })
                }(t.requestManager, e, o, s);
              return JT(AI, a, i ?? t.defaultReturnFormat)
            })
          }(this, t, e, r, n)
        })
      }
      getFeeHistory(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r, n = this.defaultReturnFormat) {
          return function(t, e) {
            return nO(this, arguments, void 0, function*(t, e, r = t.defaultBlock, n, i) {
              const o = JT({
                  format: "uint"
                }, e, sb),
                s = BA(r) ? r : JT({
                  format: "uint"
                }, r, sb),
                a = JT({
                  type: "array",
                  items: {
                    format: "uint"
                  }
                }, n, BI),
                u = yield function(t, e, r, n) {
                  return Zx(this, void 0, void 0, function*() {
                    FA.validate(["hex", "blockNumberOrTag"], [e, r]);
                    for (const t of n) FA.validate(["number"], [t]);
                    return t.send({
                      method: "eth_feeHistory",
                      params: [e, r, n]
                    })
                  })
                }(t.requestManager, o, s, a);
              return JT(wI, u, i ?? t.defaultReturnFormat)
            })
          }(this, t, e, r, n)
        })
      }
      createAccessList(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultBlock, r = this.defaultReturnFormat) {
          return pO(this, t, e, r)
        })
      }
      signTypedData(t, e, r, n) {
        return wO(this, void 0, void 0, function*() {
          var i;
          return void 0 === r && (r = !1), void 0 === n && (n = null !== (i = this.defaultReturnFormat) && void 0 !== i ? i : ob),
            function(t, e, r, n, i) {
              return nO(this, void 0, void 0, function*() {
                const o = yield function(t, e, r, n = !1) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["address"], [e]), t.send({
                      method: "eth_signTypedData" + (n ? "" : "_v4"),
                      params: [e, r]
                    })
                  })
                }(t.requestManager, e, r, n);
                return JT({
                  format: "bytes"
                }, o, i ?? t.defaultReturnFormat)
              })
            }(this, t, e, r, n)
        })
      }
      subscribe(t, e, r) {
        return wO(this, void 0, void 0, function*() {
          var n, i;
          void 0 === r && (r = null !== (n = this.defaultReturnFormat) && void 0 !== n ? n : ob);
          const o = yield null === (i = this.subscriptionManager) || void 0 === i ? void 0 : i.subscribe(t, e, r);
          return o instanceof mO && "logs" === t && "object" == typeof e && !NT(e.fromBlock) && Number.isFinite(+e.fromBlock) && setImmediate(() => {
            this.getPastLogs(e).then(t => {
              for (const e of t) o.gs(e)
            }).catch(t => {
              o.ws(t)
            })
          }), o
        })
      }
      static shouldClearSubscription({
        sub: t
      }) {
        return !(t instanceof vO)
      }
      clearSubscriptions(t = !1) {
        var e;
        return null === (e = this.subscriptionManager) || void 0 === e ? void 0 : e.unsubscribe(t ? TO.shouldClearSubscription : void 0)
      }
      createNewPendingTransactionFilter() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return function(t, e) {
            return bO(this, void 0, void 0, function*() {
              const r = yield function(t) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_newPendingTransactionFilter",
                    params: []
                  })
                })
              }(t.requestManager);
              return JT({
                format: "uint"
              }, r, e ?? t.defaultReturnFormat)
            })
          }(this, t)
        })
      }
      createNewFilter(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          return function(t, e, r) {
            return bO(this, void 0, void 0, function*() {
              let {
                toBlock: n,
                fromBlock: i
              } = e;
              RA(n) || ("number" == typeof n || "bigint" == typeof n) && (n = XA(n)), RA(i) || ("number" == typeof i || "bigint" == typeof i) && (i = XA(i));
              const o = Object.assign(Object.assign({}, e), {
                  fromBlock: i,
                  toBlock: n
                }),
                s = yield function(t, e) {
                  return Zx(this, void 0, void 0, function*() {
                    return FA.validate(["filter"], [e]), t.send({
                      method: "eth_newFilter",
                      params: [e]
                    })
                  })
                }(t.requestManager, o);
              return JT({
                format: "uint"
              }, s, r ?? t.defaultReturnFormat)
            })
          }(this, t, e)
        })
      }
      createNewBlockFilter() {
        return wO(this, arguments, void 0, function*(t = this.defaultReturnFormat) {
          return function(t, e) {
            return bO(this, void 0, void 0, function*() {
              const r = yield function(t) {
                return Zx(this, void 0, void 0, function*() {
                  return t.send({
                    method: "eth_newBlockFilter",
                    params: []
                  })
                })
              }(t.requestManager);
              return JT({
                format: "uint"
              }, r, e ?? t.defaultReturnFormat)
            })
          }(this, t)
        })
      }
      uninstallFilter(t) {
        return wO(this, void 0, void 0, function*() {
          return function(t, e) {
            return bO(this, void 0, void 0, function*() {
              return yield function(t, e) {
                return Zx(this, void 0, void 0, function*() {
                  return FA.validate(["hex"], [e]), t.send({
                    method: "eth_uninstallFilter",
                    params: [e]
                  })
                })
              }(t.requestManager, XA(e))
            })
          }(this, t)
        })
      }
      getFilterChanges(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          return function(t, e, r) {
            return bO(this, void 0, void 0, function*() {
              return (yield function(t, e) {
                return Zx(this, void 0, void 0, function*() {
                  return FA.validate(["hex"], [e]), t.send({
                    method: "eth_getFilterChanges",
                    params: [e]
                  })
                })
              }(t.requestManager, XA(e))).map(e => "string" == typeof e ? e : JT(mI, e, r ?? t.defaultReturnFormat))
            })
          }(this, t, e)
        })
      }
      getFilterLogs(t) {
        return wO(this, arguments, void 0, function*(t, e = this.defaultReturnFormat) {
          return function(t, e, r) {
            return bO(this, void 0, void 0, function*() {
              return (yield function(t, e) {
                return Zx(this, void 0, void 0, function*() {
                  return FA.validate(["hex"], [e]), t.send({
                    method: "eth_getFilterLogs",
                    params: [e]
                  })
                })
              }(t.requestManager, XA(e))).map(e => "string" == typeof e ? e : JT(mI, e, r ?? t.defaultReturnFormat))
            })
          }(this, t, e)
        })
      }
    }
    const EO = t => {
        if (RA(t.gas) || !xA(t.gas) || RA(t.gasPrice) || !xA(t.gasPrice)) throw new Mm({
          gas: t.gas,
          gasPrice: t.gasPrice
        });
        if (!RA(t.maxFeePerGas) || !RA(t.maxPriorityFeePerGas)) throw new Nm({
          maxFeePerGas: t.maxFeePerGas,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas
        })
      },
      PO = t => {
        if (!RA(t.gasPrice) && "0x2" === t.type) throw new Rm(t.gasPrice);
        if ("0x0" === t.type || "0x1" === t.type) throw new Nm({
          maxFeePerGas: t.maxFeePerGas,
          maxPriorityFeePerGas: t.maxPriorityFeePerGas
        });
        if (RA(t.maxFeePerGas) || !xA(t.maxFeePerGas) || RA(t.maxPriorityFeePerGas) || !xA(t.maxPriorityFeePerGas)) throw new Cm({
          maxPriorityFeePerGas: t.maxPriorityFeePerGas,
          maxFeePerGas: t.maxFeePerGas
        })
      },
      kO = (t, e, r, ...n) => function(t, e, r, n) {
        return new(r || (r = Promise))(function(t, i) {
          function o(t) {
            try {
              a(n.next(t))
            } catch (t) {
              i(t)
            }
          }

          function s(t) {
            try {
              a(n.throw(t))
            } catch (t) {
              i(t)
            }
          }

          function a(e) {
            e.done ? t(e.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(e.value).then(o, s)
          }
          a((n = n.apply(undefined, e || [])).next())
        })
      }(0, [t, e, r, ...n], void 0, function*(t, e, r, n = !1, i = !0) {
        const o = yield(t => CI(void 0, void 0, void 0, function*() {
          var e;
          return (null !== (e = t.web3Context.transactionBuilder) && void 0 !== e ? e : jI)(Object.assign(Object.assign({}, t), {
            transaction: t.transaction
          }))
        }))({
          transaction: t,
          web3Context: e,
          privateKey: r,
          fillGasPrice: n,
          fillGasLimit: i
        }), s = TI(o, sb, {
          transactionSchema: e.config.customTransactionSchema
        });
        return ((t, e, r = {
          transactionSchema: void 0
        }) => {
          if (!RA(e)) return void e(t);
          if ("object" != typeof t || RA(t)) throw new jm(t);
          (t => {
            if (!RA(t.common)) {
              if (RA(t.common.customChain)) throw new Am;
              if (RA(t.common.customChain.chainId)) throw new Tm;
              if (!RA(t.chainId) && t.chainId !== t.common.customChain.chainId) throw new Em({
                txChainId: t.chainId,
                customChainId: t.common.customChain.chainId
              })
            }
          })(t), (t => {
            if (!RA(t.common) && !RA(t.chain) && !RA(t.hardfork)) throw new xm;
            if (!RA(t.chain) && RA(t.hardfork) || !RA(t.hardfork) && RA(t.chain)) throw new Im({
              chain: t.chain,
              hardfork: t.hardfork
            })
          })(t), (t => {
            if (!RA(t.common) && !RA(t.common.baseChain) && !RA(t.chain) && t.chain !== t.common.baseChain) throw new Pm({
              txChain: t.chain,
              baseChain: t.common.baseChain
            })
          })(t), (t => {
            if (!RA(t.common) && !RA(t.common.hardfork) && !RA(t.hardfork) && t.hardfork !== t.common.hardfork) throw new km({
              txHardfork: t.hardfork,
              commonHardfork: t.common.hardfork
            })
          })(t);
          const n = TI(t, sb, {
            transactionSchema: r.transactionSchema
          });
          if ((t => {
              const e = !RA(t.gas) || !RA(t.gasLimit),
                r = e && !RA(t.gasPrice),
                n = e && !RA(t.maxPriorityFeePerGas) && !RA(t.maxFeePerGas);
              if (!r && !n) throw new Om({
                gas: t.gas,
                gasPrice: t.gasPrice,
                maxPriorityFeePerGas: t.maxPriorityFeePerGas,
                maxFeePerGas: t.maxFeePerGas
              });
              if (r && n) throw new Wm({
                gas: t.gas,
                gasPrice: t.gasPrice,
                maxPriorityFeePerGas: t.maxPriorityFeePerGas,
                maxFeePerGas: t.maxFeePerGas
              });
              (r ? EO : PO)(t), (!RA(t.type) && t.type > "0x1" ? PO : EO)(t)
            })(n), RA(n.nonce) || RA(n.chainId) || n.nonce.startsWith("-") || n.chainId.startsWith("-")) throw new _m({
            nonce: t.nonce,
            chainId: t.chainId
          })
        })(s, void 0, {
          transactionSchema: e.config.customTransactionSchema
        }), Bx.fromTxData((t => {
          var e, r;
          return Object.assign(Object.assign({}, t), {
            nonce: t.nonce,
            gasPrice: t.gasPrice,
            gasLimit: null !== (e = t.gasLimit) && void 0 !== e ? e : t.gas,
            to: t.to,
            value: t.value,
            data: null !== (r = t.data) && void 0 !== r ? r : t.input,
            type: t.type,
            chainId: t.chainId,
            accessList: t.accessList,
            maxPriorityFeePerGas: t.maxPriorityFeePerGas,
            maxFeePerGas: t.maxFeePerGas
          })
        })(s), ((t, e) => {
          var r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y, g, v;
          let w;
          if ((RA(t.chain) || RA(t.hardfork)) && RA(t.common)) e.defaultCommon ? (w = Object.assign({}, e.defaultCommon), RA(w.hardfork) && (w.hardfork = null !== (r = t.hardfork) && void 0 !== r ? r : e.defaultHardfork), RA(w.baseChain) && (w.baseChain = e.defaultChain)) : w = bx.custom({
            name: "custom-network",
            chainId: pT(t.chainId),
            networkId: RA(t.networkId) ? void 0 : pT(t.networkId),
            defaultHardfork: null !== (n = t.hardfork) && void 0 !== n ? n : e.defaultHardfork
          }, {
            baseChain: e.defaultChain
          });
          else {
            const r = null !== (a = null !== (s = null === (o = null === (i = t?.common) || void 0 === i ? void 0 : i.customChain) || void 0 === o ? void 0 : o.name) && void 0 !== s ? s : t.chain) && void 0 !== a ? a : "custom-network",
              n = pT(null !== (f = null === (c = null === (u = t?.common) || void 0 === u ? void 0 : u.customChain) || void 0 === c ? void 0 : c.chainId) && void 0 !== f ? f : t?.chainId),
              A = pT(null !== (d = null === (h = null === (l = t?.common) || void 0 === l ? void 0 : l.customChain) || void 0 === h ? void 0 : h.networkId) && void 0 !== d ? d : t?.networkId),
              T = null !== (m = null !== (b = null === (p = t?.common) || void 0 === p ? void 0 : p.hardfork) && void 0 !== b ? b : t?.hardfork) && void 0 !== m ? m : e.defaultHardfork,
              E = null !== (v = null !== (g = null === (y = t.common) || void 0 === y ? void 0 : y.baseChain) && void 0 !== g ? g : t.chain) && void 0 !== v ? v : e.defaultChain;
            n && A && r && (w = bx.custom({
              name: r,
              chainId: n,
              networkId: A,
              defaultHardfork: T
            }, {
              baseChain: E
            }))
          }
          return {
            common: w
          }
        })(s, e))
      }),
      xO = ({
        address: t
      }, e, r) => {
        var n, i;
        const o = r?.topics,
          s = null !== (n = r?.filter) && void 0 !== n ? n : {},
          a = {};
        if (NT(r?.fromBlock) || (a.fromBlock = JT(pI.properties.number, r?.fromBlock, {
            number: nb.HEX,
            bytes: ib.HEX
          })), NT(r?.toBlock) || (a.toBlock = JT(pI.properties.number, r?.toBlock, {
            number: nb.HEX,
            bytes: ib.HEX
          })), o && Array.isArray(o)) a.topics = [...o];
        else if (a.topics = [], e && !e.anonymous && ![SI, "allEvents"].includes(e.name) && a.topics.push(null !== (i = e.signature) && void 0 !== i ? i : QI(YI(e))), ![SI, "allEvents"].includes(e.name) && e.inputs)
          for (const t of e.inputs) {
            if (!t.indexed) continue;
            const e = s[t.name];
            e ? Array.isArray(e) ? a.topics.push(e.map(e => $S(t.type, e))) : "string" === t.type ? a.topics.push(QT(e)) : a.topics.push($S(t.type, e)) : a.topics.push(null)
          }
        return a.topics.length || delete a.topics, t && (a.address = t.toLowerCase()), a
      },
      IO = (t, e, r) => {
        const n = Array.isArray(t.inputs) ? t.inputs.length : 0;
        if (t.inputs && n !== e.length) throw new Zb(`The number of arguments is not matching the methods required number. You need to pass ${n} arguments.`);
        let i;
        if (i = t.inputs ? FS(Array.isArray(t.inputs) ? t.inputs : [], e).replace("0x", "") : function(t) {
            try {
              return mA(DS({
                type: "tuple",
                name: "",
                components: LS(t)
              }, t).encoded)
            } catch {
              throw new sm("Could not infer types from given params", {
                params: t
              })
            }
          }(e).replace("0x", ""), (t => !NT(t) && "object" == typeof t && !NT(t.type) && "constructor" === t.type)(t)) {
          if (!r) throw new Zb("The contract has no contract data option set. This is necessary to append the constructor parameters.");
          return r.startsWith("0x") ? `${r}${i}` : `0x${r}${i}`
        }
        return `${KS(t)}${i}`
      };
    class SO extends uP {
      constructor(t, e) {
        super(t, e), this.address = t.address, this.topics = t.topics, this.abi = t.abi, this.jsonInterface = t.jsonInterface
      }
      vs() {
        return ["logs", {
          address: this.address,
          topics: this.topics
        }]
      }
      formatSubscriptionResult(t) {
        return tO(this.abi, t, this.jsonInterface, super.returnFormat)
      }
    }
    Array.from({
      length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));
    const OO = (t, e, r, n) => {
        var i, o;
        const s = {};
        return (!NT(t.data) || "both" === n) && (s.data = IO(e, r, null !== (i = t.data) && void 0 !== i ? i : t.input)), (!NT(t.input) || "both" === n) && (s.input = IO(e, r, null !== (o = t.input) && void 0 !== o ? o : t.data)), NT(s.input) && NT(s.data) && (s[n] = IO(e, r)), {
          data: s.data,
          input: s.input
        }
      },
      BO = ({
        abi: t,
        params: e,
        options: r,
        contractOptions: n
      }) => {
        var i, o, s;
        if (!(null !== (s = null !== (o = null !== (i = r?.input) && void 0 !== i ? i : r?.data) && void 0 !== o ? o : n.input) && void 0 !== s ? s : n.data) && !r?.to && !n.address) throw new Zb("Contract address not specified");
        if (!r?.from && !n.from) throw new Zb('Contract "from" address not specified');
        let a = _T({
          to: n.address,
          gas: n.gas,
          gasPrice: n.gasPrice,
          from: n.from,
          input: n.input,
          maxPriorityFeePerGas: n.maxPriorityFeePerGas,
          maxFeePerGas: n.maxFeePerGas,
          data: n.data
        }, r);
        const u = OO(a, t, e, r?.dataInputFill);
        return a = Object.assign(Object.assign({}, a), {
          data: u.data,
          input: u.input
        }), a
      },
      WO = t => "object" == typeof t && !NT(t) && 0 !== Object.keys(t).length && !RT(t);
    class MO {
      Xs(t) {
        const e = {
          transactionResolver: t => {
            if (t.status === BigInt(0)) throw new Zb("code couldn't be stored", t);
            const e = this.parent.clone();
            return e.options.address = t.contractAddress, e
          },
          contractAbi: this.parent.options.jsonInterface,
          checkRevertBeforeSending: !1
        };
        return RA(this.parent.getTransactionMiddleware()) ? cO(this.parent, t, this.parent.defaultReturnFormat, e) : cO(this.parent, t, this.parent.defaultReturnFormat, e, this.parent.getTransactionMiddleware())
      }
      constructor(t, e) {
        this.parent = t, this.deployOptions = e;
        const {
          args: r,
          abi: n,
          contractOptions: i,
          deployData: o
        } = this.calculateDeployParams();
        this.args = r, this.constructorAbi = n, this.contractOptions = i, this.deployData = o
      }
      send(t) {
        const e = Object.assign({}, t),
          r = this.populateTransaction(e);
        return this.Xs(r)
      }
      populateTransaction(t) {
        var e, r;
        const n = Object.assign(Object.assign({}, this.contractOptions), {
            from: null !== (r = null !== (e = this.contractOptions.from) && void 0 !== e ? e : this.parent.defaultAccount) && void 0 !== r ? r : void 0
          }),
          i = BO({
            abi: this.constructorAbi,
            params: this.args,
            options: Object.assign(Object.assign({}, t), {
              dataInputFill: this.parent.contractDataInputFill
            }),
            contractOptions: n
          });
        return i.dataInputFill && delete i.dataInputFill, i
      }
      calculateDeployParams() {
        var t, e, r, n, i, o;
        let s = this.parent.options.jsonInterface.find(t => "constructor" === t.type);
        s || (s = {
          type: "constructor",
          stateMutability: ""
        });
        const a = JT({
            format: "bytes"
          }, null !== (e = null === (t = this.deployOptions) || void 0 === t ? void 0 : t.input) && void 0 !== e ? e : this.parent.options.input, ob),
          u = JT({
            format: "bytes"
          }, null !== (n = null === (r = this.deployOptions) || void 0 === r ? void 0 : r.data) && void 0 !== n ? n : this.parent.options.data, ob);
        if (!(a && "0x" !== a.trim() || u && "0x" !== u.trim())) throw new Zb("contract creation without any data provided.");
        return {
          args: null !== (o = null === (i = this.deployOptions) || void 0 === i ? void 0 : i.arguments) && void 0 !== o ? o : [],
          abi: s,
          contractOptions: Object.assign(Object.assign({}, this.parent.options), {
            input: a,
            data: u
          }),
          deployData: a ?? u
        }
      }
      estimateGas(t) {
        return function(t, e, r, n) {
          return new(r || (r = Promise))(function(i, o) {
            function s(t) {
              try {
                u(n.next(t))
              } catch (t) {
                o(t)
              }
            }

            function a(t) {
              try {
                u(n.throw(t))
              } catch (t) {
                o(t)
              }
            }

            function u(t) {
              t.done ? i(t.value) : function(t) {
                return t instanceof r ? t : new r(function(e) {
                  e(t)
                })
              }(t.value).then(s, a)
            }
            u((n = n.apply(t, e || [])).next())
          })
        }(this, arguments, void 0, function*(t, e = this.parent.defaultReturnFormat) {
          const r = Object.assign({}, t);
          return this.parent.contractMethodEstimateGas({
            abi: this.constructorAbi,
            params: this.args,
            returnFormat: e,
            options: r,
            contractOptions: this.contractOptions
          })
        })
      }
      encodeABI() {
        return IO(this.constructorAbi, this.args, JT({
          format: "bytes"
        }, this.deployData, this.parent.defaultReturnFormat))
      }
      decodeData(t) {
        return Object.assign(Object.assign({}, VS(this.constructorAbi, t.replace(this.deployData, ""), !1)), {
          Qs: this.constructorAbi.type
        })
      }
    }
    class CO extends sP {
      constructor(t, e) {
        super(t.requestManager, t.registeredSubscriptions), this.parentContract = e
      }
      subscribe(t, e) {
        const r = Object.create(null, {
          subscribe: {
            get: () => super.subscribe
          }
        });
        return function(t, e, r, n) {
          return new(r || (r = Promise))(function(i, o) {
            function s(t) {
              try {
                u(n.next(t))
              } catch (t) {
                o(t)
              }
            }

            function a(t) {
              try {
                u(n.throw(t))
              } catch (t) {
                o(t)
              }
            }

            function u(t) {
              t.done ? i(t.value) : function(t) {
                return t instanceof r ? t : new r(function(e) {
                  e(t)
                })
              }(t.value).then(s, a)
            }
            u((n = n.apply(t, e || [])).next())
          })
        }(this, arguments, void 0, function*(t, e, n = ob) {
          return r.subscribe.call(this, t, e ?? this.parentContract.options, n)
        })
      }
    }
    var RO = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    const NO = {
      logs: SO,
      newHeads: gO,
      newBlockHeaders: gO
    };
    class jO extends zx {
      get subscriptionManager() {
        return this.ds
      }
      constructor(t, e, r, n, i) {
        var o, s, a;
        const u = RT(e) ? e : RT(r) ? r : void 0;
        let c, f;
        if (c = WO(e) ? e : WO(r) ? r : n, f = "object" == typeof e && "provider" in e ? e.provider : "object" == typeof r && "provider" in r ? r.provider : "object" == typeof n && "provider" in n ? n.provider : jO.givenProvider, super(Object.assign(Object.assign({}, c), {
            provider: f,
            registeredSubscriptions: NO
          })), this.syncWithContext = !1, this._a = {}, this.ds = new CO(super.subscriptionManager, this), c?.wallet && (this.Vs = c.wallet), c?.accountProvider && (this.fo = c.accountProvider), !RA(u) && !RA(u.data) && !RA(u.input) && "both" !== this.config.contractDataInputFill) throw new Qb({
          data: u.data,
          input: u.input
        });
        this.tu = new Map;
        const l = GT(n) ? n : GT(r) ? r : i ?? this.defaultReturnFormat,
          h = "string" == typeof e ? e : void 0;
        this.config.contractDataInputFill = null !== (o = u?.dataInputFill) && void 0 !== o ? o : this.config.contractDataInputFill, this.eu(t, l), this.defaultReturnFormat !== l && (this.defaultReturnFormat = l), RA(h) || this.ru(h, l), this.options = {
          address: h,
          jsonInterface: this.nu,
          gas: null !== (s = u?.gas) && void 0 !== s ? s : u?.gasLimit,
          gasPrice: u?.gasPrice,
          from: u?.from,
          input: u?.input,
          data: u?.data
        }, this.syncWithContext = null !== (a = u?.syncWithContext) && void 0 !== a && a, c instanceof zx && this.subscribeToContextEvents(c), Object.defineProperty(this.options, "address", {
          set: t => this.ru(t, l),
          get: () => this.iu
        }), Object.defineProperty(this.options, "jsonInterface", {
          set: t => this.eu(t, l),
          get: () => this.nu
        }), c instanceof zx && c.on($E.CONFIG_CHANGE, t => {
          this.setConfig({
            [t.name]: t.newValue
          })
        })
      }
      setTransactionMiddleware(t) {
        this.transactionMiddleware = t
      }
      getTransactionMiddleware() {
        return this.transactionMiddleware
      }
      get events() {
        return this.ye
      }
      get methods() {
        return this.ou
      }
      clone() {
        let t;
        return t = this.options.address ? new jO([...this.nu, ...this.su], this.options.address, {
          gas: this.options.gas,
          gasPrice: this.options.gasPrice,
          from: this.options.from,
          input: this.options.input,
          data: this.options.data,
          provider: this.currentProvider,
          syncWithContext: this.syncWithContext,
          dataInputFill: this.config.contractDataInputFill
        }, this.getContextObject()) : new jO([...this.nu, ...this.su], {
          gas: this.options.gas,
          gasPrice: this.options.gasPrice,
          from: this.options.from,
          input: this.options.input,
          data: this.options.data,
          provider: this.currentProvider,
          syncWithContext: this.syncWithContext,
          dataInputFill: this.config.contractDataInputFill
        }, this.getContextObject()), this.context && t.subscribeToContextEvents(this.context), t
      }
      deploy(t) {
        return new MO(this, t)
      }
      getPastEvents(t, e, r) {
        return RO(this, void 0, void 0, function*() {
          var n;
          const i = "string" == typeof t ? t : SI,
            o = "string" == typeof t || GT(t) ? GT(e) ? {} : e : t,
            s = GT(t) ? t : GT(e) ? e : r ?? this.defaultReturnFormat,
            a = "allEvents" === i || i === SI ? OI : this.nu.find(t => "name" in t && t.name === i);
          if (!a) throw new Zb(`Event ${i+""} not found.`);
          const {
            fromBlock: u,
            toBlock: c,
            topics: f,
            address: l
          } = xO(this.options, a, o ?? {}), h = yield hO(this, {
            fromBlock: u,
            toBlock: c,
            topics: f,
            address: l
          }, s), d = h ? h.map(t => "string" == typeof t ? t : tO(a, t, this.nu, s)) : [], p = null !== (n = o?.filter) && void 0 !== n ? n : {}, b = Object.keys(p);
          return b.length > 0 ? d.filter(t => "string" == typeof t || b.every(e => {
            var r;
            if (Array.isArray(p[e])) return p[e].some(r => (t.returnValues[e] + "").toUpperCase() === (r + "").toUpperCase());
            const n = null === (r = a.inputs) || void 0 === r ? void 0 : r.filter(t => t.name === e)[0];
            return !(!n?.indexed || "string" !== n.type || QT(p[e]) !== t.returnValues[e] + "") || (t.returnValues[e] + "").toUpperCase() === (p[e] + "").toUpperCase()
          })) : d
        })
      }
      ru(t, e = this.defaultReturnFormat) {
        this.iu = t && gT(JT({
          format: "address"
        }, t, e))
      }
      decodeMethodData(t) {
        const e = t.slice(0, 10),
          r = this.nu.filter(t => "error" !== t.type).find(t => e === KS(YI(t)));
        if (!r) throw new Zb(`The ABI for the provided method signature ${e} was not found.`);
        return VS(r, t)
      }
      eu(t, e = this.defaultReturnFormat) {
        var r, n;
        this._a = {}, this.ou = {}, this.ye = {};
        let i = [];
        const o = t.filter(t => "error" !== t.type),
          s = t.filter(t => GI(t));
        for (const t of o) {
          const o = Object.assign(Object.assign({}, t), {
            signature: ""
          });
          if (VI(o)) {
            const t = YI(o),
              e = KS(t);
            o.methodNameWithInputs = t, o.signature = e, o.constant = "view" === o.stateMutability || "pure" === o.stateMutability || o.constant, o.payable = "payable" === o.stateMutability || o.payable, this.tu.set(o.name, [...null !== (r = this.tu.get(o.name)) && void 0 !== r ? r : [], o]);
            const i = null !== (n = this.tu.get(o.name)) && void 0 !== n ? n : [],
              a = this.au(i, s),
              u = this.au(i, s, !0);
            this._a[t] = {
              signature: e,
              method: u
            }, this.ou[o.name] = a, this.ou[t] = u, this.ou[e] = u
          } else if (KI(o)) {
            const t = YI(o),
              r = QI(t),
              n = this.uu(o, e);
            o.signature = r, (!(t in this.ye) || "bound" === o.name) && (this.ye[t] = n), this.ye[o.name] = n, this.ye[r] = n
          }
          i = [...i, o]
        }
        this.ye.allEvents = this.uu(OI, e), this.nu = [...i], this.su = s
      }
      cu(t, e) {
        var r;
        try {
          return lA(null !== (r = t.inputs) && void 0 !== r ? r : [], e)
        } catch (e) {
          throw new Zb(`Invalid parameters for method ${t.name}: ${e.message}`)
        }
      }
      au(t, e, r = !1) {
        const n = t[t.length - 1];
        return (...t) => {
          var i, o, s;
          let a;
          const u = null !== (o = r ? null === (i = this.tu.get(n.name)) || void 0 === i ? void 0 : i.filter(t => t.signature === n.signature) : this.tu.get(n.name)) && void 0 !== o ? o : [];
          let c = u[0];
          const f = e,
            l = u.filter(e => {
              var r;
              return (null !== (r = e.inputs) && void 0 !== r ? r : []).length === t.length
            });
          if (1 === u.length || 0 === l.length) a = this.cu(c, t), FA.validate(null !== (s = n.inputs) && void 0 !== s ? s : [], a);
          else {
            const e = [],
              r = [];
            for (const n of l) try {
              a = this.cu(n, t), FA.validate(n.inputs, a), r.push(n)
            } catch (t) {
              e.push(t)
            }
            if (1 === r.length ? [c] = r : r.length > 1 && ([c] = r, console.warn(`Multiple methods found that is compatible with the given inputs.\n\tFound ${r.length} compatible methods: ${JSON.stringify(r.map(t=>`${t.methodNameWithInputs} (signature: ${t.signature})`))} \n\tThe first one will be used: ${c.methodNameWithInputs}`)), e.length === l.length) throw new Jw(e)
          }
          const h = {
            arguments: a,
            call: (t, e) => RO(this, void 0, void 0, function*() {
              return this.fu(c, a, f, t, e)
            }),
            send: t => this.lu(c, a, f, t),
            populateTransaction: (e, r) => {
              var i, o;
              let s = r ?? this.options;
              s = Object.assign(Object.assign({}, s), {
                input: void 0,
                from: null !== (o = null !== (i = s?.from) && void 0 !== i ? i : this.defaultAccount) && void 0 !== o ? o : void 0
              });
              const a = BO({
                abi: n,
                params: t,
                options: Object.assign(Object.assign({}, e), {
                  dataInputFill: this.config.contractDataInputFill
                }),
                contractOptions: s
              });
              return a.dataInputFill && delete a.dataInputFill, a
            },
            estimateGas: (t, ...e) => RO(this, [t, ...e], void 0, function*(t, e = this.defaultReturnFormat) {
              return this.contractMethodEstimateGas({
                abi: c,
                params: a,
                returnFormat: e,
                options: t
              })
            }),
            encodeABI: () => IO(c, a),
            decodeData: t => VS(c, t),
            createAccessList: (t, e) => RO(this, void 0, void 0, function*() {
              return this.hu(c, a, f, t, e)
            })
          };
          return c.stateMutability, h
        }
      }
      fu(t, e, r, n, i) {
        return RO(this, void 0, void 0, function*() {
          var o;
          const s = (({
            abi: t,
            params: e,
            options: r,
            contractOptions: n
          }) => {
            if (!r?.to && !n.address) throw new Zb("Contract address not specified");
            let i = _T({
              to: n.address,
              gas: n.gas,
              gasPrice: n.gasPrice,
              from: n.from,
              input: n.input,
              maxPriorityFeePerGas: n.maxPriorityFeePerGas,
              maxFeePerGas: n.maxFeePerGas,
              data: n.data
            }, r);
            const o = OO(i, t, e, r?.dataInputFill);
            return i = Object.assign(Object.assign({}, i), {
              data: o.data,
              input: o.input
            }), i
          })({
            abi: t,
            params: e,
            options: Object.assign(Object.assign({}, n), {
              dataInputFill: this.config.contractDataInputFill
            }),
            contractOptions: Object.assign(Object.assign({}, this.options), {
              from: null !== (o = this.options.from) && void 0 !== o ? o : this.config.defaultAccount
            })
          });
          try {
            const e = yield fO(this, s, i, this.defaultReturnFormat);
            return ((t, e) => {
              if ("constructor" === t.type) return e;
              if (!e) return null;
              const r = 2 > e.length ? e : e.slice(2);
              if (!t.outputs) return null;
              const n = HS([...t.outputs], r);
              return 1 === n.Ys ? n[0] : n
            })(t, e)
          } catch (t) {
            throw t instanceof Yb && JS(r, t.cause), t
          }
        })
      }
      hu(t, e, r, n, i) {
        return RO(this, void 0, void 0, function*() {
          var o;
          const s = (({
            abi: t,
            params: e,
            options: r,
            contractOptions: n
          }) => {
            if (!r?.to && !n.address) throw new Zb("Contract address not specified");
            if (!r?.from && !n.from) throw new Zb('Contract "from" address not specified');
            let i = _T({
              to: n.address,
              gas: n.gas,
              gasPrice: n.gasPrice,
              from: n.from,
              input: n.input,
              maxPriorityFeePerGas: n.maxPriorityFeePerGas,
              maxFeePerGas: n.maxFeePerGas,
              data: n.data
            }, r);
            const o = OO(i, t, e, r?.dataInputFill);
            return i = Object.assign(Object.assign({}, i), {
              data: o.data,
              input: o.input
            }), i
          })({
            abi: t,
            params: e,
            options: Object.assign(Object.assign({}, n), {
              dataInputFill: this.config.contractDataInputFill
            }),
            contractOptions: Object.assign(Object.assign({}, this.options), {
              from: null !== (o = this.options.from) && void 0 !== o ? o : this.config.defaultAccount
            })
          });
          try {
            return pO(this, s, i, this.defaultReturnFormat)
          } catch (t) {
            throw t instanceof Yb && JS(r, t.cause), t
          }
        })
      }
      lu(t, e, r, n, i) {
        var o, s;
        let a = i ?? this.options;
        a = Object.assign(Object.assign({}, a), {
          input: void 0,
          from: null !== (s = null !== (o = a.from) && void 0 !== o ? o : this.defaultAccount) && void 0 !== s ? s : void 0
        });
        const u = BO({
            abi: t,
            params: e,
            options: Object.assign(Object.assign({}, n), {
              dataInputFill: this.config.contractDataInputFill
            }),
            contractOptions: a
          }),
          c = RA(this.transactionMiddleware) ? cO(this, u, this.defaultReturnFormat, {
            checkRevertBeforeSending: !1,
            contractAbi: this.nu
          }) : cO(this, u, this.defaultReturnFormat, {
            checkRevertBeforeSending: !1,
            contractAbi: this.nu
          }, this.transactionMiddleware);
        return c.on("error", t => {
          t instanceof Yb && JS(r, t.cause)
        }), c
      }
      contractMethodEstimateGas(t) {
        return RO(this, arguments, void 0, function*({
          abi: t,
          params: e,
          returnFormat: r,
          options: n,
          contractOptions: i
        }) {
          const o = (({
            abi: t,
            params: e,
            options: r,
            contractOptions: n
          }) => {
            let i = _T({
              to: n.address,
              gas: n.gas,
              gasPrice: n.gasPrice,
              from: n.from,
              input: n.input,
              data: n.data
            }, r);
            const o = OO(i, t, e, r?.dataInputFill);
            return i = Object.assign(Object.assign({}, i), {
              data: o.data,
              input: o.input
            }), i
          })({
            abi: t,
            params: e,
            options: Object.assign(Object.assign({}, n), {
              dataInputFill: this.config.contractDataInputFill
            }),
            contractOptions: i ?? this.options
          });
          return lO(this, o, ab.LATEST, r ?? this.defaultReturnFormat)
        })
      }
      uu(t, e = this.defaultReturnFormat) {
        return (...r) => {
          var n;
          const {
            topics: i,
            fromBlock: o
          } = xO(this.options, t, r[0]), s = new SO({
            address: this.options.address,
            topics: i,
            abi: t,
            jsonInterface: this.nu
          }, {
            subscriptionManager: this.subscriptionManager,
            returnFormat: e
          });
          return RA(o) || this.getPastEvents(t.name, {
            fromBlock: o,
            topics: i
          }, e).then(t => {
            t && t.forEach(t => s.emit("data", t))
          }).catch(t => {
            s.emit("error", new fm("Failed to get past events.", t))
          }), null === (n = this.subscriptionManager) || void 0 === n || n.addSubscription(s).catch(t => {
            s.emit("error", new fm("Failed to subscribe.", t))
          }), s
        }
      }
      subscribeToContextEvents(t) {
        const e = this;
        this.context = t, e.syncWithContext && t.on($E.CONFIG_CHANGE, t => {
          e.setConfig({
            [t.name]: t.newValue
          })
        })
      }
    }
    const _O = jO,
      DO = {
        addr: "0x3b3b57de",
        name: "0x691f3431",
        abi: "0x2203ab56",
        pubkey: "0xc8690233",
        text: "0x59d1d43c",
        contenthash: "0xbc1c58d1"
      },
      UO = {
        main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
      },
      LO = {
        "0x1": "main",
        "0x5": "goerli"
      },
      FO = [{
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !0,
          internalType: "bytes32",
          name: "label",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "address",
          name: "owner",
          type: "address"
        }],
        name: "NewOwner",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "address",
          name: "resolver",
          type: "address"
        }],
        name: "NewResolver",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "address",
          name: "owner",
          type: "address"
        }],
        name: "Transfer",
        type: "event"
      }, {
        inputs: [{
          internalType: "address",
          name: "owner",
          type: "address"
        }, {
          internalType: "address",
          name: "operator",
          type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "owner",
        outputs: [{
          internalType: "address",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "recordExists",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "resolver",
        outputs: [{
          internalType: "address",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "ttl",
        outputs: [{
          internalType: "uint64",
          name: "",
          type: "uint64"
        }],
        stateMutability: "view",
        type: "function"
      }],
      $O = [{
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "address",
          name: "a",
          type: "address"
        }],
        name: "AddrChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "uint256",
          name: "coinType",
          type: "uint256"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "newAddress",
          type: "bytes"
        }],
        name: "AddressChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "address",
          name: "owner",
          type: "address"
        }, {
          indexed: !0,
          internalType: "address",
          name: "operator",
          type: "address"
        }, {
          indexed: !1,
          internalType: "bool",
          name: "approved",
          type: "bool"
        }],
        name: "ApprovalForAll",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "hash",
          type: "bytes"
        }],
        name: "ContenthashChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "name",
          type: "bytes"
        }, {
          indexed: !1,
          internalType: "uint16",
          name: "resource",
          type: "uint16"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "record",
          type: "bytes"
        }],
        name: "DNSRecordChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "name",
          type: "bytes"
        }, {
          indexed: !1,
          internalType: "uint16",
          name: "resource",
          type: "uint16"
        }],
        name: "DNSRecordDeleted",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "DNSZoneCleared",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "lastzonehash",
          type: "bytes"
        }, {
          indexed: !1,
          internalType: "bytes",
          name: "zonehash",
          type: "bytes"
        }],
        name: "DNSZonehashChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !0,
          internalType: "bytes4",
          name: "interfaceID",
          type: "bytes4"
        }, {
          indexed: !1,
          internalType: "address",
          name: "implementer",
          type: "address"
        }],
        name: "InterfaceChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "string",
          name: "name",
          type: "string"
        }],
        name: "NameChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes32",
          name: "x",
          type: "bytes32"
        }, {
          indexed: !1,
          internalType: "bytes32",
          name: "y",
          type: "bytes32"
        }],
        name: "PubkeyChanged",
        type: "event"
      }, {
        anonymous: !1,
        inputs: [{
          indexed: !0,
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          indexed: !0,
          internalType: "string",
          name: "indexedKey",
          type: "string"
        }, {
          indexed: !1,
          internalType: "string",
          name: "key",
          type: "string"
        }],
        name: "TextChanged",
        type: "event"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "uint256",
          name: "contentTypes",
          type: "uint256"
        }],
        name: "ABI",
        outputs: [{
          internalType: "uint256",
          name: "",
          type: "uint256"
        }, {
          internalType: "bytes",
          name: "",
          type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "addr",
        outputs: [{
          internalType: "address payable",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "uint256",
          name: "coinType",
          type: "uint256"
        }],
        name: "addr",
        outputs: [{
          internalType: "bytes",
          name: "",
          type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "contenthash",
        outputs: [{
          internalType: "bytes",
          name: "",
          type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "bytes32",
          name: "name",
          type: "bytes32"
        }, {
          internalType: "uint16",
          name: "resource",
          type: "uint16"
        }],
        name: "dnsRecord",
        outputs: [{
          internalType: "bytes",
          name: "",
          type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "bytes32",
          name: "name",
          type: "bytes32"
        }],
        name: "hasDNSRecords",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "bytes4",
          name: "interfaceID",
          type: "bytes4"
        }],
        name: "interfaceImplementer",
        outputs: [{
          internalType: "address",
          name: "",
          type: "address"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "address",
          name: "account",
          type: "address"
        }, {
          internalType: "address",
          name: "operator",
          type: "address"
        }],
        name: "isApprovedForAll",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "name",
        outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "pubkey",
        outputs: [{
          internalType: "bytes32",
          name: "x",
          type: "bytes32"
        }, {
          internalType: "bytes32",
          name: "y",
          type: "bytes32"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes4",
          name: "interfaceID",
          type: "bytes4"
        }],
        name: "supportsInterface",
        outputs: [{
          internalType: "bool",
          name: "",
          type: "bool"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "string",
          name: "key",
          type: "string"
        }],
        name: "text",
        outputs: [{
          internalType: "string",
          name: "",
          type: "string"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }],
        name: "zonehash",
        outputs: [{
          internalType: "bytes",
          name: "",
          type: "bytes"
        }],
        stateMutability: "view",
        type: "function"
      }, {
        inputs: [{
          internalType: "bytes32",
          name: "node",
          type: "bytes32"
        }, {
          internalType: "address",
          name: "a",
          type: "address"
        }],
        name: "setAddr",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }],
      zO = new Map([
        [8217, "apostrophe"],
        [8260, "fraction slash"],
        [12539, "middle dot"]
      ]);

    function HO(t) {
      return function(t) {
        let e = 0;
        return () => t[e++]
      }(function(t) {
        let e = 0;

        function r() {
          return t[e++] << 8 | t[e++]
        }
        let n = r(),
          i = 1,
          o = [0, 1];
        for (let t = 1; n > t; t++) o.push(i += r());
        let s = r(),
          a = e;
        e += s;
        let u = 0,
          c = 0;

        function f() {
          return 0 == u && (c = c << 8 | t[e++], u = 8), c >> --u & 1
        }
        const l = 2 ** 31,
          h = l >>> 1,
          d = h >> 1,
          p = l - 1;
        let b = 0;
        for (let t = 0; 31 > t; t++) b = b << 1 | f();
        let m = [],
          y = 0,
          g = l;
        for (;;) {
          let t = Math.floor(((b - y + 1) * i - 1) / g),
            e = 0,
            r = n;
          for (; r - e > 1;) {
            let n = e + r >>> 1;
            t < o[n] ? r = n : e = n
          }
          if (0 == e) break;
          m.push(e);
          let s = y + Math.floor(g * o[e] / i),
            a = y + Math.floor(g * o[e + 1] / i) - 1;
          for (; 0 == ((s ^ a) & h);) b = b << 1 & p | f(), s = s << 1 & p, a = a << 1 & p | 1;
          for (; s & ~a & d;) b = b & h | b << 1 & p >>> 1 | f(), s = s << 1 ^ h, a = (a ^ h) << 1 | h | 1;
          y = s, g = 1 + a - s
        }
        let v = n - 4;
        return m.map(e => {
          switch (e - v) {
            case 3:
              return v + 65792 + (t[a++] << 16 | t[a++] << 8 | t[a++]);
            case 2:
              return v + 256 + (t[a++] << 8 | t[a++]);
            case 1:
              return v + t[a++];
            default:
              return e - 1
          }
        })
      }(function(t) {
        let e = [];
        [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((t, r) => e[t.charCodeAt(0)] = r);
        let r = t.length,
          n = new Uint8Array(6 * r >> 3);
        for (let i = 0, o = 0, s = 0, a = 0; r > i; i++) a = a << 6 | e[t.charCodeAt(i)], s += 6, s >= 8 && (n[o++] = a >> (s -= 8));
        return n
      }(t)))
    }

    function GO(t) {
      return 1 & t ? ~t >> 1 : t >> 1
    }

    function KO(t, e) {
      let r = Array(t);
      for (let n = 0, i = 0; t > n; n++) r[n] = i += GO(e());
      return r
    }

    function VO(t, e = 0) {
      let r = [];
      for (;;) {
        let n = t(),
          i = t();
        if (!i) break;
        e += n;
        for (let t = 0; i > t; t++) r.push(e + t);
        e += i + 1
      }
      return r
    }

    function ZO(t) {
      return JO(() => {
        let e = VO(t);
        if (e.length) return e
      })
    }

    function qO(t) {
      let e = [];
      for (;;) {
        let r = t();
        if (0 == r) break;
        e.push(QO(r, t))
      }
      for (;;) {
        let r = t() - 1;
        if (0 > r) break;
        e.push(XO(r, t))
      }
      return e.flat()
    }

    function JO(t) {
      let e = [];
      for (;;) {
        let r = t(e.length);
        if (!r) break;
        e.push(r)
      }
      return e
    }

    function YO(t, e, r) {
      let n = Array(t).fill().map(() => []);
      for (let i = 0; e > i; i++) KO(t, r).forEach((t, e) => n[e].push(t));
      return n
    }

    function QO(t, e) {
      let r = 1 + e(),
        n = e(),
        i = JO(e);
      return YO(i.length, 1 + t, e).flatMap((t, e) => {
        let [o, ...s] = t;
        return Array(i[e]).fill().map((t, e) => {
          let i = e * n;
          return [o + e * r, s.map(t => t + i)]
        })
      })
    }

    function XO(t, e) {
      return YO(1 + e(), 1 + t, e).map(t => [t[0], t.slice(1)])
    }

    function tB(t) {
      return `{${function(t){return t.toString(16).toUpperCase().padStart(2,"0")}(t)}}`
    }

    function eB(t) {
      let e = t.length;
      if (4096 > e) return String.fromCodePoint(...t);
      let r = [];
      for (let n = 0; e > n;) r.push(String.fromCodePoint(...t.slice(n, n += 4096)));
      return r.join("")
    }

    function rB(t, e) {
      let r = t.length,
        n = r - e.length;
      for (let i = 0; 0 == n && r > i; i++) n = t[i] - e[i];
      return n
    }
    const nB = 44032,
      iB = 4352,
      oB = 4449,
      sB = 4519;

    function aB(t) {
      return t >> 24 & 255
    }

    function uB(t) {
      return 16777215 & t
    }
    let cB, fB, lB, hB;

    function dB(t) {
      return t >= nB && 55204 > t
    }

    function pB(t, e) {
      if (t >= iB && 4371 > t && e >= oB && 4470 > e) return nB + 588 * (t - iB) + 28 * (e - oB);
      if (dB(t) && e > sB && 4547 > e && (t - nB) % 28 == 0) return t + (e - sB);
      {
        let r = hB.get(t);
        return r && (r = r.get(e), r) ? r : -1
      }
    }

    function bB(t) {
      cB || function() {
        let t = HO("AEUDWAHSCGYATwDVADIAdgAiADQAFAAtABQAIQAPACcADQASAAsAGQAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAecDNACxCmIB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJEMAJpIBpob5AERSMAKNoAXqaQLRBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobPgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vLIBDAHUGVsQ8wCzfQIbGVcCHBZHAZ8CBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rpF27H7fsd/twPt4l+UW1yQYKBt2Cgy7qJpGiLcdE2P1cQSImUbqJ6ICH27H4knQMIRMrFkHu3sx6tC35Y+eLIh4e4CMKJ4DfyV+8mfta499RCAJ0xfeZR8PsoYOApva9pjGn4PhvyZS7/h5JLuhaucfjuU+Z584wwqNO4hWYmaBCcjgQPale1bjoHzMUbut/zTgxHxBnAyrdKpF4IRMASLBtD/jviyLeCgj8twWjAd3HchN/uqaeRYeHJgl7JEY9/cTrvtfybx/r3Y/NtxJ9dp+MTVmiS9bwBH73s8Di56/Ma+mTPMHq4T1yEG1fWcqr0u+hrGnJEvU1JJAm/maQSrKrazIyvSkDFkj8UUlfBq8baniTGPng6YZRL661rDNw4w/1g2figG0IhXnL7wosd/sVNo5dYSmMBTP5c7rYLjRdCwg8quwljOMPf63D8ICAL0r71XRiyFHdgwHbwfgnPOf4Lzjf2v+j+IiDHG2isp5yUnzSDyDRb4i/Vs0qHSHq8PiEQ/JnBP7PxnjN0j6gT4AVAeRx/1o9VnEUlUwvFrzJqHk9jxAw4sYxCnrxaeBdCFFKbnE7z+x54F5W7ZZsU6kx8Qocul6FoAHHy01FGL/nne61mn4+uYXfQ1Uccn+HMLKE+cZzT8BB1E3FRskOgJrRsq25rauLm8+uamXpkS/bTy6y1wDbCrW4eD532kTWrtNUmVVZOIn/C+/JR9KVR5iG9TY8iaT67ubm/whL1xbKZoqtY+a6fNxMJrg211bGYJDUkYMNWA0BMB++9zOm6Eik4roqs9CCEFW0lyAK0PbvlzvoxrZuY/OEhNW/l/63U15Od/RSvmDvXpGLiVmeGi5PDSH2bYz5o2g6wFDQ2FbZgYgTF8rPlvA1ifjZD3NLtFdXdpSIJvgKR7GpjJWG7GZGawPomIH8B5tUmtHH9LpM+/KQKunEPa1GiQkCXv4Cnm9DLORo2joicHdPDZ64obQrPZ5bgqckkj0G6/NEiPYBY4bCkL7W8G5YzsUb6GakFjykSPkT7JGeLeB6uJOGMm+x7N381BCDfbJFx0dtLgV9Q477BfL1fvitX5anV/oYfxeYl+eF5x5bB8+Ep/L2nsmd56aKF4aAD4GbJWsdKyBW22xEmAD3XdbtsMyAFoR5mOla0gEd9U/YVB7zvHGpHbQonay9Sv0bQ8iZ8piaXVrKc5AG1AmqqgaEvzHSP2Wux7aZTWh6quVDVU01JtMIVRdCFwlSbbqqhoFlyzsotQzRexFvZ/MqUSFu3OhRIuNBbufvBpdVgb8XdGJ48/lJPCZ7dsOujTTbKPSEvGXkOnG2Xdi8/nM3EMRqITd5QeU7iOjKqC7URJY6TnLsHij22xAHKnVRD5MDtBYnoGFqZGMDmXCW6Oj+BAWw14hESY/xLF6bLku06AHkiXTHPCFZ0f9YSqqo27eAhhS67OrA2Het4M9JM3jm/yRX6bYxnfmzYl5qQdHxN08FsNuWDrWd4vMUY2QD3hr8vS73SCTkFoXZR3xNzOQt8d/6HfjBmXqvrE6EGkLzK6YK2U2/ksU/iUH+LvVIsJI+ri2AL/klo+ShdDyfs5A83i2prkMs51IKR7ZcqjZJi5X3+bd8GlyWvtddxKEoEqSgEO7A8jIgf2nH0h8FjM7oB6yte3X5mpL0i/E4Rx0CotKnILJj/vJqo4VkPQ93jRtRVfaitQPqldl5xRYPq8387Z0DcnZvOeION0Ht1+P27kFLGQIcLBX4FG3sffccNHh5cPfzp9INoRtqVtdViJfg8RjnXiIz/MNqEN6zvzX3hMzyWC7oSoXIT14ubc0abPX8Rp9GVa5NI/8iv+6ela1oTncbdimRKnrbRffDR/X4nH+bgqAuHWl7hOaeXPWVzIeRl7ga+JzD4Sx3mlj/q6Ra/E2HhDf21eEzTLNGfCZsY+/yxZzQzIAuijG65ii4O/waAJCrEJaWd/DRAKMQ5678Dw5AT7RCKzdadIwd8LsD+DgPBASmWsUlf8R0k1w/2k4lO2Wpb4zMI6EJVJs0xk/wn8/fRUPqrDKhbjHR41SqgFMx5RGMPuduFwlu5lK89tW11sTqiX/5EfGs5nO+y9FKvgXKPOEmgE05EKNL6Sjb3xS40H3BVPhm0ESOZgAjZoymc8be0inDVo4JdJVf+NKd3tN/CaB7GShhH27qf95NoFZVX/6ZkR2lX+CgWrQ2INgkh+bbMz68+uJ3Clsh8HSMPEQtAt+BBE6fXDab7KIlsKxU1lIXW/KWVstpdPanJ0pdXpQinDyUQjtY7ZVcfiecRxRDMAUhHFU2cEaciQ+htiPMPx1kdvtWG9T44w3r037ljHBFJdYR0r55qvMRixtAEFJAqA4T1ES87FAx7UozXasytg8MftZYt0rjYgLe6EJ5aWvy2qscBSBQ7yehoJIA3wIIZ9ukfkyBb6qnue5ko8W50rpV4kXqWjI5nbGRXrNW0tBZHXlY48nSgcUXBHWT4GcgLZJoLlKJnV96kCYpq9eWHh7xJzkCAyrQuQ5AJ0qq/uZ3toJglNterev+Qm0KXxPg/+YbFRJdfhbp1wOnVOEYdVHTya6CtO0afhEaBhx3oHwCb5Kq6RwHDzFMl2vfjL8GwzcCoTj7wZe+UFnYDV2yKpPU9dba29gYBdNqJg/KXozO+CJTlKmlKhnqTf5doeS35DZFV+cYJQVjd+oVY/Gtc/6XPzUxb1gMqf6cEjNNoRC8AObrp+fx0cVtGu4ffC2TgXRC8zPl8moUHCB5HZ25d87mlsiiK0aNwBtcEQjRNBT/QrXbw/8aVXdKMHn9EqYEKEyxSGTpYQOaes1G1Qq8pDgqkZtlO2HRyCXpmeM7TSrRPkAh004BfisVpF6zP44n2Jvxz/gOVocNCyy9V6lkod28QM4pbaMvVJigD/w3BrsjSJrXlqc4ulBYOCceiBN4b/gHajYyupbhEt63a619Ay4wsL6a6w6B+A7TnoyE7BliWHJfzVxxIKM/W3M/J8Bx99Op863Q8eNuIMGRx++VbYfjm+VGYBA3Ap/KEu/wxBNBpJJncwHPG45V8Gh98ZIrGCc20MwijGowZbcS7d1nEgcOW5cddZpHL2XPAIRbColiheZzXTvBxZOY3iMSDSKDrICyJ/iQs1vdplVdH/JrLJsQ2jtTnfCrITIghq3KFX3qAgLWAIp8IffNSdTYptnbGfc8s+qcr3zyzyHp1aJg+jxTF4kD1ry5Wauv5V3xnOGwTFecNzXSLHBW20/pCQjk4uorD0plIhMSTc79+/r4RKPClRYTBYex1Ob5crtfvRQBBv6re/6FhtCqtduag67glqRA77/3ulblh9YRtMdDxkCyJDeNnAuCLPQFmdRRWJtH20Z8DstfJf+5oj5SSB64d0iF5/Ya4KfTWxfivj9Ap2/zbYaTo/1gO3tM6RYsCZharMBFr7Fm61mLSrQnEI4OF1gbVS4k/JE9UotOrnLJZuswoWodCSV8zbybkJSVIP7n8UaE9xCR39rJZmf27HOAPVOGc9pdkQUcRrI0qyVF9Z3j1RHDbxIfwbWzmPVjwIdPJvtmBYwEQIUsIW1S939hcVikK00ozPRI02cqhzVUNzpOxVdrwRPvlh1aIOf0xFEqD3YkGnCnFah/cFN3J2gB7N+bZSGawwkKFu1tpQMrp1W+27YNkyT0TpcFpTqgOqqLabrgcCUPxh97mREOGy4xItzQ9xSl6rq+8BZsHcrQFReS+QeMxJ3P6CnL9EP/eOLDjumLhvrcQrpPiknsofbzBv9gTP0lU+TIVwE6E7CcKfT36q+ZiEOHJ9ayf0dyUJLezAb2M8aNHwd0+OJmsVgTzRWA");
        cB = new Map(ZO(t).flatMap((t, e) => t.map(t => [t, e + 1 << 24]))), fB = new Set(VO(t)), lB = new Map, hB = new Map;
        for (let [e, r] of qO(t)) {
          if (!fB.has(e) && 2 == r.length) {
            let [t, n] = r, i = hB.get(t);
            i || (i = new Map, hB.set(t, i)), i.set(n, e)
          }
          lB.set(e, r.reverse())
        }
      }();
      let e = [],
        r = [],
        n = !1;

      function i(t) {
        let r = cB.get(t);
        r && (n = !0, t |= r), e.push(t)
      }
      for (let n of t)
        for (;;) {
          if (128 > n) e.push(n);
          else if (dB(n)) {
            let t = n - nB,
              e = t % 588 / 28 | 0,
              r = t % 28;
            i(iB + (t / 588 | 0)), i(oB + e), r > 0 && i(sB + r)
          } else {
            let t = lB.get(n);
            t ? r.push(...t) : i(n)
          }
          if (!r.length) break;
          n = r.pop()
        }
      if (n && e.length > 1) {
        let t = aB(e[0]);
        for (let r = 1; r < e.length; r++) {
          let n = aB(e[r]);
          if (0 == n || n >= t) {
            t = n;
            continue
          }
          let i = r - 1;
          for (;;) {
            let r = e[i + 1];
            if (e[i + 1] = e[i], e[i] = r, !i || (t = aB(e[--i]), n >= t)) break
          }
          t = aB(e[r])
        }
      }
      return e
    }

    function mB(t) {
      return bB(t).map(uB)
    }

    function yB(t) {
      return function(t) {
        let e = [],
          r = [],
          n = -1,
          i = 0;
        for (let o of t) {
          let t = aB(o),
            s = uB(o);
          if (-1 == n) 0 == t ? n = s : e.push(s);
          else if (i > 0 && i >= t) 0 == t ? (e.push(n, ...r), r.length = 0, n = s) : r.push(s), i = t;
          else {
            let o = pB(n, s);
            0 > o ? 0 == i && 0 == t ? (e.push(n), n = s) : (r.push(s), i = t) : n = o
          }
        }
        return n >= 0 && e.push(n, ...r), e
      }(bB(t))
    }
    const gB = t => Array.from(t);

    function vB(t, e) {
      return t.P.has(e) || t.Q.has(e)
    }
    class wB extends Array {
      get is_emoji() {
        return !0
      }
    }
    let AB, TB, EB, PB, kB, xB, IB, SB, OB, BB, WB, MB;

    function CB() {
      if (AB) return;
      let t = HO("AEkVMQnvDV0B0wKWAQYBQgDpATQAoQDcAIUApwBsAOMAcACTAEUAigBRAHkAPgA/ACwANwAoAGIAHgAvACsAJQAXAC8AHAAhACIALwAVACsAEQAiAAsAGwARABgAFwA7ACoAKwAsADQAFgAtABIAHAAhAA4AHQAdABUAFgAZAA0ADgAXABAAGQAUABIEtAYQASIUOjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqft7uycM2yDPCLspA7EUOwD3LWujAKF9GAAXBCXXFgEdALkZzQT6CSBMNwmXCYgeG1ZZTOODQgATAAwAFQAOa1QAIQAOAEfuFdg98zlYypXmLgoQHV9NWD3sABMADAAVAA5rIFxAlwDD6wAbADkMxQAbFVup+3EB224cHQVbBeIC0J8CxLAKTBykZRRzGm1M9QC7DWcC4QALLTSJF8mRAoF7ARMbAL0NZwLhAAstAUhQJZFMCgMt+wUyCddpF60B10MASSsSdwIxFiEC6ye5N2sAOeEB9SUAxw7LtQEbY4EAsQUABQCK00kFG8MfBxcAqCfRAaErLQObAGcBChk+7Td0BBgXAKoBxwIhANMrEnM681CwBZA6dyc1SAX6JwVZBVivuAVpO11CEjpYQZd7k2ZfofgLEwPFByXxdyMEo0sCU1MCdRurJwGPo6U1WwNFFwSDYQkA0QarPy8jBykCOV0AawFhH3EAgx0ZAJUBSbcAJ2kXAa/FAzctIUNTAW9ZBmUCZQDxSRcDKQEFAElBAKsAXQBzACu1Bgfz7xmNfwAJIQApALMbRwHRAdsHCzGXeIHoAAoAEQA0AD0AODN3edPAEF8QXAFNCUxsOhULAqwPpgvlERUM0SrL09gANKkH6wNTB+sDUwNTB+sH6wNTB+sDUwNTA1MDUxwK8BrTwBBfD0gEbQWOBYsE1giDJkkRgQcoCNJUDXQeHEcDRQD8IyVJHDuTMwslQkwMTQMH/DZCbKd9OANHMatU9ZCiA8syTzlsAR5xEqAAKg9zHDW1Tn56R3GgCktPrrV/SWJOZwK+Oqg/+AohCZNvu3dOBj0QFyehEPMMLwGxATcN6UvUBO0GNwTFH3kZFQ/JlZgIoS3ZDOkm3y6dgFYj8Sp/BelL8DzZC0lRZA9VC2EJ3zpfgUoDHQEJIocK2Q01CGkQ7wrFZw3hEUEHNQPRSZYAoQb9Cw0dMRWxJgxiqAsFOXMG9xryC4smqxMlevgFzxodBkkBJRr7AMsu44WsWi1cGE9bBf8LISPDFKRQHA0hQLN4RBoXBxElpQKNQ2xKg1EyHo8h8jw5DWIuD1F4B/E8ARlLC308mkanRQoRzj6JPUQiRUwoBDF7LCsnhwnLD4EMtXxuAVUJHQmtDG0TLRETN8EINQcVKZcgJxEIHUaRYJYE85sD7xPNAwcFOwk9Bw8DsRwpEyoVJQUJgSDTAu820S6vAotWfAETBccPIR/bEExH3A7lCJcCYQN/JecAKRUdABMilwg/XwBbj9RTAS7HCMNqaCNwA2MU410RbweNDlMHoxwvFbsc3XDEXgeGBCifqwlXAXEJlQFbBN8IBTVXjJwgPWdPi1QYlyBdQTtd+AItDGEVm0S5h3QChw9nEhcBMQFvBzUM/QJzEekRZxCRCOeGADWxM/Q6IQRLIX8gDQojA0tsygsjJvUM9GUBnxJeAwg0OXfqZ6dgsiAX+QcVMsFBXCHtC45PyQyYGr0YPlQqGeAHuwPvGu8n5kFTBfsDnw86STPqBLkLZQiHCTsARQ6fEwfTGGYKbYzMAS2HAbOVA1ONfwJriwYzBwcAYweDBXXhABkCowifAAEAywNTADUCqQeZABUAgT0BOQMjKwEd4QKLA48ILccBkSsB7yUEF78MEQDzM25GAsOtAoBmZp4F2VQCigJFMQFJIQQBSkNNA6tt3QDXAEcGD9tDARGnRscW3z8B22snAMMA9wABMQcBPQHJAe9pALMBWwstCZ6vsQFJ5SUAfwARZwHTAoUA2QAxAHvtAU8ASQVV9QXPAktFAQ0tFCdTXQG3AxsBLwEJAHUGx4mhxQMbBGkHzwIQFxXdAu8qB7EDItsTyULBAr3aUQAyEgo0CrUKtB9f81wvAi1uPUwACh+kPsM/SgVNO087VDtPO1Q7TztUO087VDtPO1QDk7veu94KaF9BYecMog3QRMQ6RRPXYE1gLhPELbMUvRXKJVIZORq4JwEl4FUFDwAtz2YsCCg0cRe4ADspZIM9Y4IeLApHHONTjVT0LRcArUueM6sNqBsRRDwFQ3XpYiYWCgoeAmR9AmI+V0mrVzccAqHzAmiUAmYFAp+AOBcHAmY3AmYiBGoEewN/DwN+jjkCOXMTOX46Hx8CbBkCMjI4BgJtwwJtquuGL2NBJwFjANoA3QBGAQeUDIkA+ge+AAmxAncrAnaeOwJ5Rz8CeLYZWNdFqkbTAnw7AnrEAn0FAnzsBVUFHEf8SHlfIAAnEUlUSlcRE0rIAtD9AtDISyMDiEsDh+JEwZEuAvKdXP8DA6pLykwpIctNSE2rAos7AorUvRcDGT9jAbMCjjMCjlg8k30CjtUCjlh0UbBTMQZS0FSBApP3ApMIAOUAGFUaVatVzAIsFymRgjLdeGJFNzUCl5sC765YHaQAVSEClosClniYAKVZqFoFfUkANwKWsQKWSlxAXM0CmccCmWBcxl0DFQKclzm+OpkCnBICn5cCnrSGABkLLSYLAp3tAp6OALE5YTBh6wKezwKgagGlAp6bGwKeSqFjxGQjIScCJ6sCJnoCoPcCoEgCotkCocACpisCpcoCp/sAeQKn7mh4aK3/RWoYas0CrN8CrKoCrWMCrP4CVxkCVdgCsd3TAx9KbJMCsrkJArLkE2zcbV9tRFsDJckCtlg3O26MAylBArhaArlDEQK5JnNwMnDdAr0VArvWcJIDMg0CvoRx/gMzbQK+FnMec0sCw8cCwwBzfnRHMUF03AM8owM8lgM9uwLFeALGQwLGDIUCyGVNAshAAslLAskqAmSZAt3OeHVdeKp5IUvMAxifZv4CYfAZ75Ugewdejl63DQLPZwLPaCtHT87vD5sAwqkCz28BJeYDTg5+RwEC3CMC24YC0ksDUlgDU1sA/QNViICFO8cS6VxBghiCz4LKg4kC2sMC2dqEDIRFpzgDhqEAKwNkCoZtVfUAUQLfYQLetG9zAuIr7RAB8ywjAfSXAfLOgwLr7wLpbHUC6vUC6uAA9UMBtQLuhQLrmJamlv8C7jsDhdyYdXDccZ0C8v8AZQOOEpmPAvcPA5FqA5KDAveUAvnVAvhimhiap7czmxoDnX8C/vYBFwA1nxifrwMFiQOmZgOm1QDNwQMGZqGEogEFAwxFAQsBGwdpBl21YwEAtwRnuw2HHq8JABNxNQAfAy8SSQOFewFfIx0AjOsAHQDmnwObjQizBhufwQCnBRG76R09PhZ4BWg3PkArQiFCtF9xEV+8AJbFBTIAkEwZm7k7JmAyEbrPDi8YxhiJyfYFVwVYBVcFWAVjBVgFVwVYBVcFWAVXBVgFVwVYRhUI14VnAgICCmRe6SsEyQOxBi+7uwC7BKe7AOdAKRayBUY+aT5wQj9Ctl91N1/oAFgRM6sAjP7Ma8v8pudGej0mIwQrFic2NX5t32rB8RnCLGkBa9duMBcFXwVqycHJuAjPSVsAAAAKfF59i74AMz+BAAMW0QblrSMFAIzDCwMBDQDlZR09JB9KQrFCvEE4I18nYDYnOCMJwT0KRD9DPng+gT5wPnECiUK8SUI7X8tOT2pNCixrVC9qC24fX+AzOhsJZ5sKYiMrPB0mQqtCvCvMAcv8X8kOHy4JCAkifp3fajotShfJq8msCWXBy8wKYEFfD+UQoxEAk40dRUIlG6ltOc44CjM/Qz5wQj8cBwodTEdsWywtWuG8Egp97R0rQj8cXQhKCQ4zVENCNwQ7Q5wsCoEbLUI/G/UIUyIjGDAxAAWPYfBeCnFkyWALYC0jbkNgGTkCGx5gswYCaxBlTmBNEQFk52AVYJVgfWCzYEtgkWgWFwa1DtxVqbxaC0MWqwG7K83BAh8VABwDHgF5AmwvMJVSgAGKCrhHGgDkI3SOCsoNpk3qAZsCh5xPBUBfAPf3BwA0FlcMC6UMJB+6r0eAgQw0ABUTnyuCCHoC0gtLZREbANhOBnUECh5aADEAtritAJQnCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cHAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4rQCUJy07Ds4CkBh7ULtYyHRyjsOlmw/ZFUkb7AEpEFwSBh/lAccJOhCTBQ8rDDYLABEAs+AiAQIApADhAJiCCrJrOS8AFABbG8YubHYqDcEQAjskHNPhHB4LG30CewTBCqrxbAAnLQ6mLs6hHAe7CQAQOg+7GkcczaF3HgE9Kl8cLs4RGQB9q9ocAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvAk8DrsFmAEbawouzqEqD4sa4QHDAREWOwCgCzsLuxC7BBiqe9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOxjbL7ZtvgNIqLsAB7sALrsC6w5WAAq7BAAeuwJVICp/FTwVuwG+J+QAsloBvSjgo7vIAAFbAAG7AAJbAALjAAg7AA67AgAbu6VbDr/EAPQAaPuoOwMBu5UnSwDn3Rm7CBp7CKEFCv9wAN+7p7sau6OLeXIG+6mbgwASuwYbCwG8AACGAG27BgALu6c7ARo7ugihnMoBuwvtB8CpOwDhewG/AADlABW7AAb7AAm7AGmLABq7GLuOaRX7AA5rAC5LHgAGuwAXuwghAA1KAcIAt68mAcAAALQADpsAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAIPAAUOwARawAPiwAN6wANuwAZCwYWGwAVOwBumxm7ALobLgATOwMAaSsKAOFLAAI7AARSABd7BRsABtAAGLsAC/sAX7sAa/sA5IsBuwAXdgG8AAFyC6EABUoAbXYAB/sA5XsAHGseAXsoUgA5RQD+Bw0McgAoKnABpAUIXgG8XiMMCQdvS2xfKokfPBRiLTYDoQq0AdgAFgLRA24BdnJHUhQhA08CFT4BLAYDc0a8e1J6QAApADEB+wBTCtsAe5AsASsAduUNETJGAUoAVwUAAVABB4rMAHg7BCClAFoA1hUAlWg3H4sAzWuxAM/UFgjCdXMbGFYdCdEBiJCrIlNTTUgSPMKJ+QB/HDdAKSvgEZdPAHIBKSwwKUIZDwMwVQT3xe4AS2XcAGoCcQI/EXo6x3guNdUGBQAQGx0KCAwqBB8dKU5TTgi5ugAKEs0AJgABGgCGAIkAjjUA7gC0AOAAnTwAuwCrAKYAoQDyAJ8A0wCcAOsBDAEHAMAAeQBaAMsAzQEHANcA6wCIAKIBNQDjANgA1QMBByoz1NTU1LbA3M3QzkMyFwFNAVcvRwFVAWQBYwFWAUdLQ0VoDQFOFQcIAzI2DAcAIg0kJiksODo6PT09Pj8OQB5RUVFRU1NSUylUVVdWVhxdYWFgYmEjZmhwb3JycnJycnR0dHR0dHR0dHR0dnZ3dnVbAEDsAEUAlgB0AC4AYvIAigBTAFMAMwJz6QCH//LyAGAAj+wAmwBLAF4AYPn5qgCBAIEAZQBSAK0AHgCyAH8CPAI/APgA4wD6APoA5AD7AOUA5QDkAOIAKQJ3AU0BPAE6AVABOgE6AToBNQE0ATQBNAEYAVQPACsIAABNFwoWAxUWDgCKAJIAogBLAGQYAi0AcABpAJEDEgMkKgMeQT5HKQCLAksAwwJTAqAAugKSApICkgKSApICkgKHApICkgKSApICkgKSApECkQKUApwCkwKSApICkAKQApACkAKOApECcQHQApMCmwKSApICkRZ5CwD6BQOnAl0CNhcBUBA1At4RCisTAUo3E02RAXekPAFlWQD/Az1HAQAAkykeGI9qAClgAGkALgCJA5TMi/CuhFoFuisOwhEBndV0KgsEIzFsATNabAGyAN5+gH9+gH6BgoJ+g4aEfoWIhoCHgoiCiX6Kfot+jIqNfo5+j4KQfpF+kn6TfpSDlYiWgpd+2gLabOEC2GwAgmwkbKAAg2xsBEkERgRIBEsESQRPBEwERwRNBE8ETgRKBEwETwCWZmwAowOIbAC0ZgEFbADJUWxsAM9sAgxsAPZabAD2ARkA9gD0APQA9QD0A31ebNSEI2XAAPYA9AD0APUA9BxsbACJWmwA9gCJARkA9gCJAL4A6AAIAPYAiQN9XmzUhCNlwBxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN9XmzUhCNlwBxsbACJWmwBGQD2AIkA9gCJAu0A9gCJAL4CNwD3AIkDfV5s1IQjZcAcbAJDATZsAkoBOWwCS8FsbAJXbGwDnwLtA58DnwOgA6ADoAOg1IQjZcAGA31ebBxsbACJWmwBGQOfAIkDnwCJAu0DnwCJAL4CNwOfAInUhCNlwAYDfV5sHGwEPmwAiQQ/AIkGjTFtIDFs1m4DKGwDrAJsbABVWv4VMgJsbACJAmwAVAEAul5sAmxebGwAiV5sAmxebD3YAEls1gJsbEbCxxP/x5BApA0KYFA89AsjTx97EHmJQPyocItC2JnNFRCEnFU6SFTDoI0PxeRNRoNRWkpzVnWW8pTagkNmgf+jGupqZ3eu50LAFnc+OzfJwdub1AdpOy76VnijWNR/CMEevikQkFyQuLuPajxWi9chqOoMJ7qpCN4sx3LJG4Myu8kD68wC6+iAwt+pU1JEeY13rpCVkXSZfinVKn4xZpxsI3Lp8bJLrJ9ujkrIalMRBAcv/GSKEtowzcEn5XmJw2BagB8V2UWJoJHZ14SXhM7p0XeGFOuw6mlvyq99WYp5XxrO6ru9nn4RHcOkJ7hx5UqWtman7yVMLzYXQefQRUdIY70RYQE8+aAzCNSGQkXiHfnHYRMi+xczKDdZLk3AV1gzxkkSHLjBwuq8shIJ+/RAbqjqQbugFhe0rqklu432EERkM5k9y1DXzds46oLqKAx6OhPT2WiqEfhaITn7OF9Y694AmKmUvbpWp0xJqDaf3jeNJXnK6NpnGcFOmbclbARC+5+5U52ufw5b0Hh+2LrrNimvZe4eYmApRsZnJE310SqB+1xB6rSJfnV1f2D0awB18Oc0sXAFqIlgHgWiaZGdvP5CJUSsCTCQUC335+iSkwPlLJJ5lwjTSn9Lw22NbK1Tu8w+bUpHtDRDPho7Gun8aw2Jzu9i+N0Ot/kPMbLAb/rUQ82kfpk85qLDkfxLl39QPDngo72GYh/Xigbpcm1pA23D2ywt3D8GgMOao040wDqkHxOEx0OhC+ZmHiIdjK7yRbfJD2ouZbAedhD3p7s8WDmCJfNforgDYPGAXSI08fTjPZ5B37lc5VXGzc1vJmibDwBNVzXuaUzg7N5H4BxqjhJ+kz9HLUJys7bpBDYAPvbut13AwJCWd059tS8YTYgC8HwrkewBfa1LSSpmMr9uR2EekTiAMH+Mx4AGzgbquccwBDlLmRhgXL/YiLPCEb6d2k5qJ6o800qddABkpqt7NG+sc2uvHZwZs57W1AHTFM1KkMShasADAh2FvzbzJOzVDMS3ZlT2BSFKdnkZFB6JyqJbhm6XANis9TrtzJdlPVp+rl8v3nIke6Jou7m2TKu53Vounupgkz2LzrQPhhatLIG7rfF/gUKWp15X3LKt+ZvuCDSqPUigF9yJntimC1HJR7Yj/dUrLAXWrT+1tnwPJJLGKAlQ5VeNDWRKCTt2vz3rJuo4+gIt75/Mkfl/gSZblZ9r/SEeeosZXneli/xNh1WVCvkRt2RnyyjtMkMqhzXh1PVOCbILqv0r7rGYm0CHIyKdhHL90cl9E1I6eEtQTCt6RXj8M0HHrHCHLVRpNM6WIbT5BCMGVnL0o5895qSRbCJz+5I8PGMhAN/Xrj4BgIdlKqlHtBHqTJwmK169toZ2IWxNzrAbIG7zh85Q/LG2A4yBcaBel52zdunokB0lv3A7kXnTI7M6ZnfZ7nwuj5lkGhqSpW+w5CI/FmRlplBEbnZy1ZxS3DL8rf1YWhO5XivWZBSRh1gFsjjyj3qRG1cm/6ors7WsEif6WRxns1MKDZa6KrbfMQ/swIb+2nb0tqxHeii6FcgVeAjE/Xwac1owx04dJKG8R5YQgHNnEfHf0qb8WOnU0eQSjazq+IK7cSuCqYzPEUB/x+QgGZqM3dBoYvNvZVOHDkbgdilWdagqO5bkybXfLpyMPuGq8mvAAEZGbR6RwXGlW9ErOWTfnjfx6dXFJqBj0OBSGFz4lWQasNOmVJeN4SFWSLfOGB/7ehV5YuoNNROHZEG9ElVuMnqbDMMuDleOt/cN/gsWxGw128mwU8/HxkOKqdTZnI7dHka67WCTf/FmBrxpNCaKJ1GxBTCSS7MNfhNj8S4Gtotg6Z3AM9cAeVROnppUMaiV5jjudLnNqoVrKO1/FijLlAc74kxydxKX1RQuMqHR63eecYr5o6MJ+B78VsLlCrpelWh6GOrCOBIoQmIcdpJL1pwE2zzZqBkecGTdK8KMOB6r1eNRURyrz6M899TZaoS/vNOxHf+5gORU+OyYIcIW6diP25GHF6u8TNjuL/GJzCnLLXd01KrsjRa51v4+O/VIAWXESJxfxWjv628J+cWUQpoD+Yytzs3jSMRJ23/XT+vUdtUMLDQq1vnIoeg/GjWh88MT6k9dRqDaQ+vodilFgvjuNw5pJpId9mfwyYeLCGb3BmHXdfQfhfPRQaupe/f8TG4Bk3eDKlYBaEK3kZYNN2Sdxz47m/vYBxvIOKtnqplB1pebzuXmAr/MuzQCknKe653dzaWQQ7MUhWYWvzIZwLe1v0rXxImLaz+AkAu+sYikhouNF3EW6w4crZ6MuUiDbIAx8XhAfegcvW6x9BPb3/sCxGWu9YyatqExB+TSm69qIkI9IwhjrcnzME+jWBx4mNQm5WwLzUjSyY4FZ0aMF5YFlXUD4hL4XfOeYv5rDe2s2D/Cn+28fZ9UCnOQvXFMnQqfc0G+ZqOWWD9l/liqUPaNQzZjxCHpUAD8Rcc90MniQ02ugHWsUupFUvhC9usY7zNPt5F2jO7qgzhafsQSd50jgLrC6Qx6bpHbXR3WNAu1BzGmwbz+ebGmwTjdy006Y6zipP7n/OJlvSmbq+SY+nefAVKK6EBMPbce5n3IdRI8+vbxCpN53rw3TvgNds1SuMiuLGxt89L71mxPDeanGhyHvOjmO56tnVpoHalQnL6TqNuqKsHjHCIKB4pCgj4WyYPvRvYvqi5EMr7lN3MotPR/KH7JUD1lZbU0QzfbrEBJnuQiVAyAC9vwXWp2TRU1/0aapyAH2cbglEHVAdl+1rb1u147uV0td1eNoQZsqHrIMIYVPXtLk2TIU3cJE08PjoYNDpfF/IcJnYQHl6nsplczX3Rgah4NbJJHl//5scUufqsSd//kbIS406ZWoMP//+jhGUswX/5nVNz/jAj9KmXPtAmMiK+khhbn1w/mELzZMT/WxcW//y/jsHaOM/61oAW/CjYhJtY622/TtMYuP7bilBvbiT3vB9n8IcFPnwM78H0KfhYDRdY5PhWJ4jWRQzB+HT5NVZV56LG82hcQms+jOTT/c9Y9sx5rPi1/wB7f/+c5UfUCKk3iwwCuywUc2MGnAwsXf1E5hoI55x1Q/Qby+sWH8NRjavZ8VaDsdi1NUVhH86BJHX1yaFt1w1OYeL5LVmdN+5Q+KuTvXEPDzUCg6xp0HhsUhTWSe7MZMM/6rsTUb0/nbUE3YQlGGt48kT1/6cnf6yHnvHtQx9EosOXN077yyEq/jE3YTiG/5SEJmXFeocJJ1EAd6vKeK6VEdJLOZ1km/EwOnZWCQpzCLKPHxrfh4yJhGq//2dos2E/3+MOcdW5EsgIdmTQUQetzRy5fQHhDBl37XbWzsqO/cASEDjyst1/8NEROqVAxWnddQV+umJ8IrKVgKvGaTc0GsQ4s8h0Osql5QKwlddPDjJhKInyWqYUKmmlIts+FIcXZ6yM6cljbsjUG2ksSOkuIw4sYHffRNgBOLApvD6XrR6Rt0rV2Uf8IpnIUVnb9Twt91QjAaD/dStSWDxg7aYY+VXIgnuowYdOkjywa2hlgrnI6PjaU3e3UjQ5Yk5mdIJGyHnv3/P+1EkMav1yFyF+FeJE/RXnWBw+Nh0aOo6TGlKX7d+dkP9+brvr79SdtXJtcD/aXBGiMNfG6/NQniQHYQlK78FEHDqOh+bDI0o+2Ub0h53EL/vlzjrBczVEZz2bOtvIL+DIzDkk9nCWt7tlqsq3l9JMtJk3r5HG2iJ9b/X11TG6wwMAjHLQ2oasaMEsydh88QPvI+hmqIHhvalpKoKOueJR0eZ9J8G2alNOIOy98jwvbc87Ewk9d+5G/tUijTmlbjFlDKXV05HalKxaRTrucc73On7yzAPS6f2v4ogiaWyWeV73dv/MsQT5HjRrsYV9dLAcI3T+zC2qEVINyNpEhoKV+xVSuWtT4AhBfpnZ7unIM+HX3msI0HiI+P+z2PFgkjGi5PqEbG/wNIWeRUjPtDEgbbubN+I4JaDLrW9borRBDob7ZFx+JdKeFVUKVeWqb/c88Ol7DhM0suLtuEd8tkDSMTD3DFx8UphPINHMHi51hAPttXL4Ektt/lKEUG/R4qZKohHjVpAcPIMiHyWr6xR8/EWnNJvBFET76yCdk5er7ADB/1bgoImhpSiZ/omZjPKPCEeZsOwvPmXL+1vlJNeGO3TzySmGA1X6e58gLrazDM71jywM1XL8zKHN6G3kB31Y8vLtP982N975SZXk2JwDvmv7AY/aDsFFk1v+nE7/hbvuOWhBH4kuemeYozPk2K22Vx/YGiDTLU7YilpOt29u3RZMBh4UJjlTP5ItxTzWv6ebL9b+GSU1Vsm2S8LMfVfJczaBSqE8J1A4YUjpsALL7++bwCPXFhaufdpDFtBlHb9makeYbqdg9ltvK/HwF/rNE6KrtWUkEcxmTB7Iyu5TiVaIgW/YxzQhpArliIMkOoK5L7ShVtF+DYqV01mk7fwop04hQRwg4KFmr5z9nYf05VVqkSe7gfnx5bxxlQ0qEV0jiwzf064qG11iEqjHcUgDWWsDs/LEGlzX31T5KVL+7D4EoKim7HBagiqRo5JI3WfDBgpKIruWz9j/J6Hp5Q/EJbMWB8NeSMuFarNw3AEYPBJtYQO/4oD/ZgPTSQ06di0EeumX5EbrdThO+fvYEVSxLtZ3AJkee0Xn0sDwNtiiZhJjJRDuG1YRKB1vOulfd9JjHeyu+UHTmrtra/pm+8Rixh4WKiLaLOCxIbZNoWRZSyyUGLPjAaAo+SQBpfO2uruWrzFxLlpvrXJNMCWtlJDKGAnlWK5xpU2tcxXbeD+sbdfwYXt/qTwDk6UqXR/aUt099DhSNl4Nk8mXwpw+b0nvjKOG6Mg1PRXjrMUMANvNgEArv8nMJs3vj1aHi8MHz/UfJWWzkcrSpZTNBhduXlGR7i+ip/THDp5R9KRNcDKECgtwgXg4EFN5HHfikP/XvsoCkHTg+NbsD8Gl6eknk4Arwn/BWGJ0hgW0/gUKrzuGZhub7igRP3abetpIm+24xEOlWl3YKpm2qTBFvX8ddDRvm1LcwnCJuEfZx12qPY9TrntMIQsv316zvpyWnyStX8VU4j6tQk+CWlLBUCJR6MdH9Cp7g2qdn2WM9qFbREmejH09dlWEPm8hPF0L7RxwRRdiCs0DP8ewk6ApoELkKU9hckSdbnXm8UHJmaNXjxv/q0fTTpu8rnl9lN0vQCpDRbCtcz12rGRFEA7Cfg7FhZn5QFkNmv1ZURKEsiZce1nS9K7HrwpC7yJV4Xt3eAVbLJfoXHrtwG60Z8gwaSnmxoL3s2ZlRqggZN/MHo1oUS4L+GwObFI596Ld4Mvi8l+cQmF1gJpkpnDio7TuO35npaMHiWzFqPSX3qNgkIPGuX0qGYnPIVsM901Yu8oZnOZOY1TbtIdFUNKNq2dP8SJ4F/VCEzIjF0/Rh+7UrZj80tC6rognVH3mqa8eCs/lcQU1Pjj98kBmAKDbZUTwosv02UunRR3n0X6c+f73mtwB7/WbQ16gO431EtwZbNG1SM4TZPBnsQSESlsfG2JLQXx5xWf4bmQ/xcVCPISAX5897JxHKLD/Xkgu57+ABR2+MMtEbX64+MNlBHpKC7sjlWVEShf5qA+dGc59LFVlZrX/Enq9z/v+wnZ1HErmxmjJjxOA+hAjVUWgtq6ygAi/8ewJDjUMFw3zhQFtbyTLDPFd21Ji5S5QPZo9nMSxdg1+DGFSN0wlWt7XeYPbHqLfliV0J1kOhQNp0VbUPy0MS2Ms66OxtSWvaULaWHnfAA+sieVVgtjDwN3nKonWapkSKRN8BKKJQpCfqo8RQI5udhfu5s5+7vwsppmAJDgz2GNA7d43VdbV2l/SrvEu4RYslmNJmfSOVbssxAhSYy6WxpIQdDB0FVBpZ6IM8yr81QN+XLZ3n/wed/R+s6LslkxKbzzst/GkRbe6rFmtvJCwr1T44ETM+IMgOnjUO0eG6a1n2w7lwM1oFBvzMUWRkNFOvKcx3oSb5XdenZ5dXsute6nkRypBiSdAtA2fxAd8UdLOZW/MB7fZoEuFheQXijdaF8kuaRZoSeWdKOkKsGYEGaXfaDKTu0WMTcLniQs7KRCz9iK3SP+Y2xIjkfVGqFLSQ6vh+A1u6FdfwXsv1VPMfi2cxmdM+/xTgMXEyo2ZGcQ2YmPsghnYdv2+z48JpGZA4tUK1p1q2VdVxyfypXEXcrxKKtmt8UdW7sHWmKMqDuBBM3J/JUQx8eUYN4pJ5oRqvdiPHU1o/WPjiKvnlCqOdyxlxF54L9PrtLD1NejZ9aZDivVr6ZfMFK1/psVygoPIAnphcJWWb9+5IKMKmgRQULsTPZi6Bw4wP32zVEoKcHpP73CkFAqS98nSaGoWDjDJiaACJn4p5o1jq9R4Q4VcibhXF//LHP0bdf63kRVZdRbbhGe7sDQcyWS5tpkfeYHnff25WK+4FpzLlAcbaKmHdIBqOw3fImx1uqQIADH0TyHzFlqTG6nMoY81svP0T6BIyELMS8tMe+E1p6TFP6sVpZa6VNaTumufD5aj9goRa9SAmdJT4HhI2r0egj8UrgFb8L59wGLnYlzkLAiUd3m/WWIIEU61kPoEjd3gIVy/fiBcgqQqHnoXpL0SqLGdGGgn7DQeVMSYWHfjno1FngIKP9cjYaTlcRP6bZunjHP13/lbVm4awti894pTf/ZNNqr4OR+tDVie/m+rC8QpVnRbsCMPukOH87B2jM4AG6pHuXl1x9SiKdhYJVOhfo/+SCaGjUW2CoogL1FFhFGN9o+acoVLl0SXs/3vrSccmZeAF3NewFuOg/P12QYKQF+SH+KYcNnsAhIAELPBUgre/KRUJEA+KPD0MHRjv+3J/j2Z23MuJmkfy7leWcMsti8wXLSHgXFJTaksx1Woi6oljwxFVIJG12SBSZLNJDbXMYPekmiXT4FclKI35BFgqnYpKfcsr+f8HUXQoHJ9UYZ4J5YMiHHyAxg6eidhodgqJ2Htf/xYEx+G0zXchuzlt8hcAl+AT8NCQ4orFc4DerabF1enA7NTLnvtZh3FUwqIOvY7Q4DYmoDHwXTSw5UNNh6r7j0B/ezMYJMDcw4+6gCTZX4YQ+7Xs8de72vsR3cmfpxIX64/6KR1p3VX4F6vfHEzxzarh8aDH4G1DFoBBM6npXFpK+Rh+WrcFclAeAxi0PoaR9CpOxxGLSdvxKVSw8oOOanG/soKImRopN38AdcUhhM2GT/PgQeSQrG12njuJJD5Z7vWfAZmFybYLdSA91kB4aoBhoj1Z//KNIVVujqaLLRwCkbyn4vh0739C9V9iSjybeOIeSOvNs7LW1a7EUtNoKAnOGML4U8KBXpfrw73WjAszJG4Qscq+Xr3kZWR4Omm0xT6qE9y6FNSpstV4onMZSqCEJ+3VX9qjvdx5QVrM0WXxmPZxejdfnihcFAjzv5PjlTl6ickDbHe6+Lch52pjOPqk+m3RZ+bh2JSMGtFBuODbMchrpRVlt16NTQ05Ps0IDtWlUmWfP2vX8M4YDynIuOZ4Ck91+591B98Gw9fw+yQogTR8CSg0zaJu+rlBo/mr3A+1NziF+kdubz+whc857AZt6DwIBIF5+5yiaaf3ByQp1Fm3sOkZDAzwsYSQTM/Kv6idkugF63FDobDdUY3huruU+sCaBuRR+HmOowvmZoBjZHNh77SXFtmY/oOUE7ifN7nBHAo83S/xvcS6H4Ci2u/9Id62Wv6Ui+zMNLAzhfkTkVcW2BwrnYvpur0ZDlzs+ZLsmGTWvd1892t78gx1YjEJusGcxphjLkV0UfAKlekfSBVWHE2ahk4AbbRmHyL7GYdtKfdlINwrcdJuf3Cee1nfUojDQn/YmItESOFhtLzrkEv4k2XpMU9oaJQ3VUC+1INh6BE68pkHameGJm4Gvdb24Q0fXWxd9Tp3A9mzFSe4qXDGGDIV4AAGV1jIDfveknH1TwWpUT6HiQxKP3AAHJNkJeRlj/mXBmS4S1j8FK6YmpK7jyyAiRbsMCCLoJcx01fvgpMvKQRxu9IOwymconQjD56g7ksOrcOeoTbius4JnGesAS1DtgdaophYsw1wGIsMS3P7K6doE3K5czznqPQLSRRF/Ylzb5NtSKsL33SgskFNCF4khn5LWaDxI23ZRi2hzqN8uW8UzZEBYy68+VtGLSymQrXGUlr2nO2BbBIT5Vh1RmGAyDXaW0FPrpx3wv2UYdFk9tSl+906bMxCuXQaKDQP/U19UEcVGK4gmksL8lAorxQSAOwpeYX9xrZsh6yoGaL/X5O3tgQC8OM+/GvxnW9XvAtu/JxAigydfSmZfqZfg1XOcHNOpLlN8j64OZ36l5qawDBJ62YaTvxeNmm5gowCdBosgcpHOgNgwA+sknN8XmsR2IYChcafl9bGNMZ/nB5guWuvEziv6QI2bP2DtyKWG/qUjZMaxy+wASkkVGtuwGtywkTYG6MYrZBo18vYcww48G/+f+eITA/qMwbLlJC0S3+/ai2pPvkOhRRVmGTuSupaxhIk0xoXLtixCxSAn4Z3OnUS3wBqVscLI4P3GP7i/6gxYsswsVmkvDXFLhO/OKcur8flegCSKiqmVpIRvCzgbjEA0mXPn+RExXY/2OE1f/BYuWpRQY8gCDpMOYBx9Gn4tL3hihSIR1ixh2PIIT7cr2gUJbfs76EKYG52Jk0UZF/PQkBxGuFCEWXnG6ue/hTIqjTRq1sotVrKrwIGHDrITyuanUzbIYdgdEeV88K1VD82TYB2B61Ft+tB1KqHPmT9+hWoaV+iF3SuvtJqvnoLaA8wxrD56AUMULEgzO9SvBcBAfqz/dzMYzwMt/YLszDbmGe1bcHHfFMcvGql9bf/tp+Hrj4q18aNnftGjmXTfws39emn7/5IBxog9MrmftAA5Oq4awenm8HimWO72dwVlHcHmutVMdrMHw+p2vzpzT+B0iIZ+IEpplwWhClcXlxhxAsF3CHRnnaUEqq3ByQ+cqhe5SvR4SFxh/LZoQwtj8QZQGT1BzY2EMpYnUcZWQEPlwFZw+7UryK9qV8KgruYsvyMoK16KI2sN4SOblrVwhyiL8+IBZ8cpUhsJQSU7TFHAi+L2F0sn0y+FtDODlnuif2Mba8QddPZYYxjTsIgkMe3M6+7kXxUfZvbCUlyq71J1eNczGk6Vqw6rSx2K3vM+DjLxDRGzWepTO2qTT/W8S7u0QXcyFUahcB4vq8xCYTpy8iswtnyz7Kx6lgTEQJ9RqkgEIN6DOUqB0uRdeYuDa7AP7Zy9z+ZlTsmVR5vtV71m3dmdtNeWghbr5PnPJtjXAzcvZjxyV96VEx/B1TA0IEQSI50ywGuIbmAYdQg/l/rxhQLX+6uOLyFsaUt6mtjpAJkLfehnB6MlOHnNOrWLvCBqVBS07jcM+4RzLEed3f3/0Xwp92U+nataNHyEgnnuYR6PXEjRLETz0xrt3UglfK7Bn4aNlXG7cZco4lMziLv5+Mh2JCww3mz69Z9ZMRR/xv5EKJ38IFxKd9dw5CgPIXja/gzAshMbF14/qBIgNkdUQeP8YE7SrICGtiTnAKTyA9cXa3OauDHxZOdTP7yuYBzD1UcHstIO16FxF1bRUAlSkszI83YufTchU8OPnnozDl9bS0y6CnnjGwgj9M61cXcZsljjhLeT/Vq+30ScN2PcT/dOoxUDqDS38+OpCCzLDdnwHQc3ECQVIkaxmdPaZTSdfp2jjGzSdNLM5yPQsgJDl+ZnhclDQi8ltUnkqWJ323IvTZPN8rn0+EshL1cx9PiaLTzUsryn9Zp2Nt/detUAh4N/2I3dlMQqjHFxSihv0uykzflq5clMy2ZBaxoEb0/QMp03IQQus3vnZd/NOmSsmgqXqKFP3ozyDgY7RQS+npabe/hNG+5sa5FtvL8v0uYuag2NewYkcol3TOTadpuncCnDgOGpmLnTQ1PEPUN2cNsrW8LYfIv+hzfb7vod+ipXHzmbgj5Fzc6RcT/5PD7VQ8nTJBNj1urkVUx9uJvTWmqY08OC80rGDLaWXv243VB16gjt4Xtwp5H2UDR0LiKW24Ed/sOO8jl1yEU/XAb3h7ScKnCFy/V3sICrkY1D0K9fSokHIL0s5/7DLShLAPXRbV7fbv4qj6OwHC9d5PlEOX3LRpQ3P7hcSAKlIKPDM83ypz56U5+rJeo0cyUtC7wltL8wqEiNSgZsDWzACc7RFoZqhlD0+sihIBQlkQTXmvUyIOZhkQX2zqME5VRC7ms1sa3CY+odMn3mMBiTvCMKnnCxg5ZPLq4GUDB4jF8Br2K4x4sxfWjGXQatJ25I1JyrIv2Z4bP1jKw5C+B2/s0v4dGUOsaS6IPIQV3ETQ+F2fSl2BPBXHzyYN8VmwWIrKeMX9pyGWuAOVXwkxJsRBaBVzLhZDP8ONGncknL5DpTxHN32GgFWMwsc0GmL0oRDmRT8u2lvjAKUIi0MmXhIHSlFeh3Qh5pP6ap4YUd6b569ZIaHgya2AyD12cPxY0In/PBjzDctTaKJCU+xc6m9RkNLDEE8guvxtJP8sl8N9bLqw0F/qejaBlcHYqw31zYpsutQp07hsP1vhGdl4hJ1wA7OCsAHnKj9879uSHILEmuZ6vI1lT4tvnWCVKZhhYrWHW9oPKPKpbOC6FTjf/OtUvwmiXr2ykvyLzHGQeyS7BenZpL3N/CaF5T7Gkml7JXN5cj0PKaDpZVImD61FuMgFHPqSHvt4Ej4KBdAfdcoO3AjQPLwwtKsgGM+ty4lNZMBEItJSRLunG5ckrM/BeoXWoPZVvEoIzLgFQYPupMwZCXis4W2SCJ2zsefZqCj+aTfSq1FYdUj2UeJALvVTf7vuuikOE1Hit3UIAGUi/sqgMum9vw218y1FlY/9XnOji9nqhGAcMYICc7BiqLZj5N+cKEuSAuiyWbMg81ZD1lHovy/we2eaCcCv4MzEW3O0mVA/t2xdA0cxTVbXmFhn+tARDpvDz5ftLr15OAAmvo2QiAky+feVO4bGibv2nlBmBzqx0lEDfEm4UnEs11pbnwZlJ/0Y73/wBPYfTNZiJKR73TzdCW1BffiJq9bLjQmaKnU0+gN8sfe25IKSUCooQwxePDrFn3a/zUgWxvPoTYVXfobY/GV2qqTkeVDV9D8657fhY0/wiaJ5NfLxhXbE/naxs34N0hd6vxNfdm1TCnozm/NKSCThchoYgMF7Z2tzXFovRfsNVkf86JjrM60r7UIuV3bsmfrMOqzjXjN6HPBG25zCJ3QLueySbj9oFvX/HxWBqh31PBPxduCVAxMqC9HK+YL3oBZqBruoh6LKvdMqoz0PYXUBrwbiioyE8Tj5ImjJmiOOWLbAZvIZ/l9rIPljx3T5glJ2ewlfuIT5GlodQsAf/IEtmYkML5SRQGxxwW+rlZkD8belJNu09Itwx9xDULTnemVDeojdbgcd2gKGM9aO00Jivtbs7ZyOSE8IPh98GfvatD8Ud5uHcZfAfMiPSlIxd4UqeSDzuNfbKDuFepkyC/s3j9fawmhY1b9NqDi0ZS5eP35l7rL2eK5QlWLlyCmxx8AFaFiTuD2pMUxZV5mBSJuJduOaq2ZrWpu28DE8jl/hisBz7bGWH6qLF0ayWNq1Sejtcs8KQrQqJk5P9QHDYHOIolgNsMDmEaWcTelghbfFCDqWrq6YLwDWy+m68ec5nShgq2fduUBpQUuKKKgnttaUX9PRfMmxqJyU7e0RLr1bev+ge1KK0bZyhHKKDE8gQX9Vf7rNHWOxBtZcxwwGusyMpH77qWZxXsQmbgIGhtiO+gSSRCyu/ek+OFsz1HMiQH0IHV7PjJi3dszYfFp8ue9h4+AfKte4MTiehPvxNcm/T1t9vsFZx8rHN5ie77r2jzZOq/Em4Q+H9sNcZakf9HnzCc1fJixppxP8FQABmVnqa6GbJhwaka7WH7Wdoz1WxOjSNV8N9sgW5S3Ppgkut+TTCkjA+AodUOk1KIR+8G8S3WrSZG4nyqfJ6FEjXl6a/LEoRMHZUqfPRWvwqrtXYy9IUsmUGzkqi76ib4NANCe5DnyOxnFRZ9d8FdBVBjra3iNuZhJuWW5Omi/hBigqDsg0mu2AhfJDXdwyMIJ33HHHPfS2JtjegRejX11m41TbNL+Qp7mR0g9CPKTj9PIjuSycGN/YPozXI4zarXuAeLv5CHKtKcJKRbd6R2oLNiEt0T8+QIVJH7zt9ncKMgd49vV2P1AyScZ9Qzbu3m3LBnuu6dw7aE0b6r4kzVkI/GUS88mA53L/rLtntkFlZXGtIoqNP2mD3eVv08AVVPT3wJn81zpbJV9SuqZ6Pd1ge0Zz2RFHeCdV5CLPftH9V5o9+VzFu4R0QeumqDwUhXn3IyYotdJnxr1l3BqWnQVAeDBEOtPyJQx1q5+mODiClXtYeBLTWtsJ42AMBcf/IFIhpfhYO08hsg0Ik+DpQFNOKReK3o3cudkxWX0soPtI5eSFOA6yNylS+IQjrQtYQ/5s4UcixJfokumBUjpH9ofSjUTwPCapGFndfqqG5IHeMMvfg+88SXm7bNyjk6pGKzL+WxDAdqKtQ72WWVbOk3I+ueGuammmB2pvFZvqIcU/lvW3n9+r2lycnQLE4OX9R1jIgW4cDjJ3v8dAa66mVcfC7ptCr5io6mCaA9qI9T9FFWqo1ZAaMxgxAu8aXqmaOYryMND2sTUfoHvxcYK7hEiJhCLYFDx3PBhE97c2a0ub1/ePJcyJOqr7UaTAPTJ+xvZtjb/40sloY1ltRnTkWILmIP2b7S3AdXCR+YiArMUHwdncpjpyDGfzqGOUoAuaamWzAMacQtb34/M32FEgR5lUEf8fRzFrZUhzQj0fR7/6gdzdnVVvcSneLmtqJ930VCCDORY8CVdQWdo/S3PNkX3pQsPVKWIYGAMrFZoq8bQ/OJBDSXP7KSBdL3QN0Zqd393p6VFc7DnlnFiN00SY5Nux7yadeIM0Upl2rVsu8/VAI");
      const e = () => VO(t),
        r = () => new Set(e()),
        n = (t, e) => e.forEach(e => t.add(e));
      AB = new Map(qO(t)), TB = r(), EB = e(), PB = new Set(e().map(t => EB[t])), EB = new Set(EB), kB = r(), xB = r();
      let i = ZO(t),
        o = t();
      const s = () => {
        let t = new Set;
        return e().forEach(e => n(t, i[e])), n(t, e()), t
      };
      IB = JO(e => {
        let r = JO(t).map(t => t + 96);
        if (r.length) {
          let n = e >= o;
          return r[0] -= 32, r = eB(r), n && (r = `Restricted[${r}]`), {
            N: r,
            P: s(),
            Q: s(),
            M: !t(),
            R: n
          }
        }
      }), SB = r(), OB = new Map;
      let a = e().concat(gB(SB)).sort((t, e) => t - e);
      a.forEach((e, r) => {
        let n = t(),
          i = a[r] = n ? a[r - n] : {
            V: [],
            M: new Map
          };
        i.V.push(e), SB.has(e) || OB.set(e, i)
      });
      for (let {
          V: t,
          M: e
        }
        of new Set(OB.values())) {
        let r = [];
        for (let e of t) {
          let t = IB.filter(t => vB(t, e)),
            i = r.find(({
              G: e
            }) => t.some(t => e.has(t)));
          i || (i = {
            G: new Set,
            V: []
          }, r.push(i)), i.V.push(e), n(i.G, t)
        }
        let i = r.flatMap(t => gB(t.G));
        for (let {
            G: t,
            V: n
          }
          of r) {
          let r = new Set(i.filter(e => !t.has(e)));
          for (let t of n) e.set(t, r)
        }
      }
      BB = new Set;
      let u = new Set;
      const c = t => BB.has(t) ? u.add(t) : BB.add(t);
      for (let t of IB) {
        for (let e of t.P) c(e);
        for (let e of t.Q) c(e)
      }
      for (let t of BB) !OB.has(t) && !u.has(t) && OB.set(t, 1);
      n(BB, mB(BB)), WB = function(t) {
        let e = [],
          r = VO(t);
        return function t({
          S: r,
          B: n
        }, i, o) {
          if (!(4 & r && o === i[i.length - 1])) {
            2 & r && (o = i[i.length - 1]), 1 & r && e.push(i);
            for (let e of n)
              for (let r of e.Q) t(e, [...i, r], o)
          }
        }(function e(n) {
          let i = t(),
            o = JO(() => {
              let n = VO(t).map(t => r[t]);
              if (n.length) return e(n)
            });
          return {
            S: i,
            B: o,
            Q: n
          }
        }([]), []), e
      }(t).map(t => wB.from(t)).sort(rB), MB = new Map;
      for (let t of WB) {
        let e = [MB];
        for (let r of t) {
          let t = e.map(t => {
            let e = t.get(r);
            return e || (e = new Map, t.set(r, e)), e
          });
          65039 === r ? e.push(...t) : e = t
        }
        for (let r of e) r.V = t
      }
    }

    function RB(t) {
      return (_B(t) ? "" : NB(jB([t])) + " ") + tB(t)
    }

    function NB(t) {
      return `"${t}"`
    }

    function jB(t, e = 1 / 0, r = tB) {
      let n = [];
      (function(t) {
        return CB(), EB.has(t)
      })(t[0]) && n.push(""), t.length > e && (e >>= 1, t = [...t.slice(0, e), 8230, ...t.slice(-e)]);
      let i = 0,
        o = t.length;
      for (let e = 0; o > e; e++) {
        let o = t[e];
        _B(o) && (n.push(eB(t.slice(i, e))), n.push(r(o)), i = e + 1)
      }
      return n.push(eB(t.slice(i, o))), n.join("")
    }

    function _B(t) {
      return CB(), kB.has(t)
    }

    function DB(t) {
      return Error("disallowed character: " + RB(t))
    }

    function UB(t, e) {
      let r = RB(e),
        n = IB.find(t => t.P.has(e));
      return n && (r = `${n.N} ${r}`), Error(`illegal mixture: ${t.N} + ${r}`)
    }

    function LB(t) {
      return Error("illegal placement: " + t)
    }

    function FB(t) {
      return t.filter(t => 65039 != t)
    }

    function $B(t, e) {
      let r, n = MB,
        i = t.length;
      for (; i && (n = n.get(t[--i]), n);) {
        let {
          V: o
        } = n;
        o && (r = o, e && e.push(...t.slice(i).reverse()), t.length = i)
      }
      return r
    }
    const zB = t => function(t) {
        return function(t) {
          return t.map(({
            input: e,
            error: r,
            output: n
          }) => {
            if (r) {
              let n = r.message;
              throw Error(1 == t.length ? n : `Invalid label ${NB(jB(e,63))}: ${n}`)
            }
            return eB(n)
          }).join(".")
        }(function(t, e, r) {
          if (!t) return [];
          CB();
          let n = 0;
          return t.split(".").map(t => {
            let i = function(t) {
                let e = [];
                for (let r = 0, n = t.length; n > r;) {
                  let n = t.codePointAt(r);
                  r += 65536 > n ? 1 : 2, e.push(n)
                }
                return e
              }(t),
              o = {
                input: i,
                offset: n
              };
            n += i.length + 1;
            try {
              let t, n = o.tokens = function(t, e, r) {
                  let n = [],
                    i = [];
                  for (t = t.slice().reverse(); t.length;) {
                    let o = $B(t);
                    if (o) i.length && (n.push(e(i)), i = []), n.push(r(o));
                    else {
                      let e = t.pop();
                      if (BB.has(e)) i.push(e);
                      else {
                        let t = AB.get(e);
                        if (t) i.push(...t);
                        else if (!TB.has(e)) throw DB(e)
                      }
                    }
                  }
                  return i.length && n.push(e(i)), n
                }(i, e, r),
                s = n.length;
              if (!s) throw Error("empty label");
              let a = o.output = n.flat();
              if (function(t) {
                  for (let e = t.lastIndexOf(95); e > 0;)
                    if (95 !== t[--e]) throw Error("underscore allowed only at start")
                }(a), !(o.emoji = s > 1 || n[0].is_emoji) && a.every(t => 128 > t))(function(t) {
                if (t.length >= 4 && 45 == t[2] && 45 == t[3]) throw Error(`invalid label extension: "${eB(t.slice(0,4))}"`)
              })(a), t = "ASCII";
              else {
                let e = n.flatMap(t => t.is_emoji ? [] : t);
                if (e.length) {
                  if (EB.has(a[0])) throw LB("leading combining mark");
                  for (let t = 1; s > t; t++) {
                    let e = n[t];
                    if (!e.is_emoji && EB.has(e[0])) throw LB(`emoji + combining mark: "${eB(n[t-1])} + ${jB([e[0]])}"`)
                  }! function(t) {
                    let e = t[0],
                      r = zO.get(e);
                    if (r) throw LB("leading " + r);
                    let n = t.length,
                      i = -1;
                    for (let o = 1; n > o; o++) {
                      e = t[o];
                      let n = zO.get(e);
                      if (n) {
                        if (i == o) throw LB(`${r} + ${n}`);
                        i = o + 1, r = n
                      }
                    }
                    if (i == n) throw LB("trailing " + r)
                  }(a);
                  let r = gB(new Set(e)),
                    [i] = function(t) {
                      let e = IB;
                      for (let r of t) {
                        let t = e.filter(t => vB(t, r));
                        if (!t.length) throw IB.some(t => vB(t, r)) ? UB(e[0], r) : DB(r);
                        if (e = t, 1 == t.length) break
                      }
                      return e
                    }(r);
                  (function(t, e) {
                    for (let r of e)
                      if (!vB(t, r)) throw UB(t, r);
                    if (t.M) {
                      let t = mB(e);
                      for (let e = 1, r = t.length; r > e; e++)
                        if (PB.has(t[e])) {
                          let n = e + 1;
                          for (let i; r > n && PB.has(i = t[n]); n++)
                            for (let r = e; n > r; r++)
                              if (t[r] == i) throw Error("duplicate non-spacing marks: " + RB(i));
                          if (n - e > 4) throw Error(`excessive non-spacing marks: ${NB(jB(t.slice(e-1,n)))} (${n-e}/4)`);
                          e = n
                        }
                    }
                  })(i, e),
                  function(t, e) {
                    let r, n = [];
                    for (let t of e) {
                      let e = OB.get(t);
                      if (1 === e) return;
                      if (e) {
                        let n = e.M.get(t);
                        if (r = r ? r.filter(t => n.has(t)) : gB(n), !r.length) return
                      } else n.push(t)
                    }
                    if (r)
                      for (let e of r)
                        if (n.every(t => vB(e, t))) throw Error(`whole-script confusable: ${t.N}/${e.N}`)
                  }(i, r), t = i.N
                } else t = "Emoji"
              }
              o.type = t
            } catch (t) {
              o.error = t
            }
            return o
          })
        }(t, yB, FB))
      }(t),
      HB = t => {
        let e = "";
        for (let t = 0; 32 > t; t += 1) e += "00";
        if (t) {
          const r = zB(t).split(".");
          for (let t = r.length - 1; t >= 0; t -= 1) {
            const n = tE(r[t]).slice(2);
            e = tE(`0x${e}${n}`).slice(2)
          }
        }
        return "0x" + e
      };
    var GB = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class KB {
      constructor(t, e) {
        this.contract = new jO(FO, e ?? UO.main, t), this.context = t
      }
      getOwner(t) {
        return GB(this, void 0, void 0, function*() {
          try {
            return this.contract.methods.owner(HB(t)).call()
          } catch {
            throw Error()
          }
        })
      }
      getTTL(t) {
        return GB(this, void 0, void 0, function*() {
          try {
            return this.contract.methods.ttl(HB(t)).call()
          } catch {
            throw Error()
          }
        })
      }
      recordExists(t) {
        return GB(this, void 0, void 0, function*() {
          try {
            return this.contract.methods.recordExists(HB(t)).call()
          } catch {
            throw Error()
          }
        })
      }
      getResolver(t) {
        return GB(this, void 0, void 0, function*() {
          try {
            return this.contract.methods.resolver(HB(t)).call().then(t => {
              if ("string" == typeof t) return new jO($O, t, this.context);
              throw Error()
            })
          } catch {
            throw Error()
          }
        })
      }
      get events() {
        return this.contract.events
      }
    }
    var VB = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class ZB {
      constructor(t) {
        this.registry = t
      }
      getResolverContractAdapter(t) {
        return VB(this, void 0, void 0, function*() {
          return this.registry.getResolver(t)
        })
      }
      checkInterfaceSupport(t, e) {
        var r, n;
        return VB(this, void 0, void 0, function*() {
          if (NT(DO[e])) throw new qb(null !== (r = t.options.address) && void 0 !== r ? r : "", e);
          if (!(yield t.methods.supportsInterface(DO[e]).call())) throw new qb(null !== (n = t.options.address) && void 0 !== n ? n : "", e)
        })
      }
      supportsInterface(t, e) {
        var r;
        return VB(this, void 0, void 0, function*() {
          const n = yield this.getResolverContractAdapter(t);
          let i = e;
          if (!tA(i)) {
            if (i = null !== (r = XT(e)) && void 0 !== r ? r : "", "" === e) throw Error("Invalid interface Id");
            i = i.slice(0, 10)
          }
          return n.methods.supportsInterface(i).call()
        })
      }
      getAddress(t, e = 60) {
        return VB(this, void 0, void 0, function*() {
          const r = yield this.getResolverContractAdapter(t);
          return yield this.checkInterfaceSupport(r, "addr"), r.methods.addr(HB(t), e).call()
        })
      }
      getPubkey(t) {
        return VB(this, void 0, void 0, function*() {
          const e = yield this.getResolverContractAdapter(t);
          return yield this.checkInterfaceSupport(e, "pubkey"), e.methods.pubkey(HB(t)).call()
        })
      }
      getContenthash(t) {
        return VB(this, void 0, void 0, function*() {
          const e = yield this.getResolverContractAdapter(t);
          return yield this.checkInterfaceSupport(e, "contenthash"), e.methods.contenthash(HB(t)).call()
        })
      }
      setAddress(t, e, r) {
        return VB(this, void 0, void 0, function*() {
          const n = yield this.getResolverContractAdapter(t);
          return yield this.checkInterfaceSupport(n, "addr"), n.methods.setAddr(HB(t), e).send(r)
        })
      }
      getText(t, e) {
        return VB(this, void 0, void 0, function*() {
          const r = yield this.getResolverContractAdapter(t);
          return yield this.checkInterfaceSupport(r, "text"), r.methods.text(HB(t), e).call()
        })
      }
      getName(t, e = !0) {
        return VB(this, void 0, void 0, function*() {
          const r = t.toLowerCase().substring(2) + ".addr.reverse",
            n = yield this.getResolverContractAdapter(r);
          return e && (yield this.checkInterfaceSupport(n, "name")), n.methods.name(HB(r)).call()
        })
      }
    }
    var qB = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    class JB extends zx {
      constructor(t, e) {
        super(e ?? ""), this.registryAddress = t ?? UO.main, this.du = new KB(this.getContextObject(), t), this.pu = new ZB(this.du)
      }
      getResolver(t) {
        return qB(this, void 0, void 0, function*() {
          return this.du.getResolver(t)
        })
      }
      recordExists(t) {
        return qB(this, void 0, void 0, function*() {
          return this.du.recordExists(t)
        })
      }
      getTTL(t) {
        return qB(this, void 0, void 0, function*() {
          return this.du.getTTL(t)
        })
      }
      getOwner(t) {
        return qB(this, void 0, void 0, function*() {
          return this.du.getOwner(t)
        })
      }
      getAddress(t, e = 60) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.getAddress(t, e)
        })
      }
      getText(t, e) {
        return qB(this, void 0, void 0, function*() {
          return PA(t) ? this.pu.getText(yield this.pu.getName(t, !1), e) : this.pu.getText(t, e)
        })
      }
      getName(t, e = !0) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.getName(t, e)
        })
      }
      getPubkey(t) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.getPubkey(t)
        })
      }
      getContenthash(t) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.getContenthash(t)
        })
      }
      checkNetwork() {
        return qB(this, void 0, void 0, function*() {
          const t = Date.now() / 1e3;
          if (!this.bu || t - this.bu > 3600) {
            const e = yield(t => nO(void 0, void 0, void 0, function*() {
              return qx(t.requestManager)
            }))(this);
            if ("boolean" != typeof e || e) throw new tm;
            this.bu = t
          }
          if (this.mu) return this.mu;
          const e = yield PI(this, Object.assign(Object.assign({}, this.defaultReturnFormat), {
            number: nb.HEX
          })), r = UO[LO[e]];
          if (typeof r > "u") throw new Xb(e);
          return this.mu = r, this.mu
        })
      }
      supportsInterface(t, e) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.supportsInterface(t, e)
        })
      }
      get events() {
        return this.du.events
      }
      setAddress(t, e, r) {
        return qB(this, void 0, void 0, function*() {
          return this.pu.setAddress(t, e, r)
        })
      }
    }
    var YB, QB, XB = function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              u(n.next(t))
            } catch (t) {
              o(t)
            }
          }

          function a(t) {
            try {
              u(n.throw(t))
            } catch (t) {
              o(t)
            }
          }

          function u(t) {
            t.done ? i(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(s, a)
          }
          u((n = n.apply(t, e || [])).next())
        })
      },
      tW = function(t, e, r, n) {
        return new(r || (r = Promise))(function(i, o) {
          function s(t) {
            try {
              u(n.next(t))
            } catch (t) {
              o(t)
            }
          }

          function a(t) {
            try {
              u(n.throw(t))
            } catch (t) {
              o(t)
            }
          }

          function u(t) {
            t.done ? i(t.value) : function(t) {
              return t instanceof r ? t : new r(function(e) {
                e(t)
              })
            }(t.value).then(s, a)
          }
          u((n = n.apply(t, e || [])).next())
        })
      };
    class eW extends zx {
      getAccounts() {
        return tW(this, void 0, void 0, function*() {
          return (t => XB(void 0, void 0, void 0, function*() {
            return (yield(t => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_listAccounts",
                params: []
              })
            }))(t)).map(gT)
          }))(this.requestManager)
        })
      }
      newAccount(t) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e) => XB(void 0, void 0, void 0, function*() {
            FA.validate(["string"], [e]);
            const r = yield((t, e) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_newAccount",
                params: [e]
              })
            }))(t, e);
            return gT(r)
          }))(this.requestManager, t)
        })
      }
      unlockAccount(t, e, r) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r, n) => XB(void 0, void 0, void 0, function*() {
            return FA.validate(["address", "string", "uint"], [e, r, n]), ((t, e, r, n) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_unlockAccount",
                params: [e, r, n]
              })
            }))(t, e, r, n)
          }))(this.requestManager, t, e, r)
        })
      }
      lockAccount(t) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e) => XB(void 0, void 0, void 0, function*() {
            return FA.validate(["address"], [e]), ((t, e) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_lockAccount",
                params: [e]
              })
            }))(t, e)
          }))(this.requestManager, t)
        })
      }
      importRawKey(t, e) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r) => XB(void 0, void 0, void 0, function*() {
            return FA.validate(["string", "string"], [e, r]), ((t, e, r) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_importRawKey",
                params: [e, r]
              })
            }))(t, e, r)
          }))(this.requestManager, t, e)
        })
      }
      sendTransaction(t, e) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r, n) => XB(void 0, void 0, void 0, function*() {
            const i = TI(e, sb, {
              transactionSchema: n?.customTransactionSchema
            });
            return ((t, e, r) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_sendTransaction",
                params: [e, r]
              })
            }))(t, i, r)
          }))(this.requestManager, t, e, this.config)
        })
      }
      signTransaction(t, e) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r, n) => XB(void 0, void 0, void 0, function*() {
            const i = TI(e, sb, {
              transactionSchema: n?.customTransactionSchema
            });
            return ((t, e, r) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_signTransaction",
                params: [e, r]
              })
            }))(t, i, r)
          }))(this.requestManager, t, e, this.config)
        })
      }
      sign(t, e, r) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r, n) => XB(void 0, void 0, void 0, function*() {
            FA.validate(["string", "address", "string"], [e, r, n]);
            const i = tA(e) ? e : rT(e);
            return ((t, e, r, n) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_sign",
                params: [e, r, n]
              })
            }))(t, i, r, n)
          }))(this.requestManager, t, e, r)
        })
      }
      ecRecover(t, e) {
        return tW(this, void 0, void 0, function*() {
          return ((t, e, r) => XB(void 0, void 0, void 0, function*() {
            FA.validate(["string", "string"], [e, r]);
            const n = tA(e) ? e : rT(e);
            return ((t, e, r) => Xx(void 0, void 0, void 0, function*() {
              return t.send({
                method: "personal_ecRecover",
                params: [e, r]
              })
            }))(t, n, r)
          }))(this.requestManager, t, e)
        })
      }
    }! function(t) {
      t.HTTPS = "https", t.WebSocket = "wss"
    }(YB || (YB = {})),
    function(t) {
      t.ETH_MAINNET = "eth_mainnet", t.ETH_SEPOLIA = "eth_sepolia", t.ETH_HOLESKY = "eth_holesky", t.POLYGON_MAINNET = "polygon_mainnet", t.POLYGON_AMOY = "polygon_amoy", t.AVALANCHE_C_MAINNET = "avalanche_c_mainnet", t.AVALANCHE_P_MAINNET = "avalanche_p_mainnet", t.AVALANCHE_X_MAINNET = "avalanche_x_mainnet", t.ARBITRUM_MAINNET = "arbitrum_mainnet", t.ARBITRUM_SEPOLIA = "arbitrum_sepolia", t.BASE_MAINNET = "base_mainnet", t.BASE_SEPOLIA = "base_sepolia", t.OPTIMISM_MAINNET = "optimism_mainnet", t.OPTIMISM_SEPOLIA = "optimism_sepolia", t.FANTOM_MAINNET = "fantom_mainnet", t.FANTOM_TESTNET = "fantom_testnet", t.DYMENSION_MAINNET = "dymension_mainnet", t.DYMENSION_TESTNET = "dymension_testnet", t.BNB_MAINNET = "bnb_mainnet", t.BNB_TESTNET = "bnb_testnet", t.BSC_MAINNET = "bsc_mainnet", t.BSC_TESTNET = "bsc_testnet", t.ARBITRUM_ONE = "arbitrum_one", t.ARBITRUM_NOVA = "arbitrum_nova", t.AVALANCHE_FUJI_C = "avalanche_fuji_c", t.AVALANCHE_FUJI_P = "avalanche_fuji_p", t.AVALANCHE_FUJI_X = "avalanche_fuji_x", t.BLAST_MAINNET = "blast_mainnet", t.OPBNB_MAINNET = "opbnb_mainnet", t.OPBNB_TESTNET = "opbnb_testnet", t.GNOSIS_MAINNET = "gnosis_mainnet", t.GNOSIS_CHIADO = "gnosis_chiado", t.PULSECHAIN_MAINNET = "pulsechain_mainnet", t.PULSECHAIN_TESTNET = "pulsechain_testnet", t.KAVA_MAINNET = "kava_mainnet", t.CRONOS_MAINNET = "cronos_mainnet", t.MANTLE_MAINNET = "mantle_mainnet", t.CHILIZ_MAINNET = "chiliz_mainnet", t.CHILIZ_SPICY = "chiliz_spicy", t.MOONBEAM_MAINNET = "moonbeam_mainnet", t.TAIKO_MAINNET = "taiko_mainnet", t.TAIKO_HEKLA = "taiko_hekla", t.LINEA_MAINNET = "linea_mainnet", t.LINEA_SEPOLIA = "linea_sepolia", t.BAHAMUT_MAINNET = "bahamut_mainnet", t.SCROLL_MAINNET = "scroll_mainnet", t.SCROLL_SEPOLIA = "scroll_sepolia", t.TRON_MAINNET = "tron_mainnet", t.SYSCOIN_MAINNET = "syscoin_mainnet", t.SYSCOIN_TANENBAUM = "syscoin_tanenbaum", t.MOONRIVER_MAINNET = "moonriver_mainnet", t.HAQQ_MAINNET = "haqq_mainnet", t.EVMOS_MAINNET = "evmos_mainnet", t.EVMOS_TESTNET = "evmos_testnet", t.BERACHAIN_TESTNET = "berachain_testnet"
    }(QB || (QB = {}));
    class rW extends Wb {
      constructor(t) {
        super("You've reach the rate limit of free RPC calls from our Partner Quick Nodes. There are two options you can either create a paid Quick Nodes account and get 20% off for 2 months using WEB3JS referral code, or use Free public RPC endpoint.", t), this.code = 1300
      }
    }
    class nW extends Wb {
      constructor(t) {
        super("Invalid provider config options given for " + t), this.code = 1301
      }
    }
    class iW extends _E {
      constructor(t, e, r, n, i) {
        if (super(), void 0 !== i && e === YB.HTTPS && !("providerOptions" in i)) throw new nW("HTTP Provider");
        if (void 0 !== i && e === YB.WebSocket && !("socketOptions" in i) && !("reconnectOptions" in i)) throw new nW("Websocket Provider");
        this.transport = e, e === YB.HTTPS ? this.provider = new GE(this.getRPCURL(t, e, r, n), i) : e === YB.WebSocket && (this.provider = new ZE(this.getRPCURL(t, e, r, n), i?.socketOptions, i?.reconnectOptions))
      }
      request(t, e) {
        return function(t, e, r, n) {
          return new(r || (r = Promise))(function(e, i) {
            function o(t) {
              try {
                a(n.next(t))
              } catch (t) {
                i(t)
              }
            }

            function s(t) {
              try {
                a(n.throw(t))
              } catch (t) {
                i(t)
              }
            }

            function a(t) {
              t.done ? e(t.value) : function(t) {
                return t instanceof r ? t : new r(function(e) {
                  e(t)
                })
              }(t.value).then(o, s)
            }
            a((n = n.call(t)).next())
          })
        }(this, 0, void 0, function*() {
          return this.transport === YB.HTTPS ? yield this.provider.request(t, e): this.provider.request(t)
        })
      }
      getStatus() {
        return this.provider.getStatus()
      }
      supportsSubscriptions() {
        return this.provider.supportsSubscriptions()
      }
      once(t, e) {
        var r;
        null !== (r = this.provider) && void 0 !== r && r.once && this.provider.once(t, e)
      }
      removeAllListeners(t) {
        var e;
        null !== (e = this.provider) && void 0 !== e && e.removeAllListeners && this.provider.removeAllListeners(t)
      }
      connect() {
        var t;
        null !== (t = this.provider) && void 0 !== t && t.connect && this.provider.connect()
      }
      disconnect(t, e) {
        var r;
        null !== (r = this.provider) && void 0 !== r && r.disconnect && this.provider.disconnect(t, e)
      }
      reset() {
        var t;
        null !== (t = this.provider) && void 0 !== t && t.reset && this.provider.reset()
      }
      on(t, e) {
        this.provider && this.provider.on(t, e)
      }
      removeListener(t, e) {
        this.provider && this.provider.removeListener(t, e)
      }
    }
    const oW = t => void 0 !== t && t.trim().length > 0,
      sW = [QB.DYMENSION_MAINNET, QB.DYMENSION_TESTNET, QB.KAVA_MAINNET, QB.CRONOS_MAINNET, QB.POLYGON_MAINNET];
    class aW extends iW {
      constructor(t = QB.ETH_MAINNET, e = YB.HTTPS, r = "", n) {
        super(t, e, "", r, n)
      }
      getRPCURL(t, e, r, n) {
        if (!aW.networkHostMap[t]) throw Error("Network info not avalible.");
        const i = aW.networkHostMap[t] + ".publicnode.com",
          o = (t => void 0 !== t && t.trim().length > 0)(n) ? n : i;
        return sW.includes(t) && e === YB.WebSocket ? `${e}://${o}/websocket` : `${e}://${o}`
      }
    }
    aW.networkHostMap = {
      [QB.POLYGON_AMOY]: "polygon-amoy-bor-rpc",
      [QB.DYMENSION_MAINNET]: "dymension-evm-rpc",
      [QB.DYMENSION_TESTNET]: "dymension-testnet-evm-rpc",
      [QB.BLAST_MAINNET]: "blast-rpc",
      [QB.GNOSIS_MAINNET]: "gnosis-rpc",
      [QB.PULSECHAIN_MAINNET]: "pulsechain-rpc",
      [QB.PULSECHAIN_TESTNET]: "pulsechain-testnet-rpc",
      [QB.KAVA_MAINNET]: "kava-evm-rpc",
      [QB.CRONOS_MAINNET]: "cronos-evm-rpc",
      [QB.MANTLE_MAINNET]: "mantle-rpc",
      [QB.TAIKO_MAINNET]: "taiko-rpc",
      [QB.TAIKO_HEKLA]: "taiko-hekla-rpc",
      [QB.LINEA_MAINNET]: "linea-rpc",
      [QB.LINEA_SEPOLIA]: "linea-sepolia-rpc",
      [QB.SCROLL_MAINNET]: "scroll-rpc",
      [QB.SCROLL_SEPOLIA]: "scroll-sepolia-rpc",
      [QB.SYSCOIN_MAINNET]: "syscoin-evm-rpc",
      [QB.SYSCOIN_TANENBAUM]: "syscoin-tanenbaum-evm-rpc",
      [QB.HAQQ_MAINNET]: "haqq-evm-rpc",
      [QB.EVMOS_MAINNET]: "evmos-evm-rpc",
      [QB.EVMOS_TESTNET]: "evmos-testnet-evm-rpc",
      [QB.BERACHAIN_TESTNET]: "berachain-testnet-evm-rpc",
      [QB.ETH_MAINNET]: "ethereum-rpc",
      [QB.ETH_SEPOLIA]: "ethereum-sepolia-rpc",
      [QB.ETH_HOLESKY]: "ethereum-holesky-rpc",
      [QB.BSC_MAINNET]: "bsc-rpc",
      [QB.BSC_TESTNET]: "bsc-testnet-rpc",
      [QB.POLYGON_MAINNET]: "polygon-bor-rpc",
      [QB.BASE_MAINNET]: "base-rpc",
      [QB.BASE_SEPOLIA]: "base-sepolia-rpc",
      [QB.ARBITRUM_ONE]: "arbitrum-one-rpc",
      [QB.ARBITRUM_NOVA]: "arbitrum-nova-rpc",
      [QB.ARBITRUM_SEPOLIA]: "arbitrum-sepolia-rpc",
      [QB.AVALANCHE_C_MAINNET]: "avalanche-c-chain-rpc",
      [QB.AVALANCHE_P_MAINNET]: "avalanche-p-chain-rpc",
      [QB.AVALANCHE_X_MAINNET]: "avalanche-x-chain-rpc",
      [QB.AVALANCHE_FUJI_C]: "avalanche-fuji-c-chain-rpc",
      [QB.AVALANCHE_FUJI_P]: "avalanche-fuji-p-chain-rpc",
      [QB.AVALANCHE_FUJI_X]: "avalanche-fuji-x-chain-rpc",
      [QB.OPTIMISM_MAINNET]: "optimism-rpc",
      [QB.OPTIMISM_SEPOLIA]: "optimism-sepolia-rpc",
      [QB.FANTOM_MAINNET]: "fantom-rpc",
      [QB.FANTOM_TESTNET]: "fantom-testnet-rpc",
      [QB.OPBNB_MAINNET]: "opbnb-rpc",
      [QB.OPBNB_TESTNET]: "opbnb-testnet-rpc",
      [QB.GNOSIS_CHIADO]: "gnosis-chiado-rpc",
      [QB.CHILIZ_MAINNET]: "chiliz-rpc",
      [QB.CHILIZ_SPICY]: "chiliz-spicy-rpc",
      [QB.MOONBEAM_MAINNET]: "moonbeam-rpc",
      [QB.BAHAMUT_MAINNET]: "bahamut-rpc",
      [QB.TRON_MAINNET]: "tron-evm-rpc",
      [QB.MOONRIVER_MAINNET]: "moonriver-rpc"
    };
    const uW = new class extends iW {
        constructor(t = QB.ETH_MAINNET, e = YB.HTTPS, r = "", n = "", i) {
          super(t, e, r, n, i)
        }
        request(t, e) {
          const r = Object.create(null, {
            request: {
              get: () => super.request
            }
          });
          return function(t, e, r, n) {
            return new(r || (r = Promise))(function(e, i) {
              function o(t) {
                try {
                  a(n.next(t))
                } catch (t) {
                  i(t)
                }
              }

              function s(t) {
                try {
                  a(n.throw(t))
                } catch (t) {
                  i(t)
                }
              }

              function a(t) {
                t.done ? e(t.value) : function(t) {
                  return t instanceof r ? t : new r(function(e) {
                    e(t)
                  })
                }(t.value).then(o, s)
              }
              a((n = n.call(t)).next())
            })
          }(this, 0, void 0, function*() {
            try {
              return yield r.request.call(this, t, e)
            } catch (t) {
              throw t instanceof ly && 429 === t.statusCode ? new rW(t) : t
            }
          })
        }
        getRPCURL(t, e, r, n) {
          let i = "",
            o = "";
          switch (t) {
            case QB.ETH_MAINNET:
              i = oW(n) ? n : "powerful-holy-bush.quiknode.pro", o = oW(r) ? r : "3240624a343867035925ff7561eb60dfdba2a668";
              break;
            case QB.ETH_SEPOLIA:
              i = oW(n) ? n : "dimensional-fabled-glitter.ethereum-sepolia.quiknode.pro", o = oW(r) ? r : "382a3b5a4b938f2d6e8686c19af4b22921fde2cd";
              break;
            case QB.ETH_HOLESKY:
              i = oW(n) ? n : "yolo-morning-card.ethereum-holesky.quiknode.pro", o = oW(r) ? r : "481ebe70638c4dcf176af617a16d02ab866b9af9";
              break;
            case QB.ARBITRUM_MAINNET:
              i = oW(n) ? n : "autumn-divine-dinghy.arbitrum-mainnet.quiknode.pro", o = oW(r) ? r : "a5d7bfbf60b5ae9ce3628e53d69ef50d529e9a8c";
              break;
            case QB.ARBITRUM_SEPOLIA:
              i = oW(n) ? n : "few-patient-pond.arbitrum-sepolia.quiknode.pro", o = oW(r) ? r : "3be985450970628c860b959c65cd2642dcafe53c";
              break;
            case QB.BNB_MAINNET:
              i = oW(n) ? n : "purple-empty-reel.bsc.quiknode.pro", o = oW(r) ? r : "ebf6c532961e21f092ff2facce1ec4c89c540158";
              break;
            case QB.BNB_TESTNET:
              i = oW(n) ? n : "floral-rough-scion.bsc-testnet.quiknode.pro", o = oW(r) ? r : "5b297e5acff5f81f4c37ebf6f235f7299b6f9d28";
              break;
            case QB.POLYGON_MAINNET:
              i = oW(n) ? n : "small-chaotic-moon.matic.quiknode.pro", o = oW(r) ? r : "847569f8a017e84d985e10d0f44365d965a951f1";
              break;
            case QB.POLYGON_AMOY:
              i = oW(n) ? n : "prettiest-side-shape.matic-amoy.quiknode.pro", o = oW(r) ? r : "79a9476eea661d4f82de614db1d8a895b14b881c";
              break;
            default:
              throw Error("Network info not avalible.")
          }
          return `${e}://${i}/${o}`
        }
      },
      cW = {
        encodeEventSignature: QI,
        encodeFunctionCall: (t, e) => {
          var r;
          if (!VI(t)) throw new sm("Invalid parameter value in encodeFunctionCall");
          return `${KS(t)}${FS(null!==(r=t.inputs)&&void 0!==r?r:[],e??[]).replace("0x","")}`
        },
        encodeFunctionSignature: KS,
        encodeParameter: $S,
        encodeParameters: FS,
        decodeParameter: GS,
        decodeParameters: HS,
        decodeLog: qS
      };
    var fW = function(t, e, r, n) {
      return new(r || (r = Promise))(function(i, o) {
        function s(t) {
          try {
            u(n.next(t))
          } catch (t) {
            o(t)
          }
        }

        function a(t) {
          try {
            u(n.throw(t))
          } catch (t) {
            o(t)
          }
        }

        function u(t) {
          t.done ? i(t.value) : function(t) {
            return t instanceof r ? t : new r(function(e) {
              e(t)
            })
          }(t.value).then(s, a)
        }
        u((n = n.apply(t, e || [])).next())
      })
    };
    var lW;
    ! function(t) {
      t.eip6963announceProvider = "eip6963:announceProvider", t.eip6963requestProvider = "eip6963:requestProvider"
    }(lW || (lW = {}));
    const hW = new Map,
      dW = "web3:providersMapUpdated";
    class pW extends zx {
      constructor(t = uW) {
        var e;
        (NT(t) || "string" == typeof t && "" === t.trim() || "string" != typeof t && !tP(t) && !t.provider) && console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
        let r = {};
        "string" == typeof t || tP(t) ? r.provider = t : r = t || {}, r.registeredSubscriptions = Object.assign(Object.assign({}, AO), null !== (e = r.registeredSubscriptions) && void 0 !== e ? e : {}), super(r);
        const i = (t => {
          const e = (e, r) => fW(void 0, void 0, void 0, function*() {
              return ((t, e) => Wx(void 0, void 0, void 0, function*() {
                const r = t.sign(JA(e));
                if (RA(r.v) || RA(r.r) || RA(r.s)) throw new Zm("Signer Error");
                const n = r.validate(!0);
                if (n.length > 0) {
                  let t = "Signer Error ";
                  for (const e of n) t += `${t} ${e}.`;
                  throw new Zm(t)
                }
                const i = qA(r.serialize()),
                  o = tE(i);
                return {
                  messageHash: qA(r.getMessageToSign(!0)),
                  v: "0x" + r.v.toString(16),
                  r: "0x" + r.r.toString(16).padStart(64, "0"),
                  s: "0x" + r.s.toString(16).padStart(64, "0"),
                  rawTransaction: i,
                  transactionHash: qA(o)
                }
              }))(yield kO(e, t), JT({
                format: "bytes"
              }, r, sb))
            }),
            r = t => {
              const r = Lx(t);
              return Object.assign(Object.assign({}, r), {
                signTransaction: t => fW(void 0, void 0, void 0, function*() {
                  return e(t, r.privateKey)
                })
              })
            },
            n = (t, r, n) => fW(void 0, void 0, void 0, function*() {
              var i;
              const o = yield((t, e, r) => Wx(void 0, void 0, void 0, function*() {
                const n = "object" == typeof t ? t : JSON.parse(r ? t.toLowerCase() : t);
                if (FA.validateJSONSchema(Fk, n), 3 !== n.version) throw new Ub;
                const i = "string" == typeof e ? JA(rT(e)) : e;
                let o;
                if (FA.validate(["bytes"], [i]), "scrypt" === n.crypto.kdf) {
                  const t = n.crypto.kdfparams;
                  o = NP(i, "string" == typeof t.salt ? JA(t.salt) : t.salt, t.n, t.p, t.r, t.dklen)
                } else {
                  if ("pbkdf2" !== n.crypto.kdf) throw new _b;
                  {
                    const t = n.crypto.kdfparams;
                    o = MP(i, "string" == typeof t.salt ? JA(t.salt) : t.salt, t.c, t.dklen, "sha256")
                  }
                }
                const s = JA(n.crypto.ciphertext);
                if (tE(zA(o.slice(16, 32), s)).replace("0x", "") !== n.crypto.mac) throw new Db;
                const a = yield async function(t, e, r, n = "aes-128-ctr", i = !0) {
                  if (hP(e, r, n), lP.web) {
                    const [o, s] = await dP(n, e, r);
                    if (!i && "aes-cbc" === s.name) {
                      const i = await async function(t, e, r, n) {
                        const i = t.slice(-16);
                        for (let t = 0; 16 > t; t++) i[t] ^= 16 ^ r[t];
                        return (await pP(i, e, r, n)).slice(0, 16)
                      }(t, e, r, n);
                      t = Ky(t, i)
                    }
                    const a = await lP.web.subtle.decrypt(s, o, t),
                      u = new Uint8Array(a);
                    if ("aes-cbc" === s.name && ! function(t, e) {
                        if (t.length !== e.length) return !1;
                        for (let r = 0; r < t.length; r++)
                          if (t[r] !== e[r]) return !1;
                        return !0
                      }(await pP(u, e, r, n), t)) throw Error("AES: wrong padding");
                    return u
                  }
                  if (lP.node) {
                    const o = lP.node.createDecipheriv(n, e, r);
                    return o.setAutoPadding(i), Ky(o.update(t), o.final())
                  }
                  throw Error("The environment doesn't have AES module")
                }(JA(n.crypto.ciphertext), o.slice(0, 16), JA(n.crypto.cipherparams.iv));
                return Lx(a)
              }))(t, r, null === (i = n?.nonStrict) || void 0 === i || i);
              return Object.assign(Object.assign({}, o), {
                signTransaction: t => fW(void 0, void 0, void 0, function*() {
                  return e(t, o.privateKey)
                })
              })
            }),
            i = () => {
              const t = (() => {
                const t = _k.utils.randomPrivateKey();
                return Lx("" + qA(t))
              })();
              return Object.assign(Object.assign({}, t), {
                signTransaction: r => fW(void 0, void 0, void 0, function*() {
                  return e(r, t.privateKey)
                })
              })
            },
            o = new fP({
              create: i,
              privateKeyToAccount: r,
              decrypt: n
            });
          return {
            signTransaction: e,
            create: i,
            privateKeyToAccount: r,
            decrypt: n,
            recoverTransaction: Nx,
            hashMessage: Cx,
            sign: Rx,
            recover: jx,
            encrypt: Ux,
            wallet: o,
            privateKeyToAddress: _x,
            parseAndValidatePrivateKey: Mx,
            privateKeyToPublicKey: Dx
          }
        })(this);
        this.Vs = i.wallet, this.fo = i, this.utils = n;
        const o = this,
          s = o.use(TO);
        this.eth = Object.assign(s, {
          ens: o.use(JB, UO.main),
          Iban: Hx,
          net: o.use(II),
          personal: o.use(eW),
          Contract: class extends _O {
            constructor(t, e, r, n, i) {
              if (RT(e) && RT(r)) throw new em("Should not provide options at both 2nd and 3rd parameters");
              let a, u, c, f = {};
              if (!NT(e) && "object" != typeof e && "string" != typeof e) throw new em;
              if ("string" == typeof e && (a = e), f = RT(e) ? e : RT(r) ? r : {}, u = e instanceof zx ? e : r instanceof zx ? r : n instanceof zx ? n : o.getContextObject(), i ? c = i : GT(r) ? c = r : GT(n) && (c = n), super(t, a, f, u, c), super.subscribeToContextEvents(o), !NT(s)) {
                const t = s.getTransactionMiddleware();
                NT(t) || super.setTransactionMiddleware(t)
              }
            }
          },
          abi: cW,
          accounts: i
        })
      }
    }
    pW.version = "4.16.0", pW.utils = n, pW.requestEIP6963Providers = () => {
      return e = function*() {
        return new Promise((t, e) => {
          typeof window > "u" && e(Error("window object not available, EIP-6963 is intended to be used within a browser")), window.addEventListener(lW.eip6963announceProvider, e => {
            hW.set(e.detail.info.uuid, e.detail);
            const r = new CustomEvent(dW, {
              detail: hW
            });
            window.dispatchEvent(r), t(hW)
          }), window.dispatchEvent(new Event(lW.eip6963requestProvider))
        })
      }, new((t = void 0) || (t = Promise))(function(r, n) {
        function i(t) {
          try {
            s(e.next(t))
          } catch (t) {
            n(t)
          }
        }

        function o(t) {
          try {
            s(e.throw(t))
          } catch (t) {
            n(t)
          }
        }

        function s(e) {
          e.done ? r(e.value) : function(e) {
            return e instanceof t ? e : new t(function(t) {
              t(e)
            })
          }(e.value).then(i, o)
        }
        s((e = e.call(void 0)).next())
      });
      var t, e
    }, pW.onNewProviderDiscovered = t => {
      if (typeof window > "u") throw Error("window object not available, EIP-6963 is intended to be used within a browser");
      window.addEventListener(dW, t)
    }, pW.modules = {
      Web3Eth: TO,
      Iban: Hx,
      Net: II,
      ENS: JB,
      Personal: eW
    }, i(54089), i(25200), i(56953);
    const bW = "X-Origin",
      mW = "solana:signAndSendTransaction",
      yW = "solana:signTransaction",
      gW = "solana:signMessage",
      vW = "solana:signIn",
      wW = "standard:connect",
      AW = "standard:disconnect",
      TW = "standard:events";
    var EW = i(48287).Buffer,
      PW = {},
      kW = {
        exports: {}
      };
    ! function(t) {
      var e = {}.hasOwnProperty,
        r = "~";

      function n() {}

      function i(t, e, r) {
        this.fn = t, this.context = e, this.once = r || !1
      }

      function o(t, e, n, o, s) {
        if ("function" != typeof n) throw new TypeError("The listener must be a function");
        var a = new i(n, o || t, s),
          u = r ? r + e : e;
        return t.ye[u] ? t.ye[u].fn ? t.ye[u] = [t.ye[u], a] : t.ye[u].push(a) : (t.ye[u] = a, t.Ae++), t
      }

      function s(t, e) {
        0 === --t.Ae ? t.ye = new n : delete t.ye[e]
      }

      function a() {
        this.ye = new n, this.Ae = 0
      }
      Object.create && (n.prototype = Object.create(null), (new n).__proto__ || (r = !1)), a.prototype.eventNames = function() {
        var t, n, i = [];
        if (0 === this.Ae) return i;
        for (n in t = this.ye) e.call(t, n) && i.push(r ? n.slice(1) : n);
        return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i
      }, a.prototype.listeners = function(t) {
        var e = r ? r + t : t,
          n = this.ye[e];
        if (!n) return [];
        if (n.fn) return [n.fn];
        for (var i = 0, o = n.length, s = Array(o); o > i; i++) s[i] = n[i].fn;
        return s
      }, a.prototype.listenerCount = function(t) {
        var e = r ? r + t : t,
          n = this.ye[e];
        return n ? n.fn ? 1 : n.length : 0
      }, a.prototype.emit = function(t, e, n, i, o, s) {
        var a = r ? r + t : t;
        if (!this.ye[a]) return !1;
        var u, c, f = this.ye[a],
          l = arguments.length;
        if (f.fn) {
          switch (f.once && this.removeListener(t, f.fn, void 0, !0), l) {
            case 1:
              return f.fn.call(f.context), !0;
            case 2:
              return f.fn.call(f.context, e), !0;
            case 3:
              return f.fn.call(f.context, e, n), !0;
            case 4:
              return f.fn.call(f.context, e, n, i), !0;
            case 5:
              return f.fn.call(f.context, e, n, i, o), !0;
            case 6:
              return f.fn.call(f.context, e, n, i, o, s), !0
          }
          for (c = 1, u = Array(l - 1); l > c; c++) u[c - 1] = arguments[c];
          f.fn.apply(f.context, u)
        } else {
          var h, d = f.length;
          for (c = 0; d > c; c++) switch (f[c].once && this.removeListener(t, f[c].fn, void 0, !0), l) {
            case 1:
              f[c].fn.call(f[c].context);
              break;
            case 2:
              f[c].fn.call(f[c].context, e);
              break;
            case 3:
              f[c].fn.call(f[c].context, e, n);
              break;
            case 4:
              f[c].fn.call(f[c].context, e, n, i);
              break;
            default:
              if (!u)
                for (h = 1, u = Array(l - 1); l > h; h++) u[h - 1] = arguments[h];
              f[c].fn.apply(f[c].context, u)
          }
        }
        return !0
      }, a.prototype.on = function(t, e, r) {
        return o(this, t, e, r, !1)
      }, a.prototype.once = function(t, e, r) {
        return o(this, t, e, r, !0)
      }, a.prototype.removeListener = function(t, e, n, i) {
        var o = r ? r + t : t;
        if (!this.ye[o]) return this;
        if (!e) return s(this, o), this;
        var a = this.ye[o];
        if (a.fn) a.fn === e && (!i || a.once) && (!n || a.context === n) && s(this, o);
        else {
          for (var u = 0, c = [], f = a.length; f > u; u++)(a[u].fn !== e || i && !a[u].once || n && a[u].context !== n) && c.push(a[u]);
          c.length ? this.ye[o] = 1 === c.length ? c[0] : c : s(this, o)
        }
        return this
      }, a.prototype.removeAllListeners = function(t) {
        var e;
        return t ? (e = r ? r + t : t, this.ye[e] && s(this, e)) : (this.ye = new n, this.Ae = 0), this
      }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = r, a.EventEmitter = a, t.exports = a
    }(kW);
    var xW = {};
    Object.defineProperty(xW, "_", {
      value: !0
    }), xW.createError = xW.DefaultDataPack = void 0;
    const IW = new Map([
      [-32e3, "Event not provided"],
      [-32600, "Invalid Request"],
      [-32601, "Method not found"],
      [-32602, "Invalid params"],
      [-32603, "Internal error"],
      [-32604, "Params not found"],
      [-32605, "Method forbidden"],
      [-32606, "Event forbidden"],
      [-32700, "Parse error"]
    ]);
    xW.DefaultDataPack = class {
      encode(t) {
        return JSON.stringify(t)
      }
      decode(t) {
        return JSON.parse(t)
      }
    }, xW.createError = function(t, e) {
      const r = {
        code: t,
        message: IW.get(t) || "Internal Server Error"
      };
      return e && (r.data = e), r
    }, Object.defineProperty(PW, "_", {
      value: !0
    });
    const SW = kW.exports,
      OW = xW;
    class BW extends SW.EventEmitter {
      address;
      rpc_id;
      queue;
      options;
      autoconnect;
      ready;
      reconnect;
      reconnect_timer_id;
      reconnect_interval;
      max_reconnects;
      rest_options;
      current_reconnects;
      generate_request_id;
      socket;
      webSocketFactory;
      dataPack;
      constructor(t, e = "ws://localhost:8080", {
        autoconnect: r = !0,
        reconnect: n = !0,
        reconnect_interval: i = 1e3,
        max_reconnects: o = 5,
        ...s
      } = {}, a, u) {
        super(), this.webSocketFactory = t, this.queue = {}, this.rpc_id = 0, this.address = e, this.autoconnect = r, this.ready = !1, this.reconnect = n, this.reconnect_timer_id = void 0, this.reconnect_interval = i, this.max_reconnects = o, this.rest_options = s, this.current_reconnects = 0, this.generate_request_id = a || (() => ++this.rpc_id), this.dataPack = u || new OW.DefaultDataPack, this.autoconnect && this.Lr(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        })
      }
      connect() {
        this.socket || this.Lr(this.address, {
          autoconnect: this.autoconnect,
          reconnect: this.reconnect,
          reconnect_interval: this.reconnect_interval,
          max_reconnects: this.max_reconnects,
          ...this.rest_options
        })
      }
      call(t, e, r, n) {
        return !n && "object" == typeof r && (n = r, r = null), new Promise((i, o) => {
          if (!this.ready) return o(Error("socket not ready"));
          const s = this.generate_request_id(t, e),
            a = {
              jsonrpc: "2.0",
              method: t,
              params: e || void 0,
              id: s
            };
          this.socket.send(this.dataPack.encode(a), n, t => {
            if (t) return o(t);
            this.queue[s] = {
              promise: [i, o]
            }, r && (this.queue[s].timeout = setTimeout(() => {
              delete this.queue[s], o(Error("reply timeout"))
            }, r))
          })
        })
      }
      async login(t) {
        const e = await this.call("rpc.login", t);
        if (!e) throw Error("authentication failed");
        return e
      }
      async listMethods() {
        return await this.call("__listMethods")
      }
      notify(t, e) {
        return new Promise((r, n) => {
          if (!this.ready) return n(Error("socket not ready"));
          const i = {
            jsonrpc: "2.0",
            method: t,
            params: e
          };
          this.socket.send(this.dataPack.encode(i), t => {
            if (t) return n(t);
            r()
          })
        })
      }
      async subscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.on", t);
        if ("string" == typeof t && "ok" !== e[t]) throw Error("Failed subscribing to an event '" + t + "' with: " + e[t]);
        return e
      }
      async unsubscribe(t) {
        "string" == typeof t && (t = [t]);
        const e = await this.call("rpc.off", t);
        if ("string" == typeof t && "ok" !== e[t]) throw Error("Failed unsubscribing from an event with: " + e);
        return e
      }
      close(t, e) {
        this.socket.close(t || 1e3, e)
      }
      setAutoReconnect(t) {
        this.reconnect = t
      }
      setReconnectInterval(t) {
        this.reconnect_interval = t
      }
      setMaxReconnects(t) {
        this.max_reconnects = t
      }
      Lr(t, e) {
        clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(t, e), this.socket.addEventListener("open", () => {
          this.ready = !0, this.emit("open"), this.current_reconnects = 0
        }), this.socket.addEventListener("message", ({
          data: t
        }) => {
          t instanceof ArrayBuffer && (t = EW.from(t).toString());
          try {
            t = this.dataPack.decode(t)
          } catch {
            return
          }
          if (t.notification && this.listeners(t.notification).length) {
            if (!Object.keys(t.params).length) return this.emit(t.notification);
            const e = [t.notification];
            if (t.params.constructor === Object) e.push(t.params);
            else
              for (let r = 0; r < t.params.length; r++) e.push(t.params[r]);
            return Promise.resolve().then(() => {
              this.emit.apply(this, e)
            })
          }
          if (!this.queue[t.id]) return t.method ? Promise.resolve().then(() => {
            this.emit(t.method, t?.params)
          }) : void 0;
          "error" in t == "result" in t && this.queue[t.id].promise[1](Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[t.id].timeout && clearTimeout(this.queue[t.id].timeout), t.error ? this.queue[t.id].promise[1](t.error) : this.queue[t.id].promise[0](t.result), delete this.queue[t.id]
        }), this.socket.addEventListener("error", t => this.emit("error", t)), this.socket.addEventListener("close", ({
          code: r,
          reason: n
        }) => {
          this.ready && setTimeout(() => this.emit("close", r, n), 0), this.ready = !1, this.socket = void 0, 1e3 !== r && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || 0 === this.max_reconnects) && (this.reconnect_timer_id = setTimeout(() => this.Lr(t, e), this.reconnect_interval)))
        })
      }
    }
    PW.default = BW;
    var WW, MW = (t, e, r) => {
      if (!e.has(t)) throw TypeError("Cannot " + r)
    };
    class CW extends Event {
      constructor(t) {
        super("wallet-standard:register-wallet", {
          bubbles: !1,
          cancelable: !1,
          composed: !1
        }), ((t, e) => {
          if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
          e instanceof WeakSet ? e.add(t) : e.set(t, void 0)
        })(this, WW), ((t, e, r) => {
          MW(t, e, "write to private field"), e.set(t, r)
        })(this, WW, t)
      }
      get detail() {
        return ((t, e) => (MW(t, e, "read from private field"), e.get(t)))(this, WW)
      }
      get type() {
        return "wallet-standard:register-wallet"
      }
      preventDefault() {
        throw Error("preventDefault cannot be called")
      }
      stopImmediatePropagation() {
        throw Error("stopImmediatePropagation cannot be called")
      }
      stopPropagation() {
        throw Error("stopPropagation cannot be called")
      }
    }
    WW = new WeakMap;
    const RW = ["solana:mainnet"];

    function NW(t) {
      return RW.includes(t)
    }

    function jW(t) {
      return "version" in t
    }
    var _W, DW, UW, LW, FW, $W, zW = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      HW = (t, e, r) => (zW(t, e, "read from private field"), r ? r.call(t) : e.get(t)),
      GW = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
      },
      KW = (t, e, r, n) => (zW(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r);
    const VW = RW,
      ZW = [mW, yW, gW],
      qW = class {
        constructor({
          address: t,
          publicKey: e,
          label: r,
          icon: n
        }) {
          GW(this, _W, void 0), GW(this, DW, void 0), GW(this, UW, void 0), GW(this, LW, void 0), GW(this, FW, void 0), GW(this, $W, void 0), new.target === qW && Object.freeze(this), KW(this, _W, t), KW(this, DW, e), KW(this, UW, VW), KW(this, LW, ZW), KW(this, FW, r), KW(this, $W, n)
        }
        get address() {
          return HW(this, _W)
        }
        get publicKey() {
          return HW(this, DW).slice()
        }
        get chains() {
          return HW(this, UW).slice()
        }
        get features() {
          return HW(this, LW).slice()
        }
        get label() {
          return HW(this, FW)
        }
        get icon() {
          return HW(this, $W)
        }
      };
    let JW = qW;
    _W = new WeakMap, DW = new WeakMap, UW = new WeakMap, LW = new WeakMap, FW = new WeakMap, $W = new WeakMap;
    var YW, QW, XW, tM, eM, rM, nM, iM, oM, sM, aM, uM, cM, fM, lM, hM, dM, pM, bM, mM, yM = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      gM = (t, e, r) => (yM(t, e, "read from private field"), r ? r.call(t) : e.get(t)),
      vM = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
      },
      wM = (t, e, r, n) => (yM(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r),
      AM = (t, e, r) => (yM(t, e, "access private method"), r);
    const TM = "trust:",
      EM = class {
        constructor(t) {
          vM(this, iM), vM(this, sM), vM(this, YW, {}), vM(this, QW, "1.0.0"), vM(this, XW, "Trust"), vM(this, tM, "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTgiIGhlaWdodD0iNjUiIHZpZXdCb3g9IjAgMCA1OCA2NSIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTAgOS4zODk0OUwyOC44OTA3IDBWNjUuMDA0MkM4LjI1NDUgNTYuMzM2OSAwIDM5LjcyNDggMCAzMC4zMzUzVjkuMzg5NDlaIiBmaWxsPSIjMDUwMEZGIi8+CjxwYXRoIGQ9Ik01Ny43ODIyIDkuMzg5NDlMMjguODkxNSAwVjY1LjAwNDJDNDkuNTI3NyA1Ni4zMzY5IDU3Ljc4MjIgMzkuNzI0OCA1Ny43ODIyIDMwLjMzNTNWOS4zODk0OVoiIGZpbGw9InVybCgjcGFpbnQwX2xpbmVhcl8yMjAxXzY5NDIpIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIwMV82OTQyIiB4MT0iNTEuMzYxNSIgeTE9Ii00LjE1MjkzIiB4Mj0iMjkuNTM4NCIgeTI9IjY0LjUxNDciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agb2Zmc2V0PSIwLjAyMTEyIiBzdG9wLWNvbG9yPSIjMDAwMEZGIi8+CjxzdG9wIG9mZnNldD0iMC4wNzYyNDIzIiBzdG9wLWNvbG9yPSIjMDA5NEZGIi8+CjxzdG9wIG9mZnNldD0iMC4xNjMwODkiIHN0b3AtY29sb3I9IiM0OEZGOTEiLz4KPHN0b3Agb2Zmc2V0PSIwLjQyMDA0OSIgc3RvcC1jb2xvcj0iIzAwOTRGRiIvPgo8c3RvcCBvZmZzZXQ9IjAuNjgyODg2IiBzdG9wLWNvbG9yPSIjMDAzOEZGIi8+CjxzdG9wIG9mZnNldD0iMC45MDI0NjUiIHN0b3AtY29sb3I9IiMwNTAwRkYiLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K"), vM(this, eM, null), vM(this, rM, void 0), vM(this, nM, (t, e) => {
            var r;
            return null != (r = gM(this, YW)[t]) && r.push(e) || (gM(this, YW)[t] = [e]), () => AM(this, sM, aM).call(this, t, e)
          }), vM(this, uM, () => {
            var t;
            const e = null == (t = gM(this, rM).publicKey) ? void 0 : t.toBase58();
            if (e) {
              const t = gM(this, rM).publicKey.toBytes(),
                r = gM(this, eM);
              (!r || r.address !== e || ! function(t, e) {
                return function(t, e) {
                  if (t === e) return !0;
                  const r = t.length;
                  if (r !== e.length) return !1;
                  for (let n = 0; r > n; n++)
                    if (t[n] !== e[n]) return !1;
                  return !0
                }(t, e)
              }(r.publicKey, t)) && (wM(this, eM, new JW({
                address: e,
                publicKey: t
              })), AM(this, iM, oM).call(this, "change", {
                accounts: this.accounts
              }))
            }
          }), vM(this, cM, () => {
            gM(this, eM) && (wM(this, eM, null), AM(this, iM, oM).call(this, "change", {
              accounts: this.accounts
            }))
          }), vM(this, fM, () => {
            gM(this, rM).publicKey ? gM(this, uM).call(this) : gM(this, cM).call(this)
          }), vM(this, lM, async ({
            silent: t
          } = {}) => (gM(this, eM) || await gM(this, rM).connect(t ? {
            onlyIfTrusted: !0
          } : void 0), gM(this, uM).call(this), {
            accounts: this.accounts
          })), vM(this, hM, async () => {
            await gM(this, rM).disconnect()
          }), vM(this, dM, async (...t) => {
            if (!gM(this, eM)) throw Error("not connected");
            const e = [];
            if (1 === t.length) {
              const {
                transaction: r,
                account: n,
                chain: i,
                options: o
              } = t[0], {
                minContextSlot: s,
                preflightCommitment: a,
                skipPreflight: u,
                maxRetries: c
              } = o || {};
              if (n !== gM(this, eM)) throw Error("invalid account");
              if (!NW(i)) throw Error("invalid chain");
              const {
                signature: f
              } = await gM(this, rM).signAndSendTransaction(kh.deserialize(r), {
                preflightCommitment: a,
                minContextSlot: s,
                maxRetries: c,
                skipPreflight: u
              });
              e.push({
                signature: new Uint8Array(is.decode(f))
              })
            } else if (t.length > 1)
              for (const r of t) e.push(...await gM(this, dM).call(this, r));
            return e
          }), vM(this, pM, async (...t) => {
            if (!gM(this, eM)) throw Error("not connected");
            const e = [];
            if (1 === t.length) {
              const {
                transaction: r,
                account: n,
                chain: i
              } = t[0];
              if (n !== gM(this, eM)) throw Error("invalid account");
              if (i && !NW(i)) throw Error("invalid chain");
              const o = await gM(this, rM).signTransaction(kh.deserialize(r)),
                s = jW(o) ? o.serialize() : new Uint8Array(o.serialize({
                  requireAllSignatures: !1,
                  verifySignatures: !1
                }));
              e.push({
                signedTransaction: s
              })
            } else if (t.length > 1) {
              let r;
              for (const e of t) {
                if (e.account !== gM(this, eM)) throw Error("invalid account");
                if (e.chain) {
                  if (!NW(e.chain)) throw Error("invalid chain");
                  if (r) {
                    if (e.chain !== r) throw Error("conflicting chain")
                  } else r = e.chain
                }
              }
              const n = t.map(({
                  transaction: t
                }) => kh.deserialize(t)),
                i = await gM(this, rM).signAllTransactions(n);
              e.push(...i.map(t => ({
                signedTransaction: jW(t) ? t.serialize() : new Uint8Array(t.serialize({
                  requireAllSignatures: !1,
                  verifySignatures: !1
                }))
              })))
            }
            return e
          }), vM(this, bM, async (...t) => {
            if (!gM(this, eM)) throw Error("not connected");
            const e = [];
            if (1 === t.length) {
              const {
                message: r,
                account: n
              } = t[0];
              if (n !== gM(this, eM)) throw Error("invalid account");
              const {
                signature: i
              } = await gM(this, rM).signMessage(r);
              e.push({
                signedMessage: r,
                signature: i
              })
            } else if (t.length > 1)
              for (const r of t) e.push(...await gM(this, bM).call(this, r));
            return e
          }), vM(this, mM, async (...t) => {
            const e = [];
            if (1 >= t.length) return [await gM(this, rM).signIn(t[0])];
            for (const r of t) e.push(await gM(this, rM).signIn(r));
            return e
          }), new.target === EM && Object.freeze(this), wM(this, rM, t), t.on("connect", gM(this, uM), this), t.on("disconnect", gM(this, cM), this), t.on("accountChanged", gM(this, fM), this), gM(this, uM).call(this)
        }
        get version() {
          return gM(this, QW)
        }
        get name() {
          return gM(this, XW)
        }
        get icon() {
          return gM(this, tM)
        }
        get chains() {
          return RW.slice()
        }
        get features() {
          return {
            [wW]: {
              version: "1.0.0",
              connect: gM(this, lM)
            },
            [AW]: {
              version: "1.0.0",
              disconnect: gM(this, hM)
            },
            [TW]: {
              version: "1.0.0",
              on: gM(this, nM)
            },
            [mW]: {
              version: "1.0.0",
              supportedTransactionVersions: ["legacy", 0],
              signAndSendTransaction: gM(this, dM)
            },
            [yW]: {
              version: "1.0.0",
              supportedTransactionVersions: ["legacy", 0],
              signTransaction: gM(this, pM)
            },
            [gW]: {
              version: "1.0.0",
              signMessage: gM(this, bM)
            },
            [vW]: {
              version: "1.0.0",
              signIn: gM(this, mM)
            },
            [TM]: {
              trust: gM(this, rM)
            }
          }
        }
        get accounts() {
          return gM(this, eM) ? [gM(this, eM)] : []
        }
      };
    let PM = EM;
    YW = new WeakMap, QW = new WeakMap, XW = new WeakMap, tM = new WeakMap, eM = new WeakMap, rM = new WeakMap, nM = new WeakMap, iM = new WeakSet, oM = function(t, ...e) {
      var r;
      null == (r = gM(this, YW)[t]) || r.forEach(t => t.apply(null, e))
    }, sM = new WeakSet, aM = function(t, e) {
      var r;
      gM(this, YW)[t] = null == (r = gM(this, YW)[t]) ? void 0 : r.filter(t => e !== t)
    }, uM = new WeakMap, cM = new WeakMap, fM = new WeakMap, lM = new WeakMap, hM = new WeakMap, dM = new WeakMap, pM = new WeakMap, bM = new WeakMap, mM = new WeakMap;
    class kM {
      constructor(t, e = !1) {
        this.useLegacySign = !1, this.provider = t, this.useLegacySign = e
      }
      async connect(t) {
        const e = await this.provider.internalRequest({
          method: "requestAccounts",
          params: {
            options: t
          }
        });
        return this.provider.emit("connect"), {
          publicKey: new eh(e[0])
        }
      }
      async signTransaction(t) {
        if (this.useLegacySign) return await this.legacySign(t);
        const e = JSON.stringify(t);
        let r, n = "legacy";
        jW(t) ? (n = t.version, r = EW.from(t.message.serialize()).toString("base64")) : r = EW.from(t.serializeMessage()).toString("base64");
        const i = EW.from(t.serialize({
            requireAllSignatures: !1,
            verifySignatures: !1
          })).toString("base64"),
          o = await this.provider.internalRequest({
            method: "signRawTransaction",
            params: {
              data: e,
              raw: i,
              rawMessage: r,
              version: n
            }
          });
        return this.provider.mapSignedTransaction(t, o)
      }
      async legacySign(t) {
        const e = JSON.stringify(t),
          r = "number" != typeof t.version ? "legacy" : t.version,
          n = is.encode("legacy" === r ? t.serializeMessage() : 0 === r ? t.message.serialize() : t.serialize());
        try {
          const i = await this.provider.internalRequest({
            method: "signRawTransaction",
            params: {
              data: e,
              raw: n,
              version: r
            }
          });
          return this.provider.mapSignedTransaction(t, i)
        } catch (t) {
          console.log("<== Error: " + t)
        }
      }
      async request(t, e) {
        var r;
        switch (t.method) {
          case "signTransaction":
            return this.signTransaction(t.params);
          case "connect":
            return this.connect(null == (r = t?.params) ? void 0 : r.options)
        }
        return e()
      }
    }
    var xM, IM, SM, OM, BM, WM = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      MM = (t, e, r) => (WM(t, e, "read from private field"), r ? r.call(t) : e.get(t)),
      CM = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
      },
      RM = (t, e, r, n) => (WM(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r),
      NM = (t, e, r) => (WM(t, e, "access private method"), r);
    const jM = class extends Ue {
      constructor(t) {
        super(), CM(this, OM), CM(this, xM, !1), CM(this, IM, !0), this.isTrust = !0, this.isTrustWallet = !0, CM(this, SM, !1), t && ("u" > typeof t.enableAdapter && RM(this, IM, t.enableAdapter), "u" > typeof t.cluster && (this.connection = new zp(t.cluster, "confirmed")), "u" > typeof t.disableMobileAdapter && RM(this, xM, t.disableMobileAdapter), "u" > typeof t.useLegacySign && RM(this, SM, t.useLegacySign), "u" > typeof t.isTrust && (this.isTrust = t.isTrust, this.isTrustWallet = t.isTrust)), MM(this, IM) && function(t) {
          ! function(t) {
            const e = ({
              register: e
            }) => e(t);
            try {
              window.dispatchEvent(new CW(e))
            } catch (t) {
              console.error("wallet-standard:register-wallet event could not be dispatched\n", t)
            }
            try {
              window.addEventListener("wallet-standard:app-ready", ({
                detail: t
              }) => e(t))
            } catch (t) {
              console.error("wallet-standard:app-ready event listener could not be added\n", t)
            }
          }(t.getInstanceWithAdapter())
        }(this), MM(this, xM) || (this.mobileAdapter = new kM(this, MM(this, SM)))
      }
      static bufferToHex(t) {
        return "0x" + EW.from(t).toString("hex")
      }
      static messageToBuffer(t) {
        let e = EW.from([]);
        try {
          e = "string" == typeof t ? EW.from(t.replace("0x", ""), "hex") : EW.from(t)
        } catch (t) {
          console.log("messageToBuffer error: " + t)
        }
        return e
      }
      getInstanceWithAdapter() {
        return new PM(this)
      }
      async connect(t) {
        const e = await NM(this, OM, BM).call(this, {
          method: "connect",
          params: {
            options: t
          }
        });
        return this.publicKey = e.publicKey, e
      }
      disconnect() {
        return new Promise(t => {
          this.publicKey = null, this.emit("disconnect"), t()
        })
      }
      async signAndSendTransaction(t, e) {
        const r = await this.signTransaction(t);
        return {
          signature: await this.connection.sendRawTransaction(r.serialize(), e)
        }
      }
      signTransaction(t) {
        return NM(this, OM, BM).call(this, {
          method: "signTransaction",
          params: t
        })
      }
      signAllTransactions(t) {
        return Promise.all(t.map(t => this.signTransaction(t)))
      }
      async signRawTransactionMulti(t) {
        return (await NM(this, OM, BM).call(this, {
          method: "signRawTransactionMulti",
          params: {
            transactions: t.map(t => {
              const e = JSON.stringify(t);
              let r, n = "legacy";
              return jW(t) ? (n = t.version, r = EW.from(t.message.serialize()).toString("base64")) : r = EW.from(t.serializeMessage()).toString("base64"), {
                data: e,
                raw: EW.from(t.serialize({
                  requireAllSignatures: !1,
                  verifySignatures: !1
                })).toString("base64"),
                rawMessage: r,
                version: n
              }
            })
          }
        })).map((e, r) => this.mapSignedTransaction(t[r], e))
      }
      async signMessage(t) {
        var e;
        const r = jM.bufferToHex(t),
          n = await NM(this, OM, BM).call(this, {
            method: "signMessage",
            params: {
              data: r
            }
          });
        return {
          signature: new Uint8Array(EW.from(jM.messageToBuffer(n).buffer)),
          publicKey: null == (e = this.publicKey) ? void 0 : e.toBase58()
        }
      }
      signIn(t) {
        throw Error("Method not implemented.")
      }
      getNetwork() {
        return jM.NETWORK
      }
      mapSignedTransaction(t, e) {
        return t.addSignature(this.publicKey, is.decode(e)), t
      }
      request(t) {
        throw Error("Not implemented")
      }
      internalRequest(t) {
        return super.request(t)
      }
    };
    let _M = jM;
    xM = new WeakMap, IM = new WeakMap, SM = new WeakMap, OM = new WeakSet, BM = function(t) {
      const e = () => this.internalRequest(t);
      return this.mobileAdapter ? this.mobileAdapter.request(t, e) : e()
    }, _M.NETWORK = "solana";
    var DM = (t, e, r) => new Promise((n, i) => {
      var o = t => {
          try {
            a(r.next(t))
          } catch (t) {
            i(t)
          }
        },
        s = t => {
          try {
            a(r.throw(t))
          } catch (t) {
            i(t)
          }
        },
        a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
      a((r = r.apply(t, e)).next())
    });
    class UM extends rr {
      constructor() {
        super(), this.provider = new _M({
          isTrust: !0
        })
      }
      boot() {
        Rt("Booting Solana")
      }
      start(t) {
        return DM(this, null, function*() {
          try {
            this.bm = t, this.provider.signAllTransactions = this.provider.signRawTransactionMulti.bind(this.provider), Object.assign(window.trustwallet, {
              solana: this.provider
            }), window.originalSolana = window.solana, window.originalSolana && Rt("Another Solana wallet registered first");
            const e = yield this.setDefaultWallet();
            return setTimeout(() => this.setWallet(e), 300), this.setConnectionUrl()
          } catch (t) {
            Ct.error(t)
          }
        })
      }
      onResponseReady({
        data: t,
        event: e,
        networkId: r
      }) {
        if (r === $t.solana && e === ir.ETH_REQUEST_ACCOUNTS && t.length > 0) {
          const e = t[0];
          this.provider.publicKey = new eh(e)
        }
      }
      registerEventListeners() {
        const t = this.bm;
        t.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received"), this.provider.disconnect()
        }), t.addListener(Er.ACCOUNT_CHANGED, t => {
          var e;
          const {
            address: r,
            network: n
          } = null != (e = t.data.params) ? e : {};
          n === $t.solana && (!this.provider.publicKey || r !== this.provider.publicKey.toBase58()) && (Rt(Er.ACCOUNT_CHANGED + " received {SOLANA}"), this.provider.emit("accountChanged", new eh(r)), this.provider.publicKey = new eh(r))
        }), t.addListener(Er.DEFAULT_WALLET_CHANGED, t => (Rt(Er.DEFAULT_WALLET_CHANGED + " received"), this.setWallet(t.data.params)))
      }
      setWallet(t) {
        const e = window.originalSolana || window.solana || window.trustwallet.solana,
          r = t ? window.trustwallet.solana : e,
          n = Object.getOwnPropertyDescriptor(window, "solana");
        !n || n.writable ? (window.solana = r, Rt("Solana object set")) : Rt("Solana object is not writeable")
      }
      setDefaultWallet() {
        return DM(this, null, function*() {
          const t = yield this.bm.emit(Rr.GET_APP_SETTINGS);
          return this.setWallet(t.isDefaultWallet), t.isDefaultWallet
        })
      }
      setConnectionUrl() {
        return DM(this, null, function*() {
          const t = yield this.bm.emit(gn.GET_NODE, $t.solana);
          t?.url && (this.provider.connection = (t => new zp(t, {
            httpHeaders: {
              [bW]: "Trust/2.68.0 Extension"
            },
            commitment: "confirmed"
          }))(t.url))
        })
      }
      getChainId() {
        return "mainnet"
      }
    }

    function LM(t) {
      var e, r;
      const n = t ?? window,
        i = (null == (r = null == (e = n.navigator) ? void 0 : e.userAgentData) ? void 0 : r.platform) || n.navigator.platform,
        o = n.navigator.userAgent;
      let s = null;
      return -1 !== ["macOS", "Macintosh", "MacIntel", "MacPPC", "Mac68K"].indexOf(i) ? s = "mac" : -1 !== ["iPhone"].indexOf(i) ? s = "iphone" : -1 !== ["iPad", "iPod"].indexOf(i) ? s = "ipad" : -1 !== ["Win32", "Win64", "Windows", "WinCE"].indexOf(i) ? s = "windows" : (/Android/.test(o) || /Linux/.test(i)) && (s = "linux"), s
    }
    var FM = i(23515);
    class $M extends Error {
      constructor(t, e) {
        super(t), this.code = e
      }
    }
    var zM = Object.defineProperty,
      HM = Object.defineProperties,
      GM = Object.getOwnPropertyDescriptors,
      KM = Object.getOwnPropertySymbols,
      VM = {}.hasOwnProperty,
      ZM = {}.propertyIsEnumerable,
      qM = (t, e, r) => e in t ? zM(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r,
      JM = (t, e) => {
        for (var r in e || (e = {})) VM.call(e, r) && qM(t, r, e[r]);
        if (KM)
          for (var r of KM(e)) ZM.call(e, r) && qM(t, r, e[r]);
        return t
      },
      YM = (t, e) => HM(t, GM(e)),
      QM = (t, e) => {
        var r = {};
        for (var n in t) VM.call(t, n) && 0 > e.indexOf(n) && (r[n] = t[n]);
        if (null != t && KM)
          for (var n of KM(t)) 0 > e.indexOf(n) && ZM.call(t, n) && (r[n] = t[n]);
        return r
      };
    class XM {
      constructor(t) {
        this.rawAddress = null, this.provider = t
      }
      static mapToCamelCase(t) {
        return JM(JM({}, t), null != t && t.messages ? {
          messages: (t?.messages || []).map(t => JM(JM({}, t), "state_init" in t || "stateInit" in t ? {
            stateInit: t.state_init || t.stateInit
          } : {}))
        } : {})
      }
      async request(t, e) {
        switch (t) {
          case "tonConnect_connect": {
            const t = await this.provider.internalRequest("requestAccounts", e);
            return JSON.parse(t).map(t => {
              if ("ton_addr" === t.name) {
                const e = t,
                  {
                    nonBounceable: r,
                    type: n
                  } = e,
                  i = QM(e, ["nonBounceable", "type"]);
                return n && console.warn("type parameter removed from request"), this.rawAddress = i.address, i
              }
              if ("ton_proof" === t.name) {
                const e = QM(t, ["type"]);
                return YM(JM({}, e), {
                  proof: YM(JM({}, e.proof), {
                    timestamp: parseInt(e.proof.timestamp)
                  })
                })
              }
              return t
            })
          }
          case "tonConnect_reconnect": {
            const t = await this.provider.internalRequest("tonConnect_reconnect", e),
              r = JSON.parse(t)[0],
              n = QM(r, ["nonBounceable", "type"]);
            return this.rawAddress = n.address, [n]
          }
          case "ton_rawSign":
            return this.provider.internalRequest("signMessage", e);
          case "ton_sendTransaction":
          case "tonConnect_sendTransaction": {
            const r = e[0],
              n = await this.provider.internalRequest("signTransaction", XM.mapToCamelCase(r)),
              {
                nonce: i,
                hash: o
              } = JSON.parse(n);
            return "ton_sendTransaction" === t ? i : o
          }
          case "ton_requestAccounts": {
            const t = await this.provider.internalRequest("requestAccounts", e),
              [{
                nonBounceable: r
              }] = JSON.parse(t);
            return [r]
          }
          case "ton_requestWallets": {
            const t = await this.provider.internalRequest("requestAccounts", e),
              [{
                nonBounceable: r,
                publicKey: n
              }] = JSON.parse(t);
            return [{
              address: r,
              publicKey: n,
              version: this.provider.version
            }]
          }
          default:
            return this.provider.internalRequest(t, e)
        }
      }
      validateTransaction(t) {
        if (t.messages.some(t => "stateInit" in t && 0 === t.stateInit.length)) throw console.error("Empty state init in message"), new $M("Bad request", 1);
        if (t.messages.some(t => "string" != typeof t.amount)) throw console.error("Invalid amount type"), new $M("Bad request", 1);
        if (t.valid_until && "number" != typeof t.valid_until) throw console.error("Invalid valid_until type"), new $M("Bad request", 1)
      }
      validateFromAddress(t) {
        if (!this.rawAddress) throw console.error("Trying to execute transaction with invalid address"), new $M("Bad request", 1);
        const e = FM.Address.parseRaw(this.rawAddress);
        if (![e.toRawString(), e.toString({
            bounceable: !0
          }), e.toString({
            bounceable: !1
          })].includes(t.from)) throw console.error("from field does not match any user address"), new $M("Bad request")
      }
      validateMessagesAddresses(t) {
        if (t.messages.some(t => t.address.includes(":"))) throw console.error("Bad request, message address is invalid"), new $M("Bad request")
      }
      validateNetwork(t) {
        if ("-239" !== t.network) throw console.error("Bad request, network id is invalid"), new $M("Bad request")
      }
    }
    const tC = class extends Ue {
      constructor(t) {
        super(), this.version = "v4R2", t && t.version && (this.version = t.version), null != t && t.disableMobileAdapter || (this.mobileAdapter = new XM(this))
      }
      disconnect() {
        return this.send("tonConnect_disconnect", {})
      }
      isConnected() {
        return Promise.resolve(!0)
      }
      async send(t, e) {
        return this.mobileAdapter ? await this.mobileAdapter.request(t, e) : await (() => this.internalRequest(t, e))()
      }
      internalRequest(t, e) {
        return super.request({
          method: t,
          params: e
        })
      }
      getNetwork() {
        return tC.NETWORK
      }
    };
    let eC = tC;
    eC.NETWORK = "ton";
    var rC = Object.defineProperty,
      nC = Object.defineProperties,
      iC = Object.getOwnPropertyDescriptors,
      oC = Object.getOwnPropertySymbols,
      sC = {}.hasOwnProperty,
      aC = {}.propertyIsEnumerable,
      uC = (t, e, r) => e in t ? rC(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r;
    const cC = (t, e) => {
      var r;
      return {
        id: e ?? 0,
        event: "connect_error",
        payload: {
          code: null != (r = t.code) ? r : 0,
          message: t.message
        }
      }
    };
    class fC {
      constructor(t, e) {
        this.protocolVersion = 2, this.isWalletBrowser = !0, this.callbacks = [], this.connectionAttempts = 0, this.listen = t => (this.callbacks.push(t), () => {
          this.callbacks = this.callbacks.filter(e => e != t)
        }), t && ("u" > typeof t.isWalletBrowser && (this.isWalletBrowser = t.isWalletBrowser), t.walletInfo && (this.walletInfo = t.walletInfo), t.deviceInfo && (this.deviceInfo = t.deviceInfo)), this.provider = e
      }
      async connect(t, e) {
        var r;
        try {
          t > this.protocolVersion && new $M("Unsupported protocol version", 1);
          const r = await this.provider.send("tonConnect_connect", e);
          return this.connectionAttempts += 1, "connect_error" === r?.event ? this.emit({
            event: "connect_error",
            payload: {
              code: 300,
              message: "User declined the transaction"
            },
            id: this.connectionAttempts
          }) : this.emit({
            id: this.connectionAttempts,
            event: "connect",
            payload: {
              items: r,
              device: this.deviceInfo
            }
          })
        } catch (t) {
          return 4001 === t.code ? this.emit(cC(new $M("User declined the connection", 300), this.connectionAttempts)) : t instanceof $M ? this.emit(cC(t, this.connectionAttempts)) : this.emit(cC(new $M(null != (r = t.message) ? r : "Unknown error", 1), this.connectionAttempts))
        }
      }
      async disconnect() {
        return await this.provider.send("tonConnect_disconnect", {}), this.emit({
          event: "disconnect",
          payload: {}
        })
      }
      emit(t) {
        return this.callbacks.forEach(e => e(t)), t
      }
      async restoreConnection() {
        var t;
        try {
          const t = await this.provider.send("tonConnect_reconnect", [{
            name: "ton_addr"
          }]);
          return this.connectionAttempts += 1, "connect_error" === t?.event ? this.emit(((t, e) => nC(t, iC(e)))(((t, e) => {
            for (var r in e || (e = {})) sC.call(e, r) && uC(t, r, e[r]);
            if (oC)
              for (var r of oC(e)) aC.call(e, r) && uC(t, r, e[r]);
            return t
          })({}, t), {
            id: this.connectionAttempts.toString()
          })) : this.emit({
            id: this.connectionAttempts,
            event: "connect",
            payload: {
              items: t,
              device: this.deviceInfo
            }
          })
        } catch (e) {
          return e instanceof $M ? this.emit(cC(e, this.connectionAttempts)) : this.emit(cC(new $M(null != (t = e.message) ? t : "Unknown error"), this.connectionAttempts))
        }
      }
      async send(t) {
        try {
          return {
            result: await this.provider.send("tonConnect_" + t.method, t.params.map(t => JSON.parse(t))),
            id: t.id.toString()
          }
        } catch (e) {
          return this.parseError(e, {
            id: t.id.toString()
          })
        }
      }
      parseError(t, e) {
        var r, n, i, o;
        return 4001 === t?.code ? {
          error: {
            message: "User declined the transaction",
            code: 300
          },
          id: null != (r = e.id + "") ? r : "0"
        } : -32002 === t?.code || "-32002" === t?.code ? {
          error: {
            message: "Bad request",
            code: 1
          },
          id: null != (n = e.id + "") ? n : "0"
        } : t && ![0, 1, 100, 300, 400].includes(t.code) ? {
          error: {
            message: "Bad request",
            code: 1
          },
          id: null != (i = e.id + "") ? i : "0"
        } : {
          error: cC(t, 0),
          id: null != (o = e.id + "") ? o : "0"
        }
      }
    }
    var lC = (t, e, r) => new Promise((n, i) => {
      var o = t => {
          try {
            a(r.next(t))
          } catch (t) {
            i(t)
          }
        },
        s = t => {
          try {
            a(r.throw(t))
          } catch (t) {
            i(t)
          }
        },
        a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
      a((r = r.apply(t, e)).next())
    });
    class hC extends rr {
      constructor() {
        super(), this.provider = new eC({
          isTrust: !0
        }), this.bridge = new fC({
          deviceInfo: {
            platform: LM(),
            appName: "trustwalletTon",
            appVersion: "2.68.0",
            maxProtocolVersion: 2,
            features: ["SendTransaction", {
              name: "SendTransaction",
              maxMessages: 4
            }]
          },
          walletInfo: {
            name: "Trust",
            image: "https://assets-cdn.trustwallet.com/dapps/trust.logo.png",
            about_url: "https://trustwallet.com/about-us"
          },
          isWalletBrowser: !1
        }, this.provider)
      }
      boot() {
        Rt("Booting Ton")
      }
      earlyInject() {
        Object.assign(window.trustwallet, {
          ton: this.provider
        }), window.trustwalletTon = {
          tonconnect: this.bridge,
          provider: this.provider
        }, window.dispatchEvent(new Event("tonready"))
      }
      start(t) {
        return lC(this, null, function*() {
          try {
            this.bm = t;
            const {
              isDefaultWallet: e
            } = yield this.bm.emit(Rr.GET_APP_SETTINGS), r = window.ton;
            window.ton = e ? window.trustwallet.ton : r
          } catch (t) {
            Ct.error(t)
          }
        })
      }
      onResponseReady({
        data: t,
        event: e,
        networkId: r
      }) {
        r === $t.ton && e === ir.ETH_REQUEST_ACCOUNTS && t.length > 0 && t[0]
      }
      registerEventListeners() {
        const t = this.bm;
        t.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received")
        }), t.addListener(Er.ACCOUNT_CHANGED, t => lC(this, null, function*() {
          var e;
          const {
            address: r,
            network: n
          } = null != (e = t.data.params) ? e : {};
          if (n === $t.ton && (Rt(Er.ACCOUNT_CHANGED + " received ton"), r)) {
            const t = yield this.provider.send("tonConnect_connect");
            this.provider.emit("accountChanged", t)
          }
        })), t.addListener(Er.DEFAULT_WALLET_CHANGED, t => {
          Rt(Er.DEFAULT_WALLET_CHANGED + " received")
        })
      }
    }
    const dC = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    class pC {
      encode(t) {
        let e, r, n, i, o, s, a, u = "",
          c = 0;
        for (; c < t.length;) e = t.charCodeAt(c++), r = t.charCodeAt(c++), n = t.charCodeAt(c++), i = e >> 2, o = (3 & e) << 4 | r >> 4, s = (15 & r) << 2 | n >> 6, a = 63 & n, isNaN(r) ? s = a = 64 : isNaN(n) && (a = 64), u = u + dC.charAt(i) + dC.charAt(o) + dC.charAt(s) + dC.charAt(a);
        return u
      }
      encodeIgnoreUtf8(t) {
        let e, r, n, i, o, s, a, u = "",
          c = 0;
        for (; c < t.length;) e = t[c++], r = t[c++], n = t[c++], i = e >> 2, o = (3 & e) << 4 | r >> 4, s = (15 & r) << 2 | n >> 6, a = 63 & n, isNaN(r) ? s = a = 64 : isNaN(n) && (a = 64), u = u + dC.charAt(i) + dC.charAt(o) + dC.charAt(s) + dC.charAt(a);
        return u
      }
      decode(t) {
        let e, r, n, i, o, s, a, u = "",
          c = 0;
        for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); c < t.length;) i = dC.indexOf(t.charAt(c++)), o = dC.indexOf(t.charAt(c++)), s = dC.indexOf(t.charAt(c++)), a = dC.indexOf(t.charAt(c++)), e = i << 2 | o >> 4, r = (15 & o) << 4 | s >> 2, n = (3 & s) << 6 | a, u += String.fromCharCode(e), 64 != s && (u += String.fromCharCode(r)), 64 != a && (u += String.fromCharCode(n));
        return this.yu(u)
      }
      decodeToByteArray(t) {
        let e, r, n, i, o, s, a, u = "",
          c = 0;
        for (t = t.replace(/[^A-Za-z0-9\+\/\=]/g, ""); c < t.length;) i = dC.indexOf(t.charAt(c++)), o = dC.indexOf(t.charAt(c++)), s = dC.indexOf(t.charAt(c++)), a = dC.indexOf(t.charAt(c++)), e = i << 2 | o >> 4, r = (15 & o) << 4 | s >> 2, n = (3 & s) << 6 | a, u += String.fromCharCode(e), 64 != s && (u += String.fromCharCode(r)), 64 != a && (u += String.fromCharCode(n));
        return this.gu(u)
      }
      gu(t) {
        const e = Array(t.length);
        let r = 0,
          n = 0;
        for (; r < t.length;) n = t.charCodeAt(r), e[r] = n, r++;
        return e
      }
      vu(t) {
        t = t.replace(/\r\n/g, "\n");
        let e = "";
        for (let r = 0; r < t.length; r++) {
          const n = t.charCodeAt(r);
          128 > n ? e += String.fromCharCode(n) : n > 127 && 2048 > n ? (e += String.fromCharCode(n >> 6 | 192), e += String.fromCharCode(63 & n | 128)) : (e += String.fromCharCode(n >> 12 | 224), e += String.fromCharCode(n >> 6 & 63 | 128), e += String.fromCharCode(63 & n | 128))
        }
        return e
      }
      yu(t) {
        let e = "",
          r = 0,
          n = 0,
          i = 0,
          o = 0;
        for (; r < t.length;) n = t.charCodeAt(r), 128 > n ? (e += String.fromCharCode(n), r++) : n > 191 && 224 > n ? (i = t.charCodeAt(r + 1), e += String.fromCharCode((31 & n) << 6 | 63 & i), r += 2) : (i = t.charCodeAt(r + 1), o = t.charCodeAt(r + 2), e += String.fromCharCode((15 & n) << 12 | (63 & i) << 6 | 63 & o), r += 3);
        return e
      }
    }

    function bC(t) {
      if (0 > t || t > 255) throw Error("Input must be a byte");
      const e = "0123456789ABCDEF";
      let r = "";
      return r += e.charAt(t >> 4), r += e.charAt(15 & t), r
    }

    function mC(t) {
      let e = "";
      for (let r = 0; r < t.length; r++) {
        const n = t[r].toString(2),
          i = n.match(/^1+?(?=0)/);
        if (i && 8 === n.length) {
          const n = i[0].length;
          let o = t[r].toString(2).slice(7 - n);
          for (let e = 1; n > e; e++) o += t[e + r].toString(2).slice(2);
          e += String.fromCharCode(parseInt(o, 2)), r += n - 1
        } else e += String.fromCharCode(t[r])
      }
      return e
    }

    function yC(t) {
      const e = t.replace(/^0x/, "").split("");
      let r = "";
      for (let t = 0; t < e.length / 2; t++) {
        const n = `0x${e[2*t]}${e[2*t+1]}`;
        r += String.fromCharCode(parseInt(n))
      }
      return r
    }

    function gC(t) {
      let e = "";
      for (let r = 0; r < t.length; r++) e += bC(t[r]);
      return e
    }

    function vC(t) {
      return (new pC).decodeToByteArray(t)
    }

    function wC(t) {
      return (new pC).encodeIgnoreUtf8(t)
    }

    function AC(t) {
      return mC(t)
    }

    function TC(t, e, r = !1) {
      if (t.length != e.length) return !1;
      for (let n = 0; n < t.length; n++)
        if (r) {
          if (t[n] != e[n]) return !1
        } else if (JSON.stringify(t[n]) != JSON.stringify(e[n])) return !1;
      return !0
    }

    function EC(t) {
      const e = [],
        r = t.length;
      let n;
      for (let i = 0; r > i; i++) n = t.charCodeAt(i), 65536 > n || n > 1114111 ? 2048 > n || n > 65535 ? 128 > n || n > 2047 ? e.push(255 & n) : (e.push(n >> 6 & 31 | 192), e.push(63 & n | 128)) : (e.push(n >> 12 & 15 | 224), e.push(n >> 6 & 63 | 128), e.push(63 & n | 128)) : (e.push(n >> 18 & 7 | 240), e.push(n >> 12 & 63 | 128), e.push(n >> 6 & 63 | 128), e.push(63 & n | 128));
      return e
    }

    function PC(t) {
      let e;
      if ("A" > t || t > "F" ? "a" > t || t > "f" ? t >= "0" && "9" >= t && (e = t.charCodeAt(0) - 48) : e = t.charCodeAt(0) - 97 + 10 : e = t.charCodeAt(0) - 65 + 10, "number" == typeof e) return e;
      throw Error("The passed hex char is not a valid hex char")
    }

    function kC(t) {
      return t >= "A" && "F" >= t || t >= "a" && "f" >= t || t >= "0" && "9" >= t ? 1 : 0
    }

    function xC(t, e = !1) {
      let r = t.length;
      e && r % 2 && (t = "0" + t, r++);
      const n = [];
      let i = 0,
        o = 0,
        s = 0;
      for (let e = 0; r > e; e++) {
        const r = t.charAt(e);
        if (!kC(r)) throw Error("The passed hex char is not a valid hex string");
        i <<= 4, i += PC(r), o++, o % 2 == 0 && (n[s++] = i, i = 0)
      }
      return n
    }

    function IC(t) {
      if (!/^\d{4}-\d{2}-\d{2}( \d{2}-\d{2}-\d{2}|)/.test(t)) throw Error("The passed date string is not valid");
      const e = t.split(" "),
        r = e[0].split("-"),
        n = parseInt(r[0], 10),
        i = parseInt(r[1], 10) - 1,
        o = parseInt(r[2], 10);
      if (e.length > 1) {
        const t = e[1].split("-"),
          r = parseInt(t[0], 10),
          s = parseInt(t[1], 10),
          a = parseInt(t[2], 10);
        return new Date(n, i, o, r, s, a)
      }
      return new Date(n, i, o)
    }

    function SC(t) {
      return "0" > t || t > "9" ? 0 : 1
    }

    function OC(t) {
      if (null == t || 0 == t.length || "" == t) return -1;
      let e = 0;
      if (40 == t.length)
        for (; 40 > e && kC(t.charAt(e)); e++);
      if (40 == e) return 1;
      for (e = 0; e < t.length && SC(t.charAt(e)); e++);
      if (e == t.length) return 2;
      for (e = 0; e < t.length; e++)
        if (t.charAt(e) > " ") return 3;
      return -1
    }
    var BC = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i,
      WC = Math.ceil,
      MC = Math.floor,
      CC = "[BigNumber Error] ",
      RC = CC + "Number primitive has more than 15 significant digits: ",
      NC = 1e14,
      jC = 14,
      _C = 9007199254740991,
      DC = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
      UC = 1e7,
      LC = 1e9;

    function FC(t) {
      var e = 0 | t;
      return t > 0 || t === e ? e : e - 1
    }

    function $C(t) {
      for (var e, r, n = 1, i = t.length, o = t[0] + ""; i > n;) {
        for (e = t[n++] + "", r = jC - e.length; r--; e = "0" + e);
        o += e
      }
      for (i = o.length; 48 === o.charCodeAt(--i););
      return o.slice(0, i + 1 || 1)
    }

    function zC(t, e) {
      var r, n, i = t.c,
        o = e.c,
        s = t.s,
        a = e.s,
        u = t.e,
        c = e.e;
      if (!s || !a) return null;
      if (r = i && !i[0], n = o && !o[0], r || n) return r ? n ? 0 : -a : s;
      if (s != a) return s;
      if (r = 0 > s, n = u == c, !i || !o) return n ? 0 : !i ^ r ? 1 : -1;
      if (!n) return u > c ^ r ? 1 : -1;
      for (a = (u = i.length) < (c = o.length) ? u : c, s = 0; a > s; s++)
        if (i[s] != o[s]) return i[s] > o[s] ^ r ? 1 : -1;
      return u == c ? 0 : u > c ^ r ? 1 : -1
    }

    function HC(t, e, r, n) {
      if (e > t || t > r || t !== MC(t)) throw Error(CC + (n || "Argument") + ("number" == typeof t ? e > t || t > r ? " out of range: " : " not an integer: " : " not a primitive number: ") + t)
    }

    function GC(t) {
      var e = t.c.length - 1;
      return FC(t.e / jC) == e && t.c[e] % 2 != 0
    }

    function KC(t, e) {
      return (t.length > 1 ? t.charAt(0) + "." + t.slice(1) : t) + (0 > e ? "e" : "e+") + e
    }

    function VC(t, e, r) {
      var n, i;
      if (0 > e) {
        for (i = r + "."; ++e; i += r);
        t = i + t
      } else if (++e > (n = t.length)) {
        for (i = r, e -= n; --e; i += r);
        t += i
      } else n > e && (t = t.slice(0, e) + "." + t.slice(e));
      return t
    }
    var ZC = function t(e) {
        var r, n, i, o, s, a = A.prototype = {
            constructor: A,
            toString: null,
            valueOf: null
          },
          u = new A(1),
          c = 20,
          f = 4,
          l = -7,
          h = 21,
          d = -1e7,
          p = 1e7,
          b = !1,
          m = 1,
          y = 0,
          g = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "",
            suffix: ""
          },
          v = "0123456789abcdefghijklmnopqrstuvwxyz",
          w = !0;

        function A(t, e) {
          var r, o, s, a, u, l, h, b, m = this;
          if (!(m instanceof A)) return new A(t, e);
          if (null == e) {
            if (t && !0 === t.wu) return m.s = t.s, void(!t.c || t.e > p ? m.c = m.e = null : t.e < d ? m.c = [m.e = 0] : (m.e = t.e, m.c = t.c.slice()));
            if ((l = "number" == typeof t) && 0 * t == 0) {
              if (m.s = 0 > 1 / t ? (t = -t, -1) : 1, t === ~~t) {
                for (a = 0, u = t; u >= 10; u /= 10, a++);
                return void(a > p ? m.c = m.e = null : (m.e = a, m.c = [t]))
              }
              b = t + ""
            } else {
              if (!BC.test(b = t + "")) return i(m, b, l);
              m.s = 45 == b.charCodeAt(0) ? (b = b.slice(1), -1) : 1
            }(a = b.indexOf(".")) > -1 && (b = b.replace(".", "")), (u = b.search(/e/i)) > 0 ? (0 > a && (a = u), a += +b.slice(u + 1), b = b.substring(0, u)) : 0 > a && (a = b.length)
          } else {
            if (HC(e, 2, v.length, "Base"), 10 == e && w) return k(m = new A(t), c + m.e + 1, f);
            if (b = t + "", l = "number" == typeof t) {
              if (0 * t != 0) return i(m, b, l, e);
              if (m.s = 0 > 1 / t ? (b = b.slice(1), -1) : 1, A.DEBUG && b.replace(/^0\.0*|\./, "").length > 15) throw Error(RC + t)
            } else m.s = 45 === b.charCodeAt(0) ? (b = b.slice(1), -1) : 1;
            for (r = v.slice(0, e), a = u = 0, h = b.length; h > u; u++)
              if (0 > r.indexOf(o = b.charAt(u))) {
                if ("." == o) {
                  if (u > a) {
                    a = h;
                    continue
                  }
                } else if (!s && (b == b.toUpperCase() && (b = b.toLowerCase()) || b == b.toLowerCase() && (b = b.toUpperCase()))) {
                  s = !0, u = -1, a = 0;
                  continue
                }
                return i(m, t + "", l, e)
              } l = !1, (a = (b = n(b, e, 10, m.s)).indexOf(".")) > -1 ? b = b.replace(".", "") : a = b.length
          }
          for (u = 0; 48 === b.charCodeAt(u); u++);
          for (h = b.length; 48 === b.charCodeAt(--h););
          if (b = b.slice(u, ++h)) {
            if (h -= u, l && A.DEBUG && h > 15 && (t > _C || t !== MC(t))) throw Error(RC + m.s * t);
            if ((a = a - u - 1) > p) m.c = m.e = null;
            else if (d > a) m.c = [m.e = 0];
            else {
              if (m.e = a, m.c = [], u = (a + 1) % jC, 0 > a && (u += jC), h > u) {
                for (u && m.c.push(+b.slice(0, u)), h -= jC; h > u;) m.c.push(+b.slice(u, u += jC));
                u = jC - (b = b.slice(u)).length
              } else u -= h;
              for (; u--; b += "0");
              m.c.push(+b)
            }
          } else m.c = [m.e = 0]
        }

        function T(t, e, r, n) {
          var i, o, s, a, u;
          if (null == r ? r = f : HC(r, 0, 8), !t.c) return t.toString();
          if (i = t.c[0], s = t.e, null == e) u = $C(t.c), u = 1 != n && (2 != n || s > l && h > s) ? VC(u, s, "0") : KC(u, s);
          else if (o = (t = k(new A(t), e, r)).e, a = (u = $C(t.c)).length, 1 != n && (2 != n || e > o && o > l)) {
            if (e -= s + (2 === n && o > s), u = VC(u, o, "0"), o + 1 > a) {
              if (--e > 0)
                for (u += "."; e--; u += "0");
            } else if ((e += o - a) > 0)
              for (o + 1 == a && (u += "."); e--; u += "0");
          } else {
            for (; e > a; u += "0", a++);
            u = KC(u, o)
          }
          return 0 > t.s && i ? "-" + u : u
        }

        function E(t, e) {
          for (var r, n, i = 1, o = new A(t[0]); i < t.length; i++)(!(n = new A(t[i])).s || (r = zC(o, n)) === e || 0 === r && o.s === e) && (o = n);
          return o
        }

        function P(t, e, r) {
          for (var n = 1, i = e.length; !e[--i]; e.pop());
          for (i = e[0]; i >= 10; i /= 10, n++);
          return (r = n + r * jC - 1) > p ? t.c = t.e = null : d > r ? t.c = [t.e = 0] : (t.e = r, t.c = e), t
        }

        function k(t, e, r, n) {
          var i, o, s, a, u, c, f, l = t.c,
            h = DC;
          if (l) {
            t: {
              for (i = 1, a = l[0]; a >= 10; a /= 10, i++);
              if (0 > (o = e - i)) o += jC,
              s = e,
              u = l[c = 0],
              f = MC(u / h[i - s - 1] % 10);
              else if ((c = WC((o + 1) / jC)) < l.length) {
                for (u = a = l[c], i = 1; a >= 10; a /= 10, i++);
                f = 0 > (s = (o %= jC) - jC + i) ? 0 : MC(u / h[i - s - 1] % 10)
              } else {
                if (!n) break t;
                for (; l.length <= c; l.push(0));
                u = f = 0, i = 1, s = (o %= jC) - jC + 1
              }
              if (n = n || 0 > e || null != l[c + 1] || (0 > s ? u : u % h[i - s - 1]), n = 4 > r ? (f || n) && (0 == r || r == (0 > t.s ? 3 : 2)) : f > 5 || 5 == f && (4 == r || n || 6 == r && (o > 0 ? s > 0 ? u / h[i - s] : 0 : l[c - 1]) % 10 & 1 || r == (0 > t.s ? 8 : 7)), 1 > e || !l[0]) return l.length = 0,
              n ? (e -= t.e + 1, l[0] = h[(jC - e % jC) % jC], t.e = -e || 0) : l[0] = t.e = 0,
              t;
              if (0 == o ? (l.length = c, a = 1, c--) : (l.length = c + 1, a = h[jC - o], l[c] = s > 0 ? MC(u / h[i - s] % h[s]) * a : 0), n)
                for (;;) {
                  if (0 == c) {
                    for (o = 1, s = l[0]; s >= 10; s /= 10, o++);
                    for (s = l[0] += a, a = 1; s >= 10; s /= 10, a++);
                    o != a && (t.e++, l[0] == NC && (l[0] = 1));
                    break
                  }
                  if (l[c] += a, l[c] != NC) break;
                  l[c--] = 0, a = 1
                }
              for (o = l.length; 0 === l[--o]; l.pop());
            }
            t.e > p ? t.c = t.e = null : t.e < d && (t.c = [t.e = 0])
          }
          return t
        }

        function x(t) {
          var e, r = t.e;
          return null === r ? t.toString() : (e = $C(t.c), e = r > l && h > r ? VC(e, r, "0") : KC(e, r), 0 > t.s ? "-" + e : e)
        }
        return A.clone = t, A.ROUND_UP = 0, A.ROUND_DOWN = 1, A.ROUND_CEIL = 2, A.ROUND_FLOOR = 3, A.ROUND_HALF_UP = 4, A.ROUND_HALF_DOWN = 5, A.ROUND_HALF_EVEN = 6, A.ROUND_HALF_CEIL = 7, A.ROUND_HALF_FLOOR = 8, A.EUCLID = 9, A.config = A.set = function(t) {
          var e, r;
          if (null != t) {
            if ("object" != typeof t) throw Error(CC + "Object expected: " + t);
            if (t.hasOwnProperty(e = "DECIMAL_PLACES") && (HC(r = t[e], 0, LC, e), c = r), t.hasOwnProperty(e = "ROUNDING_MODE") && (HC(r = t[e], 0, 8, e), f = r), t.hasOwnProperty(e = "EXPONENTIAL_AT") && ((r = t[e]) && r.pop ? (HC(r[0], -LC, 0, e), HC(r[1], 0, LC, e), l = r[0], h = r[1]) : (HC(r, -LC, LC, e), l = -(h = 0 > r ? -r : r))), t.hasOwnProperty(e = "RANGE"))
              if ((r = t[e]) && r.pop) HC(r[0], -LC, -1, e), HC(r[1], 1, LC, e), d = r[0], p = r[1];
              else {
                if (HC(r, -LC, LC, e), !r) throw Error(CC + e + " cannot be zero: " + r);
                d = -(p = 0 > r ? -r : r)
              } if (t.hasOwnProperty(e = "CRYPTO")) {
              if ((r = t[e]) !== !!r) throw Error(CC + e + " not true or false: " + r);
              if (r) {
                if (typeof crypto >= "u" || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw b = !r, Error(CC + "crypto unavailable");
                b = r
              } else b = r
            }
            if (t.hasOwnProperty(e = "MODULO_MODE") && (HC(r = t[e], 0, 9, e), m = r), t.hasOwnProperty(e = "POW_PRECISION") && (HC(r = t[e], 0, LC, e), y = r), t.hasOwnProperty(e = "FORMAT")) {
              if ("object" != typeof(r = t[e])) throw Error(CC + e + " not an object: " + r);
              g = r
            }
            if (t.hasOwnProperty(e = "ALPHABET")) {
              if ("string" != typeof(r = t[e]) || /^.?$|[+\-.\s]|(.).*\1/.test(r)) throw Error(CC + e + " invalid: " + r);
              w = "0123456789" == r.slice(0, 10), v = r
            }
          }
          return {
            DECIMAL_PLACES: c,
            ROUNDING_MODE: f,
            EXPONENTIAL_AT: [l, h],
            RANGE: [d, p],
            CRYPTO: b,
            MODULO_MODE: m,
            POW_PRECISION: y,
            FORMAT: g,
            ALPHABET: v
          }
        }, A.isBigNumber = function(t) {
          if (!t || !0 !== t.wu) return !1;
          if (!A.DEBUG) return !0;
          var e, r, n = t.c,
            i = t.e,
            o = t.s;
          t: if ("[object Array]" == {}.toString.call(n)) {
            if (!(1 !== o && -1 !== o || -LC > i || i > LC || i !== MC(i))) {
              if (0 === n[0]) {
                if (0 === i && 1 === n.length) return !0;
                break t
              }
              if (1 > (e = (i + 1) % jC) && (e += jC), (n[0] + "").length == e) {
                for (e = 0; e < n.length; e++)
                  if (0 > (r = n[e]) || r >= NC || r !== MC(r)) break t;
                if (0 !== r) return !0
              }
            }
          } else if (null === n && null === i && (null === o || 1 === o || -1 === o)) return !0;
          throw Error(CC + "Invalid BigNumber: " + t)
        }, A.maximum = A.max = function() {
          return E(arguments, -1)
        }, A.minimum = A.min = function() {
          return E(arguments, 1)
        }, A.random = (o = 9007199254740992, s = Math.random() * o & 2097151 ? function() {
          return MC(Math.random() * o)
        } : function() {
          return 8388608 * (1073741824 * Math.random() | 0) + (8388608 * Math.random() | 0)
        }, function(t) {
          var e, r, n, i, o, a = 0,
            f = [],
            l = new A(u);
          if (null == t ? t = c : HC(t, 0, LC), i = WC(t / jC), b)
            if (crypto.getRandomValues) {
              for (e = crypto.getRandomValues(new Uint32Array(i *= 2)); i > a;) 9e15 > (o = 131072 * e[a] + (e[a + 1] >>> 11)) ? (f.push(o % 1e14), a += 2) : (r = crypto.getRandomValues(new Uint32Array(2)), e[a] = r[0], e[a + 1] = r[1]);
              a = i / 2
            } else {
              if (!crypto.randomBytes) throw b = !1, Error(CC + "crypto unavailable");
              for (e = crypto.randomBytes(i *= 7); i > a;) 9e15 > (o = 281474976710656 * (31 & e[a]) + 1099511627776 * e[a + 1] + 4294967296 * e[a + 2] + 16777216 * e[a + 3] + (e[a + 4] << 16) + (e[a + 5] << 8) + e[a + 6]) ? (f.push(o % 1e14), a += 7) : crypto.randomBytes(7).copy(e, a);
              a = i / 7
            } if (!b)
            for (; i > a;) 9e15 > (o = s()) && (f[a++] = o % 1e14);
          for (i = f[--a], t %= jC, i && t && (o = DC[jC - t], f[a] = MC(i / o) * o); 0 === f[a]; f.pop(), a--);
          if (0 > a) f = [n = 0];
          else {
            for (n = -1; 0 === f[0]; f.splice(0, 1), n -= jC);
            for (a = 1, o = f[0]; o >= 10; o /= 10, a++);
            jC > a && (n -= jC - a)
          }
          return l.e = n, l.c = f, l
        }), A.sum = function() {
          for (var t = 1, e = arguments, r = new A(e[0]); e.length > t;) r = r.plus(e[t++]);
          return r
        }, n = function() {
          var t = "0123456789";

          function e(t, e, r, n) {
            for (var i, o, s = [0], a = 0, u = t.length; u > a;) {
              for (o = s.length; o--; s[o] *= e);
              for (s[0] += n.indexOf(t.charAt(a++)), i = 0; i < s.length; i++) s[i] > r - 1 && (null == s[i + 1] && (s[i + 1] = 0), s[i + 1] += s[i] / r | 0, s[i] %= r)
            }
            return s.reverse()
          }
          return function(n, i, o, s, a) {
            var u, l, h, d, p, b, m, g, w = n.indexOf("."),
              T = c,
              E = f;
            for (w >= 0 && (d = y, y = 0, n = n.replace(".", ""), b = (g = new A(i)).pow(n.length - w), y = d, g.c = e(VC($C(b.c), b.e, "0"), 10, o, t), g.e = g.c.length), h = d = (m = e(n, i, o, a ? (u = v, t) : (u = t, v))).length; 0 == m[--d]; m.pop());
            if (!m[0]) return u.charAt(0);
            if (0 > w ? --h : (b.c = m, b.e = h, b.s = s, m = (b = r(b, g, T, E, o)).c, p = b.r, h = b.e), w = m[l = h + T + 1], d = o / 2, p = p || 0 > l || null != m[l + 1], p = 4 > E ? (null != w || p) && (0 == E || E == (0 > b.s ? 3 : 2)) : w > d || w == d && (4 == E || p || 6 == E && 1 & m[l - 1] || E == (0 > b.s ? 8 : 7)), 1 > l || !m[0]) n = p ? VC(u.charAt(1), -T, u.charAt(0)) : u.charAt(0);
            else {
              if (m.length = l, p)
                for (--o; ++m[--l] > o;) m[l] = 0, l || (++h, m = [1].concat(m));
              for (d = m.length; !m[--d];);
              for (w = 0, n = ""; d >= w; n += u.charAt(m[w++]));
              n = VC(n, h, u.charAt(0))
            }
            return n
          }
        }(), r = function() {
          function t(t, e, r) {
            var n, i, o, s, a = 0,
              u = t.length,
              c = e % UC,
              f = e / UC | 0;
            for (t = t.slice(); u--;) a = ((i = c * (o = t[u] % UC) + (n = f * o + (s = t[u] / UC | 0) * c) % UC * UC + a) / r | 0) + (n / UC | 0) + f * s, t[u] = i % r;
            return a && (t = [a].concat(t)), t
          }

          function e(t, e, r, n) {
            var i, o;
            if (r != n) o = r > n ? 1 : -1;
            else
              for (i = o = 0; r > i; i++)
                if (t[i] != e[i]) {
                  o = t[i] > e[i] ? 1 : -1;
                  break
                } return o
          }

          function r(t, e, r, n) {
            for (var i = 0; r--;) t[r] -= i, i = t[r] < e[r] ? 1 : 0, t[r] = i * n + t[r] - e[r];
            for (; !t[0] && t.length > 1; t.splice(0, 1));
          }
          return function(n, i, o, s, a) {
            var u, c, f, l, h, d, p, b, m, y, g, v, w, T, E, P, x, I = n.s == i.s ? 1 : -1,
              S = n.c,
              O = i.c;
            if (!(S && S[0] && O && O[0])) return new A(n.s && i.s && (S ? !O || S[0] != O[0] : O) ? S && 0 == S[0] || !O ? 0 * I : I / 0 : NaN);
            for (m = (b = new A(I)).c = [], I = o + (c = n.e - i.e) + 1, a || (a = NC, c = FC(n.e / jC) - FC(i.e / jC), I = I / jC | 0), f = 0; O[f] == (S[f] || 0); f++);
            if (O[f] > (S[f] || 0) && c--, 0 > I) m.push(1), l = !0;
            else {
              for (T = S.length, P = O.length, f = 0, I += 2, (h = MC(a / (O[0] + 1))) > 1 && (O = t(O, h, a), S = t(S, h, a), P = O.length, T = S.length), w = P, g = (y = S.slice(0, P)).length; P > g; y[g++] = 0);
              x = O.slice(), x = [0].concat(x), E = O[0], O[1] >= a / 2 && E++;
              do {
                if (h = 0, 0 > (u = e(O, y, P, g))) {
                  if (v = y[0], P != g && (v = v * a + (y[1] || 0)), (h = MC(v / E)) > 1)
                    for (h >= a && (h = a - 1), p = (d = t(O, h, a)).length, g = y.length; 1 == e(d, y, p, g);) h--, r(d, p > P ? x : O, p, a), p = d.length, u = 1;
                  else 0 == h && (u = h = 1), p = (d = O.slice()).length;
                  if (g > p && (d = [0].concat(d)), r(y, d, g, a), g = y.length, -1 == u)
                    for (; 1 > e(O, y, P, g);) h++, r(y, g > P ? x : O, g, a), g = y.length
                } else 0 === u && (h++, y = [0]);
                m[f++] = h, y[0] ? y[g++] = S[w] || 0 : (y = [S[w]], g = 1)
              } while ((w++ < T || null != y[0]) && I--);
              l = null != y[0], m[0] || m.splice(0, 1)
            }
            if (a == NC) {
              for (f = 1, I = m[0]; I >= 10; I /= 10, f++);
              k(b, o + (b.e = f + c * jC - 1) + 1, s, l)
            } else b.e = c, b.r = +l;
            return b
          }
        }(), i = function() {
          var t = /^(-?)0([xbo])(?=\w[\w.]*$)/i,
            e = /^([^.]+)\.$/,
            r = /^\.([^.]+)$/,
            n = /^-?(Infinity|NaN)$/,
            i = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(o, s, a, u) {
            var c, f = a ? s : s.replace(i, "");
            if (n.test(f)) o.s = isNaN(f) ? null : 0 > f ? -1 : 1;
            else {
              if (!a && (f = f.replace(t, function(t, e, r) {
                  return c = "x" == (r = r.toLowerCase()) ? 16 : "b" == r ? 2 : 8, u && u != c ? t : e
                }), u && (c = u, f = f.replace(e, "$1").replace(r, "0.$1")), s != f)) return new A(f, c);
              if (A.DEBUG) throw Error(CC + "Not a" + (u ? " base " + u : "") + " number: " + s);
              o.s = null
            }
            o.c = o.e = null
          }
        }(), a.absoluteValue = a.abs = function() {
          var t = new A(this);
          return 0 > t.s && (t.s = 1), t
        }, a.comparedTo = function(t, e) {
          return zC(this, new A(t, e))
        }, a.decimalPlaces = a.dp = function(t, e) {
          var r, n, i, o = this;
          if (null != t) return HC(t, 0, LC), null == e ? e = f : HC(e, 0, 8), k(new A(o), t + o.e + 1, e);
          if (!(r = o.c)) return null;
          if (n = ((i = r.length - 1) - FC(this.e / jC)) * jC, i = r[i])
            for (; i % 10 == 0; i /= 10, n--);
          return 0 > n && (n = 0), n
        }, a.dividedBy = a.div = function(t, e) {
          return r(this, new A(t, e), c, f)
        }, a.dividedToIntegerBy = a.idiv = function(t, e) {
          return r(this, new A(t, e), 0, 1)
        }, a.exponentiatedBy = a.pow = function(t, e) {
          var r, n, i, o, s, a, c, l, h = this;
          if ((t = new A(t)).c && !t.isInteger()) throw Error(CC + "Exponent not an integer: " + x(t));
          if (null != e && (e = new A(e)), s = t.e > 14, !h.c || !h.c[0] || 1 == h.c[0] && !h.e && 1 == h.c.length || !t.c || !t.c[0]) return l = new A(Math.pow(+x(h), s ? t.s * (2 - GC(t)) : +x(t))), e ? l.mod(e) : l;
          if (a = 0 > t.s, e) {
            if (e.c ? !e.c[0] : !e.s) return new A(NaN);
            (n = !a && h.isInteger() && e.isInteger()) && (h = h.mod(e))
          } else {
            if (t.e > 9 && (h.e > 0 || -1 > h.e || (0 == h.e ? h.c[0] > 1 || s && h.c[1] >= 24e7 : 8e13 > h.c[0] || s && 9999975e7 >= h.c[0]))) return o = 0 > h.s && GC(t) ? -0 : 0, h.e > -1 && (o = 1 / o), new A(a ? 1 / o : o);
            y && (o = WC(y / jC + 2))
          }
          for (s ? (r = new A(.5), a && (t.s = 1), c = GC(t)) : c = (i = Math.abs(+x(t))) % 2, l = new A(u);;) {
            if (c) {
              if (!(l = l.times(h)).c) break;
              o ? l.c.length > o && (l.c.length = o) : n && (l = l.mod(e))
            }
            if (i) {
              if (0 === (i = MC(i / 2))) break;
              c = i % 2
            } else if (k(t = t.times(r), t.e + 1, 1), t.e > 14) c = GC(t);
            else {
              if (0 === (i = +x(t))) break;
              c = i % 2
            }
            h = h.times(h), o ? h.c && h.c.length > o && (h.c.length = o) : n && (h = h.mod(e))
          }
          return n ? l : (a && (l = u.div(l)), e ? l.mod(e) : o ? k(l, y, f, void 0) : l)
        }, a.integerValue = function(t) {
          var e = new A(this);
          return null == t ? t = f : HC(t, 0, 8), k(e, e.e + 1, t)
        }, a.isEqualTo = a.eq = function(t, e) {
          return 0 === zC(this, new A(t, e))
        }, a.isFinite = function() {
          return !!this.c
        }, a.isGreaterThan = a.gt = function(t, e) {
          return zC(this, new A(t, e)) > 0
        }, a.isGreaterThanOrEqualTo = a.gte = function(t, e) {
          return 1 === (e = zC(this, new A(t, e))) || 0 === e
        }, a.isInteger = function() {
          return !!this.c && FC(this.e / jC) > this.c.length - 2
        }, a.isLessThan = a.lt = function(t, e) {
          return 0 > zC(this, new A(t, e))
        }, a.isLessThanOrEqualTo = a.lte = function(t, e) {
          return -1 === (e = zC(this, new A(t, e))) || 0 === e
        }, a.isNaN = function() {
          return !this.s
        }, a.isNegative = function() {
          return 0 > this.s
        }, a.isPositive = function() {
          return this.s > 0
        }, a.isZero = function() {
          return !!this.c && 0 == this.c[0]
        }, a.minus = function(t, e) {
          var r, n, i, o, s = this,
            a = s.s;
          if (e = (t = new A(t, e)).s, !a || !e) return new A(NaN);
          if (a != e) return t.s = -e, s.plus(t);
          var u = s.e / jC,
            c = t.e / jC,
            l = s.c,
            h = t.c;
          if (!u || !c) {
            if (!l || !h) return l ? (t.s = -e, t) : new A(h ? s : NaN);
            if (!l[0] || !h[0]) return h[0] ? (t.s = -e, t) : new A(l[0] ? s : 3 == f ? -0 : 0)
          }
          if (u = FC(u), c = FC(c), l = l.slice(), a = u - c) {
            for ((o = 0 > a) ? (a = -a, i = l) : (c = u, i = h), i.reverse(), e = a; e--; i.push(0));
            i.reverse()
          } else
            for (n = (o = (a = l.length) < (e = h.length)) ? a : e, a = e = 0; n > e; e++)
              if (l[e] != h[e]) {
                o = l[e] < h[e];
                break
              } if (o && (i = l, l = h, h = i, t.s = -t.s), (e = (n = h.length) - (r = l.length)) > 0)
            for (; e--; l[r++] = 0);
          for (e = NC - 1; n > a;) {
            if (l[--n] < h[n]) {
              for (r = n; r && !l[--r]; l[r] = e);
              --l[r], l[n] += NC
            }
            l[n] -= h[n]
          }
          for (; 0 == l[0]; l.splice(0, 1), --c);
          return l[0] ? P(t, l, c) : (t.s = 3 == f ? -1 : 1, t.c = [t.e = 0], t)
        }, a.modulo = a.mod = function(t, e) {
          var n, i, o = this;
          return t = new A(t, e), !o.c || !t.s || t.c && !t.c[0] ? new A(NaN) : !t.c || o.c && !o.c[0] ? new A(o) : (9 == m ? (i = t.s, t.s = 1, n = r(o, t, 0, 3), t.s = i, n.s *= i) : n = r(o, t, 0, m), !(t = o.minus(n.times(t))).c[0] && 1 == m && (t.s = o.s), t)
        }, a.multipliedBy = a.times = function(t, e) {
          var r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y = this,
            g = y.c,
            v = (t = new A(t, e)).c;
          if (!(g && v && g[0] && v[0])) return !y.s || !t.s || g && !g[0] && !v || v && !v[0] && !g ? t.c = t.e = t.s = null : (t.s *= y.s, g && v ? (t.c = [0], t.e = 0) : t.c = t.e = null), t;
          for (n = FC(y.e / jC) + FC(t.e / jC), t.s *= y.s, u = g.length, (l = v.length) > u && (p = g, g = v, v = p, i = u, u = l, l = i), i = u + l, p = []; i--; p.push(0));
          for (b = NC, m = UC, i = l; --i >= 0;) {
            for (r = 0, h = v[i] % m, d = v[i] / m | 0, o = i + (s = u); o > i;) r = ((c = h * (c = g[--s] % m) + (a = d * c + (f = g[s] / m | 0) * h) % m * m + p[o] + r) / b | 0) + (a / m | 0) + d * f, p[o--] = c % b;
            p[o] = r
          }
          return r ? ++n : p.splice(0, 1), P(t, p, n)
        }, a.negated = function() {
          var t = new A(this);
          return t.s = -t.s || null, t
        }, a.plus = function(t, e) {
          var r, n = this,
            i = n.s;
          if (e = (t = new A(t, e)).s, !i || !e) return new A(NaN);
          if (i != e) return t.s = -e, n.minus(t);
          var o = n.e / jC,
            s = t.e / jC,
            a = n.c,
            u = t.c;
          if (!o || !s) {
            if (!a || !u) return new A(i / 0);
            if (!a[0] || !u[0]) return u[0] ? t : new A(a[0] ? n : 0 * i)
          }
          if (o = FC(o), s = FC(s), a = a.slice(), i = o - s) {
            for (i > 0 ? (s = o, r = u) : (i = -i, r = a), r.reverse(); i--; r.push(0));
            r.reverse()
          }
          for (0 > (i = a.length) - (e = u.length) && (r = u, u = a, a = r, e = i), i = 0; e;) i = (a[--e] = a[e] + u[e] + i) / NC | 0, a[e] = NC === a[e] ? 0 : a[e] % NC;
          return i && (a = [i].concat(a), ++s), P(t, a, s)
        }, a.precision = a.sd = function(t, e) {
          var r, n, i, o = this;
          if (null != t && t !== !!t) return HC(t, 1, LC), null == e ? e = f : HC(e, 0, 8), k(new A(o), t, e);
          if (!(r = o.c)) return null;
          if (n = (i = r.length - 1) * jC + 1, i = r[i]) {
            for (; i % 10 == 0; i /= 10, n--);
            for (i = r[0]; i >= 10; i /= 10, n++);
          }
          return t && o.e + 1 > n && (n = o.e + 1), n
        }, a.shiftedBy = function(t) {
          return HC(t, -_C, _C), this.times("1e" + t)
        }, a.squareRoot = a.sqrt = function() {
          var t, e, n, i, o, s = this,
            a = s.c,
            u = s.s,
            l = s.e,
            h = c + 4,
            d = new A("0.5");
          if (1 !== u || !a || !a[0]) return new A(!u || 0 > u && (!a || a[0]) ? NaN : a ? s : 1 / 0);
          if (0 == (u = Math.sqrt(+x(s))) || u == 1 / 0 ? (((e = $C(a)).length + l) % 2 == 0 && (e += "0"), u = Math.sqrt(+e), l = FC((l + 1) / 2) - (0 > l || l % 2), n = new A(e = u == 1 / 0 ? "5e" + l : (e = u.toExponential()).slice(0, e.indexOf("e") + 1) + l)) : n = new A(u + ""), n.c[0])
            for (3 > (u = (l = n.e) + h) && (u = 0);;)
              if (o = n, n = d.times(o.plus(r(s, o, h, 1))), $C(o.c).slice(0, u) === (e = $C(n.c)).slice(0, u)) {
                if (n.e < l && --u, "9999" != (e = e.slice(u - 3, u + 1)) && (i || "4999" != e)) {
                  (!+e || !+e.slice(1) && "5" == e.charAt(0)) && (k(n, n.e + c + 2, 1), t = !n.times(n).eq(s));
                  break
                }
                if (!i && (k(o, o.e + c + 2, 0), o.times(o).eq(s))) {
                  n = o;
                  break
                }
                h += 4, u += 4, i = 1
              } return k(n, n.e + c + 1, f, t)
        }, a.toExponential = function(t, e) {
          return null != t && (HC(t, 0, LC), t++), T(this, t, e, 1)
        }, a.toFixed = function(t, e) {
          return null != t && (HC(t, 0, LC), t = t + this.e + 1), T(this, t, e)
        }, a.toFormat = function(t, e, r) {
          var n, i = this;
          if (null == r) null != t && e && "object" == typeof e ? (r = e, e = null) : t && "object" == typeof t ? (r = t, t = e = null) : r = g;
          else if ("object" != typeof r) throw Error(CC + "Argument not an object: " + r);
          if (n = i.toFixed(t, e), i.c) {
            var o, s = n.split("."),
              a = +r.groupSize,
              u = +r.secondaryGroupSize,
              c = r.groupSeparator || "",
              f = s[0],
              l = s[1],
              h = 0 > i.s,
              d = h ? f.slice(1) : f,
              p = d.length;
            if (u && (o = a, a = u, u = o, p -= o), a > 0 && p > 0) {
              for (o = p % a || a, f = d.substr(0, o); p > o; o += a) f += c + d.substr(o, a);
              u > 0 && (f += c + d.slice(o)), h && (f = "-" + f)
            }
            n = l ? f + (r.decimalSeparator || "") + ((u = +r.fractionGroupSize) ? l.replace(RegExp("\\d{" + u + "}\\B", "g"), "$&" + (r.fractionGroupSeparator || "")) : l) : f
          }
          return (r.prefix || "") + n + (r.suffix || "")
        }, a.toFraction = function(t) {
          var e, n, i, o, s, a, c, l, h, d, b, m, y = this,
            g = y.c;
          if (null != t && (!(c = new A(t)).isInteger() && (c.c || 1 !== c.s) || c.lt(u))) throw Error(CC + "Argument " + (c.isInteger() ? "out of range: " : "not an integer: ") + x(c));
          if (!g) return new A(y);
          for (e = new A(u), h = n = new A(u), i = l = new A(u), m = $C(g), s = e.e = m.length - y.e - 1, e.c[0] = DC[0 > (a = s % jC) ? jC + a : a], t = !t || c.comparedTo(e) > 0 ? s > 0 ? e : h : c, a = p, p = 1 / 0, c = new A(m), l.c[0] = 0; d = r(c, e, 0, 1), 1 != (o = n.plus(d.times(i))).comparedTo(t);) n = i, i = o, h = l.plus(d.times(o = h)), l = o, e = c.minus(d.times(o = e)), c = o;
          return o = r(t.minus(n), i, 0, 1), l = l.plus(o.times(h)), n = n.plus(o.times(i)), l.s = h.s = y.s, b = 1 > r(h, i, s *= 2, f).minus(y).abs().comparedTo(r(l, n, s, f).minus(y).abs()) ? [h, i] : [l, n], p = a, b
        }, a.toNumber = function() {
          return +x(this)
        }, a.toPrecision = function(t, e) {
          return null != t && HC(t, 1, LC), T(this, t, e, 2)
        }, a.toString = function(t) {
          var e, r = this,
            i = r.s,
            o = r.e;
          return null === o ? i ? (e = "Infinity", 0 > i && (e = "-" + e)) : e = "NaN" : (null == t ? e = o > l && h > o ? VC($C(r.c), o, "0") : KC($C(r.c), o) : 10 === t && w ? e = VC($C((r = k(new A(r), c + o + 1, f)).c), r.e, "0") : (HC(t, 2, v.length, "Base"), e = n(VC($C(r.c), o, "0"), 10, t, i, !0)), 0 > i && r.c[0] && (e = "-" + e)), e
        }, a.valueOf = a.toJSON = function() {
          return x(this)
        }, a.wu = !0, a[Symbol.toStringTag] = "BigNumber", a[Symbol.for("nodejs.util.inspect.custom")] = a.valueOf, null != e && A.set(e), A
      }(),
      qC = i(57761);

    function JC(t) {
      return "string" == typeof t && qC.isURL(t.toString(), {
        protocols: ["http", "https"],
        require_tld: !1
      })
    }

    function YC(t) {
      return t === Object(t) && "[object Array]" !== {}.toString.call(t)
    }

    function QC(t) {
      return Array.isArray(t)
    }

    function XC(t) {
      try {
        return !!JSON.parse(t)
      } catch {
        return !1
      }
    }

    function tR(t) {
      return "boolean" == typeof t
    }

    function eR(t) {
      return !!t && (t instanceof ZC || t.constructor && "BigNumber" === t.constructor.name)
    }

    function rR(t) {
      return "string" == typeof t || !!t && t.constructor && "String" === t.constructor.name
    }

    function nR(t) {
      return "function" == typeof t
    }

    function iR(t) {
      return "string" == typeof t && !isNaN(parseInt(t, 16)) && /^(0x|)[a-fA-F0-9]+$/.test(t)
    }

    function oR(t) {
      return null !== t && Number.isInteger(+t)
    }

    function sR(t, e) {
      return {}.hasOwnProperty.call(t, e)
    }

    function aR(t, ...e) {
      return e.length && !e.map(e => sR(t, e)).includes(!1)
    }

    function uR(t) {
      const e = {
        block: t.block_number,
        timestamp: t.block_timestamp,
        contract: t.contract_address,
        name: t.event_name,
        transaction: t.transaction_id,
        result: t.result,
        resourceNode: t.resource_Node || (t.Au ? "fullNode" : "solidityNode")
      };
      return t.Au && (e.unconfirmed = t.Au), t.Tu && (e.fingerprint = t.Tu), e
    }

    function cR(t, {
      inputs: e
    }) {
      if (!t.result) return t;
      if (YC(t.result))
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          "address" == n.type && n.name in t.result && (t.result[n.name] = Y$ + t.result[n.name].substr(2).toLowerCase())
        } else QC(t.result) && (t.result = t.result.reduce((t, r, n) => {
          const {
            name: i,
            type: o
          } = e[n];
          return "address" == o && (r = Y$ + r.substr(2).toLowerCase()), t[i] = r, t
        }, {}));
      return t
    }

    function fR(t, e, r) {
      let n = t.toString();
      for (; n.length < r;) n = e + n;
      return n
    }

    function lR(t) {
      return null !== t && "u" > typeof t
    }
    async function hR(t = 1e3) {
      return new Promise(e => setTimeout(e, t))
    }
    const dR = "0x0000000000000000000000000000000000000000000000000000000000000000",
      pR = "6.15.0";

    function bR(t, e, r) {
      const n = e.split("|").map(t => t.trim());
      for (let r = 0; r < n.length; r++) switch (e) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof t === e) return
      }
      const i = Error("invalid value for type " + e);
      throw i.code = "INVALID_ARGUMENT", i.argument = "value." + r, i.value = t, i
    }
    async function mR(t) {
      const e = Object.keys(t);
      return (await Promise.all(e.map(e => Promise.resolve(t[e])))).reduce((t, r, n) => (t[e[n]] = r, t), {})
    }

    function yR(t, e, r) {
      for (let n in e) {
        let i = e[n];
        const o = r ? r[n] : null;
        o && bR(i, o, n), Object.defineProperty(t, n, {
          enumerable: !0,
          value: i,
          writable: !1
        })
      }
    }

    function gR(t, e) {
      if (null == t) return "null";
      if (null == e && (e = new Set), "object" == typeof t) {
        if (e.has(t)) return "[Circular]";
        e.add(t)
      }
      if (Array.isArray(t)) return "[ " + t.map(t => gR(t, e)).join(", ") + " ]";
      if (t instanceof Uint8Array) {
        const e = "0123456789abcdef";
        let r = "0x";
        for (let n = 0; n < t.length; n++) r += e[t[n] >> 4], r += e[15 & t[n]];
        return r
      }
      if ("object" == typeof t && "function" == typeof t.toJSON) return gR(t.toJSON(), e);
      switch (typeof t) {
        case "boolean":
        case "number":
        case "symbol":
          return t.toString();
        case "bigint":
          return BigInt(t).toString();
        case "string":
          return JSON.stringify(t);
        case "object": {
          const r = Object.keys(t);
          return r.sort(), "{ " + r.map(r => `${gR(r,e)}: ${gR(t[r],e)}`).join(", ") + " }"
        }
      }
      return "[ COULD NOT SERIALIZE ]"
    }

    function vR(t, e) {
      return t && t.code === e
    }

    function wR(t, e, r) {
      let n, i = t;
      {
        const n = [];
        if (r) {
          if ("message" in r || "code" in r || "name" in r) throw Error("value will overwrite populated values: " + gR(r));
          for (const t in r) {
            if ("shortMessage" === t) continue;
            const e = r[t];
            n.push(t + "=" + gR(e))
          }
        }
        n.push("code=" + e), n.push("version=" + pR), n.length && (t += " (" + n.join(", ") + ")")
      }
      switch (e) {
        case "INVALID_ARGUMENT":
          n = new TypeError(t);
          break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
          n = new RangeError(t);
          break;
        default:
          n = Error(t)
      }
      return yR(n, {
        code: e
      }), r && Object.assign(n, r), null == n.shortMessage && yR(n, {
        shortMessage: i
      }), n
    }

    function AR(t, e, r, n) {
      if (!t) throw wR(e, r, n)
    }

    function TR(t, e, r, n) {
      AR(t, e, "INVALID_ARGUMENT", {
        argument: r,
        value: n
      })
    }

    function ER(t, e, r) {
      null == r && (r = ""), r && (r = ": " + r), AR(t >= e, "missing argument" + r, "MISSING_ARGUMENT", {
        count: t,
        expectedCount: e
      }), AR(e >= t, "too many arguments" + r, "UNEXPECTED_ARGUMENT", {
        count: t,
        expectedCount: e
      })
    }
    const PR = ["NFD", "NFC", "NFKD", "NFKC"].reduce((t, e) => {
      try {
        if ("test" !== "test".normalize(e)) throw Error("bad");
        t.push(e)
      } catch {}
      return t
    }, []);

    function kR(t) {
      AR(PR.indexOf(t) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
        operation: "String.prototype.normalize",
        info: {
          form: t
        }
      })
    }

    function xR(t, e, r) {
      if (null == r && (r = ""), t !== e) {
        let t = r,
          e = "new";
        r && (t += ".", e += " " + r), AR(!1, `private constructor; use ${t}from* methods`, "UNSUPPORTED_OPERATION", {
          operation: e
        })
      }
    }

    function IR(t, e, r) {
      if (t instanceof Uint8Array) return r ? new Uint8Array(t) : t;
      if ("string" == typeof t && t.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const e = new Uint8Array((t.length - 2) / 2);
        let r = 2;
        for (let n = 0; n < e.length; n++) e[n] = parseInt(t.substring(r, r + 2), 16), r += 2;
        return e
      }
      TR(!1, "invalid BytesLike value", e || "value", t)
    }

    function SR(t, e) {
      return IR(t, e, !1)
    }

    function OR(t, e) {
      return IR(t, e, !0)
    }

    function BR(t, e) {
      return !("string" != typeof t || !t.match(/^0x[0-9A-Fa-f]*$/) || "number" == typeof e && t.length !== 2 + 2 * e || !0 === e && t.length % 2 != 0)
    }

    function WR(t) {
      return BR(t, !0) || t instanceof Uint8Array
    }
    const MR = "0123456789abcdef";

    function CR(t) {
      const e = SR(t);
      let r = "0x";
      for (let t = 0; t < e.length; t++) {
        const n = e[t];
        r += MR[(240 & n) >> 4] + MR[15 & n]
      }
      return r
    }

    function RR(t) {
      return "0x" + t.map(t => CR(t).substring(2)).join("")
    }

    function NR(t) {
      return BR(t, !0) ? (t.length - 2) / 2 : SR(t).length
    }

    function jR(t, e, r) {
      const n = SR(t);
      return null != r && r > n.length && AR(!1, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: n,
        length: n.length,
        offset: r
      }), CR(n.slice(e ?? 0, r ?? n.length))
    }

    function _R(t, e) {
      return function(t, e) {
        const r = SR(t);
        AR(e >= r.length, "padding exceeds data length", "BUFFER_OVERRUN", {
          buffer: new Uint8Array(r),
          length: e,
          offset: e + 1
        });
        const n = new Uint8Array(e);
        return n.fill(0), n.set(r, e - r.length), CR(n)
      }(t, e)
    }
    const DR = BigInt(0),
      UR = BigInt(1),
      LR = 9007199254740991;

    function FR(t, e) {
      let r = zR(t, "value");
      const n = BigInt(VR(e, "width")),
        i = UR << n - UR;
      return DR > r ? (r = -r, AR(i >= r, "too low", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t
      }), (~r & (UR << n) - UR) + UR) : (AR(i > r, "too high", "NUMERIC_FAULT", {
        operation: "toTwos",
        fault: "overflow",
        value: t
      }), r)
    }

    function $R(t, e) {
      const r = HR(t, "value"),
        n = BigInt(VR(e, "bits"));
      return r & (UR << n) - UR
    }

    function zR(t, e) {
      switch (typeof t) {
        case "bigint":
          return t;
        case "number":
          return TR(Number.isInteger(t), "underflow", e || "value", t), TR(t >= -LR && LR >= t, "overflow", e || "value", t), BigInt(t);
        case "string":
          try {
            if ("" === t) throw Error("empty string");
            return "-" === t[0] && "-" !== t[1] ? -BigInt(t.substring(1)) : BigInt(t)
          } catch (r) {
            TR(!1, "invalid BigNumberish string: " + r.message, e || "value", t)
          }
      }
      TR(!1, "invalid BigNumberish value", e || "value", t)
    }

    function HR(t, e) {
      const r = zR(t, e);
      return AR(r >= DR, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value: t
      }), r
    }
    const GR = "0123456789abcdef";

    function KR(t) {
      if (t instanceof Uint8Array) {
        let e = "0x0";
        for (const r of t) e += GR[r >> 4], e += GR[15 & r];
        return BigInt(e)
      }
      return zR(t)
    }

    function VR(t, e) {
      switch (typeof t) {
        case "bigint":
          return TR(t >= -LR && LR >= t, "overflow", e || "value", t), +t;
        case "number":
          return TR(Number.isInteger(t), "underflow", e || "value", t), TR(t >= -LR && LR >= t, "overflow", e || "value", t), t;
        case "string":
          try {
            if ("" === t) throw Error("empty string");
            return VR(BigInt(t), e)
          } catch (r) {
            TR(!1, "invalid numeric string: " + r.message, e || "value", t)
          }
      }
      TR(!1, "invalid numeric value", e || "value", t)
    }

    function ZR(t, e) {
      let r = HR(t, "value").toString(16);
      if (null == e) r.length % 2 && (r = "0" + r);
      else {
        const n = VR(e, "width");
        for (AR(2 * n >= r.length, `value exceeds width (${n} bytes)`, "NUMERIC_FAULT", {
            operation: "toBeHex",
            fault: "overflow",
            value: t
          }); r.length < 2 * n;) r = "0" + r
      }
      return "0x" + r
    }

    function qR(t) {
      const e = HR(t, "value");
      if (e === DR) return new Uint8Array([]);
      let r = e.toString(16);
      r.length % 2 && (r = "0" + r);
      const n = new Uint8Array(r.length / 2);
      for (let t = 0; t < n.length; t++) {
        const e = 2 * t;
        n[t] = parseInt(r.substring(e, e + 2), 16)
      }
      return n
    }

    function JR(t) {
      let e = CR(WR(t) ? t : qR(t)).substring(2);
      for (; e.startsWith("0");) e = e.substring(1);
      return "" === e && (e = "0"), "0x" + e
    }
    const YR = BigInt(0),
      QR = BigInt(1),
      XR = BigInt(2),
      tN = BigInt(27),
      eN = BigInt(28),
      rN = BigInt(35),
      nN = {};

    function iN(t) {
      return _R(qR(t), 32)
    }
    class oN {
      #t;
      #e;
      #r;
      #n;
      get r() {
        return this.#t
      }
      set r(t) {
        TR(32 === NR(t), "invalid r", "value", t), this.#t = CR(t)
      }
      get s() {
        return TR(8 > parseInt(this.#e.substring(0, 3)), "non-canonical s; use ._s", "s", this.#e), this.#e
      }
      set s(t) {
        TR(32 === NR(t), "invalid s", "value", t), this.#e = CR(t)
      }
      get Eu() {
        return this.#e
      }
      isValid() {
        return 8 > parseInt(this.#e.substring(0, 3))
      }
      get v() {
        return this.#r
      }
      set v(t) {
        const e = VR(t, "value");
        TR(27 === e || 28 === e, "invalid v", "v", t), this.#r = e
      }
      get networkV() {
        return this.#n
      }
      get legacyChainId() {
        const t = this.networkV;
        return null == t ? null : oN.getChainId(t)
      }
      get yParity() {
        return 27 === this.v ? 0 : 1
      }
      get yParityAndS() {
        const t = SR(this.s);
        return this.yParity && (t[0] |= 128), CR(t)
      }
      get compactSerialized() {
        return RR([this.r, this.yParityAndS])
      }
      get serialized() {
        return RR([this.r, this.s, this.yParity ? "0x1c" : "0x1b"])
      }
      constructor(t, e, r, n) {
        xR(t, nN, "Signature"), this.#t = e, this.#e = r, this.#r = n, this.#n = null
      } [Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.Eu}"${this.isValid()?"":', valid: "false"'}, yParity: ${this.yParity}, networkV: ${this.networkV} }`
      }
      clone() {
        const t = new oN(nN, this.r, this.Eu, this.v);
        return this.networkV && (t.#n = this.networkV), t
      }
      toJSON() {
        const t = this.networkV;
        return {
          Ws: "signature",
          networkV: null != t ? t.toString() : null,
          r: this.r,
          s: this.Eu,
          v: this.v
        }
      }
      static getChainId(t) {
        const e = zR(t, "v");
        return e == tN || e == eN ? YR : (TR(e >= rN, "invalid EIP-155 v", "v", t), (e - rN) / XR)
      }
      static getChainIdV(t, e) {
        return zR(t) * XR + BigInt(35 + e - 27)
      }
      static getNormalizedV(t) {
        const e = zR(t);
        return e === YR || e === tN ? 27 : e === QR || e === eN ? 28 : (TR(e >= rN, "invalid v", "v", t), e & QR ? 27 : 28)
      }
      static from(t) {
        function e(e, r) {
          TR(e, r, "signature", t)
        }
        if (null == t) return new oN(nN, dR, dR, 27);
        if ("string" == typeof t) {
          const r = SR(t, "signature");
          if (64 === r.length) {
            const t = CR(r.slice(0, 32)),
              e = r.slice(32, 64),
              n = 128 & e[0] ? 28 : 27;
            return e[0] &= 127, new oN(nN, t, CR(e), n)
          }
          if (65 === r.length) {
            const t = CR(r.slice(0, 32)),
              e = CR(r.slice(32, 64)),
              n = oN.getNormalizedV(r[64]);
            return new oN(nN, t, e, n)
          }
          e(!1, "invalid raw signature length")
        }
        if (t instanceof oN) return t.clone();
        const r = t.r;
        e(null != r, "missing r");
        const n = iN(r),
          i = function(t, r) {
            if (null != t) return iN(t);
            if (null != r) {
              e(BR(r, 32), "invalid yParityAndS");
              const t = SR(r);
              return t[0] &= 127, CR(t)
            }
            e(!1, "missing s")
          }(t.s, t.yParityAndS),
          {
            networkV: o,
            v: s
          } = function(t, r, n) {
            if (null != t) {
              const e = zR(t);
              return {
                networkV: rN > e ? void 0 : e,
                v: oN.getNormalizedV(e)
              }
            }
            if (null != r) return e(BR(r, 32), "invalid yParityAndS"), {
              v: 128 & SR(r)[0] ? 28 : 27
            };
            if (null != n) {
              switch (VR(n, "sig.yParity")) {
                case 0:
                  return {
                    v: 27
                  };
                case 1:
                  return {
                    v: 28
                  }
              }
              e(!1, "invalid yParity")
            }
            e(!1, "missing v")
          }(t.v, t.yParityAndS, t.yParity),
          a = new oN(nN, n, i, s);
        return o && (a.#n = o), e(null == t.yParity || VR(t.yParity, "sig.yParity") === a.yParity, "yParity mismatch"), e(null == t.yParityAndS || t.yParityAndS === a.yParityAndS, "yParityAndS mismatch"), a
      }
    }

    function sN(t) {
      if (!Number.isSafeInteger(t) || 0 > t) throw Error("Wrong positive integer: " + t)
    }

    function aN(t, ...e) {
      if (!(t instanceof Uint8Array)) throw Error("Expected Uint8Array");
      if (e.length > 0 && !e.includes(t.length)) throw Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)
    }

    function uN(t) {
      if ("function" != typeof t || "function" != typeof t.create) throw Error("Hash should be wrapped by utils.wrapConstructor");
      sN(t.outputLen), sN(t.blockLen)
    }

    function cN(t, e = !0) {
      if (t.destroyed) throw Error("Hash instance has been destroyed");
      if (e && t.finished) throw Error("Hash#digest() has already been called")
    }

    function fN(t, e) {
      aN(t);
      const r = e.outputLen;
      if (t.length < r) throw Error("digestInto() expects output buffer of length at least " + r)
    }
    const lN = "object" == typeof globalThis && "crypto" in globalThis ? globalThis.crypto : void 0,
      hN = t => t instanceof Uint8Array,
      dN = t => new Uint32Array(t.buffer, t.byteOffset, Math.floor(t.byteLength / 4)),
      pN = t => new DataView(t.buffer, t.byteOffset, t.byteLength),
      bN = (t, e) => t << 32 - e | t >>> e;
    if (68 !== new Uint8Array(new Uint32Array([287454020]).buffer)[0]) throw Error("Non little-endian hardware is not supported");
    Array.from({
      length: 256
    }, (t, e) => e.toString(16).padStart(2, "0"));
    const mN = async () => {};
    async function yN(t, e, r) {
      let n = Date.now();
      for (let i = 0; t > i; i++) {
        r(i);
        const t = Date.now() - n;
        t >= 0 && e > t || (await mN(), n += t)
      }
    }

    function gN(t) {
      if ("string" == typeof t && (t = function(t) {
          if ("string" != typeof t) throw Error("utf8ToBytes expected string, got " + typeof t);
          return new Uint8Array((new TextEncoder).encode(t))
        }(t)), !hN(t)) throw Error("expected Uint8Array, got " + typeof t);
      return t
    }
    class vN {
      clone() {
        return this.jt()
      }
    }
    const wN = {}.toString;

    function AN(t, e) {
      if (void 0 !== e && "[object Object]" !== wN.call(e)) throw Error("Options should be object or undefined");
      return Object.assign(t, e)
    }

    function TN(t) {
      const e = e => t().update(gN(e)).digest(),
        r = t();
      return e.outputLen = r.outputLen, e.blockLen = r.blockLen, e.create = () => t(), e
    }

    function EN(t = 32) {
      if (lN && "function" == typeof lN.getRandomValues) return lN.getRandomValues(new Uint8Array(t));
      throw Error("crypto.getRandomValues must be defined")
    }
    class PN extends vN {
      constructor(t, e) {
        super(), this.finished = !1, this.destroyed = !1, uN(t);
        const r = gN(e);
        if (this.iHash = t.create(), "function" != typeof this.iHash.update) throw Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
        const n = this.blockLen,
          i = new Uint8Array(n);
        i.set(r.length > n ? t.create().update(r).digest() : r);
        for (let t = 0; t < i.length; t++) i[t] ^= 54;
        this.iHash.update(i), this.oHash = t.create();
        for (let t = 0; t < i.length; t++) i[t] ^= 106;
        this.oHash.update(i), i.fill(0)
      }
      update(t) {
        return cN(this), this.iHash.update(t), this
      }
      digestInto(t) {
        cN(this), aN(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy()
      }
      digest() {
        const t = new Uint8Array(this.oHash.outputLen);
        return this.digestInto(t), t
      }
      jt(t) {
        t || (t = Object.create(Object.getPrototypeOf(this), {}));
        const {
          oHash: e,
          iHash: r,
          finished: n,
          destroyed: i,
          blockLen: o,
          outputLen: s
        } = this;
        return t.finished = n, t.destroyed = i, t.blockLen = o, t.outputLen = s, t.oHash = e.jt(t.oHash), t.iHash = r.jt(t.iHash), t
      }
      destroy() {
        this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy()
      }
    }
    const kN = (t, e, r) => new PN(t, e).update(r).digest();

    function xN(t, e, r, n) {
      const {
        c: i,
        dkLen: o,
        DK: s,
        PRF: a,
        PRFSalt: u
      } = function(t, e, r, n) {
        uN(t);
        const i = AN({
            dkLen: 32,
            asyncTick: 10
          }, n),
          {
            c: o,
            dkLen: s,
            asyncTick: a
          } = i;
        if (sN(o), sN(s), sN(a), 1 > o) throw Error("PBKDF2: iterations (c) should be >= 1");
        const u = gN(e),
          c = gN(r),
          f = new Uint8Array(s),
          l = kN.create(t, u),
          h = l.jt().update(c);
        return {
          c: o,
          dkLen: s,
          asyncTick: a,
          DK: f,
          PRF: l,
          PRFSalt: h
        }
      }(t, e, r, n);
      let c;
      const f = new Uint8Array(4),
        l = pN(f),
        h = new Uint8Array(a.outputLen);
      for (let t = 1, e = 0; o > e; t++, e += a.outputLen) {
        const r = s.subarray(e, e + a.outputLen);
        l.setInt32(0, t, !1), (c = u.jt(c)).update(f).digestInto(h), r.set(h.subarray(0, r.length));
        for (let t = 1; i > t; t++) {
          a.jt(c).update(h).digestInto(h);
          for (let t = 0; t < r.length; t++) r[t] ^= h[t]
        }
      }
      return function(t, e, r, n, i) {
        return t.destroy(), e.destroy(), n && n.destroy(), i.fill(0), r
      }(a, u, s, c, h)
    }
    kN.create = (t, e) => new PN(t, e);
    class IN extends vN {
      constructor(t, e, r, n) {
        super(), this.blockLen = t, this.outputLen = e, this.padOffset = r, this.isLE = n, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = pN(this.buffer)
      }
      update(t) {
        cN(this);
        const {
          view: e,
          buffer: r,
          blockLen: n
        } = this, i = (t = gN(t)).length;
        for (let o = 0; i > o;) {
          const s = Math.min(n - this.pos, i - o);
          if (s === n) {
            const e = pN(t);
            for (; i - o >= n; o += n) this.process(e, o);
            continue
          }
          r.set(t.subarray(o, o + s), this.pos), this.pos += s, o += s, this.pos === n && (this.process(e, 0), this.pos = 0)
        }
        return this.length += t.length, this.roundClean(), this
      }
      digestInto(t) {
        cN(this), fN(t, this), this.finished = !0;
        const {
          buffer: e,
          view: r,
          blockLen: n,
          isLE: i
        } = this;
        let {
          pos: o
        } = this;
        e[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > n - o && (this.process(r, 0), o = 0);
        for (let t = o; n > t; t++) e[t] = 0;
        (function(t, e, r, n) {
          if ("function" == typeof t.setBigUint64) return t.setBigUint64(e, r, n);
          const i = BigInt(32),
            o = BigInt(4294967295),
            s = +(r >> i & o),
            a = +(r & o),
            u = n ? 4 : 0,
            c = n ? 0 : 4;
          t.setUint32(e + u, s, n), t.setUint32(e + c, a, n)
        })(r, n - 8, BigInt(8 * this.length), i), this.process(r, 0);
        const s = pN(t),
          a = this.outputLen;
        if (a % 4) throw Error("_sha2: outputLen should be aligned to 32bit");
        const u = a / 4,
          c = this.get();
        if (u > c.length) throw Error("_sha2: outputLen bigger than state");
        for (let t = 0; u > t; t++) s.setUint32(4 * t, c[t], i)
      }
      digest() {
        const {
          buffer: t,
          outputLen: e
        } = this;
        this.digestInto(t);
        const r = t.slice(0, e);
        return this.destroy(), r
      }
      jt(t) {
        t || (t = new this.constructor), t.set(...this.get());
        const {
          blockLen: e,
          buffer: r,
          length: n,
          finished: i,
          destroyed: o,
          pos: s
        } = this;
        return t.length = n, t.pos = s, t.finished = i, t.destroyed = o, n % e && t.buffer.set(r), t
      }
    }
    const SN = (t, e, r) => t & e ^ ~t & r,
      ON = (t, e, r) => t & e ^ t & r ^ e & r,
      BN = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]),
      WN = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]),
      MN = new Uint32Array(64);
    class CN extends IN {
      constructor() {
        super(64, 32, 8, !1), this.A = 0 | WN[0], this.B = 0 | WN[1], this.C = 0 | WN[2], this.D = 0 | WN[3], this.E = 0 | WN[4], this.F = 0 | WN[5], this.G = 0 | WN[6], this.H = 0 | WN[7]
      }
      get() {
        const {
          A: t,
          B: e,
          C: r,
          D: n,
          E: i,
          F: o,
          G: s,
          H: a
        } = this;
        return [t, e, r, n, i, o, s, a]
      }
      set(t, e, r, n, i, o, s, a) {
        this.A = 0 | t, this.B = 0 | e, this.C = 0 | r, this.D = 0 | n, this.E = 0 | i, this.F = 0 | o, this.G = 0 | s, this.H = 0 | a
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) MN[r] = t.getUint32(e, !1);
        for (let t = 16; 64 > t; t++) {
          const e = MN[t - 15],
            r = MN[t - 2],
            n = bN(e, 7) ^ bN(e, 18) ^ e >>> 3,
            i = bN(r, 17) ^ bN(r, 19) ^ r >>> 10;
          MN[t] = i + MN[t - 7] + n + MN[t - 16] | 0
        }
        let {
          A: r,
          B: n,
          C: i,
          D: o,
          E: s,
          F: a,
          G: u,
          H: c
        } = this;
        for (let t = 0; 64 > t; t++) {
          const e = c + (bN(s, 6) ^ bN(s, 11) ^ bN(s, 25)) + SN(s, a, u) + BN[t] + MN[t] | 0,
            f = (bN(r, 2) ^ bN(r, 13) ^ bN(r, 22)) + ON(r, n, i) | 0;
          c = u, u = a, a = s, s = o + e | 0, o = i, i = n, n = r, r = e + f | 0
        }
        r = r + this.A | 0, n = n + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, s = s + this.E | 0, a = a + this.F | 0, u = u + this.G | 0, c = c + this.H | 0, this.set(r, n, i, o, s, a, u, c)
      }
      roundClean() {
        MN.fill(0)
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0)
      }
    }
    const RN = TN(() => new CN),
      NN = BigInt(2 ** 32 - 1),
      jN = BigInt(32);

    function _N(t, e = !1) {
      return e ? {
        h: +(t & NN),
        l: +(t >> jN & NN)
      } : {
        h: 0 | +(t >> jN & NN),
        l: 0 | +(t & NN)
      }
    }

    function DN(t, e = !1) {
      let r = new Uint32Array(t.length),
        n = new Uint32Array(t.length);
      for (let i = 0; i < t.length; i++) {
        const {
          h: o,
          l: s
        } = _N(t[i], e);
        [r[i], n[i]] = [o, s]
      }
      return [r, n]
    }
    const UN = (t, e, r) => t << r | e >>> 32 - r,
      LN = (t, e, r) => e << r | t >>> 32 - r,
      FN = (t, e, r) => e << r - 32 | t >>> 64 - r,
      $N = (t, e, r) => t << r - 32 | e >>> 64 - r,
      zN = {
        fromBig: _N,
        split: DN,
        toBig: (t, e) => BigInt(t >>> 0) << jN | BigInt(e >>> 0),
        shrSH: (t, e, r) => t >>> r,
        shrSL: (t, e, r) => t << 32 - r | e >>> r,
        rotrSH: (t, e, r) => t >>> r | e << 32 - r,
        rotrSL: (t, e, r) => t << 32 - r | e >>> r,
        rotrBH: (t, e, r) => t << 64 - r | e >>> r - 32,
        rotrBL: (t, e, r) => t >>> r - 32 | e << 64 - r,
        rotr32H: (t, e) => e,
        rotr32L: (t, e) => t,
        rotlSH: UN,
        rotlSL: LN,
        rotlBH: FN,
        rotlBL: $N,
        add: function(t, e, r, n) {
          const i = (e >>> 0) + (n >>> 0);
          return {
            h: t + r + (i / 2 ** 32 | 0) | 0,
            l: 0 | i
          }
        },
        add3L: (t, e, r) => (t >>> 0) + (e >>> 0) + (r >>> 0),
        add3H: (t, e, r, n) => e + r + n + (t / 2 ** 32 | 0) | 0,
        add4L: (t, e, r, n) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0),
        add4H: (t, e, r, n, i) => e + r + n + i + (t / 2 ** 32 | 0) | 0,
        add5H: (t, e, r, n, i, o) => e + r + n + i + o + (t / 2 ** 32 | 0) | 0,
        add5L: (t, e, r, n, i) => (t >>> 0) + (e >>> 0) + (r >>> 0) + (n >>> 0) + (i >>> 0)
      },
      [HN, GN] = zN.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(t => BigInt(t))),
      KN = new Uint32Array(80),
      VN = new Uint32Array(80);
    class ZN extends IN {
      constructor() {
        super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209
      }
      get() {
        const {
          Ah: t,
          Al: e,
          Bh: r,
          Bl: n,
          Ch: i,
          Cl: o,
          Dh: s,
          Dl: a,
          Eh: u,
          El: c,
          Fh: f,
          Fl: l,
          Gh: h,
          Gl: d,
          Hh: p,
          Hl: b
        } = this;
        return [t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b]
      }
      set(t, e, r, n, i, o, s, a, u, c, f, l, h, d, p, b) {
        this.Ah = 0 | t, this.Al = 0 | e, this.Bh = 0 | r, this.Bl = 0 | n, this.Ch = 0 | i, this.Cl = 0 | o, this.Dh = 0 | s, this.Dl = 0 | a, this.Eh = 0 | u, this.El = 0 | c, this.Fh = 0 | f, this.Fl = 0 | l, this.Gh = 0 | h, this.Gl = 0 | d, this.Hh = 0 | p, this.Hl = 0 | b
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) KN[r] = t.getUint32(e), VN[r] = t.getUint32(e += 4);
        for (let t = 16; 80 > t; t++) {
          const e = 0 | KN[t - 15],
            r = 0 | VN[t - 15],
            n = zN.rotrSH(e, r, 1) ^ zN.rotrSH(e, r, 8) ^ zN.shrSH(e, r, 7),
            i = zN.rotrSL(e, r, 1) ^ zN.rotrSL(e, r, 8) ^ zN.shrSL(e, r, 7),
            o = 0 | KN[t - 2],
            s = 0 | VN[t - 2],
            a = zN.rotrSH(o, s, 19) ^ zN.rotrBH(o, s, 61) ^ zN.shrSH(o, s, 6),
            u = zN.rotrSL(o, s, 19) ^ zN.rotrBL(o, s, 61) ^ zN.shrSL(o, s, 6),
            c = zN.add4L(i, u, VN[t - 7], VN[t - 16]),
            f = zN.add4H(c, n, a, KN[t - 7], KN[t - 16]);
          KN[t] = 0 | f, VN[t] = 0 | c
        }
        let {
          Ah: r,
          Al: n,
          Bh: i,
          Bl: o,
          Ch: s,
          Cl: a,
          Dh: u,
          Dl: c,
          Eh: f,
          El: l,
          Fh: h,
          Fl: d,
          Gh: p,
          Gl: b,
          Hh: m,
          Hl: y
        } = this;
        for (let t = 0; 80 > t; t++) {
          const e = zN.rotrSH(f, l, 14) ^ zN.rotrSH(f, l, 18) ^ zN.rotrBH(f, l, 41),
            g = zN.rotrSL(f, l, 14) ^ zN.rotrSL(f, l, 18) ^ zN.rotrBL(f, l, 41),
            v = f & h ^ ~f & p,
            w = l & d ^ ~l & b,
            A = zN.add5L(y, g, w, GN[t], VN[t]),
            T = zN.add5H(A, m, e, v, HN[t], KN[t]),
            E = 0 | A,
            P = zN.rotrSH(r, n, 28) ^ zN.rotrBH(r, n, 34) ^ zN.rotrBH(r, n, 39),
            k = zN.rotrSL(r, n, 28) ^ zN.rotrBL(r, n, 34) ^ zN.rotrBL(r, n, 39),
            x = r & i ^ r & s ^ i & s,
            I = n & o ^ n & a ^ o & a;
          m = 0 | p, y = 0 | b, p = 0 | h, b = 0 | d, h = 0 | f, d = 0 | l, ({
            h: f,
            l: l
          } = zN.add(0 | u, 0 | c, 0 | T, 0 | E)), u = 0 | s, c = 0 | a, s = 0 | i, a = 0 | o, i = 0 | r, o = 0 | n;
          const S = zN.add3L(E, k, I);
          r = zN.add3H(S, T, P, x), n = 0 | S
        }({
          h: r,
          l: n
        } = zN.add(0 | this.Ah, 0 | this.Al, 0 | r, 0 | n)), ({
          h: i,
          l: o
        } = zN.add(0 | this.Bh, 0 | this.Bl, 0 | i, 0 | o)), ({
          h: s,
          l: a
        } = zN.add(0 | this.Ch, 0 | this.Cl, 0 | s, 0 | a)), ({
          h: u,
          l: c
        } = zN.add(0 | this.Dh, 0 | this.Dl, 0 | u, 0 | c)), ({
          h: f,
          l: l
        } = zN.add(0 | this.Eh, 0 | this.El, 0 | f, 0 | l)), ({
          h: h,
          l: d
        } = zN.add(0 | this.Fh, 0 | this.Fl, 0 | h, 0 | d)), ({
          h: p,
          l: b
        } = zN.add(0 | this.Gh, 0 | this.Gl, 0 | p, 0 | b)), ({
          h: m,
          l: y
        } = zN.add(0 | this.Hh, 0 | this.Hl, 0 | m, 0 | y)), this.set(r, n, i, o, s, a, u, c, f, l, h, d, p, b, m, y)
      }
      roundClean() {
        KN.fill(0), VN.fill(0)
      }
      destroy() {
        this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
      }
    }
    const qN = TN(() => new ZN),
      JN = function() {
        if ("u" > typeof self) return self;
        if ("u" > typeof window) return window;
        if ("u" > typeof global) return global;
        throw Error("unable to locate global object")
      }(),
      YN = JN.crypto || JN.msCrypto;

    function QN(t) {
      switch (t) {
        case "sha256":
          return RN.create();
        case "sha512":
          return qN.create()
      }
      TR(!1, "invalid hashing algorithm name", "algorithm", t)
    }
    const XN = function(t) {
        return QN("sha256").update(t).digest()
      },
      tj = function(t) {
        return QN("sha512").update(t).digest()
      };
    let ej = XN,
      rj = tj,
      nj = !1,
      ij = !1;

    function oj(t) {
      const e = SR(t, "data");
      return CR(ej(e))
    }

    function sj(t) {
      const e = SR(t, "data");
      return CR(rj(e))
    }
    oj.Pu = XN, oj.lock = function() {
      nj = !0
    }, oj.register = function(t) {
      if (nj) throw Error("sha256 is locked");
      ej = t
    }, Object.freeze(oj), sj.Pu = tj, sj.lock = function() {
      ij = !0
    }, sj.register = function(t) {
      if (ij) throw Error("sha512 is locked");
      rj = t
    }, Object.freeze(oj);
    let aj = !1;
    const uj = function(t, e, r, n, i) {
      return function(t, e, r, n, i) {
        const o = {
          sha256: RN,
          sha512: qN
        } [i];
        return TR(null != o, "invalid pbkdf2 algorithm", "algorithm", i), xN(o, t, e, {
          c: r,
          dkLen: n
        })
      }(t, e, r, n, i)
    };
    let cj = uj;

    function fj(t, e, r, n, i) {
      const o = SR(t, "password"),
        s = SR(e, "salt");
      return CR(cj(o, s, r, n, i))
    }

    function lj(t, e, r, n, i) {
      if ("BAD_PREFIX" === t || "UNEXPECTED_CONTINUE" === t) {
        let t = 0;
        for (let n = e + 1; n < r.length && r[n] >> 6 == 2; n++) t++;
        return t
      }
      return "OVERRUN" === t ? r.length - e - 1 : 0
    }
    fj.Pu = uj, fj.lock = function() {
      aj = !0
    }, fj.register = function(t) {
      if (aj) throw Error("pbkdf2 is locked");
      cj = t
    }, Object.freeze(fj);
    const hj = Object.freeze({
      error: function(t, e, r, n, i) {
        TR(!1, `invalid codepoint at offset ${e}; ${t}`, "bytes", r)
      },
      ignore: lj,
      replace: function(t, e, r, n, i) {
        return "OVERLONG" === t ? (TR("number" == typeof i, "invalid bad code point for replacement", "badCodepoint", i), n.push(i), 0) : (n.push(65533), lj(t, e, r))
      }
    });

    function dj(t, e) {
      TR("string" == typeof t, "invalid string value", "str", t), null != e && (kR(e), t = t.normalize(e));
      let r = [];
      for (let e = 0; e < t.length; e++) {
        const n = t.charCodeAt(e);
        if (128 > n) r.push(n);
        else if (2048 > n) r.push(n >> 6 | 192), r.push(63 & n | 128);
        else if (55296 == (64512 & n)) {
          e++;
          const i = t.charCodeAt(e);
          TR(e < t.length && 56320 == (64512 & i), "invalid surrogate pair", "str", t);
          const o = 65536 + ((1023 & n) << 10) + (1023 & i);
          r.push(o >> 18 | 240), r.push(o >> 12 & 63 | 128), r.push(o >> 6 & 63 | 128), r.push(63 & o | 128)
        } else r.push(n >> 12 | 224), r.push(n >> 6 & 63 | 128), r.push(63 & n | 128)
      }
      return new Uint8Array(r)
    }

    function pj(t, e) {
      return function(t) {
        return t.map(t => t > 65535 ? String.fromCharCode(55296 + ((t -= 65536) >> 10 & 1023), 56320 + (1023 & t)) : String.fromCharCode(t)).join("")
      }(function(t, e) {
        null == e && (e = hj.error);
        const r = SR(t, "bytes"),
          n = [];
        let i = 0;
        for (; i < r.length;) {
          const t = r[i++];
          if (!(t >> 7)) {
            n.push(t);
            continue
          }
          let o = null,
            s = null;
          if (192 == (224 & t)) o = 1, s = 127;
          else if (224 == (240 & t)) o = 2, s = 2047;
          else {
            if (240 != (248 & t)) {
              i += e(128 == (192 & t) ? "UNEXPECTED_CONTINUE" : "BAD_PREFIX", i - 1, r, n);
              continue
            }
            o = 3, s = 65535
          }
          if (i - 1 + o >= r.length) {
            i += e("OVERRUN", i - 1, r, n);
            continue
          }
          let a = t & (1 << 8 - o - 1) - 1;
          for (let t = 0; o > t; t++) {
            let t = r[i];
            if (128 != (192 & t)) {
              i += e("MISSING_CONTINUE", i, r, n), a = null;
              break
            }
            a = a << 6 | 63 & t, i++
          }
          if (null !== a) {
            if (a > 1114111) {
              i += e("OUT_OF_RANGE", i - 1 - o, r, n, a);
              continue
            }
            if (a >= 55296 && 57343 >= a) {
              i += e("UTF16_SURROGATE", i - 1 - o, r, n, a);
              continue
            }
            if (s >= a) {
              i += e("OVERLONG", i - 1 - o, r, n, a);
              continue
            }
            n.push(a)
          }
        }
        return n
      }(t, e))
    }
    const [bj, mj, yj] = [
      [],
      [],
      []
    ], gj = BigInt(0), vj = BigInt(1), wj = BigInt(2), Aj = BigInt(7), Tj = BigInt(256), Ej = BigInt(113);
    for (let t = 0, e = vj, r = 1, n = 0; 24 > t; t++) {
      [r, n] = [n, (2 * r + 3 * n) % 5], bj.push(2 * (5 * n + r)), mj.push((t + 1) * (t + 2) / 2 % 64);
      let i = gj;
      for (let t = 0; 7 > t; t++) e = (e << vj ^ (e >> Aj) * Ej) % Tj, e & wj && (i ^= vj << (vj << BigInt(t)) - vj);
      yj.push(i)
    }
    const [Pj, kj] = DN(yj, !0), xj = (t, e, r) => r > 32 ? FN(t, e, r) : UN(t, e, r), Ij = (t, e, r) => r > 32 ? $N(t, e, r) : LN(t, e, r);
    class Sj extends vN {
      constructor(t, e, r, n = !1, i = 24) {
        if (super(), this.blockLen = t, this.suffix = e, this.outputLen = r, this.enableXOF = n, this.rounds = i, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, sN(r), 0 >= this.blockLen || this.blockLen >= 200) throw Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200), this.state32 = dN(this.state)
      }
      keccak() {
        (function(t, e = 24) {
          const r = new Uint32Array(10);
          for (let n = 24 - e; 24 > n; n++) {
            for (let e = 0; 10 > e; e++) r[e] = t[e] ^ t[e + 10] ^ t[e + 20] ^ t[e + 30] ^ t[e + 40];
            for (let e = 0; 10 > e; e += 2) {
              const n = (e + 8) % 10,
                i = (e + 2) % 10,
                o = r[i],
                s = r[i + 1],
                a = xj(o, s, 1) ^ r[n],
                u = Ij(o, s, 1) ^ r[n + 1];
              for (let r = 0; 50 > r; r += 10) t[e + r] ^= a, t[e + r + 1] ^= u
            }
            let e = t[2],
              i = t[3];
            for (let r = 0; 24 > r; r++) {
              const n = mj[r],
                o = xj(e, i, n),
                s = Ij(e, i, n),
                a = bj[r];
              e = t[a], i = t[a + 1], t[a] = o, t[a + 1] = s
            }
            for (let e = 0; 50 > e; e += 10) {
              for (let n = 0; 10 > n; n++) r[n] = t[e + n];
              for (let n = 0; 10 > n; n++) t[e + n] ^= ~r[(n + 2) % 10] & r[(n + 4) % 10]
            }
            t[0] ^= Pj[n], t[1] ^= kj[n]
          }
          r.fill(0)
        })(this.state32, this.rounds), this.posOut = 0, this.pos = 0
      }
      update(t) {
        cN(this);
        const {
          blockLen: e,
          state: r
        } = this, n = (t = gN(t)).length;
        for (let i = 0; n > i;) {
          const o = Math.min(e - this.pos, n - i);
          for (let e = 0; o > e; e++) r[this.pos++] ^= t[i++];
          this.pos === e && this.keccak()
        }
        return this
      }
      finish() {
        if (this.finished) return;
        this.finished = !0;
        const {
          state: t,
          suffix: e,
          pos: r,
          blockLen: n
        } = this;
        t[r] ^= e, !!(128 & e) && r === n - 1 && this.keccak(), t[n - 1] ^= 128, this.keccak()
      }
      writeInto(t) {
        cN(this, !1), aN(t), this.finish();
        const e = this.state,
          {
            blockLen: r
          } = this;
        for (let n = 0, i = t.length; i > n;) {
          this.posOut >= r && this.keccak();
          const o = Math.min(r - this.posOut, i - n);
          t.set(e.subarray(this.posOut, this.posOut + o), n), this.posOut += o, n += o
        }
        return t
      }
      xofInto(t) {
        if (!this.enableXOF) throw Error("XOF is not possible for this instance");
        return this.writeInto(t)
      }
      xof(t) {
        return sN(t), this.xofInto(new Uint8Array(t))
      }
      digestInto(t) {
        if (fN(t, this), this.finished) throw Error("digest() was already called");
        return this.writeInto(t), this.destroy(), t
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
      }
      destroy() {
        this.destroyed = !0, this.state.fill(0)
      }
      jt(t) {
        const {
          blockLen: e,
          suffix: r,
          outputLen: n,
          rounds: i,
          enableXOF: o
        } = this;
        return t || (t = new Sj(e, r, n, o, i)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = i, t.suffix = r, t.outputLen = n, t.enableXOF = o, t.destroyed = this.destroyed, t
      }
    }
    const Oj = TN(() => new Sj(136, 1, 32));
    let Bj = !1;
    const Wj = function(t) {
      return Oj(t)
    };
    let Mj = Wj;

    function Cj(t) {
      const e = SR(t, "data");
      return CR(Mj(e))
    }

    function Rj(t) {
      return Cj(dj(t))
    }
    Cj.Pu = Wj, Cj.lock = function() {
      Bj = !0
    }, Cj.register = function(t) {
      if (Bj) throw new TypeError("keccak256 is locked");
      Mj = t
    }, Object.freeze(Cj);
    const Nj = /^[a-z]*$/i;

    function jj(t, e) {
      let r = 97;
      return t.reduce((t, n) => (n === e ? r++ : n.match(Nj) ? t.push(String.fromCharCode(r) + n) : (r = 97, t.push(n)), t), [])
    }
    class _j {
      locale;
      constructor(t) {
        yR(this, {
          locale: t
        })
      }
      split(t) {
        return t.toLowerCase().split(/\s+/g)
      }
      join(t) {
        return t.join(" ")
      }
    }
    class Dj extends _j {
      #t;
      #e;
      constructor(t, e, r) {
        super(t), this.#t = e, this.#e = r, this.#r = null
      }
      get Yr() {
        return this.#t
      }
      ku() {
        return function(t) {
          return TR("0" === t[0], "unsupported auwl data", "data", t),
            function(t, e) {
              for (let r = 28; r >= 0; r--) t = t.split(" !#$%&'()*+,-./<=>?@[]^_`{|}~" [r]).join(e.substring(2 * r, 2 * r + 2));
              const r = [],
                n = t.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (t, e, n, i) => {
                  if (n)
                    for (let t = parseInt(n); t >= 0; t--) r.push(";");
                  else r.push(e.toLowerCase());
                  return ""
                });
              if (n) throw Error("leftovers: " + JSON.stringify(n));
              return jj(jj(r, ";"), ":")
            }(t.substring(59), t.substring(1, 59))
        }(this.#t)
      }
      #r;
      #n() {
        if (null == this.#r) {
          const t = this.ku();
          if (Rj(t.join("\n") + "\n") !== this.#e) throw Error(`BIP39 Wordlist for ${this.locale} FAILED`);
          this.#r = t
        }
        return this.#r
      }
      getWord(t) {
        const e = this.#n();
        return TR(t >= 0 && t < e.length, "invalid word index: " + t, "index", t), e[t]
      }
      getWordIndex(t) {
        return this.#n().indexOf(t)
      }
    }
    let Uj = null;
    class Lj extends Dj {
      constructor() {
        super("en", "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO", "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60")
      }
      static wordlist() {
        return null == Uj && (Uj = new Lj), Uj
      }
    }

    function Fj(t) {
      return (1 << t) - 1 << 8 - t & 255
    }

    function $j(t) {
      return (1 << t) - 1 & 255
    }

    function zj(t, e) {
      kR("NFKD"), null == e && (e = Lj.wordlist());
      const r = e.split(t);
      TR(r.length % 3 == 0 && r.length >= 12 && 24 >= r.length, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
      const n = new Uint8Array(Math.ceil(11 * r.length / 8));
      let i = 0;
      for (let t = 0; t < r.length; t++) {
        let o = e.getWordIndex(r[t].normalize("NFKD"));
        TR(o >= 0, "invalid mnemonic word at index " + t, "mnemonic", "[ REDACTED ]");
        for (let t = 0; 11 > t; t++) o & 1 << 10 - t && (n[i >> 3] |= 1 << 7 - i % 8), i++
      }
      const o = 32 * r.length / 3,
        s = Fj(r.length / 3);
      return TR((SR(oj(n.slice(0, o / 8)))[0] & s) === (n[n.length - 1] & s), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]"), CR(n.slice(0, o / 8))
    }

    function Hj(t, e) {
      TR(t.length % 4 == 0 && t.length >= 16 && 32 >= t.length, "invalid entropy size", "entropy", "[ REDACTED ]"), null == e && (e = Lj.wordlist());
      const r = [0];
      let n = 11;
      for (let e = 0; e < t.length; e++) n > 8 ? (r[r.length - 1] <<= 8, r[r.length - 1] |= t[e], n -= 8) : (r[r.length - 1] <<= n, r[r.length - 1] |= t[e] >> 8 - n, r.push(t[e] & $j(8 - n)), n += 3);
      const i = t.length / 4,
        o = parseInt(oj(t).substring(2, 4), 16) & Fj(i);
      return r[r.length - 1] <<= i, r[r.length - 1] |= o >> 8 - i, e.join(r.map(t => e.getWord(t)))
    }
    const Gj = {};
    class Kj {
      phrase;
      password;
      wordlist;
      entropy;
      constructor(t, e, r, n, i) {
        null == n && (n = ""), null == i && (i = Lj.wordlist()), xR(t, Gj, "Mnemonic"), yR(this, {
          phrase: r,
          password: n,
          wordlist: i,
          entropy: e
        })
      }
      computeSeed() {
        const t = dj("mnemonic" + this.password, "NFKD");
        return fj(dj(this.phrase, "NFKD"), t, 2048, 64, "sha512")
      }
      static fromPhrase(t, e, r) {
        const n = zj(t, r);
        return t = Hj(SR(n), r), new Kj(Gj, n, t, e, r)
      }
      static fromEntropy(t, e, r) {
        const n = SR(t, "entropy"),
          i = Hj(n, r);
        return new Kj(Gj, CR(n), i, e, r)
      }
      static entropyToPhrase(t, e) {
        return Hj(SR(t, "entropy"), e)
      }
      static phraseToEntropy(t, e) {
        return zj(t, e)
      }
      static isValidMnemonic(t, e) {
        try {
          return zj(t, e), !0
        } catch {}
        return !1
      }
    }
    let Vj = !1;
    const Zj = function(t, e, r) {
      return function(t, e) {
        const r = {
          sha256: RN,
          sha512: qN
        } [t];
        return TR(null != r, "invalid hmac algorithm", "algorithm", t), kN.create(r, e)
      }(t, e).update(r).digest()
    };
    let qj = Zj;

    function Jj(t, e, r) {
      const n = SR(e, "key"),
        i = SR(r, "data");
      return CR(qj(t, n, i))
    }
    Jj.Pu = Zj, Jj.lock = function() {
      Vj = !0
    }, Jj.register = function(t) {
      if (Vj) throw Error("computeHmac is locked");
      qj = t
    }, Object.freeze(Jj);
    const Yj = BigInt(0),
      Qj = BigInt(36);

    function Xj(t) {
      const e = (t = t.toLowerCase()).substring(2).split(""),
        r = new Uint8Array(40);
      for (let t = 0; 40 > t; t++) r[t] = e[t].charCodeAt(0);
      const n = SR(Cj(r));
      for (let t = 0; 40 > t; t += 2) n[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()), (15 & n[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
      return "0x" + e.join("")
    }
    const t_ = {};
    for (let t = 0; 10 > t; t++) t_[t + ""] = t + "";
    for (let t = 0; 26 > t; t++) t_[String.fromCharCode(65 + t)] = 10 + t + "";
    const e_ = 15,
      r_ = function() {
        const t = {};
        for (let e = 0; 36 > e; e++) t["0123456789abcdefghijklmnopqrstuvwxyz" [e]] = BigInt(e);
        return t
      }();

    function n_(t) {
      if (TR("string" == typeof t, "invalid address", "address", t), t.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        t.startsWith("0x") || (t = "0x" + t);
        const e = Xj(t);
        return TR(!t.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || e === t, "bad address checksum", "address", t), e
      }
      if (t.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        TR(t.substring(2, 4) === function(t) {
          let e = (t = (t = t.toUpperCase()).substring(4) + t.substring(0, 2) + "00").split("").map(t => t_[t]).join("");
          for (; e.length >= e_;) {
            let t = e.substring(0, e_);
            e = parseInt(t, 10) % 97 + e.substring(t.length)
          }
          let r = 98 - parseInt(e, 10) % 97 + "";
          for (; 2 > r.length;) r = "0" + r;
          return r
        }(t), "bad icap checksum", "address", t);
        let e = function(t) {
          t = t.toLowerCase();
          let e = Yj;
          for (let r = 0; r < t.length; r++) e = e * Qj + r_[t[r]];
          return e
        }(t.substring(4)).toString(16);
        for (; 40 > e.length;) e = "0" + e;
        return Xj("0x" + e)
      }
      TR(!1, "invalid address", "address", t)
    }
    BigInt(0);
    const i_ = BigInt(1),
      o_ = BigInt(2),
      s_ = t => t instanceof Uint8Array,
      a_ = Array.from({
        length: 256
      }, (t, e) => e.toString(16).padStart(2, "0"));

    function u_(t) {
      if (!s_(t)) throw Error("Uint8Array expected");
      let e = "";
      for (let r = 0; r < t.length; r++) e += a_[t[r]];
      return e
    }

    function c_(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      return BigInt("" === t ? "0" : "0x" + t)
    }

    function f_(t) {
      if ("string" != typeof t) throw Error("hex string expected, got " + typeof t);
      const e = t.length;
      if (e % 2) throw Error("padded hex string expected, got unpadded hex of length " + e);
      const r = new Uint8Array(e / 2);
      for (let e = 0; e < r.length; e++) {
        const n = 2 * e,
          i = t.slice(n, n + 2),
          o = Number.parseInt(i, 16);
        if (Number.isNaN(o) || 0 > o) throw Error("Invalid byte sequence");
        r[e] = o
      }
      return r
    }

    function l_(t) {
      return c_(u_(t))
    }

    function h_(t) {
      if (!s_(t)) throw Error("Uint8Array expected");
      return c_(u_(Uint8Array.from(t).reverse()))
    }

    function d_(t, e) {
      return f_(t.toString(16).padStart(2 * e, "0"))
    }

    function p_(t, e) {
      return d_(t, e).reverse()
    }

    function b_(t, e, r) {
      let n;
      if ("string" == typeof e) try {
        n = f_(e)
      } catch (r) {
        throw Error(`${t} must be valid hex string, got "${e}". Cause: ${r}`)
      } else {
        if (!s_(e)) throw Error(t + " must be hex string or Uint8Array");
        n = Uint8Array.from(e)
      }
      const i = n.length;
      if ("number" == typeof r && i !== r) throw Error(`${t} expected ${r} bytes, got ${i}`);
      return n
    }

    function m_(...t) {
      const e = new Uint8Array(t.reduce((t, e) => t + e.length, 0));
      let r = 0;
      return t.forEach(t => {
        if (!s_(t)) throw Error("Uint8Array expected");
        e.set(t, r), r += t.length
      }), e
    }
    const y_ = t => (o_ << BigInt(t - 1)) - i_,
      g_ = t => new Uint8Array(t),
      v_ = t => Uint8Array.from(t);

    function w_(t, e, r) {
      if ("number" != typeof t || 2 > t) throw Error("hashLen must be a number");
      if ("number" != typeof e || 2 > e) throw Error("qByteLen must be a number");
      if ("function" != typeof r) throw Error("hmacFn must be a function");
      let n = g_(t),
        i = g_(t),
        o = 0;
      const s = () => {
          n.fill(1), i.fill(0), o = 0
        },
        a = (...t) => r(i, n, ...t),
        u = (t = g_()) => {
          i = a(v_([0]), t), n = a(), 0 !== t.length && (i = a(v_([1]), t), n = a())
        },
        c = () => {
          if (o++ >= 1e3) throw Error("drbg: tried 1000 values");
          let t = 0;
          const r = [];
          for (; e > t;) {
            n = a();
            const e = n.slice();
            r.push(e), t += n.length
          }
          return m_(...r)
        };
      return (t, e) => {
        let r;
        for (s(), u(t); !(r = e(c()));) u();
        return s(), r
      }
    }
    const A_ = {
      bigint: t => "bigint" == typeof t,
      function: t => "function" == typeof t,
      boolean: t => "boolean" == typeof t,
      string: t => "string" == typeof t,
      stringOrUint8Array: t => "string" == typeof t || t instanceof Uint8Array,
      isSafeInteger: t => Number.isSafeInteger(t),
      array: t => Array.isArray(t),
      field: (t, e) => e.Fp.isValid(t),
      hash: t => "function" == typeof t && Number.isSafeInteger(t.outputLen)
    };

    function T_(t, e, r = {}) {
      const n = (e, r, n) => {
        const i = A_[r];
        if ("function" != typeof i) throw Error(`Invalid validator "${r}", expected function`);
        const o = t[e];
        if (!(n && void 0 === o || i(o, t))) throw Error(`Invalid param ${e+""}=${o} (${typeof o}), expected ${r}`)
      };
      for (const [t, r] of Object.entries(e)) n(t, r, !1);
      for (const [t, e] of Object.entries(r)) n(t, e, !0);
      return t
    }
    const E_ = BigInt(0),
      P_ = BigInt(1),
      k_ = BigInt(2),
      x_ = BigInt(3),
      I_ = BigInt(4),
      S_ = BigInt(5),
      O_ = BigInt(8);

    function B_(t, e) {
      const r = t % e;
      return E_ > r ? e + r : r
    }

    function W_(t, e, r) {
      if (E_ >= r || E_ > e) throw Error("Expected power/modulo > 0");
      if (r === P_) return E_;
      let n = P_;
      for (; e > E_;) e & P_ && (n = n * t % r), t = t * t % r, e >>= P_;
      return n
    }

    function M_(t, e, r) {
      let n = t;
      for (; e-- > E_;) n *= n, n %= r;
      return n
    }

    function C_(t, e) {
      if (t === E_ || E_ >= e) throw Error(`invert: expected positive integers, got n=${t} mod=${e}`);
      let r = B_(t, e),
        n = e,
        i = E_,
        o = P_,
        s = P_,
        a = E_;
      for (; r !== E_;) {
        const t = n / r,
          e = n % r,
          u = i - s * t,
          c = o - a * t;
        n = r, r = e, i = s, o = a, s = u, a = c
      }
      if (n !== P_) throw Error("invert: does not exist");
      return B_(i, e)
    }
    BigInt(9), BigInt(16);
    const R_ = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];

    function N_(t, e) {
      const r = void 0 !== e ? e : t.toString(2).length;
      return {
        nBitLength: r,
        nByteLength: Math.ceil(r / 8)
      }
    }

    function j_(t) {
      if ("bigint" != typeof t) throw Error("field order must be bigint");
      const e = t.toString(2).length;
      return Math.ceil(e / 8)
    }

    function __(t) {
      const e = j_(t);
      return e + Math.ceil(e / 2)
    }
    const D_ = BigInt(0),
      U_ = BigInt(1);

    function L_(t) {
      return function(t) {
        T_(t, R_.reduce((t, e) => (t[e] = "function", t), {
          ORDER: "bigint",
          MASK: "bigint",
          BYTES: "isSafeInteger",
          BITS: "isSafeInteger"
        }))
      }(t.Fp), T_(t, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      }), Object.freeze({
        ...N_(t.n, t.nBitLength),
        ...t,
        p: t.Fp.ORDER
      })
    }
    const {
      Ph: F_,
      aT: $_
    } = f, z_ = {
      Err: class extends Error {
        constructor(t = "") {
          super(t)
        }
      },
      Ht(t) {
        const {
          Err: e
        } = z_;
        if (2 > t.length || 2 !== t[0]) throw new e("Invalid signature integer tag");
        const r = t[1],
          n = t.subarray(2, r + 2);
        if (!r || n.length !== r) throw new e("Invalid signature integer: wrong length");
        if (128 & n[0]) throw new e("Invalid signature integer: negative");
        if (0 === n[0] && !(128 & n[1])) throw new e("Invalid signature integer: unnecessary leading zero");
        return {
          d: F_(n),
          l: t.subarray(r + 2)
        }
      },
      toSig(t) {
        const {
          Err: e
        } = z_, r = "string" == typeof t ? $_(t) : t;
        if (!(r instanceof Uint8Array)) throw Error("ui8a expected");
        let n = r.length;
        if (2 > n || 48 != r[0]) throw new e("Invalid signature tag");
        if (r[1] !== n - 2) throw new e("Invalid signature: incorrect length");
        const {
          d: i,
          l: o
        } = z_.Ht(r.subarray(2)), {
          d: s,
          l: a
        } = z_.Ht(o);
        if (a.length) throw new e("Invalid signature: left bytes after parsing");
        return {
          r: i,
          s: s
        }
      },
      hexFromSig(t) {
        const e = t => 8 & Number.parseInt(t[0], 16) ? "00" + t : t,
          r = t => {
            const e = t.toString(16);
            return 1 & e.length ? "0" + e : e
          },
          n = e(r(t.s)),
          i = e(r(t.r)),
          o = n.length / 2,
          s = i.length / 2,
          a = r(o),
          u = r(s);
        return `30${r(s+o+4)}02${u}${i}02${a}${n}`
      }
    }, H_ = BigInt(0), G_ = BigInt(1), K_ = (BigInt(2), BigInt(3));

    function V_(t) {
      return {
        hash: t,
        hmac: (e, ...r) => kN(t, e, function(...t) {
          const e = new Uint8Array(t.reduce((t, e) => t + e.length, 0));
          let r = 0;
          return t.forEach(t => {
            if (!hN(t)) throw Error("Uint8Array expected");
            e.set(t, r), r += t.length
          }), e
        }(...r)),
        randomBytes: EN
      }
    }
    BigInt(4);
    const Z_ = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
      q_ = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
      J_ = BigInt(1),
      Y_ = BigInt(2),
      Q_ = (t, e) => (t + e / Y_) / e,
      X_ = function(t, e, r = !1, n = {}) {
        if (E_ >= t) throw Error("Expected Field ORDER > 0, got " + t);
        const {
          nBitLength: i,
          nByteLength: o
        } = N_(t, e);
        if (o > 2048) throw Error("Field lengths over 2048 bytes are not supported");
        const s = function(t) {
            if (t % I_ === x_) {
              const e = (t + P_) / I_;
              return function(t, r) {
                const n = t.pow(r, e);
                if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
                return n
              }
            }
            if (t % O_ === S_) {
              const e = (t - S_) / O_;
              return function(t, r) {
                const n = t.mul(r, k_),
                  i = t.pow(n, e),
                  o = t.mul(r, i),
                  s = t.mul(t.mul(o, k_), i),
                  a = t.mul(o, t.sub(s, t.ONE));
                if (!t.eql(t.sqr(a), r)) throw Error("Cannot find square root");
                return a
              }
            }
            return function(t) {
              const e = (t - P_) / k_;
              let r, n, i;
              for (r = t - P_, n = 0; r % k_ === E_; r /= k_, n++);
              for (i = k_; t > i && W_(i, e, t) !== t - P_; i++);
              if (1 === n) {
                const e = (t + P_) / I_;
                return function(t, r) {
                  const n = t.pow(r, e);
                  if (!t.eql(t.sqr(n), r)) throw Error("Cannot find square root");
                  return n
                }
              }
              const o = (r + P_) / k_;
              return function(t, s) {
                if (t.pow(s, e) === t.neg(t.ONE)) throw Error("Cannot find square root");
                let a = n,
                  u = t.pow(t.mul(t.ONE, i), r),
                  c = t.pow(s, o),
                  f = t.pow(s, r);
                for (; !t.eql(f, t.ONE);) {
                  if (t.eql(f, t.ZERO)) return t.ZERO;
                  let e = 1;
                  for (let r = t.sqr(f); a > e && !t.eql(r, t.ONE); e++) r = t.sqr(r);
                  const r = t.pow(u, P_ << BigInt(a - e - 1));
                  u = t.sqr(r), c = t.mul(c, r), f = t.mul(f, u), a = e
                }
                return c
              }
            }(t)
          }(t),
          a = Object.freeze({
            ORDER: t,
            BITS: i,
            BYTES: o,
            MASK: y_(i),
            ZERO: E_,
            ONE: P_,
            create: e => B_(e, t),
            isValid: e => {
              if ("bigint" != typeof e) throw Error("Invalid field element: expected bigint, got " + typeof e);
              return e >= E_ && t > e
            },
            is0: t => t === E_,
            isOdd: t => (t & P_) === P_,
            neg: e => B_(-e, t),
            eql: (t, e) => t === e,
            sqr: e => B_(e * e, t),
            add: (e, r) => B_(e + r, t),
            sub: (e, r) => B_(e - r, t),
            mul: (e, r) => B_(e * r, t),
            pow: (t, e) => function(t, e, r) {
              if (E_ > r) throw Error("Expected power > 0");
              if (r === E_) return t.ONE;
              if (r === P_) return e;
              let n = t.ONE,
                i = e;
              for (; r > E_;) r & P_ && (n = t.mul(n, i)), i = t.sqr(i), r >>= P_;
              return n
            }(a, t, e),
            div: (e, r) => B_(e * C_(r, t), t),
            sqrN: t => t * t,
            addN: (t, e) => t + e,
            subN: (t, e) => t - e,
            mulN: (t, e) => t * e,
            inv: e => C_(e, t),
            sqrt: n.sqrt || (t => s(a, t)),
            invertBatch: t => function(t, e) {
              const r = Array(e.length),
                n = e.reduce((e, n, i) => t.is0(n) ? e : (r[i] = e, t.mul(e, n)), t.ONE),
                i = t.inv(n);
              return e.reduceRight((e, n, i) => t.is0(n) ? e : (r[i] = t.mul(e, r[i]), t.mul(e, n)), i), r
            }(a, t),
            cmov: (t, e, r) => r ? e : t,
            toBytes: t => r ? p_(t, o) : d_(t, o),
            fromBytes: t => {
              if (t.length !== o) throw Error(`Fp.fromBytes: expected ${o}, got ${t.length}`);
              return r ? h_(t) : l_(t)
            }
          });
        return Object.freeze(a)
      }(Z_, void 0, void 0, {
        sqrt: function(t) {
          const e = Z_,
            r = BigInt(3),
            n = BigInt(6),
            i = BigInt(11),
            o = BigInt(22),
            s = BigInt(23),
            a = BigInt(44),
            u = BigInt(88),
            c = t * t * t % e,
            f = c * c * t % e,
            l = M_(f, r, e) * f % e,
            h = M_(l, r, e) * f % e,
            d = M_(h, Y_, e) * c % e,
            p = M_(d, i, e) * d % e,
            b = M_(p, o, e) * p % e,
            m = M_(b, a, e) * b % e,
            y = M_(m, u, e) * m % e,
            g = M_(y, a, e) * b % e,
            v = M_(g, r, e) * f % e,
            w = M_(v, s, e) * p % e,
            A = M_(w, n, e) * c % e,
            T = M_(A, Y_, e);
          if (!X_.eql(X_.sqr(T), t)) throw Error("Cannot find square root");
          return T
        }
      }),
      tD = function(t, e) {
        const r = e => function(t) {
          const e = function(t) {
              const e = L_(t);
              return T_(e, {
                hash: "hash",
                hmac: "function",
                randomBytes: "function"
              }, {
                bits2int: "function",
                bits2int_modN: "function",
                lowS: "boolean"
              }), Object.freeze({
                lowS: !0,
                ...e
              })
            }(t),
            {
              Fp: r,
              n: n
            } = e,
            i = r.BYTES + 1,
            o = 2 * r.BYTES + 1;

          function s(t) {
            return B_(t, n)
          }

          function a(t) {
            return C_(t, n)
          }
          const {
            ProjectivePoint: u,
            normPrivateKeyToScalar: c,
            weierstrassEquation: f,
            isWithinCurveOrder: l
          } = function(t) {
            const e = function(t) {
                const e = L_(t);
                T_(e, {
                  a: "field",
                  b: "field"
                }, {
                  allowedPrivateKeyLengths: "array",
                  wrapPrivateKey: "boolean",
                  isTorsionFree: "function",
                  clearCofactor: "function",
                  allowInfinityPoint: "boolean",
                  fromBytes: "function",
                  toBytes: "function"
                });
                const {
                  endo: r,
                  Fp: n,
                  a: i
                } = e;
                if (r) {
                  if (!n.eql(i, n.ZERO)) throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");
                  if ("object" != typeof r || "bigint" != typeof r.beta || "function" != typeof r.splitScalar) throw Error("Expected endomorphism with beta: bigint and splitScalar: function")
                }
                return Object.freeze({
                  ...e
                })
              }(t),
              {
                Fp: r
              } = e,
              n = e.toBytes || ((t, e, n) => {
                const i = e.toAffine();
                return m_(Uint8Array.from([4]), r.toBytes(i.x), r.toBytes(i.y))
              }),
              i = e.fromBytes || (t => {
                const e = t.subarray(1);
                return {
                  x: r.fromBytes(e.subarray(0, r.BYTES)),
                  y: r.fromBytes(e.subarray(r.BYTES, 2 * r.BYTES))
                }
              });

            function o(t) {
              const {
                a: n,
                b: i
              } = e, o = r.sqr(t), s = r.mul(o, t);
              return r.add(r.add(s, r.mul(t, n)), i)
            }
            if (!r.eql(r.sqr(e.Gy), o(e.Gx))) throw Error("bad generator point: equation left != right");

            function s(t) {
              return "bigint" == typeof t && t > H_ && t < e.n
            }

            function a(t) {
              if (!s(t)) throw Error("Expected valid bigint: 0 < bigint < curve.n")
            }

            function u(t) {
              const {
                allowedPrivateKeyLengths: r,
                nByteLength: n,
                wrapPrivateKey: i,
                n: o
              } = e;
              if (r && "bigint" != typeof t) {
                if (t instanceof Uint8Array && (t = u_(t)), "string" != typeof t || !r.includes(t.length)) throw Error("Invalid key");
                t = t.padStart(2 * n, "0")
              }
              let s;
              try {
                s = "bigint" == typeof t ? t : l_(b_("private key", t, n))
              } catch {
                throw Error(`private key must be ${n} bytes, hex or bigint, not ${typeof t}`)
              }
              return i && (s = B_(s, o)), a(s), s
            }
            const c = new Map;

            function f(t) {
              if (!(t instanceof l)) throw Error("ProjectivePoint expected")
            }
            class l {
              constructor(t, e, n) {
                if (this.px = t, this.py = e, this.pz = n, null == t || !r.isValid(t)) throw Error("x required");
                if (null == e || !r.isValid(e)) throw Error("y required");
                if (null == n || !r.isValid(n)) throw Error("z required")
              }
              static fromAffine(t) {
                const {
                  x: e,
                  y: n
                } = t || {};
                if (!t || !r.isValid(e) || !r.isValid(n)) throw Error("invalid affine point");
                if (t instanceof l) throw Error("projective point not allowed");
                const i = t => r.eql(t, r.ZERO);
                return i(e) && i(n) ? l.ZERO : new l(e, n, r.ONE)
              }
              get x() {
                return this.toAffine().x
              }
              get y() {
                return this.toAffine().y
              }
              static normalizeZ(t) {
                const e = r.invertBatch(t.map(t => t.pz));
                return t.map((t, r) => t.toAffine(e[r])).map(l.fromAffine)
              }
              static fromHex(t) {
                const e = l.fromAffine(i(b_("pointHex", t)));
                return e.assertValidity(), e
              }
              static fromPrivateKey(t) {
                return l.BASE.multiply(u(t))
              }
              zt(t) {
                this.Gt = t, c.delete(this)
              }
              assertValidity() {
                if (this.is0()) {
                  if (e.allowInfinityPoint && !r.is0(this.py)) return;
                  throw Error("bad point: ZERO")
                }
                const {
                  x: t,
                  y: n
                } = this.toAffine();
                if (!r.isValid(t) || !r.isValid(n)) throw Error("bad point: x or y not FE");
                const i = r.sqr(n),
                  s = o(t);
                if (!r.eql(i, s)) throw Error("bad point: equation left != right");
                if (!this.isTorsionFree()) throw Error("bad point: not in prime-order subgroup")
              }
              hasEvenY() {
                const {
                  y: t
                } = this.toAffine();
                if (r.isOdd) return !r.isOdd(t);
                throw Error("Field doesn't support isOdd")
              }
              equals(t) {
                f(t);
                const {
                  px: e,
                  py: n,
                  pz: i
                } = this, {
                  px: o,
                  py: s,
                  pz: a
                } = t, u = r.eql(r.mul(e, a), r.mul(o, i)), c = r.eql(r.mul(n, a), r.mul(s, i));
                return u && c
              }
              negate() {
                return new l(this.px, r.neg(this.py), this.pz)
              }
              double() {
                const {
                  a: t,
                  b: n
                } = e, i = r.mul(n, K_), {
                  px: o,
                  py: s,
                  pz: a
                } = this;
                let u = r.ZERO,
                  c = r.ZERO,
                  f = r.ZERO,
                  h = r.mul(o, o),
                  d = r.mul(s, s),
                  p = r.mul(a, a),
                  b = r.mul(o, s);
                return b = r.add(b, b), f = r.mul(o, a), f = r.add(f, f), u = r.mul(t, f), c = r.mul(i, p), c = r.add(u, c), u = r.sub(d, c), c = r.add(d, c), c = r.mul(u, c), u = r.mul(b, u), f = r.mul(i, f), p = r.mul(t, p), b = r.sub(h, p), b = r.mul(t, b), b = r.add(b, f), f = r.add(h, h), h = r.add(f, h), h = r.add(h, p), h = r.mul(h, b), c = r.add(c, h), p = r.mul(s, a), p = r.add(p, p), h = r.mul(p, b), u = r.sub(u, h), f = r.mul(p, d), f = r.add(f, f), f = r.add(f, f), new l(u, c, f)
              }
              add(t) {
                f(t);
                const {
                  px: n,
                  py: i,
                  pz: o
                } = this, {
                  px: s,
                  py: a,
                  pz: u
                } = t;
                let c = r.ZERO,
                  h = r.ZERO,
                  d = r.ZERO;
                const p = e.a,
                  b = r.mul(e.b, K_);
                let m = r.mul(n, s),
                  y = r.mul(i, a),
                  g = r.mul(o, u),
                  v = r.add(n, i),
                  w = r.add(s, a);
                v = r.mul(v, w), w = r.add(m, y), v = r.sub(v, w), w = r.add(n, o);
                let A = r.add(s, u);
                return w = r.mul(w, A), A = r.add(m, g), w = r.sub(w, A), A = r.add(i, o), c = r.add(a, u), A = r.mul(A, c), c = r.add(y, g), A = r.sub(A, c), d = r.mul(p, w), c = r.mul(b, g), d = r.add(c, d), c = r.sub(y, d), d = r.add(y, d), h = r.mul(c, d), y = r.add(m, m), y = r.add(y, m), g = r.mul(p, g), w = r.mul(b, w), y = r.add(y, g), g = r.sub(m, g), g = r.mul(p, g), w = r.add(w, g), m = r.mul(y, w), h = r.add(h, m), m = r.mul(A, w), c = r.mul(v, c), c = r.sub(c, m), m = r.mul(v, y), d = r.mul(A, d), d = r.add(d, m), new l(c, h, d)
              }
              subtract(t) {
                return this.add(t.negate())
              }
              is0() {
                return this.equals(l.ZERO)
              }
              wNAF(t) {
                return d.wNAFCached(this, c, t, t => {
                  const e = r.invertBatch(t.map(t => t.pz));
                  return t.map((t, r) => t.toAffine(e[r])).map(l.fromAffine)
                })
              }
              multiplyUnsafe(t) {
                const n = l.ZERO;
                if (t === H_) return n;
                if (a(t), t === G_) return this;
                const {
                  endo: i
                } = e;
                if (!i) return d.unsafeLadder(this, t);
                let {
                  k1neg: o,
                  k1: s,
                  k2neg: u,
                  k2: c
                } = i.splitScalar(t), f = n, h = n, p = this;
                for (; s > H_ || c > H_;) s & G_ && (f = f.add(p)), c & G_ && (h = h.add(p)), p = p.double(), s >>= G_, c >>= G_;
                return o && (f = f.negate()), u && (h = h.negate()), h = new l(r.mul(h.px, i.beta), h.py, h.pz), f.add(h)
              }
              multiply(t) {
                a(t);
                let n, i, o = t;
                const {
                  endo: s
                } = e;
                if (s) {
                  const {
                    k1neg: t,
                    k1: e,
                    k2neg: a,
                    k2: u
                  } = s.splitScalar(o);
                  let {
                    p: c,
                    f: f
                  } = this.wNAF(e), {
                    p: h,
                    f: p
                  } = this.wNAF(u);
                  c = d.constTimeNegate(t, c), h = d.constTimeNegate(a, h), h = new l(r.mul(h.px, s.beta), h.py, h.pz), n = c.add(h), i = f.add(p)
                } else {
                  const {
                    p: t,
                    f: e
                  } = this.wNAF(o);
                  n = t, i = e
                }
                return l.normalizeZ([n, i])[0]
              }
              multiplyAndAddUnsafe(t, e, r) {
                const n = l.BASE,
                  i = (t, e) => e !== H_ && e !== G_ && t.equals(n) ? t.multiply(e) : t.multiplyUnsafe(e),
                  o = i(this, e).add(i(t, r));
                return o.is0() ? void 0 : o
              }
              toAffine(t) {
                const {
                  px: e,
                  py: n,
                  pz: i
                } = this, o = this.is0();
                null == t && (t = o ? r.ONE : r.inv(i));
                const s = r.mul(e, t),
                  a = r.mul(n, t),
                  u = r.mul(i, t);
                if (o) return {
                  x: r.ZERO,
                  y: r.ZERO
                };
                if (!r.eql(u, r.ONE)) throw Error("invZ was invalid");
                return {
                  x: s,
                  y: a
                }
              }
              isTorsionFree() {
                const {
                  h: t,
                  isTorsionFree: r
                } = e;
                if (t === G_) return !0;
                if (r) return r(l, this);
                throw Error("isTorsionFree() has not been declared for the elliptic curve")
              }
              clearCofactor() {
                const {
                  h: t,
                  clearCofactor: r
                } = e;
                return t === G_ ? this : r ? r(l, this) : this.multiplyUnsafe(e.h)
              }
              toRawBytes(t = !0) {
                return this.assertValidity(), n(l, this, t)
              }
              toHex(t = !0) {
                return u_(this.toRawBytes(t))
              }
            }
            l.BASE = new l(e.Gx, e.Gy, r.ONE), l.ZERO = new l(r.ZERO, r.ONE, r.ZERO);
            const h = e.nBitLength,
              d = function(t, e) {
                const r = (t, e) => {
                    const r = e.negate();
                    return t ? r : e
                  },
                  n = t => ({
                    windows: Math.ceil(e / t) + 1,
                    windowSize: 2 ** (t - 1)
                  });
                return {
                  constTimeNegate: r,
                  unsafeLadder(e, r) {
                    let n = t.ZERO,
                      i = e;
                    for (; r > D_;) r & U_ && (n = n.add(i)), i = i.double(), r >>= U_;
                    return n
                  },
                  precomputeWindow(t, e) {
                    const {
                      windows: r,
                      windowSize: i
                    } = n(e), o = [];
                    let s = t,
                      a = s;
                    for (let t = 0; r > t; t++) {
                      a = s, o.push(a);
                      for (let t = 1; i > t; t++) a = a.add(s), o.push(a);
                      s = a.double()
                    }
                    return o
                  },
                  wNAF(e, i, o) {
                    const {
                      windows: s,
                      windowSize: a
                    } = n(e);
                    let u = t.ZERO,
                      c = t.BASE;
                    const f = BigInt(2 ** e - 1),
                      l = 2 ** e,
                      h = BigInt(e);
                    for (let t = 0; s > t; t++) {
                      const e = t * a;
                      let n = +(o & f);
                      o >>= h, n > a && (n -= l, o += U_);
                      const s = e,
                        d = e + Math.abs(n) - 1,
                        p = t % 2 != 0,
                        b = 0 > n;
                      0 === n ? c = c.add(r(p, i[s])) : u = u.add(r(b, i[d]))
                    }
                    return {
                      p: u,
                      f: c
                    }
                  },
                  wNAFCached(t, e, r, n) {
                    const i = t.Gt || 1;
                    let o = e.get(t);
                    return o || (o = this.precomputeWindow(t, i), 1 !== i && e.set(t, n(o))), this.wNAF(i, o, r)
                  }
                }
              }(l, e.endo ? Math.ceil(h / 2) : h);
            return {
              CURVE: e,
              ProjectivePoint: l,
              normPrivateKeyToScalar: u,
              weierstrassEquation: o,
              isWithinCurveOrder: s
            }
          }({
            ...e,
            toBytes(t, e, n) {
              const i = e.toAffine(),
                o = r.toBytes(i.x),
                s = m_;
              return n ? s(Uint8Array.from([e.hasEvenY() ? 2 : 3]), o) : s(Uint8Array.from([4]), o, r.toBytes(i.y))
            },
            fromBytes(t) {
              const e = t.length,
                n = t[0],
                s = t.subarray(1);
              if (e !== i || 2 !== n && 3 !== n) {
                if (e === o && 4 === n) return {
                  x: r.fromBytes(s.subarray(0, r.BYTES)),
                  y: r.fromBytes(s.subarray(r.BYTES, 2 * r.BYTES))
                };
                throw Error(`Point of length ${e} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)
              } {
                const t = l_(s);
                if (! function(t) {
                    return t > H_ && t < r.ORDER
                  }(t)) throw Error("Point is not on curve");
                const e = f(t);
                let i = r.sqrt(e);
                return !(1 & ~n) != ((i & G_) === G_) && (i = r.neg(i)), {
                  x: t,
                  y: i
                }
              }
            }
          }), h = t => u_(d_(t, e.nByteLength));

          function d(t) {
            return t > n >> G_
          }
          const p = (t, e, r) => l_(t.slice(e, r));
          class b {
            constructor(t, e, r) {
              this.r = t, this.s = e, this.recovery = r, this.assertValidity()
            }
            static fromCompact(t) {
              const r = e.nByteLength;
              return t = b_("compactSignature", t, 2 * r), new b(p(t, 0, r), p(t, r, 2 * r))
            }
            static fromDER(t) {
              const {
                r: e,
                s: r
              } = z_.toSig(b_("DER", t));
              return new b(e, r)
            }
            assertValidity() {
              if (!l(this.r)) throw Error("r must be 0 < r < CURVE.n");
              if (!l(this.s)) throw Error("s must be 0 < s < CURVE.n")
            }
            addRecoveryBit(t) {
              return new b(this.r, this.s, t)
            }
            recoverPublicKey(t) {
              const {
                r: n,
                s: i,
                recovery: o
              } = this, c = v(b_("msgHash", t));
              if (null == o || ![0, 1, 2, 3].includes(o)) throw Error("recovery id invalid");
              const f = 2 === o || 3 === o ? n + e.n : n;
              if (f >= r.ORDER) throw Error("recovery id 2 or 3 invalid");
              const l = 1 & o ? "03" : "02",
                d = u.fromHex(l + h(f)),
                p = a(f),
                b = s(-c * p),
                m = s(i * p),
                y = u.BASE.multiplyAndAddUnsafe(d, b, m);
              if (!y) throw Error("point at infinify");
              return y.assertValidity(), y
            }
            hasHighS() {
              return d(this.s)
            }
            normalizeS() {
              return this.hasHighS() ? new b(this.r, s(-this.s), this.recovery) : this
            }
            toDERRawBytes() {
              return f_(this.toDERHex())
            }
            toDERHex() {
              return z_.hexFromSig({
                r: this.r,
                s: this.s
              })
            }
            toCompactRawBytes() {
              return f_(this.toCompactHex())
            }
            toCompactHex() {
              return h(this.r) + h(this.s)
            }
          }
          const m = {
            isValidPrivateKey(t) {
              try {
                return c(t), !0
              } catch {
                return !1
              }
            },
            normPrivateKeyToScalar: c,
            randomPrivateKey: () => {
              const t = __(e.n);
              return function(t, e, r = !1) {
                const n = t.length,
                  i = j_(e),
                  o = __(e);
                if (16 > n || o > n || n > 1024) throw Error(`expected ${o}-1024 bytes of input, got ${n}`);
                const s = B_(r ? l_(t) : h_(t), e - P_) + P_;
                return r ? p_(s, i) : d_(s, i)
              }(e.randomBytes(t), e.n)
            },
            precompute: (t = 8, e = u.BASE) => (e.zt(t), e.multiply(BigInt(3)), e)
          };

          function y(t) {
            const e = t instanceof Uint8Array,
              r = "string" == typeof t,
              n = (e || r) && t.length;
            return e ? n === i || n === o : r ? n === 2 * i || n === 2 * o : t instanceof u
          }
          const g = e.bits2int || function(t) {
              const r = l_(t),
                n = 8 * t.length - e.nBitLength;
              return n > 0 ? r >> BigInt(n) : r
            },
            v = e.bits2int_modN || function(t) {
              return s(g(t))
            },
            w = y_(e.nBitLength);

          function A(t) {
            if ("bigint" != typeof t) throw Error("bigint expected");
            if (H_ > t || t >= w) throw Error("bigint expected < 2^" + e.nBitLength);
            return d_(t, e.nByteLength)
          }
          const T = {
              lowS: e.lowS,
              prehash: !1
            },
            E = {
              lowS: e.lowS,
              prehash: !1
            };
          return u.BASE.zt(8), {
            CURVE: e,
            getPublicKey: function(t, e = !0) {
              return u.fromPrivateKey(t).toRawBytes(e)
            },
            getSharedSecret: function(t, e, r = !0) {
              if (y(t)) throw Error("first arg must be private key");
              if (!y(e)) throw Error("second arg must be public key");
              return u.fromHex(e).multiply(c(t)).toRawBytes(r)
            },
            sign: function(t, n, i = T) {
              const {
                seed: o,
                k2sig: f
              } = function(t, n, i = T) {
                if (["recovered", "canonical"].some(t => t in i)) throw Error("sign() legacy options not supported");
                const {
                  hash: o,
                  randomBytes: f
                } = e;
                let {
                  lowS: h,
                  prehash: p,
                  extraEntropy: m
                } = i;
                null == h && (h = !0), t = b_("msgHash", t), p && (t = b_("prehashed msgHash", o(t)));
                const y = v(t),
                  w = c(n),
                  E = [A(w), A(y)];
                if (null != m) {
                  const t = !0 === m ? f(r.BYTES) : m;
                  E.push(b_("extraEntropy", t))
                }
                const P = m_(...E),
                  k = y;
                return {
                  seed: P,
                  k2sig: function(t) {
                    const e = g(t);
                    if (!l(e)) return;
                    const r = a(e),
                      n = u.BASE.multiply(e).toAffine(),
                      i = s(n.x);
                    if (i === H_) return;
                    const o = s(r * s(k + i * w));
                    if (o === H_) return;
                    let c = (n.x === i ? 0 : 2) | +(n.y & G_),
                      f = o;
                    return h && d(o) && (f = function(t) {
                      return d(t) ? s(-t) : t
                    }(o), c ^= 1), new b(i, f, c)
                  }
                }
              }(t, n, i), h = e;
              return w_(h.hash.outputLen, h.nByteLength, h.hmac)(o, f)
            },
            verify: function(t, r, n, i = E) {
              const o = t;
              if (r = b_("msgHash", r), n = b_("publicKey", n), "strict" in i) throw Error("options.strict was renamed to lowS");
              const {
                lowS: c,
                prehash: f
              } = i;
              let l, h;
              try {
                if ("string" == typeof o || o instanceof Uint8Array) try {
                  l = b.fromDER(o)
                } catch (t) {
                  if (!(t instanceof z_.Err)) throw t;
                  l = b.fromCompact(o)
                } else {
                  if ("object" != typeof o || "bigint" != typeof o.r || "bigint" != typeof o.s) throw Error("PARSE");
                  {
                    const {
                      r: t,
                      s: e
                    } = o;
                    l = new b(t, e)
                  }
                }
                h = u.fromHex(n)
              } catch (t) {
                if ("PARSE" === t.message) throw Error("signature must be Signature instance, Uint8Array or hex string");
                return !1
              }
              if (c && l.hasHighS()) return !1;
              f && (r = e.hash(r));
              const {
                r: d,
                s: p
              } = l, m = v(r), y = a(p), g = s(m * y), w = s(d * y), A = u.BASE.multiplyAndAddUnsafe(h, g, w)?.toAffine();
              return !!A && s(A.x) === d
            },
            ProjectivePoint: u,
            Signature: b,
            utils: m
          }
        }({
          ...t,
          ...V_(e)
        });
        return Object.freeze({
          ...r(e),
          create: r
        })
      }({
        a: BigInt(0),
        b: BigInt(7),
        Fp: X_,
        n: q_,
        Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
        Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
        h: BigInt(1),
        lowS: !0,
        endo: {
          beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
          splitScalar: t => {
            const e = q_,
              r = BigInt("0x3086d221a7d46bcde86c90e49284eb15"),
              n = -J_ * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),
              i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),
              o = r,
              s = BigInt("0x100000000000000000000000000000000"),
              a = Q_(o * t, e),
              u = Q_(-n * t, e);
            let c = B_(t - a * r - u * i, e),
              f = B_(-a * n - u * o, e);
            const l = c > s,
              h = f > s;
            if (l && (c = e - c), h && (f = e - f), c > s || f > s) throw Error("splitScalar: Endomorphism failed, k=" + t);
            return {
              k1neg: l,
              k1: c,
              k2neg: h,
              k2: f
            }
          }
        }
      }, RN);
    BigInt(0), tD.ProjectivePoint;
    class eD {
      #t;
      constructor(t) {
        TR(32 === NR(t), "invalid private key", "privateKey", "[REDACTED]"), this.#t = CR(t)
      }
      get privateKey() {
        return this.#t
      }
      get publicKey() {
        return eD.computePublicKey(this.#t)
      }
      get compressedPublicKey() {
        return eD.computePublicKey(this.#t, !0)
      }
      sign(t) {
        TR(32 === NR(t), "invalid digest length", "digest", t);
        const e = tD.sign(OR(t), OR(this.#t), {
          lowS: !0
        });
        return oN.from({
          r: ZR(e.r, 32),
          s: ZR(e.s, 32),
          v: e.recovery ? 28 : 27
        })
      }
      computeSharedSecret(t) {
        const e = eD.computePublicKey(t);
        return CR(tD.getSharedSecret(OR(this.#t), SR(e), !1))
      }
      static computePublicKey(t, e) {
        let r = SR(t, "key");
        if (32 === r.length) return CR(tD.getPublicKey(r, !!e));
        if (64 === r.length) {
          const t = new Uint8Array(65);
          t[0] = 4, t.set(r, 1), r = t
        }
        return CR(tD.ProjectivePoint.fromHex(r).toRawBytes(e))
      }
      static recoverPublicKey(t, e) {
        TR(32 === NR(t), "invalid digest length", "digest", t);
        const r = oN.from(e);
        let n = tD.Signature.fromCompact(OR(RR([r.r, r.s])));
        n = n.addRecoveryBit(r.yParity);
        const i = n.recoverPublicKey(OR(t));
        return TR(null != i, "invalid signature for digest", "signature", e), "0x" + i.toHex(!1)
      }
      static addPoints(t, e, r) {
        const n = tD.ProjectivePoint.fromHex(eD.computePublicKey(t).substring(2)),
          i = tD.ProjectivePoint.fromHex(eD.computePublicKey(e).substring(2));
        return "0x" + n.add(i).toHex(!!r)
      }
    }

    function rD(t) {
      let e;
      return e = "string" == typeof t ? eD.computePublicKey(t, !1) : t.publicKey, n_(Cj("0x" + e.substring(4)).substring(26))
    }

    function nD(t, e) {
      return rD(eD.recoverPublicKey(t, e))
    }
    const iD = 32,
      oD = new Uint8Array(iD),
      sD = ["then"],
      aD = {},
      uD = new WeakMap;

    function cD(t) {
      return uD.get(t)
    }

    function fD(t, e) {
      uD.set(t, e)
    }

    function lD(t, e) {
      const r = Error("deferred error during ABI decoding triggered accessing " + t);
      throw r.error = e, r
    }

    function hD(t, e, r) {
      return 0 > t.indexOf(null) ? t.reduce((t, n, i) => {
        let o = e.getValue(n);
        return n in t || (r && o instanceof dD && (o = hD(cD(o), o, r)), t[n] = o), t
      }, {}) : e.map((t, e) => t instanceof dD ? hD(cD(t), t, r) : t)
    }
    class dD extends Array {
      #t;
      constructor(...t) {
        const e = t[0];
        let r = t[1],
          n = (t[2] || []).slice(),
          i = !0;
        e !== aD && (r = t, n = [], i = !1), super(r.length), r.forEach((t, e) => {
          this[e] = t
        });
        const o = n.reduce((t, e) => ("string" == typeof e && t.set(e, (t.get(e) || 0) + 1), t), new Map);
        if (fD(this, Object.freeze(r.map((t, e) => {
            const r = n[e];
            return null != r && 1 === o.get(r) ? r : null
          }))), this.#t = [], null == this.#t && this.#t, !i) return;
        Object.freeze(this);
        const s = new Proxy(this, {
          get: (t, e, r) => {
            if ("string" == typeof e) {
              if (e.match(/^[0-9]+$/)) {
                const r = VR(e, "%index");
                if (0 > r || r >= this.length) throw new RangeError("out of result range");
                const n = t[r];
                return n instanceof Error && lD("index " + r, n), n
              }
              if (sD.indexOf(e) >= 0) return Reflect.get(t, e, r);
              const n = t[e];
              if (n instanceof Function) return function(...e) {
                return n.apply(this === r ? t : this, e)
              };
              if (!(e in t)) return t.getValue.call(this === r ? t : this, e)
            }
            return Reflect.get(t, e, r)
          }
        });
        return fD(s, cD(this)), s
      }
      toArray(t) {
        const e = [];
        return this.forEach((r, n) => {
          r instanceof Error && lD("index " + n, r), t && r instanceof dD && (r = r.toArray(t)), e.push(r)
        }), e
      }
      toObject(t) {
        const e = cD(this);
        return e.reduce((r, n, i) => (AR(null != n, `value at index ${i} unnamed`, "UNSUPPORTED_OPERATION", {
          operation: "toObject()"
        }), hD(e, this, t)), {})
      }
      slice(t, e) {
        null == t && (t = 0), 0 > t && 0 > (t += this.length) && (t = 0), null == e && (e = this.length), 0 > e && 0 > (e += this.length) && (e = 0), e > this.length && (e = this.length);
        const r = cD(this),
          n = [],
          i = [];
        for (let o = t; e > o; o++) n.push(this[o]), i.push(r[o]);
        return new dD(aD, n, i)
      }
      filter(t, e) {
        const r = cD(this),
          n = [],
          i = [];
        for (let o = 0; o < this.length; o++) {
          const s = this[o];
          s instanceof Error && lD("index " + o, s), t.call(e, s, o, this) && (n.push(s), i.push(r[o]))
        }
        return new dD(aD, n, i)
      }
      map(t, e) {
        const r = [];
        for (let n = 0; n < this.length; n++) {
          const i = this[n];
          i instanceof Error && lD("index " + n, i), r.push(t.call(e, i, n, this))
        }
        return r
      }
      getValue(t) {
        const e = cD(this).indexOf(t);
        if (-1 === e) return;
        const r = this[e];
        return r instanceof Error && lD("property " + JSON.stringify(t), r.error), r
      }
      static fromItems(t, e) {
        return new dD(aD, t, e)
      }
    }

    function pD(t) {
      let e = qR(t);
      return AR(e.length <= iD, "value out-of-bounds", "BUFFER_OVERRUN", {
        buffer: e,
        length: iD,
        offset: e.length
      }), e.length !== iD && (e = OR(RR([oD.slice(e.length % iD), e]))), e
    }
    class bD {
      name;
      type;
      localName;
      dynamic;
      constructor(t, e, r, n) {
        yR(this, {
          name: t,
          type: e,
          localName: r,
          dynamic: n
        }, {
          name: "string",
          type: "string",
          localName: "string",
          dynamic: "boolean"
        })
      }
      xu(t, e) {
        TR(!1, t, this.localName, e)
      }
    }
    class mD {
      #t;
      #e;
      constructor() {
        this.#t = [], this.#e = 0
      }
      get data() {
        return RR(this.#t)
      }
      get length() {
        return this.#e
      }
      #r(t) {
        return this.#t.push(t), this.#e += t.length, t.length
      }
      appendWriter(t) {
        return this.#r(OR(t.data))
      }
      writeBytes(t) {
        let e = OR(t);
        const r = e.length % iD;
        return r && (e = OR(RR([e, oD.slice(r)]))), this.#r(e)
      }
      writeValue(t) {
        return this.#r(pD(t))
      }
      writeUpdatableValue() {
        const t = this.#t.length;
        return this.#t.push(oD), this.#e += iD, e => {
          this.#t[t] = pD(e)
        }
      }
    }
    class yD {
      allowLoose;
      #t;
      #e;
      #r;
      #n;
      #i;
      constructor(t, e, r) {
        yR(this, {
          allowLoose: !!e
        }), this.#t = OR(t), this.#r = 0, this.#n = null, this.#i = r ?? 1024, this.#e = 0
      }
      get data() {
        return CR(this.#t)
      }
      get dataLength() {
        return this.#t.length
      }
      get consumed() {
        return this.#e
      }
      get bytes() {
        return new Uint8Array(this.#t)
      }
      #o(t) {
        if (this.#n) return this.#n.#o(t);
        this.#r += t, AR(1 > this.#i || this.#r <= this.#i * this.dataLength, `compressed ABI data exceeds inflation ratio of ${this.#i} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
          buffer: OR(this.#t),
          offset: this.#e,
          length: t,
          info: {
            bytesRead: this.#r,
            dataLength: this.dataLength
          }
        })
      }
      #s(t, e, r) {
        let n = Math.ceil(e / iD) * iD;
        return this.#e + n > this.#t.length && (this.allowLoose && r && this.#e + e <= this.#t.length ? n = e : AR(!1, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: OR(this.#t),
          length: this.#t.length,
          offset: this.#e + n
        })), this.#t.slice(this.#e, this.#e + n)
      }
      subReader(t) {
        const e = new yD(this.#t.slice(this.#e + t), this.allowLoose, this.#i);
        return e.#n = this, e
      }
      readBytes(t, e) {
        let r = this.#s(0, t, !!e);
        return this.#o(t), this.#e += r.length, r.slice(0, t)
      }
      readValue() {
        return KR(this.readBytes(iD))
      }
      readIndex() {
        return function(t) {
          return VR(KR(t))
        }(this.readBytes(iD))
      }
    }
    const gD = {};

    function vD(t, e) {
      let r = !1;
      return 0 > e && (r = !0, e *= -1), new TD(gD, `${r?"":"u"}int${e}`, t, {
        signed: r,
        width: e
      })
    }

    function wD(t, e) {
      return new TD(gD, "bytes" + (e || ""), t, {
        size: e
      })
    }
    const AD = Symbol.for("_ethers_typed");
    class TD {
      type;
      value;
      #t;
      Iu;
      constructor(t, e, r, n) {
        null == n && (n = null), xR(gD, t, "Typed"), yR(this, {
          Iu: AD,
          type: e,
          value: r
        }), this.#t = n, this.format()
      }
      format() {
        if ("array" === this.type) throw Error("");
        if ("dynamicArray" === this.type) throw Error("");
        return "tuple" === this.type ? `tuple(${this.value.map(t=>t.format()).join(",")})` : this.type
      }
      defaultValue() {
        return 0
      }
      minValue() {
        return 0
      }
      maxValue() {
        return 0
      }
      isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/)
      }
      isData() {
        return this.type.startsWith("bytes")
      }
      isString() {
        return "string" === this.type
      }
      get tupleName() {
        if ("tuple" !== this.type) throw TypeError("not a tuple");
        return this.#t
      }
      get arrayLength() {
        if ("array" !== this.type) throw TypeError("not an array");
        return !0 === this.#t ? -1 : !1 === this.#t ? this.value.length : null
      }
      static from(t, e) {
        return new TD(gD, t, e)
      }
      static uint8(t) {
        return vD(t, 8)
      }
      static uint16(t) {
        return vD(t, 16)
      }
      static uint24(t) {
        return vD(t, 24)
      }
      static uint32(t) {
        return vD(t, 32)
      }
      static uint40(t) {
        return vD(t, 40)
      }
      static uint48(t) {
        return vD(t, 48)
      }
      static uint56(t) {
        return vD(t, 56)
      }
      static uint64(t) {
        return vD(t, 64)
      }
      static uint72(t) {
        return vD(t, 72)
      }
      static uint80(t) {
        return vD(t, 80)
      }
      static uint88(t) {
        return vD(t, 88)
      }
      static uint96(t) {
        return vD(t, 96)
      }
      static uint104(t) {
        return vD(t, 104)
      }
      static uint112(t) {
        return vD(t, 112)
      }
      static uint120(t) {
        return vD(t, 120)
      }
      static uint128(t) {
        return vD(t, 128)
      }
      static uint136(t) {
        return vD(t, 136)
      }
      static uint144(t) {
        return vD(t, 144)
      }
      static uint152(t) {
        return vD(t, 152)
      }
      static uint160(t) {
        return vD(t, 160)
      }
      static uint168(t) {
        return vD(t, 168)
      }
      static uint176(t) {
        return vD(t, 176)
      }
      static uint184(t) {
        return vD(t, 184)
      }
      static uint192(t) {
        return vD(t, 192)
      }
      static uint200(t) {
        return vD(t, 200)
      }
      static uint208(t) {
        return vD(t, 208)
      }
      static uint216(t) {
        return vD(t, 216)
      }
      static uint224(t) {
        return vD(t, 224)
      }
      static uint232(t) {
        return vD(t, 232)
      }
      static uint240(t) {
        return vD(t, 240)
      }
      static uint248(t) {
        return vD(t, 248)
      }
      static uint256(t) {
        return vD(t, 256)
      }
      static uint(t) {
        return vD(t, 256)
      }
      static int8(t) {
        return vD(t, -8)
      }
      static int16(t) {
        return vD(t, -16)
      }
      static int24(t) {
        return vD(t, -24)
      }
      static int32(t) {
        return vD(t, -32)
      }
      static int40(t) {
        return vD(t, -40)
      }
      static int48(t) {
        return vD(t, -48)
      }
      static int56(t) {
        return vD(t, -56)
      }
      static int64(t) {
        return vD(t, -64)
      }
      static int72(t) {
        return vD(t, -72)
      }
      static int80(t) {
        return vD(t, -80)
      }
      static int88(t) {
        return vD(t, -88)
      }
      static int96(t) {
        return vD(t, -96)
      }
      static int104(t) {
        return vD(t, -104)
      }
      static int112(t) {
        return vD(t, -112)
      }
      static int120(t) {
        return vD(t, -120)
      }
      static int128(t) {
        return vD(t, -128)
      }
      static int136(t) {
        return vD(t, -136)
      }
      static int144(t) {
        return vD(t, -144)
      }
      static int152(t) {
        return vD(t, -152)
      }
      static int160(t) {
        return vD(t, -160)
      }
      static int168(t) {
        return vD(t, -168)
      }
      static int176(t) {
        return vD(t, -176)
      }
      static int184(t) {
        return vD(t, -184)
      }
      static int192(t) {
        return vD(t, -192)
      }
      static int200(t) {
        return vD(t, -200)
      }
      static int208(t) {
        return vD(t, -208)
      }
      static int216(t) {
        return vD(t, -216)
      }
      static int224(t) {
        return vD(t, -224)
      }
      static int232(t) {
        return vD(t, -232)
      }
      static int240(t) {
        return vD(t, -240)
      }
      static int248(t) {
        return vD(t, -248)
      }
      static int256(t) {
        return vD(t, -256)
      }
      static int(t) {
        return vD(t, -256)
      }
      static bytes1(t) {
        return wD(t, 1)
      }
      static bytes2(t) {
        return wD(t, 2)
      }
      static bytes3(t) {
        return wD(t, 3)
      }
      static bytes4(t) {
        return wD(t, 4)
      }
      static bytes5(t) {
        return wD(t, 5)
      }
      static bytes6(t) {
        return wD(t, 6)
      }
      static bytes7(t) {
        return wD(t, 7)
      }
      static bytes8(t) {
        return wD(t, 8)
      }
      static bytes9(t) {
        return wD(t, 9)
      }
      static bytes10(t) {
        return wD(t, 10)
      }
      static bytes11(t) {
        return wD(t, 11)
      }
      static bytes12(t) {
        return wD(t, 12)
      }
      static bytes13(t) {
        return wD(t, 13)
      }
      static bytes14(t) {
        return wD(t, 14)
      }
      static bytes15(t) {
        return wD(t, 15)
      }
      static bytes16(t) {
        return wD(t, 16)
      }
      static bytes17(t) {
        return wD(t, 17)
      }
      static bytes18(t) {
        return wD(t, 18)
      }
      static bytes19(t) {
        return wD(t, 19)
      }
      static bytes20(t) {
        return wD(t, 20)
      }
      static bytes21(t) {
        return wD(t, 21)
      }
      static bytes22(t) {
        return wD(t, 22)
      }
      static bytes23(t) {
        return wD(t, 23)
      }
      static bytes24(t) {
        return wD(t, 24)
      }
      static bytes25(t) {
        return wD(t, 25)
      }
      static bytes26(t) {
        return wD(t, 26)
      }
      static bytes27(t) {
        return wD(t, 27)
      }
      static bytes28(t) {
        return wD(t, 28)
      }
      static bytes29(t) {
        return wD(t, 29)
      }
      static bytes30(t) {
        return wD(t, 30)
      }
      static bytes31(t) {
        return wD(t, 31)
      }
      static bytes32(t) {
        return wD(t, 32)
      }
      static address(t) {
        return new TD(gD, "address", t)
      }
      static bool(t) {
        return new TD(gD, "bool", !!t)
      }
      static bytes(t) {
        return new TD(gD, "bytes", t)
      }
      static string(t) {
        return new TD(gD, "string", t)
      }
      static array(t, e) {
        throw Error("not implemented yet")
      }
      static tuple(t, e) {
        throw Error("not implemented yet")
      }
      static overrides(t) {
        return new TD(gD, "overrides", Object.assign({}, t))
      }
      static isTyped(t) {
        return t && "object" == typeof t && "Iu" in t && t.Iu === AD
      }
      static dereference(t, e) {
        if (TD.isTyped(t)) {
          if (t.type !== e) throw Error(`invalid type: expecetd ${e}, got ${t.type}`);
          return t.value
        }
        return t
      }
    }
    class ED extends bD {
      constructor(t) {
        super("address", "address", t, !1)
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000"
      }
      encode(t, e) {
        let r = TD.dereference(e, "string");
        try {
          r = n_(r)
        } catch (t) {
          return this.xu(t.message, e)
        }
        return t.writeValue(r)
      }
      decode(t) {
        return n_(ZR(t.readValue(), 20))
      }
    }
    class PD extends bD {
      coder;
      constructor(t) {
        super(t.name, t.type, "_", t.dynamic), this.coder = t
      }
      defaultValue() {
        return this.coder.defaultValue()
      }
      encode(t, e) {
        return this.coder.encode(t, e)
      }
      decode(t) {
        return this.coder.decode(t)
      }
    }

    function kD(t, e, r) {
      let n = [];
      if (Array.isArray(r)) n = r;
      else if (r && "object" == typeof r) {
        let t = {};
        n = e.map(e => {
          const n = e.localName;
          return AR(n, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", {
            argument: "values",
            info: {
              coder: e
            },
            value: r
          }), AR(!t[n], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", {
            argument: "values",
            info: {
              coder: e
            },
            value: r
          }), t[n] = !0, r[n]
        })
      } else TR(!1, "invalid tuple value", "tuple", r);
      TR(e.length === n.length, "types/value length mismatch", "tuple", r);
      let i = new mD,
        o = new mD,
        s = [];
      e.forEach((t, e) => {
        let r = n[e];
        if (t.dynamic) {
          let e = o.length;
          t.encode(o, r);
          let n = i.writeUpdatableValue();
          s.push(t => {
            n(t + e)
          })
        } else t.encode(i, r)
      }), s.forEach(t => {
        t(i.length)
      });
      let a = t.appendWriter(i);
      return a += t.appendWriter(o), a
    }

    function xD(t, e) {
      let r = [],
        n = [],
        i = t.subReader(0);
      return e.forEach(e => {
        let o = null;
        if (e.dynamic) {
          let r = t.readIndex(),
            n = i.subReader(r);
          try {
            o = e.decode(n)
          } catch (t) {
            if (vR(t, "BUFFER_OVERRUN")) throw t;
            o = t, o.baseType = e.name, o.name = e.localName, o.type = e.type
          }
        } else try {
          o = e.decode(t)
        } catch (t) {
          if (vR(t, "BUFFER_OVERRUN")) throw t;
          o = t, o.baseType = e.name, o.name = e.localName, o.type = e.type
        }
        if (null == o) throw Error("investigate");
        r.push(o), n.push(e.localName || null)
      }), dD.fromItems(r, n)
    }
    class ID extends bD {
      coder;
      length;
      constructor(t, e, r) {
        super("array", t.type + "[" + (0 > e ? "" : e) + "]", r, -1 === e || t.dynamic), yR(this, {
          coder: t,
          length: e
        })
      }
      defaultValue() {
        const t = this.coder.defaultValue(),
          e = [];
        for (let r = 0; r < this.length; r++) e.push(t);
        return e
      }
      encode(t, e) {
        const r = TD.dereference(e, "array");
        Array.isArray(r) || this.xu("expected array value", r);
        let n = this.length; - 1 === n && (n = r.length, t.writeValue(r.length)), ER(r.length, n, "coder array" + (this.localName ? " " + this.localName : ""));
        let i = [];
        for (let t = 0; t < r.length; t++) i.push(this.coder);
        return kD(t, i, r)
      }
      decode(t) {
        let e = this.length; - 1 === e && (e = t.readIndex(), AR(e * iD <= t.dataLength, "insufficient data length", "BUFFER_OVERRUN", {
          buffer: t.bytes,
          offset: e * iD,
          length: t.dataLength
        }));
        let r = [];
        for (let t = 0; e > t; t++) r.push(new PD(this.coder));
        return xD(t, r)
      }
    }
    class SD extends bD {
      constructor(t) {
        super("bool", "bool", t, !1)
      }
      defaultValue() {
        return !1
      }
      encode(t, e) {
        const r = TD.dereference(e, "bool");
        return t.writeValue(r ? 1 : 0)
      }
      decode(t) {
        return !!t.readValue()
      }
    }
    class OD extends bD {
      constructor(t, e) {
        super(t, t, e, !0)
      }
      defaultValue() {
        return "0x"
      }
      encode(t, e) {
        e = OR(e);
        let r = t.writeValue(e.length);
        return r += t.writeBytes(e), r
      }
      decode(t) {
        return t.readBytes(t.readIndex(), !0)
      }
    }
    class BD extends OD {
      constructor(t) {
        super("bytes", t)
      }
      decode(t) {
        return CR(super.decode(t))
      }
    }
    class WD extends bD {
      size;
      constructor(t, e) {
        let r = "bytes" + t;
        super(r, r, e, !1), yR(this, {
          size: t
        }, {
          size: "number"
        })
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size)
      }
      encode(t, e) {
        let r = OR(TD.dereference(e, this.type));
        return r.length !== this.size && this.xu("incorrect data length", e), t.writeBytes(r)
      }
      decode(t) {
        return CR(t.readBytes(this.size))
      }
    }
    const MD = new Uint8Array([]);
    class CD extends bD {
      constructor(t) {
        super("null", "", t, !1)
      }
      defaultValue() {
        return null
      }
      encode(t, e) {
        return null != e && this.xu("not null", e), t.writeBytes(MD)
      }
      decode(t) {
        return t.readBytes(0), null
      }
    }
    const RD = BigInt(0),
      ND = BigInt(1),
      jD = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    class _D extends bD {
      size;
      signed;
      constructor(t, e, r) {
        const n = (e ? "int" : "uint") + 8 * t;
        super(n, n, r, !1), yR(this, {
          size: t,
          signed: e
        }, {
          size: "number",
          signed: "boolean"
        })
      }
      defaultValue() {
        return 0
      }
      encode(t, e) {
        let r = zR(TD.dereference(e, this.type)),
          n = $R(jD, 256);
        if (this.signed) {
          let t = $R(n, 8 * this.size - 1);
          (r > t || -(t + ND) > r) && this.xu("value out-of-bounds", e), r = FR(r, 256)
        } else(RD > r || r > $R(n, 8 * this.size)) && this.xu("value out-of-bounds", e);
        return t.writeValue(r)
      }
      decode(t) {
        let e = $R(t.readValue(), 8 * this.size);
        return this.signed && (e = function(t, e) {
          const r = HR(t, "value"),
            n = BigInt(VR(e, "width"));
          return AR(r >> n === DR, "overflow", "NUMERIC_FAULT", {
            operation: "fromTwos",
            fault: "overflow",
            value: t
          }), r >> n - UR ? -((~r & (UR << n) - UR) + UR) : r
        }(e, 8 * this.size)), e
      }
    }
    class DD extends OD {
      constructor(t) {
        super("string", t)
      }
      defaultValue() {
        return ""
      }
      encode(t, e) {
        return super.encode(t, dj(TD.dereference(e, "string")))
      }
      decode(t) {
        return pj(super.decode(t))
      }
    }
    class UD extends bD {
      coders;
      constructor(t, e) {
        let r = !1;
        const n = [];
        t.forEach(t => {
          t.dynamic && (r = !0), n.push(t.type)
        }), super("tuple", "tuple(" + n.join(",") + ")", e, r), yR(this, {
          coders: Object.freeze(t.slice())
        })
      }
      defaultValue() {
        const t = [];
        this.coders.forEach(e => {
          t.push(e.defaultValue())
        });
        const e = this.coders.reduce((t, e) => {
          const r = e.localName;
          return r && (t[r] || (t[r] = 0), t[r]++), t
        }, {});
        return this.coders.forEach((r, n) => {
          let i = r.localName;
          !i || 1 !== e[i] || ("length" === i && (i = "_length"), null == t[i] && (t[i] = t[n]))
        }), Object.freeze(t)
      }
      encode(t, e) {
        const r = TD.dereference(e, "tuple");
        return kD(t, this.coders, r)
      }
      decode(t) {
        return xD(t, this.coders)
      }
    }

    function LD(t) {
      const e = new Set;
      return t.forEach(t => e.add(t)), Object.freeze(e)
    }
    LD("external public payable override".split(" "));
    const FD = "constant external internal payable private public pure view override",
      $D = (LD(FD.split(" ")), "constructor error event fallback function receive struct"),
      zD = (LD($D.split(" ")), "calldata memory storage payable indexed"),
      HD = LD(zD.split(" ")),
      GD = LD([$D, zD, "tuple returns", FD].join(" ").split(" ")),
      KD = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
      },
      VD = RegExp("^(\\s*)"),
      ZD = RegExp("^([0-9]+)"),
      qD = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
      JD = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
      YD = RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
    class QD {
      #t;
      #e;
      get offset() {
        return this.#t
      }
      get length() {
        return this.#e.length - this.#t
      }
      constructor(t) {
        this.#t = 0, this.#e = t.slice()
      }
      clone() {
        return new QD(this.#e)
      }
      reset() {
        this.#t = 0
      }
      #r(t = 0, e = 0) {
        return new QD(this.#e.slice(t, e).map(e => Object.freeze(Object.assign({}, e, {
          match: e.match - t,
          linkBack: e.linkBack - t,
          linkNext: e.linkNext - t
        }))))
      }
      popKeyword(t) {
        const e = this.peek();
        if ("KEYWORD" !== e.type || !t.has(e.text)) throw Error("expected keyword " + e.text);
        return this.pop().text
      }
      popType(t) {
        if (this.peek().type !== t) {
          const e = this.peek();
          throw Error(`expected ${t}; got ${e.type} ${JSON.stringify(e.text)}`)
        }
        return this.pop().text
      }
      popParen() {
        const t = this.peek();
        if ("OPEN_PAREN" !== t.type) throw Error("bad start");
        const e = this.#r(this.#t + 1, t.match + 1);
        return this.#t = t.match + 1, e
      }
      popParams() {
        const t = this.peek();
        if ("OPEN_PAREN" !== t.type) throw Error("bad start");
        const e = [];
        for (; this.#t < t.match - 1;) {
          const t = this.peek().linkNext;
          e.push(this.#r(this.#t + 1, t)), this.#t = t
        }
        return this.#t = t.match + 1, e
      }
      peek() {
        if (this.#t >= this.#e.length) throw Error("out-of-bounds");
        return this.#e[this.#t]
      }
      peekKeyword(t) {
        const e = this.peekType("KEYWORD");
        return null != e && t.has(e) ? e : null
      }
      peekType(t) {
        if (0 === this.length) return null;
        const e = this.peek();
        return e.type === t ? e.text : null
      }
      pop() {
        const t = this.peek();
        return this.#t++, t
      }
      toString() {
        const t = [];
        for (let e = this.#t; e < this.#e.length; e++) {
          const r = this.#e[e];
          t.push(`${r.type}:${r.text}`)
        }
        return `<TokenString ${t.join(" ")}>`
      }
    }

    function XD(t, e) {
      const r = new Set;
      for (;;) {
        const n = t.peekType("KEYWORD");
        if (null == n || e && !e.has(n)) break;
        if (t.pop(), r.has(n)) throw Error("duplicate keywords: " + JSON.stringify(n));
        r.add(n)
      }
      return Object.freeze(r)
    }
    const tU = RegExp(/^(.*)\[([0-9]*)\]$/);

    function eU(t) {
      const e = t.match(YD);
      if (TR(e, "invalid type", "type", t), "uint" === t) return "uint256";
      if ("int" === t) return "int256";
      if (e[2]) {
        const r = parseInt(e[2]);
        TR(0 !== r && 32 >= r, "invalid bytes length", "type", t)
      } else if (e[3]) {
        const r = parseInt(e[3]);
        TR(0 !== r && 256 >= r && r % 8 == 0, "invalid numeric width", "type", t)
      }
      return t
    }
    const rU = {},
      nU = Symbol.for("_ethers_internal"),
      iU = "_ParamTypeInternal";
    class oU {
      name;
      type;
      baseType;
      indexed;
      components;
      arrayLength;
      arrayChildren;
      constructor(t, e, r, n, i, o, s, a) {
        if (xR(t, rU, "ParamType"), Object.defineProperty(this, nU, {
            value: iU
          }), o && (o = Object.freeze(o.slice())), "array" === n) {
          if (null == s || null == a) throw Error("")
        } else if (null != s || null != a) throw Error("");
        if ("tuple" === n) {
          if (null == o) throw Error("")
        } else if (null != o) throw Error("");
        yR(this, {
          name: e,
          type: r,
          baseType: n,
          indexed: i,
          components: o,
          arrayLength: s,
          arrayChildren: a
        })
      }
      format(t) {
        if (null == t && (t = "sighash"), "json" === t) {
          const e = this.name || "";
          if (this.isArray()) {
            const t = JSON.parse(this.arrayChildren.format("json"));
            return t.name = e, t.type += `[${0>this.arrayLength?"":this.arrayLength+""}]`, JSON.stringify(t)
          }
          const r = {
            type: "tuple" === this.baseType ? "tuple" : this.type,
            name: e
          };
          return "boolean" == typeof this.indexed && (r.indexed = this.indexed), this.isTuple() && (r.components = this.components.map(e => JSON.parse(e.format(t)))), JSON.stringify(r)
        }
        let e = "";
        return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${0>this.arrayLength?"":this.arrayLength+""}]`) : this.isTuple() ? e += "(" + this.components.map(e => e.format(t)).join("full" === t ? ", " : ",") + ")" : e += this.type, "sighash" !== t && (!0 === this.indexed && (e += " indexed"), "full" === t && this.name && (e += " " + this.name)), e
      }
      isArray() {
        return "array" === this.baseType
      }
      isTuple() {
        return "tuple" === this.baseType
      }
      isIndexable() {
        return null != this.indexed
      }
      walk(t, e) {
        if (this.isArray()) {
          if (!Array.isArray(t)) throw Error("invalid array value");
          if (-1 !== this.arrayLength && t.length !== this.arrayLength) throw Error("array is wrong length");
          const r = this;
          return t.map(t => r.arrayChildren.walk(t, e))
        }
        if (this.isTuple()) {
          if (!Array.isArray(t)) throw Error("invalid tuple value");
          if (t.length !== this.components.length) throw Error("array is wrong length");
          const r = this;
          return t.map((t, n) => r.components[n].walk(t, e))
        }
        return e(this.type, t)
      }
      #t(t, e, r, n) {
        if (this.isArray()) {
          if (!Array.isArray(e)) throw Error("invalid array value");
          if (-1 !== this.arrayLength && e.length !== this.arrayLength) throw Error("array is wrong length");
          const i = this.arrayChildren,
            o = e.slice();
          return o.forEach((e, n) => {
            i.#t(t, e, r, t => {
              o[n] = t
            })
          }), void n(o)
        }
        if (this.isTuple()) {
          const i = this.components;
          let o;
          if (Array.isArray(e)) o = e.slice();
          else {
            if (null == e || "object" != typeof e) throw Error("invalid tuple value");
            o = i.map(t => {
              if (!t.name) throw Error("cannot use object value with unnamed components");
              if (!(t.name in e)) throw Error("missing value for component " + t.name);
              return e[t.name]
            })
          }
          if (o.length !== this.components.length) throw Error("array is wrong length");
          return o.forEach((e, n) => {
            i[n].#t(t, e, r, t => {
              o[n] = t
            })
          }), void n(o)
        }
        const i = r(this.type, e);
        i.then ? t.push(async function() {
          n(await i)
        }()) : n(i)
      }
      async walkAsync(t, e) {
        const r = [],
          n = [t];
        return this.#t(r, t, e, t => {
          n[0] = t
        }), r.length && await Promise.all(r), n[0]
      }
      static from(t, e) {
        if (oU.isParamType(t)) return t;
        if ("string" == typeof t) try {
          return oU.from(function(t) {
            const e = [],
              r = e => {
                const r = o < t.length ? JSON.stringify(t[o]) : "$EOI";
                throw Error(`invalid token ${r} at ${o}: ${e}`)
              };
            let n = [],
              i = [],
              o = 0;
            for (; o < t.length;) {
              let s = t.substring(o),
                a = s.match(VD);
              a && (o += a[1].length, s = t.substring(o));
              const u = {
                depth: n.length,
                linkBack: -1,
                linkNext: -1,
                match: -1,
                type: "",
                text: "",
                offset: o,
                value: -1
              };
              e.push(u);
              let c = KD[s[0]] || "";
              if (c) {
                if (u.type = c, u.text = s[0], o++, "OPEN_PAREN" === c) n.push(e.length - 1), i.push(e.length - 1);
                else if ("CLOSE_PAREN" == c) 0 === n.length && r("no matching open bracket"), u.match = n.pop(), e[u.match].match = e.length - 1, u.depth--, u.linkBack = i.pop(), e[u.linkBack].linkNext = e.length - 1;
                else if ("COMMA" === c) u.linkBack = i.pop(), e[u.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
                else if ("OPEN_BRACKET" === c) u.type = "BRACKET";
                else if ("CLOSE_BRACKET" === c) {
                  let t = e.pop().text;
                  if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
                    const r = e.pop().text;
                    t = r + t, e[e.length - 1].value = VR(r)
                  }
                  if (0 === e.length || "BRACKET" !== e[e.length - 1].type) throw Error("missing opening bracket");
                  e[e.length - 1].text += t
                }
              } else if (a = s.match(qD), a) {
                if (u.text = a[1], o += u.text.length, GD.has(u.text)) {
                  u.type = "KEYWORD";
                  continue
                }
                if (u.text.match(YD)) {
                  u.type = "TYPE";
                  continue
                }
                u.type = "ID"
              } else {
                if (a = s.match(ZD), !a) throw Error(`unexpected token ${JSON.stringify(s[0])} at position ${o}`);
                u.text = a[1], u.type = "NUMBER", o += u.text.length
              }
            }
            return new QD(e.map(t => Object.freeze(t)))
          }(t), e)
        } catch {
          TR(!1, "invalid param type", "obj", t)
        } else if (t instanceof QD) {
          let r = "",
            n = "",
            i = null;
          XD(t, LD(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (n = "tuple", i = t.popParams().map(t => oU.from(t)), r = `tuple(${i.map(t=>t.format()).join(",")})`) : (r = eU(t.popType("TYPE")), n = r);
          let o = null,
            s = null;
          for (; t.length && t.peekType("BRACKET");) {
            const e = t.pop();
            o = new oU(rU, "", r, n, null, i, s, o), s = e.value, r += e.text, n = "array", i = null
          }
          let a = null;
          if (XD(t, HD).has("indexed")) {
            if (!e) throw Error("");
            a = !0
          }
          const u = t.peekType("ID") ? t.pop().text : "";
          if (t.length) throw Error("leftover tokens");
          return new oU(rU, u, r, n, a, i, s, o)
        } const r = t.name;
        TR(!r || "string" == typeof r && r.match(JD), "invalid name", "obj.name", r);
        let n = t.indexed;
        null != n && (TR(e, "parameter cannot be indexed", "obj.indexed", t.indexed), n = !!n);
        let i = t.type,
          o = i.match(tU);
        if (o) {
          const e = parseInt(o[2] || "-1"),
            s = oU.from({
              type: o[1],
              components: t.components
            });
          return new oU(rU, r || "", i, "array", n, null, e, s)
        }
        if ("tuple" === i || i.startsWith("tuple(") || i.startsWith("(")) {
          const e = null != t.components ? t.components.map(t => oU.from(t)) : null;
          return new oU(rU, r || "", i, "tuple", n, e, null, null)
        }
        return i = eU(t.type), new oU(rU, r || "", i, i, n, null, null, null)
      }
      static isParamType(t) {
        return t && t[nU] === iU
      }
    }
    const sU = new Map;
    sU.set(0, "GENERIC_PANIC"), sU.set(1, "ASSERT_FALSE"), sU.set(17, "OVERFLOW"), sU.set(18, "DIVIDE_BY_ZERO"), sU.set(33, "ENUM_RANGE_ERROR"), sU.set(34, "BAD_STORAGE_DATA"), sU.set(49, "STACK_UNDERFLOW"), sU.set(50, "ARRAY_RANGE_ERROR"), sU.set(65, "OUT_OF_MEMORY"), sU.set(81, "UNINITIALIZED_FUNCTION_CALL");
    const aU = RegExp(/^bytes([0-9]*)$/),
      uU = RegExp(/^(u?int)([0-9]*)$/);
    let cU = null,
      fU = 1024;
    class lU {
      #t(t) {
        if (t.isArray()) return new ID(this.#t(t.arrayChildren), t.arrayLength, t.name);
        if (t.isTuple()) return new UD(t.components.map(t => this.#t(t)), t.name);
        switch (t.baseType) {
          case "address":
            return new ED(t.name);
          case "bool":
            return new SD(t.name);
          case "string":
            return new DD(t.name);
          case "bytes":
            return new BD(t.name);
          case "":
            return new CD(t.name)
        }
        let e = t.type.match(uU);
        if (e) {
          let r = parseInt(e[2] || "256");
          return TR(0 !== r && 256 >= r && r % 8 == 0, "invalid " + e[1] + " bit length", "param", t), new _D(r / 8, "int" === e[1], t.name)
        }
        if (e = t.type.match(aU), e) {
          let r = parseInt(e[1]);
          return TR(0 !== r && 32 >= r, "invalid bytes length", "param", t), new WD(r, t.name)
        }
        TR(!1, "invalid type", "type", t.type)
      }
      getDefaultValue(t) {
        const e = t.map(t => this.#t(oU.from(t)));
        return new UD(e, "_").defaultValue()
      }
      encode(t, e) {
        ER(e.length, t.length, "types/values length mismatch");
        const r = t.map(t => this.#t(oU.from(t))),
          n = new UD(r, "_"),
          i = new mD;
        return n.encode(i, e), i.data
      }
      decode(t, e, r) {
        const n = t.map(t => this.#t(oU.from(t)));
        return new UD(n, "_").decode(new yD(e, r, fU))
      }
      static Su(t) {
        TR("number" == typeof t && Number.isInteger(t), "invalid defaultMaxInflation factor", "value", t), fU = t
      }
      static defaultAbiCoder() {
        return null == cU && (cU = new lU), cU
      }
      static getBuiltinCallException(t, e, r) {
        return function(t, e, r, n) {
          let i = "missing revert data",
            o = null,
            s = null;
          if (r) {
            i = "execution reverted";
            const t = SR(r);
            if (r = CR(r), 0 === t.length) i += " (no data present; likely require(false) occurred", o = "require(false)";
            else if (t.length % 32 != 4) i += " (could not decode reason; invalid data length)";
            else if ("0x08c379a0" === CR(t.slice(0, 4))) try {
              o = n.decode(["string"], t.slice(4))[0], s = {
                signature: "Error(string)",
                name: "Error",
                args: [o]
              }, i += ": " + JSON.stringify(o)
            } catch {
              i += " (could not decode reason; invalid string data)"
            } else if ("0x4e487b71" === CR(t.slice(0, 4))) try {
              const e = +n.decode(["uint256"], t.slice(4))[0];
              s = {
                signature: "Panic(uint256)",
                name: "Panic",
                args: [e]
              }, o = `Panic due to ${sU.get(e)||"UNKNOWN"}(${e})`, i += ": " + o
            } catch {
              i += " (could not decode panic code)"
            } else i += " (unknown custom error)"
          }
          const a = {
            to: e.to ? n_(e.to) : null,
            data: e.data || "0x"
          };
          return e.from && (a.from = n_(e.from)), wR(i, "CALL_EXCEPTION", {
            action: t,
            data: r,
            reason: o,
            transaction: a,
            invocation: null,
            revert: s
          })
        }(t, e, r, lU.defaultAbiCoder())
      }
    }
    const hU = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]),
      dU = Uint8Array.from({
        length: 16
      }, (t, e) => e),
      pU = dU.map(t => (9 * t + 5) % 16);
    let bU = [dU],
      mU = [pU];
    for (let t = 0; 4 > t; t++)
      for (let e of [bU, mU]) e.push(e[t].map(t => hU[t]));
    const yU = [
        [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
        [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
        [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
        [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
        [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
      ].map(t => new Uint8Array(t)),
      gU = bU.map((t, e) => t.map(t => yU[e][t])),
      vU = mU.map((t, e) => t.map(t => yU[e][t])),
      wU = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]),
      AU = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]),
      TU = (t, e) => t << e | t >>> 32 - e;

    function EU(t, e, r, n) {
      return 0 === t ? e ^ r ^ n : 1 === t ? e & r | ~e & n : 2 === t ? (e | ~r) ^ n : 3 === t ? e & n | r & ~n : e ^ (r | ~n)
    }
    const PU = new Uint32Array(16);
    class kU extends IN {
      constructor() {
        super(64, 20, 8, !0), this.h0 = 1732584193, this.h1 = -271733879, this.h2 = -1732584194, this.h3 = 271733878, this.h4 = -1009589776
      }
      get() {
        const {
          h0: t,
          h1: e,
          h2: r,
          h3: n,
          h4: i
        } = this;
        return [t, e, r, n, i]
      }
      set(t, e, r, n, i) {
        this.h0 = 0 | t, this.h1 = 0 | e, this.h2 = 0 | r, this.h3 = 0 | n, this.h4 = 0 | i
      }
      process(t, e) {
        for (let r = 0; 16 > r; r++, e += 4) PU[r] = t.getUint32(e, !0);
        let r = 0 | this.h0,
          n = r,
          i = 0 | this.h1,
          o = i,
          s = 0 | this.h2,
          a = s,
          u = 0 | this.h3,
          c = u,
          f = 0 | this.h4,
          l = f;
        for (let t = 0; 5 > t; t++) {
          const e = 4 - t,
            h = wU[t],
            d = AU[t],
            p = bU[t],
            b = mU[t],
            m = gU[t],
            y = vU[t];
          for (let e = 0; 16 > e; e++) {
            const n = TU(r + EU(t, i, s, u) + PU[p[e]] + h, m[e]) + f | 0;
            r = f, f = u, u = 0 | TU(s, 10), s = i, i = n
          }
          for (let t = 0; 16 > t; t++) {
            const r = TU(n + EU(e, o, a, c) + PU[b[t]] + d, y[t]) + l | 0;
            n = l, l = c, c = 0 | TU(a, 10), a = o, o = r
          }
        }
        this.set(this.h1 + s + c | 0, this.h2 + u + l | 0, this.h3 + f + n | 0, this.h4 + r + o | 0, this.h0 + i + a | 0)
      }
      roundClean() {
        PU.fill(0)
      }
      destroy() {
        this.destroyed = !0, this.buffer.fill(0), this.set(0, 0, 0, 0, 0)
      }
    }
    const xU = TN(() => new kU);
    let IU = !1;
    const SU = function(t) {
      return xU(t)
    };
    let OU = SU;

    function BU(t) {
      const e = SR(t, "data");
      return CR(OU(e))
    }
    BU.Pu = SU, BU.lock = function() {
      IU = !0
    }, BU.register = function(t) {
      if (IU) throw new TypeError("ripemd160 is locked");
      OU = t
    }, Object.freeze(BU);
    let WU = !1;
    const MU = function(t) {
      return new Uint8Array(function(t) {
        AR(null != YN, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
          operation: "randomBytes"
        }), TR(Number.isInteger(t) && t > 0 && 1024 >= t, "invalid length", "length", t);
        const e = new Uint8Array(t);
        return YN.getRandomValues(e), e
      }(t))
    };
    let CU = MU;

    function RU(t) {
      return CU(t)
    }
    async function NU(t, e) {
      const r = await e;
      return (null == r || "0x0000000000000000000000000000000000000000" === r) && (AR("string" != typeof t, "unconfigured name", "UNCONFIGURED_NAME", {
        value: t
      }), TR(!1, "invalid AddressLike value; did not resolve to a value address", "target", t)), n_(r)
    }

    function jU(t, e) {
      return "string" == typeof t ? t.match(/^0x[0-9a-f]{40}$/i) ? n_(t) : (AR(null != e, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName"
      }), NU(t, e.resolveName(t))) : function(t) {
        return t && "function" == typeof t.getAddress
      }(t) ? NU(t, t.getAddress()) : t && "function" == typeof t.then ? NU(t, t) : void TR(!1, "unsupported addressable value", "target", t)
    }
    RU.Pu = MU, RU.lock = function() {
      WU = !0
    }, RU.register = function(t) {
      if (WU) throw Error("randomBytes is locked");
      CU = t
    }, Object.freeze(RU);
    const _U = "0x0000000000000000000000000000000000000000";

    function DU(t) {
      let e = t.toString(16);
      for (; 2 > e.length;) e = "0" + e;
      return "0x" + e
    }

    function UU(t, e, r) {
      let n = 0;
      for (let i = 0; r > i; i++) n = 256 * n + t[e + i];
      return n
    }

    function LU(t, e, r, n) {
      const i = [];
      for (; e + 1 + n > r;) {
        const o = FU(t, r);
        i.push(o.result), AR(e + 1 + n >= (r += o.consumed), "child data too short", "BUFFER_OVERRUN", {
          buffer: t,
          length: n,
          offset: e
        })
      }
      return {
        consumed: 1 + n,
        result: i
      }
    }

    function FU(t, e) {
      AR(0 !== t.length, "data too short", "BUFFER_OVERRUN", {
        buffer: t,
        length: 0,
        offset: 1
      });
      const r = e => {
        AR(e <= t.length, "data short segment too short", "BUFFER_OVERRUN", {
          buffer: t,
          length: t.length,
          offset: e
        })
      };
      if (t[e] >= 248) {
        const n = t[e] - 247;
        r(e + 1 + n);
        const i = UU(t, e + 1, n);
        return r(e + 1 + n + i), LU(t, e, e + 1 + n, n + i)
      }
      if (t[e] >= 192) {
        const n = t[e] - 192;
        return r(e + 1 + n), LU(t, e, e + 1, n)
      }
      if (t[e] >= 184) {
        const n = t[e] - 183;
        r(e + 1 + n);
        const i = UU(t, e + 1, n);
        return r(e + 1 + n + i), {
          consumed: 1 + n + i,
          result: CR(t.slice(e + 1 + n, e + 1 + n + i))
        }
      }
      if (t[e] >= 128) {
        const n = t[e] - 128;
        return r(e + 1 + n), {
          consumed: 1 + n,
          result: CR(t.slice(e + 1, e + 1 + n))
        }
      }
      return {
        consumed: 1,
        result: DU(t[e])
      }
    }

    function $U(t) {
      const e = SR(t, "data"),
        r = FU(e, 0);
      return TR(r.consumed === e.length, "unexpected junk after rlp payload", "data", t), r.result
    }

    function zU(t) {
      const e = [];
      for (; t;) e.unshift(255 & t), t >>= 8;
      return e
    }

    function HU(t) {
      if (Array.isArray(t)) {
        let e = [];
        if (t.forEach(function(t) {
            e = e.concat(HU(t))
          }), 55 >= e.length) return e.unshift(192 + e.length), e;
        const r = zU(e.length);
        return r.unshift(247 + r.length), r.concat(e)
      }
      const e = [].slice.call(SR(t, "object"));
      if (1 === e.length && 127 >= e[0]) return e;
      if (55 >= e.length) return e.unshift(128 + e.length), e;
      const r = zU(e.length);
      return r.unshift(183 + r.length), r.concat(e)
    }
    const GU = "0123456789abcdef";

    function KU(t) {
      let e = "0x";
      for (const r of HU(t)) e += GU[r >> 4], e += GU[15 & r];
      return e
    }

    function VU(t, e) {
      return {
        address: n_(t),
        storageKeys: e.map((t, e) => (TR(BR(t, 32), "invalid slot", `storageKeys[${e}]`, t), t.toLowerCase()))
      }
    }

    function ZU(t) {
      if (Array.isArray(t)) return t.map((e, r) => Array.isArray(e) ? (TR(2 === e.length, "invalid slot set", `value[${r}]`, e), VU(e[0], e[1])) : (TR(null != e && "object" == typeof e, "invalid address-slot set", "value", t), VU(e.address, e.storageKeys)));
      TR(null != t && "object" == typeof t, "invalid access list", "value", t);
      const e = Object.keys(t).map(e => {
        const r = t[e].reduce((t, e) => (t[e] = !0, t), {});
        return VU(e, Object.keys(r).sort())
      });
      return e.sort((t, e) => t.address.localeCompare(e.address)), e
    }
    const qU = BigInt(0),
      JU = BigInt(2),
      YU = BigInt(27),
      QU = BigInt(28),
      XU = BigInt(35),
      tL = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
      eL = 131072;

    function rL(t, e) {
      let r = t.toString(16);
      for (; 2 > r.length;) r = "0" + r;
      return r += oj(e).substring(4), "0x" + r
    }

    function nL(t) {
      return "0x" === t ? null : n_(t)
    }

    function iL(t, e) {
      try {
        return ZU(t)
      } catch (r) {
        TR(!1, r.message, e, t)
      }
    }

    function oL(t, e) {
      try {
        if (!Array.isArray(t)) throw Error("authorizationList: invalid array");
        const e = [];
        for (let r = 0; r < t.length; r++) {
          const n = t[r];
          if (!Array.isArray(n)) throw Error(`authorization[${r}]: invalid array`);
          if (6 !== n.length) throw Error(`authorization[${r}]: wrong length`);
          if (!n[1]) throw Error(`authorization[${r}]: null address`);
          e.push({
            address: nL(n[1]),
            nonce: aL(n[2], "nonce"),
            chainId: aL(n[0], "chainId"),
            signature: oN.from({
              yParity: sL(n[3], "yParity"),
              r: _R(n[4], 32),
              s: _R(n[5], 32)
            })
          })
        }
        return e
      } catch (r) {
        TR(!1, r.message, e, t)
      }
    }

    function sL(t, e) {
      return "0x" === t ? 0 : VR(t, e)
    }

    function aL(t, e) {
      if ("0x" === t) return qU;
      const r = zR(t, e);
      return TR(tL >= r, "value exceeds uint size", e, r), r
    }

    function uL(t, e) {
      const r = zR(t, "value"),
        n = qR(r);
      return TR(32 >= n.length, "value too large", "tx." + e, r), n
    }

    function cL(t) {
      return ZU(t).map(t => [t.address, t.storageKeys])
    }

    function fL(t) {
      return t.map(t => [uL(t.chainId, "chainId"), t.address, uL(t.nonce, "nonce"), uL(t.signature.yParity, "yParity"), qR(t.signature.r), qR(t.signature.s)])
    }

    function lL(t, e) {
      TR(Array.isArray(t), "invalid " + e, "value", t);
      for (let e = 0; e < t.length; e++) TR(BR(t[e], 32), "invalid ${ param } hash", `value[${e}]`, t[e]);
      return t
    }

    function hL(t, e) {
      let r;
      try {
        if (r = sL(e[0], "yParity"), 0 !== r && 1 !== r) throw Error("bad yParity")
      } catch {
        TR(!1, "invalid yParity", "yParity", e[0])
      }
      const n = _R(e[1], 32),
        i = _R(e[2], 32),
        o = oN.from({
          r: n,
          s: i,
          yParity: r
        });
      t.signature = o
    }
    class dL {
      #t;
      #e;
      #r;
      #n;
      #i;
      #o;
      #s;
      #a;
      #u;
      #c;
      #f;
      #l;
      #h;
      #d;
      #p;
      #b;
      #m;
      get type() {
        return this.#t
      }
      set type(t) {
        switch (t) {
          case null:
            this.#t = null;
            break;
          case 0:
          case "legacy":
            this.#t = 0;
            break;
          case 1:
          case "berlin":
          case "eip-2930":
            this.#t = 1;
            break;
          case 2:
          case "london":
          case "eip-1559":
            this.#t = 2;
            break;
          case 3:
          case "cancun":
          case "eip-4844":
            this.#t = 3;
            break;
          case 4:
          case "pectra":
          case "eip-7702":
            this.#t = 4;
            break;
          default:
            TR(!1, "unsupported transaction type", "type", t)
        }
      }
      get typeName() {
        switch (this.type) {
          case 0:
            return "legacy";
          case 1:
            return "eip-2930";
          case 2:
            return "eip-1559";
          case 3:
            return "eip-4844";
          case 4:
            return "eip-7702"
        }
        return null
      }
      get to() {
        const t = this.#e;
        return null == t && 3 === this.type ? _U : t
      }
      set to(t) {
        this.#e = null == t ? null : n_(t)
      }
      get nonce() {
        return this.#n
      }
      set nonce(t) {
        this.#n = VR(t, "value")
      }
      get gasLimit() {
        return this.#i
      }
      set gasLimit(t) {
        this.#i = zR(t)
      }
      get gasPrice() {
        const t = this.#o;
        return null != t || 0 !== this.type && 1 !== this.type ? t : qU
      }
      set gasPrice(t) {
        this.#o = null == t ? null : zR(t, "gasPrice")
      }
      get maxPriorityFeePerGas() {
        return this.#s ?? (2 === this.type || 3 === this.type ? qU : null)
      }
      set maxPriorityFeePerGas(t) {
        this.#s = null == t ? null : zR(t, "maxPriorityFeePerGas")
      }
      get maxFeePerGas() {
        return this.#a ?? (2 === this.type || 3 === this.type ? qU : null)
      }
      set maxFeePerGas(t) {
        this.#a = null == t ? null : zR(t, "maxFeePerGas")
      }
      get data() {
        return this.#r
      }
      set data(t) {
        this.#r = CR(t)
      }
      get value() {
        return this.#u
      }
      set value(t) {
        this.#u = zR(t, "value")
      }
      get chainId() {
        return this.#c
      }
      set chainId(t) {
        this.#c = zR(t)
      }
      get signature() {
        return this.#f || null
      }
      set signature(t) {
        this.#f = null == t ? null : oN.from(t)
      }
      get accessList() {
        return (this.#l || null) ?? (1 === this.type || 2 === this.type || 3 === this.type ? [] : null)
      }
      set accessList(t) {
        this.#l = null == t ? null : ZU(t)
      }
      get authorizationList() {
        const t = this.#m || null;
        return null == t && 4 === this.type ? [] : t
      }
      set authorizationList(t) {
        this.#m = null == t ? null : t.map(t => function(t) {
          return {
            address: n_(t.address),
            nonce: zR(null != t.nonce ? t.nonce : 0),
            chainId: zR(null != t.chainId ? t.chainId : 0),
            signature: oN.from(t.signature)
          }
        }(t))
      }
      get maxFeePerBlobGas() {
        const t = this.#h;
        return null == t && 3 === this.type ? qU : t
      }
      set maxFeePerBlobGas(t) {
        this.#h = null == t ? null : zR(t, "maxFeePerBlobGas")
      }
      get blobVersionedHashes() {
        let t = this.#d;
        return null == t && 3 === this.type ? [] : t
      }
      set blobVersionedHashes(t) {
        if (null != t) {
          TR(Array.isArray(t), "blobVersionedHashes must be an Array", "value", t), t = t.slice();
          for (let e = 0; e < t.length; e++) TR(BR(t[e], 32), "invalid blobVersionedHash", `value[${e}]`, t[e])
        }
        this.#d = t
      }
      get blobs() {
        return null == this.#b ? null : this.#b.map(t => Object.assign({}, t))
      }
      set blobs(t) {
        if (null == t) return void(this.#b = null);
        const e = [],
          r = [];
        for (let n = 0; n < t.length; n++) {
          const i = t[n];
          if (WR(i)) {
            AR(this.#p, "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
              operation: "set blobs()"
            });
            let t = SR(i);
            if (TR(t.length <= eL, "blob is too large", `blobs[${n}]`, i), t.length !== eL) {
              const e = new Uint8Array(eL);
              e.set(t), t = e
            }
            const o = this.#p.blobToKzgCommitment(t),
              s = CR(this.#p.computeBlobKzgProof(t, o));
            e.push({
              data: CR(t),
              commitment: CR(o),
              proof: s
            }), r.push(rL(1, o))
          } else {
            const t = CR(i.commitment);
            e.push({
              data: CR(i.data),
              commitment: t,
              proof: CR(i.proof)
            }), r.push(rL(1, t))
          }
        }
        this.#b = e, this.#d = r
      }
      get kzg() {
        return this.#p
      }
      set kzg(t) {
        this.#p = null == t ? null : function(t) {
          return {
            blobToKzgCommitment: e => {
              if ("computeBlobProof" in t) {
                if ("blobToKzgCommitment" in t && "function" == typeof t.blobToKzgCommitment) return SR(t.blobToKzgCommitment(CR(e)))
              } else if ("blobToKzgCommitment" in t && "function" == typeof t.blobToKzgCommitment) return SR(t.blobToKzgCommitment(e));
              if ("blobToKZGCommitment" in t && "function" == typeof t.blobToKZGCommitment) return SR(t.blobToKZGCommitment(CR(e)));
              TR(!1, "unsupported KZG library", "kzg", t)
            },
            computeBlobKzgProof: (e, r) => "computeBlobProof" in t && "function" == typeof t.computeBlobProof ? SR(t.computeBlobProof(CR(e), CR(r))) : "computeBlobKzgProof" in t && "function" == typeof t.computeBlobKzgProof ? t.computeBlobKzgProof(e, r) : "computeBlobKZGProof" in t && "function" == typeof t.computeBlobKZGProof ? SR(t.computeBlobKZGProof(CR(e), CR(r))) : void TR(!1, "unsupported KZG library", "kzg", t)
          }
        }(t)
      }
      constructor() {
        this.#t = null, this.#e = null, this.#n = 0, this.#i = qU, this.#o = null, this.#s = null, this.#a = null, this.#r = "0x", this.#u = qU, this.#c = qU, this.#f = null, this.#l = null, this.#h = null, this.#d = null, this.#p = null, this.#b = null, this.#m = null
      }
      get hash() {
        return null == this.signature ? null : Cj(this.#y(!0, !1))
      }
      get unsignedHash() {
        return Cj(this.unsignedSerialized)
      }
      get from() {
        return null == this.signature ? null : nD(this.unsignedHash, this.signature)
      }
      get fromPublicKey() {
        return null == this.signature ? null : eD.recoverPublicKey(this.unsignedHash, this.signature)
      }
      isSigned() {
        return null != this.signature
      }
      #y(t, e) {
        AR(!t || null != this.signature, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", {
          operation: ".serialized"
        });
        const r = t ? this.signature : null;
        switch (this.inferType()) {
          case 0:
            return function(t, e) {
              const r = [uL(t.nonce, "nonce"), uL(t.gasPrice || 0, "gasPrice"), uL(t.gasLimit, "gasLimit"), t.to || "0x", uL(t.value, "value"), t.data];
              let n = qU;
              if (t.chainId != qU) n = zR(t.chainId, "tx.chainId"), TR(!e || null == e.networkV || e.legacyChainId === n, "tx.chainId/sig.v mismatch", "sig", e);
              else if (t.signature) {
                const e = t.signature.legacyChainId;
                null != e && (n = e)
              }
              if (!e) return n !== qU && (r.push(qR(n)), r.push("0x"), r.push("0x")), KU(r);
              let i = BigInt(27 + e.yParity);
              return n !== qU ? i = oN.getChainIdV(n, e.v) : BigInt(e.v) !== i && TR(!1, "tx.chainId/sig.v mismatch", "sig", e), r.push(qR(i)), r.push(qR(e.r)), r.push(qR(e.s)), KU(r)
            }(this, r);
          case 1:
            return function(t, e) {
              const r = [uL(t.chainId, "chainId"), uL(t.nonce, "nonce"), uL(t.gasPrice || 0, "gasPrice"), uL(t.gasLimit, "gasLimit"), t.to || "0x", uL(t.value, "value"), t.data, cL(t.accessList || [])];
              return e && (r.push(uL(e.yParity, "recoveryParam")), r.push(qR(e.r)), r.push(qR(e.s))), RR(["0x01", KU(r)])
            }(this, r);
          case 2:
            return function(t, e) {
              const r = [uL(t.chainId, "chainId"), uL(t.nonce, "nonce"), uL(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), uL(t.maxFeePerGas || 0, "maxFeePerGas"), uL(t.gasLimit, "gasLimit"), t.to || "0x", uL(t.value, "value"), t.data, cL(t.accessList || [])];
              return e && (r.push(uL(e.yParity, "yParity")), r.push(qR(e.r)), r.push(qR(e.s))), RR(["0x02", KU(r)])
            }(this, r);
          case 3:
            return function(t, e, r) {
              const n = [uL(t.chainId, "chainId"), uL(t.nonce, "nonce"), uL(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), uL(t.maxFeePerGas || 0, "maxFeePerGas"), uL(t.gasLimit, "gasLimit"), t.to || _U, uL(t.value, "value"), t.data, cL(t.accessList || []), uL(t.maxFeePerBlobGas || 0, "maxFeePerBlobGas"), lL(t.blobVersionedHashes || [], "blobVersionedHashes")];
              return e && (n.push(uL(e.yParity, "yParity")), n.push(qR(e.r)), n.push(qR(e.s)), r) ? RR(["0x03", KU([n, r.map(t => t.data), r.map(t => t.commitment), r.map(t => t.proof)])]) : RR(["0x03", KU(n)])
            }(this, r, e ? this.blobs : null);
          case 4:
            return function(t, e) {
              const r = [uL(t.chainId, "chainId"), uL(t.nonce, "nonce"), uL(t.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), uL(t.maxFeePerGas || 0, "maxFeePerGas"), uL(t.gasLimit, "gasLimit"), t.to || "0x", uL(t.value, "value"), t.data, cL(t.accessList || []), fL(t.authorizationList || [])];
              return e && (r.push(uL(e.yParity, "yParity")), r.push(qR(e.r)), r.push(qR(e.s))), RR(["0x04", KU(r)])
            }(this, r)
        }
        AR(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
          operation: ".serialized"
        })
      }
      get serialized() {
        return this.#y(!0, !0)
      }
      get unsignedSerialized() {
        return this.#y(!1, !1)
      }
      inferType() {
        const t = this.inferTypes();
        return 0 > t.indexOf(2) ? t.pop() : 2
      }
      inferTypes() {
        const t = null != this.gasPrice,
          e = null != this.maxFeePerGas || null != this.maxPriorityFeePerGas,
          r = null != this.accessList,
          n = null != this.#h || this.#d;
        null != this.maxFeePerGas && null != this.maxPriorityFeePerGas && AR(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", {
          value: this
        }), AR(!e || 0 !== this.type && 1 !== this.type, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", {
          value: this
        }), AR(0 !== this.type || !r, "legacy transaction cannot have accessList", "BAD_DATA", {
          value: this
        });
        const i = [];
        return null != this.type ? i.push(this.type) : this.authorizationList && this.authorizationList.length ? i.push(4) : e ? i.push(2) : t ? (i.push(1), r || i.push(0)) : r ? (i.push(1), i.push(2)) : (n && this.to || (i.push(0), i.push(1), i.push(2)), i.push(3)), i.sort(), i
      }
      isLegacy() {
        return 0 === this.type
      }
      isBerlin() {
        return 1 === this.type
      }
      isLondon() {
        return 2 === this.type
      }
      isCancun() {
        return 3 === this.type
      }
      clone() {
        return dL.from(this)
      }
      toJSON() {
        const t = t => null == t ? null : t.toString();
        return {
          type: this.type,
          to: this.to,
          data: this.data,
          nonce: this.nonce,
          gasLimit: t(this.gasLimit),
          gasPrice: t(this.gasPrice),
          maxPriorityFeePerGas: t(this.maxPriorityFeePerGas),
          maxFeePerGas: t(this.maxFeePerGas),
          value: t(this.value),
          chainId: t(this.chainId),
          sig: this.signature ? this.signature.toJSON() : null,
          accessList: this.accessList
        }
      }
      static from(t) {
        if (null == t) return new dL;
        if ("string" == typeof t) {
          const e = SR(t);
          if (e[0] >= 127) return dL.from(function(t) {
            const e = $U(t);
            TR(Array.isArray(e) && (9 === e.length || 6 === e.length), "invalid field count for legacy transaction", "data", t);
            const r = {
              type: 0,
              nonce: sL(e[0], "nonce"),
              gasPrice: aL(e[1], "gasPrice"),
              gasLimit: aL(e[2], "gasLimit"),
              to: nL(e[3]),
              value: aL(e[4], "value"),
              data: CR(e[5]),
              chainId: qU
            };
            if (6 === e.length) return r;
            const n = aL(e[6], "v"),
              i = aL(e[7], "r"),
              o = aL(e[8], "s");
            if (i === qU && o === qU) r.chainId = n;
            else {
              let t = (n - XU) / JU;
              qU > t && (t = qU), r.chainId = t, TR(t !== qU || n === YU || n === QU, "non-canonical legacy v", "v", e[6]), r.signature = oN.from({
                r: _R(e[7], 32),
                s: _R(e[8], 32),
                v: n
              })
            }
            return r
          }(e));
          switch (e[0]) {
            case 1:
              return dL.from(function(t) {
                const e = $U(SR(t).slice(1));
                TR(Array.isArray(e) && (8 === e.length || 11 === e.length), "invalid field count for transaction type: 1", "data", CR(t));
                const r = {
                  type: 1,
                  chainId: aL(e[0], "chainId"),
                  nonce: sL(e[1], "nonce"),
                  gasPrice: aL(e[2], "gasPrice"),
                  gasLimit: aL(e[3], "gasLimit"),
                  to: nL(e[4]),
                  value: aL(e[5], "value"),
                  data: CR(e[6]),
                  accessList: iL(e[7], "accessList")
                };
                return 8 === e.length || hL(r, e.slice(8)), r
              }(e));
            case 2:
              return dL.from(function(t) {
                const e = $U(SR(t).slice(1));
                TR(Array.isArray(e) && (9 === e.length || 12 === e.length), "invalid field count for transaction type: 2", "data", CR(t));
                const r = {
                  type: 2,
                  chainId: aL(e[0], "chainId"),
                  nonce: sL(e[1], "nonce"),
                  maxPriorityFeePerGas: aL(e[2], "maxPriorityFeePerGas"),
                  maxFeePerGas: aL(e[3], "maxFeePerGas"),
                  gasPrice: null,
                  gasLimit: aL(e[4], "gasLimit"),
                  to: nL(e[5]),
                  value: aL(e[6], "value"),
                  data: CR(e[7]),
                  accessList: iL(e[8], "accessList")
                };
                return 9 === e.length || hL(r, e.slice(9)), r
              }(e));
            case 3:
              return dL.from(function(t) {
                let e = $U(SR(t).slice(1)),
                  r = "3",
                  n = null;
                if (4 === e.length && Array.isArray(e[0])) {
                  r = "3 (network format)";
                  const t = e[1],
                    i = e[2],
                    o = e[3];
                  TR(Array.isArray(t), "invalid network format: blobs not an array", "fields[1]", t), TR(Array.isArray(i), "invalid network format: commitments not an array", "fields[2]", i), TR(Array.isArray(o), "invalid network format: proofs not an array", "fields[3]", o), TR(t.length === i.length, "invalid network format: blobs/commitments length mismatch", "fields", e), TR(t.length === o.length, "invalid network format: blobs/proofs length mismatch", "fields", e), n = [];
                  for (let r = 0; r < e[1].length; r++) n.push({
                    data: t[r],
                    commitment: i[r],
                    proof: o[r]
                  });
                  e = e[0]
                }
                TR(Array.isArray(e) && (11 === e.length || 14 === e.length), "invalid field count for transaction type: " + r, "data", CR(t));
                const i = {
                  type: 3,
                  chainId: aL(e[0], "chainId"),
                  nonce: sL(e[1], "nonce"),
                  maxPriorityFeePerGas: aL(e[2], "maxPriorityFeePerGas"),
                  maxFeePerGas: aL(e[3], "maxFeePerGas"),
                  gasPrice: null,
                  gasLimit: aL(e[4], "gasLimit"),
                  to: nL(e[5]),
                  value: aL(e[6], "value"),
                  data: CR(e[7]),
                  accessList: iL(e[8], "accessList"),
                  maxFeePerBlobGas: aL(e[9], "maxFeePerBlobGas"),
                  blobVersionedHashes: e[10]
                };
                n && (i.blobs = n), TR(null != i.to, "invalid address for transaction type: " + r, "data", t), TR(Array.isArray(i.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", t);
                for (let e = 0; e < i.blobVersionedHashes.length; e++) TR(BR(i.blobVersionedHashes[e], 32), `invalid blobVersionedHash at index ${e}: must be length 32`, "data", t);
                return 11 === e.length || hL(i, e.slice(11)), i
              }(e));
            case 4:
              return dL.from(function(t) {
                const e = $U(SR(t).slice(1));
                TR(Array.isArray(e) && (10 === e.length || 13 === e.length), "invalid field count for transaction type: 4", "data", CR(t));
                const r = {
                  type: 4,
                  chainId: aL(e[0], "chainId"),
                  nonce: sL(e[1], "nonce"),
                  maxPriorityFeePerGas: aL(e[2], "maxPriorityFeePerGas"),
                  maxFeePerGas: aL(e[3], "maxFeePerGas"),
                  gasPrice: null,
                  gasLimit: aL(e[4], "gasLimit"),
                  to: nL(e[5]),
                  value: aL(e[6], "value"),
                  data: CR(e[7]),
                  accessList: iL(e[8], "accessList"),
                  authorizationList: oL(e[9], "authorizationList")
                };
                return 10 === e.length || hL(r, e.slice(10)), r
              }(e))
          }
          AR(!1, "unsupported transaction type", "UNSUPPORTED_OPERATION", {
            operation: "from"
          })
        }
        const e = new dL;
        return null != t.type && (e.type = t.type), null != t.to && (e.to = t.to), null != t.nonce && (e.nonce = t.nonce), null != t.gasLimit && (e.gasLimit = t.gasLimit), null != t.gasPrice && (e.gasPrice = t.gasPrice), null != t.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = t.maxPriorityFeePerGas), null != t.maxFeePerGas && (e.maxFeePerGas = t.maxFeePerGas), null != t.maxFeePerBlobGas && (e.maxFeePerBlobGas = t.maxFeePerBlobGas), null != t.data && (e.data = t.data), null != t.value && (e.value = t.value), null != t.chainId && (e.chainId = t.chainId), null != t.signature && (e.signature = oN.from(t.signature)), null != t.accessList && (e.accessList = t.accessList), null != t.authorizationList && (e.authorizationList = t.authorizationList), null != t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes), null != t.kzg && (e.kzg = t.kzg), null != t.blobs && (e.blobs = t.blobs), null != t.hash && (TR(e.isSigned(), "unsigned transaction cannot define '.hash'", "tx", t), TR(e.hash === t.hash, "hash mismatch", "tx", t)), null != t.from && (TR(e.isSigned(), "unsigned transaction cannot define '.from'", "tx", t), TR(e.from.toLowerCase() === (t.from || "").toLowerCase(), "from mismatch", "tx", t)), e
      }
    }

    function pL(t) {
      const e = {};
      t.to && (e.to = t.to), t.from && (e.from = t.from), t.data && (e.data = CR(t.data));
      const r = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
      for (const n of r) !(n in t) || null == t[n] || (e[n] = zR(t[n], "request." + n));
      const n = "type,nonce".split(/,/);
      for (const r of n) !(r in t) || null == t[r] || (e[r] = VR(t[r], "request." + r));
      return t.accessList && (e.accessList = ZU(t.accessList)), t.authorizationList && (e.authorizationList = t.authorizationList.slice()), "blockTag" in t && (e.blockTag = t.blockTag), "enableCcipRead" in t && (e.enableCcipRead = !!t.enableCcipRead), "customData" in t && (e.customData = t.customData), "blobVersionedHashes" in t && t.blobVersionedHashes && (e.blobVersionedHashes = t.blobVersionedHashes.slice()), "kzg" in t && (e.kzg = t.kzg), "blobs" in t && t.blobs && (e.blobs = t.blobs.map(t => WR(t) ? CR(t) : Object.assign({}, t))), e
    }

    function bL(t, e) {
      if (t.provider) return t.provider;
      AR(!1, "missing provider", "UNSUPPORTED_OPERATION", {
        operation: e
      })
    }
    async function mL(t, e) {
      let r = pL(e);
      if (null != r.to && (r.to = jU(r.to, t)), null != r.from) {
        const e = r.from;
        r.from = Promise.all([t.getAddress(), jU(e, t)]).then(([t, e]) => (TR(t.toLowerCase() === e.toLowerCase(), "transaction from mismatch", "tx.from", e), t))
      } else r.from = t.getAddress();
      return await mR(r)
    }
    BigInt(0), Symbol.iterator, Symbol.iterator;
    class yL {
      provider;
      constructor(t) {
        yR(this, {
          provider: t || null
        })
      }
      async getNonce(t) {
        return bL(this, "getTransactionCount").getTransactionCount(await this.getAddress(), t)
      }
      async populateCall(t) {
        return await mL(this, t)
      }
      async populateTransaction(t) {
        const e = bL(this, "populateTransaction"),
          r = await mL(this, t);
        null == r.nonce && (r.nonce = await this.getNonce("pending")), null == r.gasLimit && (r.gasLimit = await this.estimateGas(r));
        const n = await this.provider.getNetwork();
        null != r.chainId ? TR(zR(r.chainId) === n.chainId, "transaction chainId mismatch", "tx.chainId", t.chainId) : r.chainId = n.chainId;
        const i = null != r.maxFeePerGas || null != r.maxPriorityFeePerGas;
        if (null == r.gasPrice || 2 !== r.type && !i ? (0 === r.type || 1 === r.type) && i && TR(!1, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", t) : TR(!1, "eip-1559 transaction do not support gasPrice", "tx", t), 2 !== r.type && null != r.type || null == r.maxFeePerGas || null == r.maxPriorityFeePerGas)
          if (0 === r.type || 1 === r.type) {
            const t = await e.getFeeData();
            AR(null != t.gasPrice, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
              operation: "getGasPrice"
            }), null == r.gasPrice && (r.gasPrice = t.gasPrice)
          } else {
            const t = await e.getFeeData();
            if (null == r.type)
              if (null != t.maxFeePerGas && null != t.maxPriorityFeePerGas)
                if (r.authorizationList && r.authorizationList.length ? r.type = 4 : r.type = 2, null != r.gasPrice) {
                  const t = r.gasPrice;
                  delete r.gasPrice, r.maxFeePerGas = t, r.maxPriorityFeePerGas = t
                } else null == r.maxFeePerGas && (r.maxFeePerGas = t.maxFeePerGas), null == r.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = t.maxPriorityFeePerGas);
            else null != t.gasPrice ? (AR(!i, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
              operation: "populateTransaction"
            }), null == r.gasPrice && (r.gasPrice = t.gasPrice), r.type = 0) : AR(!1, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
              operation: "signer.getFeeData"
            });
            else(2 === r.type || 3 === r.type || 4 === r.type) && (null == r.maxFeePerGas && (r.maxFeePerGas = t.maxFeePerGas), null == r.maxPriorityFeePerGas && (r.maxPriorityFeePerGas = t.maxPriorityFeePerGas))
          }
        else r.type = 2;
        return await mR(r)
      }
      async populateAuthorization(t) {
        const e = Object.assign({}, t);
        return null == e.chainId && (e.chainId = (await bL(this, "getNetwork").getNetwork()).chainId), null == e.nonce && (e.nonce = await this.getNonce()), e
      }
      async estimateGas(t) {
        return bL(this, "estimateGas").estimateGas(await this.populateCall(t))
      }
      async call(t) {
        return bL(this, "call").call(await this.populateCall(t))
      }
      async resolveName(t) {
        return await bL(this, "resolveName").resolveName(t)
      }
      async sendTransaction(t) {
        const e = bL(this, "sendTransaction"),
          r = await this.populateTransaction(t);
        delete r.from;
        const n = dL.from(r);
        return await e.broadcastTransaction(await this.signTransaction(n))
      }
      authorize(t) {
        AR(!1, "authorization not implemented for this signer", "UNSUPPORTED_OPERATION", {
          operation: "authorize"
        })
      }
    }
    class gL extends yL {
      address;
      constructor(t, e) {
        super(e), yR(this, {
          address: t
        })
      }
      async getAddress() {
        return this.address
      }
      connect(t) {
        return new gL(this.address, t)
      }
      #t(t, e) {
        AR(!1, "VoidSigner cannot sign " + t, "UNSUPPORTED_OPERATION", {
          operation: e
        })
      }
      async signTransaction(t) {
        this.#t("transactions", "signTransaction")
      }
      async signMessage(t) {
        this.#t("messages", "signMessage")
      }
      async signTypedData(t, e, r) {
        this.#t("typed-data", "signTypedData")
      }
    }
    const vL = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    let wL = null;

    function AL(t) {
      if (null == wL) {
        wL = {};
        for (let t = 0; 58 > t; t++) wL[vL[t]] = BigInt(t)
      }
      const e = wL[t];
      return TR(null != e, "invalid base58 value", "letter", t), e
    }
    const TL = BigInt(0),
      EL = BigInt(58),
      PL = new Uint8Array(32);
    PL.fill(0);
    const kL = BigInt(-1),
      xL = BigInt(0),
      IL = BigInt(1),
      SL = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
      OL = ZR(IL, 32),
      BL = ZR(xL, 32),
      WL = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      },
      ML = ["name", "version", "chainId", "verifyingContract", "salt"];

    function CL(t) {
      return function(e) {
        return TR("string" == typeof e, "invalid domain value for " + JSON.stringify(t), "domain." + t, e), e
      }
    }
    const RL = {
      name: CL("name"),
      version: CL("version"),
      chainId: function(t) {
        const e = zR(t, "domain.chainId");
        return TR(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? +e : JR(e)
      },
      verifyingContract: function(t) {
        try {
          return n_(t).toLowerCase()
        } catch {}
        TR(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t)
      },
      salt: function(t) {
        const e = SR(t, "domain.salt");
        return TR(32 === e.length, 'invalid domain value "salt"', "domain.salt", t), CR(e)
      }
    };

    function NL(t) {
      {
        const e = t.match(/^(u?)int(\d+)$/);
        if (e) {
          const r = "" === e[1],
            n = parseInt(e[2]);
          TR(n % 8 == 0 && 0 !== n && 256 >= n && e[2] === n + "", "invalid numeric width", "type", t);
          const i = $R(SL, r ? n - 1 : n),
            o = r ? (i + IL) * kL : xL;
          return function(e) {
            const n = zR(e, "value");
            return TR(n >= o && i >= n, "value out-of-bounds for " + t, "value", n), ZR(r ? FR(n, 256) : n, 32)
          }
        }
      } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
          const r = parseInt(e[1]);
          return TR(0 !== r && 32 >= r && e[1] === r + "", "invalid bytes width", "type", t),
            function(e) {
              return TR(SR(e).length === r, "invalid length for " + t, "value", e),
                function(t) {
                  const e = SR(t),
                    r = e.length % 32;
                  return r ? RR([e, PL.slice(r)]) : CR(e)
                }(e)
            }
        }
      }
      switch (t) {
        case "address":
          return function(t) {
            return _R(n_(t), 32)
          };
        case "bool":
          return function(t) {
            return t ? OL : BL
          };
        case "bytes":
          return function(t) {
            return Cj(t)
          };
        case "string":
          return function(t) {
            return Rj(t)
          }
      }
      return null
    }

    function jL(t, e) {
      return `${t}(${e.map(({name:t,type:e})=>e+" "+t).join(",")})`
    }

    function _L(t) {
      const e = t.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
      return e ? {
        base: e[1],
        index: e[2] + e[4],
        array: {
          base: e[1],
          prefix: e[1] + e[2],
          count: e[5] ? parseInt(e[5]) : -1
        }
      } : {
        base: t
      }
    }
    class DL {
      primaryType;
      #t;
      get types() {
        return JSON.parse(this.#t)
      }
      #e;
      #r;
      constructor(t) {
        this.#e = new Map, this.#r = new Map;
        const e = new Map,
          r = new Map,
          n = new Map,
          i = {};
        Object.keys(t).forEach(o => {
          i[o] = t[o].map(({
            name: e,
            type: r
          }) => {
            let {
              base: n,
              index: i
            } = _L(r);
            return "int" === n && !t.int && (n = "int256"), "uint" === n && !t.uint && (n = "uint256"), {
              name: e,
              type: n + (i || "")
            }
          }), e.set(o, new Set), r.set(o, []), n.set(o, new Set)
        }), this.#t = JSON.stringify(i);
        for (const n in i) {
          const o = new Set;
          for (const s of i[n]) {
            TR(!o.has(s.name), `duplicate variable name ${JSON.stringify(s.name)} in ${JSON.stringify(n)}`, "types", t), o.add(s.name);
            const i = _L(s.type).base;
            TR(i !== n, "circular type reference to " + JSON.stringify(i), "types", t), !NL(i) && (TR(r.has(i), "unknown type " + JSON.stringify(i), "types", t), r.get(i).push(n), e.get(n).add(i))
          }
        }
        const o = Array.from(r.keys()).filter(t => 0 === r.get(t).length);
        TR(0 !== o.length, "missing primary type", "types", t), TR(1 === o.length, "ambiguous primary types or unused types: " + o.map(t => JSON.stringify(t)).join(", "), "types", t), yR(this, {
            primaryType: o[0]
          }),
          function i(o, s) {
            TR(!s.has(o), "circular type reference to " + JSON.stringify(o), "types", t), s.add(o);
            for (const t of e.get(o))
              if (r.has(t)) {
                i(t, s);
                for (const e of s) n.get(e).add(t)
              } s.delete(o)
          }(this.primaryType, new Set);
        for (const [t, e] of n) {
          const r = Array.from(e);
          r.sort(), this.#e.set(t, jL(t, i[t]) + r.map(t => jL(t, i[t])).join(""))
        }
      }
      getEncoder(t) {
        let e = this.#r.get(t);
        return e || (e = this.#n(t), this.#r.set(t, e)), e
      }
      #n(t) {
        {
          const e = NL(t);
          if (e) return e
        }
        const e = _L(t).array;
        if (e) {
          const t = e.prefix,
            r = this.getEncoder(t);
          return n => {
            TR(-1 === e.count || e.count === n.length, "array length mismatch; expected length " + e.count, "value", n);
            let i = n.map(r);
            return this.#e.has(t) && (i = i.map(Cj)), Cj(RR(i))
          }
        }
        const r = this.types[t];
        if (r) {
          const e = Rj(this.#e.get(t));
          return t => {
            const n = r.map(({
              name: e,
              type: r
            }) => {
              const n = this.getEncoder(r)(t[e]);
              return this.#e.has(r) ? Cj(n) : n
            });
            return n.unshift(e), RR(n)
          }
        }
        TR(!1, "unknown type: " + t, "type", t)
      }
      encodeType(t) {
        const e = this.#e.get(t);
        return TR(e, "unknown type: " + JSON.stringify(t), "name", t), e
      }
      encodeData(t, e) {
        return this.getEncoder(t)(e)
      }
      hashStruct(t, e) {
        return Cj(this.encodeData(t, e))
      }
      encode(t) {
        return this.encodeData(this.primaryType, t)
      }
      hash(t) {
        return this.hashStruct(this.primaryType, t)
      }
      Ou(t, e, r) {
        if (NL(t)) return r(t, e);
        const n = _L(t).array;
        if (n) return TR(-1 === n.count || n.count === e.length, "array length mismatch; expected length " + n.count, "value", e), e.map(t => this.Ou(n.prefix, t, r));
        const i = this.types[t];
        if (i) return i.reduce((t, {
          name: n,
          type: i
        }) => (t[n] = this.Ou(i, e[n], r), t), {});
        TR(!1, "unknown type: " + t, "type", t)
      }
      visit(t, e) {
        return this.Ou(this.primaryType, t, e)
      }
      static from(t) {
        return new DL(t)
      }
      static getPrimaryType(t) {
        return DL.from(t).primaryType
      }
      static hashStruct(t, e, r) {
        return DL.from(e).hashStruct(t, r)
      }
      static hashDomain(t) {
        const e = [];
        for (const r in t) {
          if (null == t[r]) continue;
          const n = WL[r];
          TR(n, "invalid typed-data domain key: " + JSON.stringify(r), "domain", t), e.push({
            name: r,
            type: n
          })
        }
        return e.sort((t, e) => ML.indexOf(t.name) - ML.indexOf(e.name)), DL.hashStruct("EIP712Domain", {
          EIP712Domain: e
        }, t)
      }
      static encode(t, e, r) {
        return RR(["0x1901", DL.hashDomain(t), DL.from(e).hash(r)])
      }
      static hash(t, e, r) {
        return Cj(DL.encode(t, e, r))
      }
      static async resolveNames(t, e, r, n) {
        t = Object.assign({}, t);
        for (const e in t) null == t[e] && delete t[e];
        const i = {};
        t.verifyingContract && !BR(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x");
        const o = DL.from(e);
        o.visit(r, (t, e) => ("address" === t && !BR(e, 20) && (i[e] = "0x"), e));
        for (const t in i) i[t] = await n(t);
        return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), {
          domain: t,
          value: r = o.visit(r, (t, e) => "address" === t && i[e] ? i[e] : e)
        }
      }
      static getPayload(t, e, r) {
        DL.hashDomain(t);
        const n = {},
          i = [];
        ML.forEach(e => {
          const r = t[e];
          null != r && (n[e] = RL[e](r), i.push({
            name: e,
            type: WL[e]
          }))
        });
        const o = DL.from(e);
        e = o.types;
        const s = Object.assign({}, e);
        return TR(null == s.EIP712Domain, "types must not contain EIP712Domain type", "types.EIP712Domain", e), s.EIP712Domain = i, o.encode(r), {
          types: s,
          domain: n,
          primaryType: o.primaryType,
          message: o.visit(r, (t, e) => {
            if (t.match(/^bytes(\d*)/)) return CR(SR(e));
            if (t.match(/^u?int/)) return zR(e).toString();
            switch (t) {
              case "address":
                return e.toLowerCase();
              case "bool":
                return !!e;
              case "string":
                return TR("string" == typeof e, "invalid string", "value", e), e
            }
            TR(!1, "unsupported type", "type", t)
          })
        }
      }
    }
    class UL extends yL {
      address;
      #t;
      constructor(t, e) {
        super(e), TR(t && "function" == typeof t.sign, "invalid private key", "privateKey", "[ REDACTED ]"), this.#t = t, yR(this, {
          address: rD(this.signingKey.publicKey)
        })
      }
      get signingKey() {
        return this.#t
      }
      get privateKey() {
        return this.signingKey.privateKey
      }
      async getAddress() {
        return this.address
      }
      connect(t) {
        return new UL(this.#t, t)
      }
      async signTransaction(t) {
        t = pL(t);
        const {
          to: e,
          from: r
        } = await mR({
          to: t.to ? jU(t.to, this) : void 0,
          from: t.from ? jU(t.from, this) : void 0
        });
        null != e && (t.to = e), null != r && (t.from = r), null != t.from && (TR(n_(t.from) === this.address, "transaction from address mismatch", "tx.from", t.from), delete t.from);
        const n = dL.from(t);
        return n.signature = this.signingKey.sign(n.unsignedHash), n.serialized
      }
      async signMessage(t) {
        return this.signMessageSync(t)
      }
      signMessageSync(t) {
        return this.signingKey.sign(function(t) {
          return "string" == typeof t && (t = dj(t)), Cj(RR([dj("Ethereum Signed Message:\n"), dj(t.length + ""), t]))
        }(t)).serialized
      }
      authorizeSync(t) {
        TR("string" == typeof t.address, "invalid address for authorizeSync", "auth.address", t);
        const e = this.signingKey.sign(function(t) {
          return TR("string" == typeof t.address, "invalid address for hashAuthorization", "auth.address", t), Cj(RR(["0x05", KU([null != t.chainId ? qR(t.chainId) : "0x", n_(t.address), null != t.nonce ? qR(t.nonce) : "0x"])]))
        }(t));
        return Object.assign({}, {
          address: n_(t.address),
          nonce: zR(t.nonce || 0),
          chainId: zR(t.chainId || 0)
        }, {
          signature: e
        })
      }
      async authorize(t) {
        return t = Object.assign({}, t, {
          address: await jU(t.address, this)
        }), this.authorizeSync(await this.populateAuthorization(t))
      }
      async signTypedData(t, e, r) {
        const n = await DL.resolveNames(t, e, r, async t => {
          AR(null != this.provider, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName",
            info: {
              name: t
            }
          });
          const e = await this.provider.resolveName(t);
          return AR(null != e, "unconfigured ENS name", "UNCONFIGURED_NAME", {
            value: t
          }), e
        });
        return this.signingKey.sign(DL.hash(n.domain, e, n.value)).serialized
      }
    }
    var LL, FL, $L, zL = function(t, e, r, n) {
        if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter");
        if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === r ? n : "a" === r ? n.call(t) : n ? n.value : e.get(t)
      },
      HL = function(t, e, r, n, i) {
        if ("m" === n) throw new TypeError("Private method is not writable");
        if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter");
        if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return "a" === n ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
      };
    const GL = {
        16: 10,
        24: 12,
        32: 14
      },
      KL = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
      VL = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
      ZL = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
      qL = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
      JL = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
      YL = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
      QL = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
      XL = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
      tF = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
      eF = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
      rF = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
      nF = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
      iF = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
      oF = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
      sF = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

    function aF(t) {
      const e = [];
      for (let r = 0; r < t.length; r += 4) e.push(t[r] << 24 | t[r + 1] << 16 | t[r + 2] << 8 | t[r + 3]);
      return e
    }
    class uF {
      get key() {
        return zL(this, LL, "f").slice()
      }
      constructor(t) {
        if (LL.set(this, void 0), FL.set(this, void 0), $L.set(this, void 0), !(this instanceof uF)) throw Error("AES must be instanitated with `new`");
        HL(this, LL, new Uint8Array(t), "f");
        const e = GL[this.key.length];
        if (null == e) throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
        HL(this, $L, [], "f"), HL(this, FL, [], "f");
        for (let t = 0; e >= t; t++) zL(this, $L, "f").push([0, 0, 0, 0]), zL(this, FL, "f").push([0, 0, 0, 0]);
        const r = 4 * (e + 1),
          n = this.key.length / 4,
          i = aF(this.key);
        let o;
        for (let t = 0; n > t; t++) o = t >> 2, zL(this, $L, "f")[o][t % 4] = i[t], zL(this, FL, "f")[e - o][t % 4] = i[t];
        let s, a = 0,
          u = n;
        for (; r > u;) {
          if (s = i[n - 1], i[0] ^= VL[s >> 16 & 255] << 24 ^ VL[s >> 8 & 255] << 16 ^ VL[255 & s] << 8 ^ VL[s >> 24 & 255] ^ KL[a] << 24, a += 1, 8 != n)
            for (let t = 1; n > t; t++) i[t] ^= i[t - 1];
          else {
            for (let t = 1; n / 2 > t; t++) i[t] ^= i[t - 1];
            s = i[n / 2 - 1], i[n / 2] ^= VL[255 & s] ^ VL[s >> 8 & 255] << 8 ^ VL[s >> 16 & 255] << 16 ^ VL[s >> 24 & 255] << 24;
            for (let t = n / 2 + 1; n > t; t++) i[t] ^= i[t - 1]
          }
          let t, o, c = 0;
          for (; n > c && r > u;) t = u >> 2, o = u % 4, zL(this, $L, "f")[t][o] = i[c], zL(this, FL, "f")[e - t][o] = i[c++], u++
        }
        for (let t = 1; e > t; t++)
          for (let e = 0; 4 > e; e++) s = zL(this, FL, "f")[t][e], zL(this, FL, "f")[t][e] = nF[s >> 24 & 255] ^ iF[s >> 16 & 255] ^ oF[s >> 8 & 255] ^ sF[255 & s]
      }
      encrypt(t) {
        if (16 != t.length) throw new TypeError("invalid plaintext size (must be 16 bytes)");
        const e = zL(this, $L, "f").length - 1,
          r = [0, 0, 0, 0];
        let n = aF(t);
        for (let t = 0; 4 > t; t++) n[t] ^= zL(this, $L, "f")[0][t];
        for (let t = 1; e > t; t++) {
          for (let e = 0; 4 > e; e++) r[e] = qL[n[e] >> 24 & 255] ^ JL[n[(e + 1) % 4] >> 16 & 255] ^ YL[n[(e + 2) % 4] >> 8 & 255] ^ QL[255 & n[(e + 3) % 4]] ^ zL(this, $L, "f")[t][e];
          n = r.slice()
        }
        const i = new Uint8Array(16);
        let o = 0;
        for (let t = 0; 4 > t; t++) o = zL(this, $L, "f")[e][t], i[4 * t] = 255 & (VL[n[t] >> 24 & 255] ^ o >> 24), i[4 * t + 1] = 255 & (VL[n[(t + 1) % 4] >> 16 & 255] ^ o >> 16), i[4 * t + 2] = 255 & (VL[n[(t + 2) % 4] >> 8 & 255] ^ o >> 8), i[4 * t + 3] = 255 & (VL[255 & n[(t + 3) % 4]] ^ o);
        return i
      }
      decrypt(t) {
        if (16 != t.length) throw new TypeError("invalid ciphertext size (must be 16 bytes)");
        const e = zL(this, FL, "f").length - 1,
          r = [0, 0, 0, 0];
        let n = aF(t);
        for (let t = 0; 4 > t; t++) n[t] ^= zL(this, FL, "f")[0][t];
        for (let t = 1; e > t; t++) {
          for (let e = 0; 4 > e; e++) r[e] = XL[n[e] >> 24 & 255] ^ tF[n[(e + 3) % 4] >> 16 & 255] ^ eF[n[(e + 2) % 4] >> 8 & 255] ^ rF[255 & n[(e + 1) % 4]] ^ zL(this, FL, "f")[t][e];
          n = r.slice()
        }
        const i = new Uint8Array(16);
        let o = 0;
        for (let t = 0; 4 > t; t++) o = zL(this, FL, "f")[e][t], i[4 * t] = 255 & (ZL[n[t] >> 24 & 255] ^ o >> 24), i[4 * t + 1] = 255 & (ZL[n[(t + 3) % 4] >> 16 & 255] ^ o >> 16), i[4 * t + 2] = 255 & (ZL[n[(t + 2) % 4] >> 8 & 255] ^ o >> 8), i[4 * t + 3] = 255 & (ZL[255 & n[(t + 1) % 4]] ^ o);
        return i
      }
    }
    LL = new WeakMap, FL = new WeakMap, $L = new WeakMap;
    class cF {
      constructor(t, e, r) {
        if (r && !(this instanceof r)) throw Error(t + ' must be instantiated with "new"');
        Object.defineProperties(this, {
          aes: {
            enumerable: !0,
            value: new uF(e)
          },
          name: {
            enumerable: !0,
            value: t
          }
        })
      }
    }
    new WeakMap, new WeakMap, new WeakMap, new WeakMap, new WeakSet;
    var fF, lF, hF, dF = function(t, e, r, n, i) {
        if ("m" === n) throw new TypeError("Private method is not writable");
        if ("a" === n && !i) throw new TypeError("Private accessor was defined without a setter");
        if ("function" == typeof e ? t !== e || !i : !e.has(t)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return "a" === n ? i.call(t, r) : i ? i.value = r : e.set(t, r), r
      },
      pF = function(t, e, r, n) {
        if ("a" === r && !n) throw new TypeError("Private accessor was defined without a getter");
        if ("function" == typeof e ? t !== e || !n : !e.has(t)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return "m" === r ? n : "a" === r ? n.call(t) : n ? n.value : e.get(t)
      };
    class bF extends cF {
      constructor(t, e) {
        super("CTR", t, bF), fF.set(this, void 0), lF.set(this, void 0), hF.set(this, void 0), dF(this, hF, new Uint8Array(16), "f"), pF(this, hF, "f").fill(0), dF(this, fF, pF(this, hF, "f"), "f"), dF(this, lF, 16, "f"), null == e && (e = 1), "number" == typeof e ? this.setCounterValue(e) : this.setCounterBytes(e)
      }
      get counter() {
        return new Uint8Array(pF(this, hF, "f"))
      }
      setCounterValue(t) {
        if (!Number.isInteger(t) || 0 > t || t > Number.MAX_SAFE_INTEGER) throw new TypeError("invalid counter initial integer value");
        for (let e = 15; e >= 0; --e) pF(this, hF, "f")[e] = t % 256, t = Math.floor(t / 256)
      }
      setCounterBytes(t) {
        if (16 !== t.length) throw new TypeError("invalid counter initial Uint8Array value length");
        pF(this, hF, "f").set(t)
      }
      increment() {
        for (let t = 15; t >= 0; t--) {
          if (255 !== pF(this, hF, "f")[t]) {
            pF(this, hF, "f")[t]++;
            break
          }
          pF(this, hF, "f")[t] = 0
        }
      }
      encrypt(t) {
        var e, r;
        const n = new Uint8Array(t);
        for (let t = 0; t < n.length; t++) 16 === pF(this, lF, "f") && (dF(this, fF, this.aes.encrypt(pF(this, hF, "f")), "f"), dF(this, lF, 0, "f"), this.increment()), n[t] ^= pF(this, fF, "f")[(dF(this, lF, (r = pF(this, lF, "f"), e = r++, r), "f"), e)];
        return n
      }
      decrypt(t) {
        return this.encrypt(t)
      }
    }
    fF = new WeakMap, lF = new WeakMap, hF = new WeakMap, new WeakMap, new WeakMap, new WeakMap;
    const mF = (t, e) => t << e | t >>> 32 - e;

    function yF(t, e, r, n, i, o) {
      let s = t[e++] ^ r[n++],
        a = t[e++] ^ r[n++],
        u = t[e++] ^ r[n++],
        c = t[e++] ^ r[n++],
        f = t[e++] ^ r[n++],
        l = t[e++] ^ r[n++],
        h = t[e++] ^ r[n++],
        d = t[e++] ^ r[n++],
        p = t[e++] ^ r[n++],
        b = t[e++] ^ r[n++],
        m = t[e++] ^ r[n++],
        y = t[e++] ^ r[n++],
        g = t[e++] ^ r[n++],
        v = t[e++] ^ r[n++],
        w = t[e++] ^ r[n++],
        A = t[e++] ^ r[n++],
        T = s,
        E = a,
        P = u,
        k = c,
        x = f,
        I = l,
        S = h,
        O = d,
        B = p,
        W = b,
        M = m,
        C = y,
        R = g,
        N = v,
        j = w,
        _ = A;
      for (let t = 0; 8 > t; t += 2) x ^= mF(T + R | 0, 7), B ^= mF(x + T | 0, 9), R ^= mF(B + x | 0, 13), T ^= mF(R + B | 0, 18), W ^= mF(I + E | 0, 7), N ^= mF(W + I | 0, 9), E ^= mF(N + W | 0, 13), I ^= mF(E + N | 0, 18), j ^= mF(M + S | 0, 7), P ^= mF(j + M | 0, 9), S ^= mF(P + j | 0, 13), M ^= mF(S + P | 0, 18), k ^= mF(_ + C | 0, 7), O ^= mF(k + _ | 0, 9), C ^= mF(O + k | 0, 13), _ ^= mF(C + O | 0, 18), E ^= mF(T + k | 0, 7), P ^= mF(E + T | 0, 9), k ^= mF(P + E | 0, 13), T ^= mF(k + P | 0, 18), S ^= mF(I + x | 0, 7), O ^= mF(S + I | 0, 9), x ^= mF(O + S | 0, 13), I ^= mF(x + O | 0, 18), C ^= mF(M + W | 0, 7), B ^= mF(C + M | 0, 9), W ^= mF(B + C | 0, 13), M ^= mF(W + B | 0, 18), R ^= mF(_ + j | 0, 7), N ^= mF(R + _ | 0, 9), j ^= mF(N + R | 0, 13), _ ^= mF(j + N | 0, 18);
      i[o++] = s + T | 0, i[o++] = a + E | 0, i[o++] = u + P | 0, i[o++] = c + k | 0, i[o++] = f + x | 0, i[o++] = l + I | 0, i[o++] = h + S | 0, i[o++] = d + O | 0, i[o++] = p + B | 0, i[o++] = b + W | 0, i[o++] = m + M | 0, i[o++] = y + C | 0, i[o++] = g + R | 0, i[o++] = v + N | 0, i[o++] = w + j | 0, i[o++] = A + _ | 0
    }

    function gF(t, e, r, n, i) {
      let o = n + 0,
        s = n + 16 * i;
      for (let n = 0; 16 > n; n++) r[s + n] = t[e + 16 * (2 * i - 1) + n];
      for (let n = 0; i > n; n++, o += 16, e += 16) yF(r, s, t, e, r, o), n > 0 && (s += 16), yF(r, o, t, e += 16, r, s)
    }

    function vF(t, e, r) {
      const n = AN({
          dkLen: 32,
          asyncTick: 10,
          maxmem: 1073742848
        }, r),
        {
          N: i,
          r: o,
          p: s,
          dkLen: a,
          asyncTick: u,
          maxmem: c,
          onProgress: f
        } = n;
      if (sN(i), sN(o), sN(s), sN(a), sN(u), sN(c), void 0 !== f && "function" != typeof f) throw Error("progressCb should be function");
      const l = 128 * o,
        h = l / 4;
      if (1 >= i || i & i - 1 || i >= 2 ** (l / 8) || i > 2 ** 32) throw Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
      if (0 > s || s > 137438953440 / l) throw Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
      if (0 > a || a > 137438953440) throw Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
      const d = l * (i + s);
      if (d > c) throw Error(`Scrypt: parameters too large, ${d} (128 * r * (N + p)) > ${c} (maxmem)`);
      const p = xN(RN, t, e, {
          c: 1,
          dkLen: l * s
        }),
        b = dN(p),
        m = dN(new Uint8Array(l * i)),
        y = dN(new Uint8Array(l));
      let g = () => {};
      if (f) {
        const t = 2 * i * s,
          e = Math.max(Math.floor(t / 1e4), 1);
        let r = 0;
        g = () => {
          r++, f && (!(r % e) || r === t) && f(r / t)
        }
      }
      return {
        N: i,
        r: o,
        p: s,
        dkLen: a,
        blockSize32: h,
        V: m,
        B32: b,
        B: p,
        tmp: y,
        blockMixCb: g,
        asyncTick: u
      }
    }

    function wF(t, e, r, n, i) {
      const o = xN(RN, t, r, {
        c: 1,
        dkLen: e
      });
      return r.fill(0), n.fill(0), i.fill(0), o
    }
    let AF = !1,
      TF = !1;
    const EF = async function(t, e, r, n, i, o, s) {
      return await async function(t, e, r) {
        const {
          N: n,
          r: i,
          p: o,
          dkLen: s,
          blockSize32: a,
          V: u,
          B32: c,
          B: f,
          tmp: l,
          blockMixCb: h,
          asyncTick: d
        } = vF(t, e, r);
        for (let t = 0; o > t; t++) {
          const e = a * t;
          for (let t = 0; a > t; t++) u[t] = c[e + t];
          let r = 0;
          await yN(n - 1, d, () => {
            gF(u, r, u, r += a, i), h()
          }), gF(u, (n - 1) * a, c, e, i), h(), await yN(n, d, () => {
            const t = c[e + a - 16] % n;
            for (let r = 0; a > r; r++) l[r] = c[e + r] ^ u[t * a + r];
            gF(l, 0, c, e, i), h()
          })
        }
        return wF(t, s, f, u, l)
      }(t, e, {
        N: r,
        r: n,
        p: i,
        dkLen: o,
        onProgress: s
      })
    }, PF = function(t, e, r, n, i, o) {
      return function(t, e, r) {
        const {
          N: n,
          r: i,
          p: o,
          dkLen: s,
          blockSize32: a,
          V: u,
          B32: c,
          B: f,
          tmp: l,
          blockMixCb: h
        } = vF(t, e, r);
        for (let t = 0; o > t; t++) {
          const e = a * t;
          for (let t = 0; a > t; t++) u[t] = c[e + t];
          for (let t = 0, e = 0; n - 1 > t; t++) gF(u, e, u, e += a, i), h();
          gF(u, (n - 1) * a, c, e, i), h();
          for (let t = 0; n > t; t++) {
            const t = c[e + a - 16] % n;
            for (let r = 0; a > r; r++) l[r] = c[e + r] ^ u[t * a + r];
            gF(l, 0, c, e, i), h()
          }
        }
        return wF(t, s, f, u, l)
      }(t, e, {
        N: r,
        r: n,
        p: i,
        dkLen: o
      })
    };
    let kF = EF,
      xF = PF;
    async function IF(t, e, r, n, i, o, s) {
      const a = SR(t, "passwd"),
        u = SR(e, "salt");
      return CR(await kF(a, u, r, n, i, o, s))
    }

    function SF(t, e, r, n, i, o) {
      const s = SR(t, "passwd"),
        a = SR(e, "salt");
      return CR(xF(s, a, r, n, i, o))
    }

    function OF(t) {
      const e = SR(t, "randomBytes");
      e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128;
      const r = CR(e);
      return [r.substring(2, 10), r.substring(10, 14), r.substring(14, 18), r.substring(18, 22), r.substring(22, 34)].join("-")
    }

    function BF(t, e) {
      for (t += ""; t.length < e;) t = "0" + t;
      return t
    }

    function WF(t) {
      return "string" == typeof t ? dj(t, "NFKC") : OR(t)
    }

    function MF(t) {
      const e = null != t.salt ? SR(t.salt, "options.salt") : RU(32);
      let r = 1 << 17,
        n = 8,
        i = 1;
      return t.scrypt && (t.scrypt.N && (r = t.scrypt.N), t.scrypt.r && (n = t.scrypt.r), t.scrypt.p && (i = t.scrypt.p)), TR("number" == typeof r && r > 0 && Number.isSafeInteger(r) && (BigInt(r) & BigInt(r - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", r), TR("number" == typeof n && n > 0 && Number.isSafeInteger(n), "invalid scrypt r parameter", "options.r", n), TR("number" == typeof i && i > 0 && Number.isSafeInteger(i), "invalid scrypt p parameter", "options.p", i), {
        name: "scrypt",
        dkLen: 32,
        salt: e,
        N: r,
        r: n,
        p: i
      }
    }

    function CF(t, e, r, n) {
      const i = SR(r.privateKey, "privateKey"),
        o = null != n.iv ? SR(n.iv, "options.iv") : RU(16);
      TR(16 === o.length, "invalid options.iv length", "options.iv", n.iv);
      const s = null != n.uuid ? SR(n.uuid, "options.uuid") : RU(16);
      TR(16 === s.length, "invalid options.uuid length", "options.uuid", n.iv);
      const a = t.slice(0, 16),
        u = t.slice(16, 32),
        c = SR(new bF(a, o).encrypt(i)),
        f = Cj(RR([u, c])),
        l = {
          address: r.address.substring(2).toLowerCase(),
          id: OF(s),
          version: 3,
          Crypto: {
            cipher: "aes-128-ctr",
            cipherparams: {
              iv: CR(o).substring(2)
            },
            ciphertext: CR(c).substring(2),
            kdf: "scrypt",
            kdfparams: {
              salt: CR(e.salt).substring(2),
              n: e.N,
              dklen: 32,
              p: e.p,
              r: e.r
            },
            mac: f.substring(2)
          }
        };
      if (r.mnemonic) {
        const e = null != n.client ? n.client : "ethers/" + pR,
          i = r.mnemonic.path || "m/44'/60'/0'/0/0",
          o = r.mnemonic.locale || "en",
          s = t.slice(32, 64),
          a = SR(r.mnemonic.entropy, "account.mnemonic.entropy"),
          u = RU(16),
          c = SR(new bF(s, u).encrypt(a)),
          f = new Date,
          h = "UTC--" + f.getUTCFullYear() + "-" + BF(f.getUTCMonth() + 1, 2) + "-" + BF(f.getUTCDate(), 2) + "T" + BF(f.getUTCHours(), 2) + "-" + BF(f.getUTCMinutes(), 2) + "-" + BF(f.getUTCSeconds(), 2) + ".0Z--" + l.address;
        l["x-ethers"] = {
          client: e,
          gethFilename: h,
          path: i,
          locale: o,
          mnemonicCounter: CR(u).substring(2),
          mnemonicCiphertext: CR(c).substring(2),
          version: "0.1"
        }
      }
      return JSON.stringify(l)
    }
    IF.Pu = EF, IF.lock = function() {
      TF = !0
    }, IF.register = function(t) {
      if (TF) throw Error("scrypt is locked");
      kF = t
    }, Object.freeze(IF), SF.Pu = PF, SF.lock = function() {
      AF = !0
    }, SF.register = function(t) {
      if (AF) throw Error("scryptSync is locked");
      xF = t
    }, Object.freeze(SF);
    const RF = "m/44'/60'/0'/0/0",
      NF = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]),
      jF = 2147483648,
      _F = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");

    function DF(t, e) {
      let r = "";
      for (; t;) r = "0123456789abcdef" [t % 16] + r, t = Math.trunc(t / 16);
      for (; r.length < 2 * e;) r = "0" + r;
      return "0x" + r
    }

    function UF(t) {
      const e = SR(t);
      return function(t) {
        const e = SR(t);
        let r = KR(e),
          n = "";
        for (; r;) n = vL[+r % EL] + n, r /= EL;
        for (let t = 0; t < e.length && !e[t]; t++) n = "1" + n;
        return n
      }(RR([e, jR(oj(oj(e)), 0, 4)]))
    }
    const LF = {};

    function FF(t, e, r, n) {
      const i = new Uint8Array(37);
      t & jF ? (AR(null != n, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
        operation: "deriveChild"
      }), i.set(SR(n), 1)) : i.set(SR(r));
      for (let e = 24; e >= 0; e -= 8) i[33 + (e >> 3)] = t >> 24 - e & 255;
      const o = SR(Jj("sha512", e, i));
      return {
        IL: o.slice(0, 32),
        IR: o.slice(32)
      }
    }

    function $F(t, e) {
      const r = e.split("/");
      TR(r.length > 0, "invalid path", "path", e), "m" === r[0] && (TR(0 === t.depth, 'cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ' + t.depth, "path", e), r.shift());
      let n = t;
      for (let t = 0; t < r.length; t++) {
        const e = r[t];
        if (e.match(/^[0-9]+'$/)) {
          const r = parseInt(e.substring(0, e.length - 1));
          TR(jF > r, "invalid path index", `path[${t}]`, e), n = n.deriveChild(jF + r)
        } else if (e.match(/^[0-9]+$/)) {
          const r = parseInt(e);
          TR(jF > r, "invalid path index", `path[${t}]`, e), n = n.deriveChild(r)
        } else TR(!1, "invalid path component", `path[${t}]`, e)
      }
      return n
    }
    class zF extends UL {
      publicKey;
      fingerprint;
      parentFingerprint;
      mnemonic;
      chainCode;
      path;
      index;
      depth;
      constructor(t, e, r, n, i, o, s, a, u) {
        super(e, u), xR(t, LF, "HDNodeWallet"), yR(this, {
          publicKey: e.compressedPublicKey
        }), yR(this, {
          parentFingerprint: r,
          fingerprint: jR(BU(oj(this.publicKey)), 0, 4),
          chainCode: n,
          path: i,
          index: o,
          depth: s
        }), yR(this, {
          mnemonic: a
        })
      }
      connect(t) {
        return new zF(LF, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, t)
      }
      #t() {
        const t = {
            address: this.address,
            privateKey: this.privateKey
          },
          e = this.mnemonic;
        return this.path && e && "en" === e.wordlist.locale && "" === e.password && (t.mnemonic = {
          path: this.path,
          locale: "en",
          entropy: e.entropy
        }), t
      }
      async encrypt(t, e) {
        return await async function(t, e, r) {
          null == r && (r = {});
          const n = WF(e),
            i = MF(r);
          return CF(SR(await IF(n, i.salt, i.N, i.r, i.p, 64, r.progressCallback)), i, t, r)
        }(this.#t(), t, {
          progressCallback: e
        })
      }
      encryptSync(t) {
        return function(t, e, r) {
          null == r && (r = {});
          const n = WF(e),
            i = MF(r);
          return CF(SR(SF(n, i.salt, i.N, i.r, i.p, 64)), i, t, r)
        }(this.#t(), t)
      }
      get extendedKey() {
        return AR(256 > this.depth, "Depth too deep", "UNSUPPORTED_OPERATION", {
          operation: "extendedKey"
        }), UF(RR(["0x0488ADE4", DF(this.depth, 1), this.parentFingerprint, DF(this.index, 4), this.chainCode, RR(["0x00", this.privateKey])]))
      }
      hasPath() {
        return null != this.path
      }
      neuter() {
        return new HF(LF, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider)
      }
      deriveChild(t) {
        const e = VR(t, "index");
        TR(4294967295 >= e, "invalid index", "index", e);
        let r = this.path;
        r && (r += "/" + (e & ~jF), e & jF && (r += "'"));
        const {
          IR: n,
          IL: i
        } = FF(e, this.chainCode, this.publicKey, this.privateKey), o = new eD(ZR((KR(i) + BigInt(this.privateKey)) % _F, 32));
        return new zF(LF, o, this.fingerprint, CR(n), r, e, this.depth + 1, this.mnemonic, this.provider)
      }
      derivePath(t) {
        return $F(this, t)
      }
      static #e(t, e) {
        TR(WR(t), "invalid seed", "seed", "[REDACTED]");
        const r = SR(t, "seed");
        TR(r.length >= 16 && 64 >= r.length, "invalid seed", "seed", "[REDACTED]");
        const n = SR(Jj("sha512", NF, r)),
          i = new eD(CR(n.slice(0, 32)));
        return new zF(LF, i, "0x00000000", CR(n.slice(32)), "m", 0, 0, e, null)
      }
      static fromExtendedKey(t) {
        const e = qR(function(t) {
          let e = TL;
          for (let r = 0; r < t.length; r++) e *= EL, e += AL(t[r]);
          return e
        }(t));
        TR(82 === e.length || UF(e.slice(0, 78)) === t, "invalid extended key", "extendedKey", "[ REDACTED ]");
        const r = e[4],
          n = CR(e.slice(5, 9)),
          i = parseInt(CR(e.slice(9, 13)).substring(2), 16),
          o = CR(e.slice(13, 45)),
          s = e.slice(45, 78);
        switch (CR(e.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf": {
            const t = CR(s);
            return new HF(LF, rD(t), t, n, o, null, i, r, null)
          }
          case "0x0488ade4":
          case "0x04358394 ":
            if (0 !== s[0]) break;
            return new zF(LF, new eD(s.slice(1)), n, o, null, i, r, null, null)
        }
        TR(!1, "invalid extended key prefix", "extendedKey", "[ REDACTED ]")
      }
      static createRandom(t, e, r) {
        null == t && (t = ""), null == e && (e = RF), null == r && (r = Lj.wordlist());
        const n = Kj.fromEntropy(RU(16), t, r);
        return zF.#e(n.computeSeed(), n).derivePath(e)
      }
      static fromMnemonic(t, e) {
        return e || (e = RF), zF.#e(t.computeSeed(), t).derivePath(e)
      }
      static fromPhrase(t, e, r, n) {
        null == e && (e = ""), null == r && (r = RF), null == n && (n = Lj.wordlist());
        const i = Kj.fromPhrase(t, e, n);
        return zF.#e(i.computeSeed(), i).derivePath(r)
      }
      static fromSeed(t) {
        return zF.#e(t, null)
      }
    }
    class HF extends gL {
      publicKey;
      fingerprint;
      parentFingerprint;
      chainCode;
      path;
      index;
      depth;
      constructor(t, e, r, n, i, o, s, a, u) {
        super(e, u), xR(t, LF, "HDNodeVoidWallet"), yR(this, {
          publicKey: r
        }), yR(this, {
          publicKey: r,
          fingerprint: jR(BU(oj(r)), 0, 4),
          parentFingerprint: n,
          chainCode: i,
          path: o,
          index: s,
          depth: a
        })
      }
      connect(t) {
        return new HF(LF, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, t)
      }
      get extendedKey() {
        return AR(256 > this.depth, "Depth too deep", "UNSUPPORTED_OPERATION", {
          operation: "extendedKey"
        }), UF(RR(["0x0488B21E", DF(this.depth, 1), this.parentFingerprint, DF(this.index, 4), this.chainCode, this.publicKey]))
      }
      hasPath() {
        return null != this.path
      }
      deriveChild(t) {
        const e = VR(t, "index");
        TR(4294967295 >= e, "invalid index", "index", e);
        let r = this.path;
        r && (r += "/" + (e & ~jF), e & jF && (r += "'"));
        const {
          IR: n,
          IL: i
        } = FF(e, this.chainCode, this.publicKey, null), o = eD.addPoints(i, this.publicKey, !0), s = rD(o);
        return new HF(LF, s, o, this.fingerprint, CR(n), r, e, this.depth + 1, this.provider)
      }
      derivePath(t) {
        return $F(this, t)
      }
    }
    const GF = {
      en: Lj.wordlist()
    };
    var KF;

    function VF(t) {
      const e = new Set;
      return t.forEach(t => e.add(t)), Object.freeze(e)
    }
    const ZF = "constant external internal payable private public pure view",
      qF = VF(ZF.split(" ")),
      JF = "constructor error event fallback function receive struct",
      YF = VF(JF.split(" ")),
      QF = "calldata memory storage payable indexed",
      XF = VF(QF.split(" ")),
      t$ = VF([JF, QF, "tuple returns", ZF].join(" ").split(" ")),
      e$ = {
        "(": "OPEN_PAREN",
        ")": "CLOSE_PAREN",
        "[": "OPEN_BRACKET",
        "]": "CLOSE_BRACKET",
        ",": "COMMA",
        "@": "AT"
      },
      r$ = RegExp("^(\\s*)"),
      n$ = RegExp("^([0-9]+)"),
      i$ = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)"),
      o$ = RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$"),
      s$ = RegExp("^(trcToken|address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
    class a$ {
      #t;
      #e;
      get offset() {
        return this.#t
      }
      get length() {
        return this.#e.length - this.#t
      }
      constructor(t) {
        this.#t = 0, this.#e = t.slice()
      }
      clone() {
        return new KF(this.#e)
      }
      reset() {
        this.#t = 0
      }
      #r(t = 0, e = 0) {
        return new KF(this.#e.slice(t, e).map(e => Object.freeze(Object.assign({}, e, {
          match: e.match - t,
          linkBack: e.linkBack - t,
          linkNext: e.linkNext - t
        }))))
      }
      popKeyword(t) {
        const e = this.peek();
        if ("KEYWORD" !== e.type || !t.has(e.text)) throw Error("expected keyword " + e.text);
        return this.pop().text
      }
      popType(t) {
        if (this.peek().type !== t) throw Error(`expected ${t}; got ${JSON.stringify(this.peek())}`);
        return this.pop().text
      }
      popParen() {
        const t = this.peek();
        if ("OPEN_PAREN" !== t.type) throw Error("bad start");
        const e = this.#r(this.#t + 1, t.match + 1);
        return this.#t = t.match + 1, e
      }
      popParams() {
        const t = this.peek();
        if ("OPEN_PAREN" !== t.type) throw Error("bad start");
        const e = [];
        for (; this.#t < t.match - 1;) {
          const t = this.peek().linkNext;
          e.push(this.#r(this.#t + 1, t)), this.#t = t
        }
        return this.#t = t.match + 1, e
      }
      peek() {
        if (this.#t >= this.#e.length) throw Error("out-of-bounds");
        return this.#e[this.#t]
      }
      peekKeyword(t) {
        const e = this.peekType("KEYWORD");
        return null != e && t.has(e) ? e : null
      }
      peekType(t) {
        if (0 === this.length) return null;
        const e = this.peek();
        return e.type === t ? e.text : null
      }
      pop() {
        const t = this.peek();
        return this.#t++, t
      }
      toString() {
        const t = [];
        for (let e = this.#t; e < this.#e.length; e++) {
          const r = this.#e[e];
          t.push(`${r.type}:${r.text}`)
        }
        return `<TokenString ${t.join(" ")}>`
      }
    }

    function u$(t) {
      const e = [],
        r = e => {
          const r = o < t.length ? JSON.stringify(t[o]) : "$EOI";
          throw Error(`invalid token ${r} at ${o}: ${e}`)
        },
        n = [],
        i = [];
      let o = 0;
      for (; o < t.length;) {
        let s = t.substring(o),
          a = s.match(r$);
        a && (o += a[1].length, s = t.substring(o));
        const u = {
          depth: n.length,
          linkBack: -1,
          linkNext: -1,
          match: -1,
          type: "",
          text: "",
          offset: o,
          value: -1
        };
        e.push(u);
        const c = e$[s[0]] || "";
        if (c) {
          if (u.type = c, u.text = s[0], o++, "OPEN_PAREN" === c) n.push(e.length - 1), i.push(e.length - 1);
          else if ("CLOSE_PAREN" == c) 0 === n.length && r("no matching open bracket"), u.match = n.pop(), e[u.match].match = e.length - 1, u.depth--, u.linkBack = i.pop(), e[u.linkBack].linkNext = e.length - 1;
          else if ("COMMA" === c) u.linkBack = i.pop(), e[u.linkBack].linkNext = e.length - 1, i.push(e.length - 1);
          else if ("OPEN_BRACKET" === c) u.type = "BRACKET";
          else if ("CLOSE_BRACKET" === c) {
            let t = e.pop().text;
            if (e.length > 0 && "NUMBER" === e[e.length - 1].type) {
              const r = e.pop().text;
              t = r + t, e[e.length - 1].value = VR(r)
            }
            if (0 === e.length || "BRACKET" !== e[e.length - 1].type) throw Error("missing opening bracket");
            e[e.length - 1].text += t
          }
        } else if (a = s.match(i$), a) {
          if (u.text = a[1], o += u.text.length, t$.has(u.text)) {
            u.type = "KEYWORD";
            continue
          }
          if (u.text.match(s$)) {
            u.type = "TYPE";
            continue
          }
          u.type = "ID"
        } else {
          if (a = s.match(n$), !a) throw Error(`unexpected token ${JSON.stringify(s[0])} at position ${o}`);
          u.text = a[1], u.type = "NUMBER", o += u.text.length
        }
      }
      return new a$(e.map(t => Object.freeze(t)))
    }

    function c$(t, e) {
      const r = [];
      for (const n in e.keys()) t.has(n) && r.push(n);
      if (r.length > 1) throw Error("conflicting types: " + r.join(", "))
    }

    function f$(t, e) {
      if (e.peekKeyword(YF)) {
        const r = e.pop().text;
        if (r !== t) throw Error(`expected ${t}, got ${r}`)
      }
      return e.popType("ID")
    }

    function l$(t, e) {
      const r = new Set;
      for (;;) {
        const n = t.peekType("KEYWORD");
        if (null == n || e && !e.has(n)) break;
        if (t.pop(), r.has(n)) throw Error("duplicate keywords: " + JSON.stringify(n));
        r.add(n)
      }
      return Object.freeze(r)
    }

    function h$(t) {
      const e = l$(t, qF);
      return c$(e, VF("constant payable nonpayable".split(" "))), c$(e, VF("pure view payable nonpayable".split(" "))), e.has("view") ? "view" : e.has("pure") ? "pure" : e.has("payable") ? "payable" : e.has("nonpayable") ? "nonpayable" : e.has("constant") ? "view" : "nonpayable"
    }

    function d$(t, e) {
      return t.popParams().map(t => I$.from(t, e))
    }

    function p$(t) {
      if (t.peekType("AT")) {
        if (t.pop(), t.peekType("NUMBER")) return zR(t.pop().text);
        throw Error("invalid gas")
      }
      return null
    }

    function b$(t) {
      if (t.length) throw Error("unexpected tokens: " + t.toString())
    }
    KF = a$;
    const m$ = RegExp(/^(.*)\[([0-9]*)\]$/);

    function y$(t) {
      const e = t.match(s$);
      if (TR(e, "invalid type", "type", t), "uint" === t) return "uint256";
      if ("int" === t) return "int256";
      if (e[2]) {
        const r = parseInt(e[2]);
        TR(0 !== r && 32 >= r, "invalid bytes length", "type", t)
      } else if (e[3]) {
        const r = parseInt(e[3]);
        TR(0 !== r && 256 >= r && r % 8 == 0, "invalid numeric width", "type", t)
      }
      return t
    }
    const g$ = {},
      v$ = Symbol.for("_ethers_internal"),
      w$ = "_ParamTypeInternal",
      A$ = "_ErrorInternal",
      T$ = "_EventInternal",
      E$ = "_ConstructorInternal",
      P$ = "_FallbackInternal",
      k$ = "_FunctionInternal",
      x$ = "_StructInternal";
    class I$ {
      name;
      type;
      baseType;
      indexed;
      components;
      arrayLength;
      arrayChildren;
      constructor(t, e, r, n, i, o, s, a) {
        if (xR(t, g$, "ParamType"), Object.defineProperty(this, v$, {
            value: w$
          }), o && (o = Object.freeze(o.slice())), "array" === n) {
          if (null == s || null == a) throw Error("")
        } else if (null != s || null != a) throw Error("");
        if ("tuple" === n) {
          if (null == o) throw Error("")
        } else if (null != o) throw Error("");
        yR(this, {
          name: e,
          type: r,
          baseType: n,
          indexed: i,
          components: o,
          arrayLength: s,
          arrayChildren: a
        })
      }
      format(t) {
        if (null == t && (t = "sighash"), "json" === t) {
          const e = {
            type: "tuple" === this.baseType ? "tuple" : this.type,
            name: this.name || void 0
          };
          return "boolean" == typeof this.indexed && (e.indexed = this.indexed), this.isTuple() && (e.components = this.components.map(e => JSON.parse(e.format(t)))), JSON.stringify(e)
        }
        let e = "";
        return this.isArray() ? (e += this.arrayChildren.format(t), e += `[${0>this.arrayLength?"":this.arrayLength+""}]`) : this.isTuple() ? ("sighash" !== t && (e += this.type), e += "(" + this.components.map(e => e.format(t)).join("full" === t ? ", " : ",") + ")") : e += this.type, "sighash" !== t && (!0 === this.indexed && (e += " indexed"), "full" === t && this.name && (e += " " + this.name)), e
      }
      isArray() {
        return "array" === this.baseType
      }
      isTuple() {
        return "tuple" === this.baseType
      }
      isIndexable() {
        return null != this.indexed
      }
      walk(t, e) {
        if (this.isArray()) {
          if (!Array.isArray(t)) throw Error("invalid array value");
          if (-1 !== this.arrayLength && t.length !== this.arrayLength) throw Error("array is wrong length");
          return t.map(t => this.arrayChildren?.walk(t, e))
        }
        if (this.isTuple()) {
          if (!Array.isArray(t)) throw Error("invalid tuple value");
          if (t.length !== this.components.length) throw Error("array is wrong length");
          return t.map((t, r) => this.components?.[r].walk(t, e))
        }
        return e(this.type, t)
      }
      #t(t, e, r, n) {
        if (this.isArray()) {
          if (!Array.isArray(e)) throw Error("invalid array value");
          if (-1 !== this.arrayLength && e.length !== this.arrayLength) throw Error("array is wrong length");
          const i = this.arrayChildren,
            o = e.slice();
          return o.forEach((e, n) => {
            i.#t(t, e, r, t => {
              o[n] = t
            })
          }), void n(o)
        }
        if (this.isTuple()) {
          const i = this.components;
          let o;
          if (Array.isArray(e)) o = e.slice();
          else {
            if (null == e || "object" != typeof e) throw Error("invalid tuple value");
            o = i.map(t => {
              if (!t.name) throw Error("cannot use object value with unnamed components");
              if (!(t.name in e)) throw Error("missing value for component " + t.name);
              return e[t.name]
            })
          }
          if (o.length !== this.components.length) throw Error("array is wrong length");
          return o.forEach((e, n) => {
            i[n].#t(t, e, r, t => {
              o[n] = t
            })
          }), void n(o)
        }
        const i = r(this.type, e);
        i.then ? t.push(async function() {
          n(await i)
        }()) : n(i)
      }
      async walkAsync(t, e) {
        const r = [],
          n = [t];
        return this.#t(r, t, e, t => {
          n[0] = t
        }), r.length && await Promise.all(r), n[0]
      }
      static from(t, e) {
        if (I$.isParamType(t)) return t;
        if ("string" == typeof t) return I$.from(u$(t), e);
        if (t instanceof a$) {
          let r = "",
            n = "",
            i = null;
          l$(t, VF(["tuple"])).has("tuple") || t.peekType("OPEN_PAREN") ? (n = "tuple", i = t.popParams().map(t => I$.from(t)), r = `tuple(${i.map(t=>t.format()).join(",")})`) : (r = y$(t.popType("TYPE")), n = r);
          let o = null,
            s = null;
          for (; t.length && t.peekType("BRACKET");) {
            const e = t.pop();
            o = new I$(g$, "", r, n, null, i, s, o), s = e.value, r += e.text, n = "array", i = null
          }
          let a = null;
          if (l$(t, XF).has("indexed")) {
            if (!e) throw Error("");
            a = !0
          }
          const u = t.peekType("ID") ? t.pop().text : "";
          if (t.length) throw Error("leftover tokens");
          return new I$(g$, u, r, n, a, i, s, o)
        }
        const r = t.name;
        TR(!r || "string" == typeof r && r.match(o$), "invalid name", "obj.name", r);
        let n = t.indexed;
        null != n && (TR(e, "parameter cannot be indexed", "obj.indexed", t.indexed), n = !!n);
        let i = t.type;
        const o = i.match(m$);
        if (o) {
          const e = parseInt(o[2] || "-1"),
            s = I$.from({
              type: o[1],
              components: t.components
            });
          return new I$(g$, r || "", i, "array", n, null, e, s)
        }
        if ("tuple" === i || i.startsWith("tuple(") || i.startsWith("(")) {
          const e = null != t.components ? t.components.map(t => I$.from(t)) : null;
          return new I$(g$, r || "", i, "tuple", n, e, null, null)
        }
        return i = y$(t.type), new I$(g$, r || "", i, i, n, null, null, null)
      }
      static isParamType(t) {
        return t && t[v$] === w$
      }
    }
    class S$ {
      type;
      inputs;
      constructor(t, e, r) {
        xR(t, g$, "Fragment"), yR(this, {
          type: e,
          inputs: r = Object.freeze(r.slice())
        })
      }
      static from(t) {
        if ("string" == typeof t) {
          try {
            S$.from(JSON.parse(t))
          } catch {}
          return S$.from(u$(t))
        }
        if (t instanceof a$) switch (t.peekKeyword(YF)) {
          case "constructor":
            return C$.from(t);
          case "error":
            return W$.from(t);
          case "event":
            return M$.from(t);
          case "fallback":
          case "receive":
            return R$.from(t);
          case "function":
            return N$.from(t);
          case "struct":
            return j$.from(t)
        } else if ("object" == typeof t) {
          switch (t.type) {
            case "constructor":
              return C$.from(t);
            case "error":
              return W$.from(t);
            case "event":
              return M$.from(t);
            case "fallback":
            case "receive":
              return R$.from(t);
            case "function":
              return N$.from(t);
            case "struct":
              return j$.from(t)
          }
          AR(!1, "unsupported type: " + t.type, "UNSUPPORTED_OPERATION", {
            operation: "Fragment.from"
          })
        } TR(!1, "unsupported frgament object", "obj", t)
      }
      static isConstructor(t) {
        return C$.isFragment(t)
      }
      static isError(t) {
        return W$.isFragment(t)
      }
      static isEvent(t) {
        return M$.isFragment(t)
      }
      static isFunction(t) {
        return N$.isFragment(t)
      }
      static isStruct(t) {
        return j$.isFragment(t)
      }
    }
    class O$ extends S$ {
      name;
      constructor(t, e, r, n) {
        super(t, e, n), TR("string" == typeof r && r.match(o$), "invalid identifier", "name", r), n = Object.freeze(n.slice()), yR(this, {
          name: r
        })
      }
    }

    function B$(t, e) {
      return "(" + e.map(e => e.format(t)).join("full" === t ? ", " : ",") + ")"
    }
    class W$ extends O$ {
      constructor(t, e, r) {
        super(t, "error", e, r), Object.defineProperty(this, v$, {
          value: A$
        })
      }
      get selector() {
        return Rj(this.format("sighash")).substring(0, 10)
      }
      format(t) {
        if (null == t && (t = "sighash"), "json" === t) return JSON.stringify({
          type: "error",
          name: this.name,
          inputs: this.inputs.map(e => JSON.parse(e.format(t)))
        });
        const e = [];
        return "sighash" !== t && e.push("error"), e.push(this.name + B$(t, this.inputs)), e.join(" ")
      }
      static from(t) {
        if (W$.isFragment(t)) return t;
        if ("string" == typeof t) return W$.from(u$(t));
        if (t instanceof a$) {
          const e = f$("error", t),
            r = d$(t);
          return b$(t), new W$(g$, e, r)
        }
        return new W$(g$, t.name, t.inputs ? t.inputs.map(I$.from) : [])
      }
      static isFragment(t) {
        return t && t[v$] === A$
      }
    }
    class M$ extends O$ {
      anonymous;
      constructor(t, e, r, n) {
        super(t, "event", e, r), Object.defineProperty(this, v$, {
          value: T$
        }), yR(this, {
          anonymous: n
        })
      }
      get topicHash() {
        return Rj(this.format("sighash"))
      }
      format(t) {
        if (null == t && (t = "sighash"), "json" === t) return JSON.stringify({
          type: "event",
          anonymous: this.anonymous,
          name: this.name,
          inputs: this.inputs.map(e => JSON.parse(e.format(t)))
        });
        const e = [];
        return "sighash" !== t && e.push("event"), e.push(this.name + B$(t, this.inputs)), "sighash" !== t && this.anonymous && e.push("anonymous"), e.join(" ")
      }
      static getTopicHash(t, e) {
        return e = (e || []).map(t => I$.from(t)), new M$(g$, t, e, !1).topicHash
      }
      static from(t) {
        if (M$.isFragment(t)) return t;
        if ("string" == typeof t) return M$.from(u$(t));
        if (t instanceof a$) {
          const e = f$("event", t),
            r = d$(t, !0),
            n = !!l$(t, VF(["anonymous"])).has("anonymous");
          return b$(t), new M$(g$, e, r, n)
        }
        return new M$(g$, t.name, t.inputs ? t.inputs.map(t => I$.from(t, !0)) : [], !!t.anonymous)
      }
      static isFragment(t) {
        return t && t[v$] === T$
      }
    }
    class C$ extends S$ {
      payable;
      gas;
      constructor(t, e, r, n, i) {
        super(t, e, r), Object.defineProperty(this, v$, {
          value: E$
        }), yR(this, {
          payable: n,
          gas: i
        })
      }
      format(t) {
        if (AR(null != t && "sighash" !== t, "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", {
            operation: "format(sighash)"
          }), "json" === t) return JSON.stringify({
          type: "constructor",
          stateMutability: this.payable ? "payable" : "undefined",
          payable: this.payable,
          gas: null != this.gas ? this.gas : void 0,
          inputs: this.inputs.map(e => JSON.parse(e.format(t)))
        });
        const e = ["constructor" + B$(t, this.inputs)];
        return e.push(this.payable ? "payable" : "nonpayable"), null != this.gas && e.push("@" + this.gas.toString()), e.join(" ")
      }
      static from(t) {
        if (C$.isFragment(t)) return t;
        if ("string" == typeof t) return C$.from(u$(t));
        if (t instanceof a$) {
          l$(t, VF(["constructor"]));
          const e = d$(t),
            r = !!l$(t, VF(["payable"])).has("payable"),
            n = p$(t);
          return b$(t), new C$(g$, "constructor", e, r, n)
        }
        return new C$(g$, "constructor", t.inputs ? t.inputs.map(I$.from) : [], !!t.payable, null != t.gas ? t.gas : null)
      }
      static isFragment(t) {
        return t && t[v$] === E$
      }
    }
    class R$ extends S$ {
      payable;
      constructor(t, e, r) {
        super(t, "fallback", e), Object.defineProperty(this, v$, {
          value: P$
        }), yR(this, {
          payable: r
        })
      }
      format(t) {
        const e = 0 === this.inputs.length ? "receive" : "fallback";
        if ("json" === t) {
          const t = this.payable ? "payable" : "nonpayable";
          return JSON.stringify({
            type: e,
            stateMutability: t
          })
        }
        return `${e}()${this.payable?" payable":""}`
      }
      static from(t) {
        if (R$.isFragment(t)) return t;
        if ("string" == typeof t) return R$.from(u$(t));
        if (t instanceof a$) {
          const e = t.toString();
          if (TR(t.peekKeyword(VF(["fallback", "receive"])), "type must be fallback or receive", "obj", e), "receive" === t.popKeyword(VF(["fallback", "receive"]))) {
            const e = d$(t);
            return TR(0 === e.length, "receive cannot have arguments", "obj.inputs", e), l$(t, VF(["payable"])), b$(t), new R$(g$, [], !0)
          }
          let r = d$(t);
          r.length ? TR(1 === r.length && "bytes" === r[0].type, "invalid fallback inputs", "obj.inputs", r.map(t => t.format("minimal")).join(", ")) : r = [I$.from("bytes")];
          const n = h$(t);
          if (TR("nonpayable" === n || "payable" === n, "fallback cannot be constants", "obj.stateMutability", n), l$(t, VF(["returns"])).has("returns")) {
            const e = d$(t);
            TR(1 === e.length && "bytes" === e[0].type, "invalid fallback outputs", "obj.outputs", e.map(t => t.format("minimal")).join(", "))
          }
          return b$(t), new R$(g$, r, "payable" === n)
        }
        if ("receive" === t.type) return new R$(g$, [], !0);
        if ("fallback" === t.type) {
          const e = [I$.from("bytes")],
            r = "payable" === t.stateMutability;
          return new R$(g$, e, r)
        }
        TR(!1, "invalid fallback description", "obj", t)
      }
      static isFragment(t) {
        return t && t[v$] === P$
      }
    }
    class N$ extends O$ {
      constant;
      outputs;
      stateMutability;
      payable;
      gas;
      constructor(t, e, r, n, i, o) {
        super(t, "function", e, n), Object.defineProperty(this, v$, {
          value: k$
        }), yR(this, {
          constant: "view" === r || "pure" === r,
          gas: o,
          outputs: i = Object.freeze(i.slice()),
          payable: "payable" === r,
          stateMutability: r
        })
      }
      get selector() {
        return Rj(this.format("sighash")).substring(0, 10)
      }
      format(t) {
        if (null == t && (t = "sighash"), "json" === t) return JSON.stringify({
          type: "function",
          name: this.name,
          constant: this.constant,
          stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
          payable: this.payable,
          gas: null != this.gas ? this.gas : void 0,
          inputs: this.inputs.map(e => JSON.parse(e.format(t))),
          outputs: this.outputs.map(e => JSON.parse(e.format(t)))
        });
        const e = [];
        return "sighash" !== t && e.push("function"), e.push(this.name + B$(t, this.inputs)), "sighash" !== t && ("nonpayable" !== this.stateMutability && e.push(this.stateMutability), this.outputs && this.outputs.length && (e.push("returns"), e.push(B$(t, this.outputs))), null != this.gas && e.push("@" + this.gas.toString())), e.join(" ")
      }
      static getSelector(t, e) {
        return e = (e || []).map(t => I$.from(t)), new N$(g$, t, "view", e, [], null).selector
      }
      static from(t) {
        if (N$.isFragment(t)) return t;
        if ("string" == typeof t) return N$.from(u$(t));
        if (t instanceof a$) {
          const e = f$("function", t),
            r = d$(t),
            n = h$(t);
          let i = [];
          l$(t, VF(["returns"])).has("returns") && (i = d$(t));
          const o = p$(t);
          return b$(t), new N$(g$, e, n, r, i, o)
        }
        let e = t.stateMutability;
        return null == e && (e = "payable", "boolean" == typeof t.constant ? (e = "view", t.constant || (e = "payable", "boolean" == typeof t.payable && !t.payable && (e = "nonpayable"))) : "boolean" == typeof t.payable && !t.payable && (e = "nonpayable")), new N$(g$, t.name, e, t.inputs ? t.inputs.map(I$.from) : [], t.outputs ? t.outputs.map(I$.from) : [], null != t.gas ? t.gas : null)
      }
      static isFragment(t) {
        return t && t[v$] === k$
      }
    }
    class j$ extends O$ {
      constructor(t, e, r) {
        super(t, "struct", e, r), Object.defineProperty(this, v$, {
          value: x$
        })
      }
      format() {
        throw Error("@TODO")
      }
      static from(t) {
        if ("string" == typeof t) return j$.from(u$(t));
        if (t instanceof a$) {
          const e = f$("struct", t),
            r = d$(t);
          return b$(t), new j$(g$, e, r)
        }
        return new j$(g$, t.name, t.inputs ? t.inputs.map(I$.from) : [])
      }
      static isFragment(t) {
        return t && t[v$] === x$
      }
    }
    class _$ {
      fragment;
      name;
      signature;
      topic;
      args;
      constructor(t, e, r) {
        const n = t.name,
          i = t.format();
        yR(this, {
          fragment: t,
          name: n,
          signature: i,
          topic: e,
          args: r
        })
      }
    }
    class D$ {
      fragment;
      name;
      args;
      signature;
      selector;
      value;
      constructor(t, e, r, n) {
        const i = t.name,
          o = t.format();
        yR(this, {
          fragment: t,
          name: i,
          args: r,
          signature: o,
          selector: e,
          value: n
        })
      }
    }
    class U$ {
      fragment;
      name;
      args;
      signature;
      selector;
      constructor(t, e, r) {
        const n = t.name,
          i = t.format();
        yR(this, {
          fragment: t,
          name: n,
          args: r,
          signature: i,
          selector: e
        })
      }
    }
    class L$ {
      hash;
      Bu;
      static isIndexed(t) {
        return !(!t || !t.Bu)
      }
      constructor(t) {
        yR(this, {
          hash: t,
          Bu: !0
        })
      }
    }
    const F$ = {
        0: "generic panic",
        1: "assert(false)",
        17: "arithmetic overflow",
        18: "division or modulo by zero",
        33: "enum overflow",
        34: "invalid encoded storage byte array accessed",
        49: "out-of-bounds array access; popping on an empty array",
        50: "out-of-bounds access of an array or bytesN",
        65: "out of memory",
        81: "uninitialized function"
      },
      $$ = {
        "0x08c379a0": {
          signature: "Error(string)",
          name: "Error",
          inputs: ["string"],
          reason: t => "reverted with reason string " + JSON.stringify(t)
        },
        "0x4e487b71": {
          signature: "Panic(uint256)",
          name: "Panic",
          inputs: ["uint256"],
          reason: t => {
            let e = "unknown panic code";
            return t >= 0 && 255 >= t && F$[t.toString()] && (e = F$[t.toString()]), `reverted with panic code 0x${t.toString(16)} (${e})`
          }
        }
      };
    class z$ {
      fragments;
      deploy;
      fallback;
      receive;
      #t;
      #e;
      #r;
      #n;
      constructor(t) {
        let e = [];
        e = "string" == typeof t ? JSON.parse(t) : t, this.#r = new Map, this.#t = new Map, this.#e = new Map;
        const r = [];
        for (const t of e) try {
          r.push(S$.from(t))
        } catch (t) {
          console.log("EE", t)
        }
        yR(this, {
          fragments: Object.freeze(r)
        });
        let n = null,
          i = !1;
        this.#n = this.getAbiCoder(), this.fragments.forEach((t, e) => {
          let r;
          switch (t.type) {
            case "constructor":
              return this.deploy ? void console.log("duplicate definition - constructor") : void yR(this, {
                deploy: t
              });
            case "fallback":
              return void(0 === t.inputs.length ? i = !0 : (TR(!n || t.payable !== n.payable, "conflicting fallback fragments", `fragments[${e}]`, t), n = t, i = n.payable));
            case "function":
              r = this.#r;
              break;
            case "event":
              r = this.#e;
              break;
            case "error":
              r = this.#t;
              break;
            default:
              return
          }
          const o = t.format();
          r.has(o) || r.set(o, t)
        }), this.deploy || yR(this, {
          deploy: C$.from("constructor()")
        }), yR(this, {
          fallback: n,
          receive: i
        })
      }
      format(t) {
        const e = t ? "minimal" : "full";
        return this.fragments.map(t => t.format(e))
      }
      formatJson() {
        const t = this.fragments.map(t => t.format("json"));
        return JSON.stringify(t.map(t => JSON.parse(t)))
      }
      getAbiCoder() {
        return lU.defaultAbiCoder()
      }
      #i(t, e, r) {
        if (BR(t)) {
          const e = t.toLowerCase();
          for (const t of this.#r.values())
            if (e === t.selector) return t;
          return null
        }
        if (-1 === t.indexOf("(")) {
          const n = [];
          for (const [e, r] of this.#r) e.split("(")[0] === t && n.push(r);
          if (e) {
            const t = e.length > 0 ? e[e.length - 1] : null;
            let r = e.length,
              i = !0;
            TD.isTyped(t) && "overrides" === t.type && (i = !1, r--);
            for (let t = n.length - 1; t >= 0; t--) {
              const e = n[t].inputs.length;
              e !== r && (!i || e !== r - 1) && n.splice(t, 1)
            }
            for (let t = n.length - 1; t >= 0; t--) {
              const r = n[t].inputs;
              for (let i = 0; i < e.length; i++)
                if (TD.isTyped(e[i])) {
                  if (i >= r.length) {
                    if ("overrides" === e[i].type) continue;
                    n.splice(t, 1);
                    break
                  }
                  if (e[i].type !== r[i].baseType) {
                    n.splice(t, 1);
                    break
                  }
                }
            }
          }
          if (1 === n.length && e && e.length !== n[0].inputs.length) {
            const t = e[e.length - 1];
            (null == t || Array.isArray(t) || "object" != typeof t) && n.splice(0, 1)
          }
          return 0 === n.length ? null : (n.length > 1 && r && TR(!1, `ambiguous function description (i.e. matches ${n.map(t=>JSON.stringify(t.format())).join(", ")})`, "key", t), n[0])
        }
        return this.#r.get(N$.from(t).format()) || null
      }
      getFunctionName(t) {
        const e = this.#i(t, null, !1);
        return TR(e, "no matching function", "key", t), e.name
      }
      hasFunction(t) {
        return !!this.#i(t, null, !1)
      }
      getFunction(t, e) {
        return this.#i(t, e || null, !0)
      }
      forEachFunction(t) {
        const e = Array.from(this.#r.keys());
        e.sort((t, e) => t.localeCompare(e));
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          t(this.#r.get(n), r)
        }
      }
      #o(t, e, r) {
        if (BR(t)) {
          const e = t.toLowerCase();
          for (const t of this.#e.values())
            if (e === t.topicHash) return t;
          return null
        }
        if (-1 === t.indexOf("(")) {
          const n = [];
          for (const [e, r] of this.#e) e.split("(")[0] === t && n.push(r);
          if (e) {
            for (let t = n.length - 1; t >= 0; t--) n[t].inputs.length < e.length && n.splice(t, 1);
            for (let t = n.length - 1; t >= 0; t--) {
              const r = n[t].inputs;
              for (let i = 0; i < e.length; i++)
                if (TD.isTyped(e[i]) && e[i].type !== r[i].baseType) {
                  n.splice(t, 1);
                  break
                }
            }
          }
          return 0 === n.length ? null : (n.length > 1 && r && TR(!1, `ambiguous event description (i.e. matches ${n.map(t=>JSON.stringify(t.format())).join(", ")})`, "key", t), n[0])
        }
        return this.#e.get(M$.from(t).format()) || null
      }
      getEventName(t) {
        const e = this.#o(t, null, !1);
        return TR(e, "no matching event", "key", t), e.name
      }
      hasEvent(t) {
        return !!this.#o(t, null, !1)
      }
      getEvent(t, e) {
        return this.#o(t, e || null, !0)
      }
      forEachEvent(t) {
        const e = Array.from(this.#e.keys());
        e.sort((t, e) => t.localeCompare(e));
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          t(this.#e.get(n), r)
        }
      }
      getError(t, e) {
        if (BR(t)) {
          const e = t.toLowerCase();
          if ($$[e]) return W$.from($$[e].signature);
          for (const t of this.#t.values())
            if (e === t.selector) return t;
          return null
        }
        if (-1 === t.indexOf("(")) {
          const e = [];
          for (const [r, n] of this.#t) r.split("(")[0] === t && e.push(n);
          return 0 === e.length ? "Error" === t ? W$.from("error Error(string)") : "Panic" === t ? W$.from("error Panic(uint256)") : null : (e.length > 1 && TR(!1, `ambiguous error description (i.e. ${e.map(t=>JSON.stringify(t.format())).join(", ")})`, "name", t), e[0])
        }
        return "Error(string)" === (t = W$.from(t).format()) ? W$.from("error Error(string)") : "Panic(uint256)" === t ? W$.from("error Panic(uint256)") : this.#t.get(t) || null
      }
      forEachError(t) {
        const e = Array.from(this.#t.keys());
        e.sort((t, e) => t.localeCompare(e));
        for (let r = 0; r < e.length; r++) {
          const n = e[r];
          t(this.#t.get(n), r)
        }
      }
      Wu(t, e) {
        return this.#n.decode(t, e)
      }
      Mu(t, e) {
        return this.#n.encode(t, e)
      }
      encodeDeploy(t) {
        return this.Mu(this.deploy.inputs, t || [])
      }
      decodeErrorResult(t, e) {
        if ("string" == typeof t) {
          const e = this.getError(t);
          TR(e, "unknown error", "fragment", t), t = e
        }
        return TR(jR(e, 0, 4) === t.selector, `data signature does not match error ${t.name}.`, "data", e), this.Wu(t.inputs, jR(e, 4))
      }
      encodeErrorResult(t, e) {
        if ("string" == typeof t) {
          const e = this.getError(t);
          TR(e, "unknown error", "fragment", t), t = e
        }
        return RR([t.selector, this.Mu(t.inputs, e || [])])
      }
      decodeFunctionData(t, e) {
        if ("string" == typeof t) {
          const e = this.getFunction(t);
          TR(e, "unknown function", "fragment", t), t = e
        }
        return TR(jR(e, 0, 4) === t.selector, `data signature does not match function ${t.name}.`, "data", e), this.Wu(t.inputs, jR(e, 4))
      }
      encodeFunctionData(t, e) {
        if ("string" == typeof t) {
          const e = this.getFunction(t);
          TR(e, "unknown function", "fragment", t), t = e
        }
        return RR([t.selector, this.Mu(t.inputs, e || [])])
      }
      decodeFunctionResult(t, e) {
        if ("string" == typeof t) {
          const e = this.getFunction(t);
          TR(e, "unknown function", "fragment", t), t = e
        }
        let r = "invalid length for result data";
        const n = OR(e);
        if (n.length % 32 == 0) try {
          return this.#n.decode(t.outputs, n)
        } catch {
          r = "could not decode result data"
        }
        AR(!1, r, "BAD_DATA", {
          value: CR(n),
          info: {
            method: t.name,
            signature: t.format()
          }
        })
      }
      makeError(t, e) {
        const r = SR(t, "data"),
          n = lU.getBuiltinCallException("call", e, r);
        if (n.message.startsWith("execution reverted (unknown custom error)")) {
          const t = CR(r.slice(0, 4)),
            e = this.getError(t);
          if (e) try {
            const t = this.#n.decode(e.inputs, r.slice(4));
            n.revert = {
              name: e.name,
              signature: e.format(),
              args: t
            }, n.reason = n.revert.signature, n.message = "execution reverted: " + n.reason
          } catch {
            n.message = "execution reverted (coult not decode custom error)"
          }
        }
        const i = this.parseTransaction(e);
        return i && (n.invocation = {
          method: i.name,
          signature: i.signature,
          args: i.args
        }), n
      }
      encodeFunctionResult(t, e) {
        if ("string" == typeof t) {
          const e = this.getFunction(t);
          TR(e, "unknown function", "fragment", t), t = e
        }
        return CR(this.#n.encode(t.outputs, e || []))
      }
      encodeFilterTopics(t, e) {
        if ("string" == typeof t) {
          const e = this.getEvent(t);
          TR(e, "unknown event", "eventFragment", t), t = e
        }
        AR(e.length <= t.inputs.length, "too many arguments for " + t.format(), "UNEXPECTED_ARGUMENT", {
          count: e.length,
          expectedCount: t.inputs.length
        });
        const r = [];
        t.anonymous || r.push(t.topicHash);
        const n = (t, e) => "string" === t.type ? Rj(e) : "bytes" === t.type ? Cj(CR(e)) : ("bool" === t.type && "boolean" == typeof e && (e = e ? "0x01" : "0x00"), t.type.match(/^u?int/) && (e = ZR(e)), "address" === t.type && this.#n.encode(["address"], [e]), _R(CR(e), 32));
        for (e.forEach((e, i) => {
            const o = t.inputs[i];
            o.indexed ? null == e ? r.push(null) : "array" === o.baseType || "tuple" === o.baseType ? TR(!1, "filtering with tuples or arrays not supported", "contract." + o.name, e) : Array.isArray(e) ? r.push(e.map(t => n(o, t))) : r.push(n(o, e)) : TR(null == e, "cannot filter non-indexed parameters; must be null", "contract." + o.name, e)
          }); r.length && null === r[r.length - 1];) r.pop();
        return r
      }
      encodeEventLog(t, e) {
        if ("string" == typeof t) {
          const e = this.getEvent(t);
          TR(e, "unknown event", "eventFragment", t), t = e
        }
        const r = [],
          n = [],
          i = [];
        return t.anonymous || r.push(t.topicHash), TR(e.length === t.inputs.length, "event arguments/values mismatch", "values", e), t.inputs.forEach((t, o) => {
          const s = e[o];
          if (t.indexed)
            if ("string" === t.type) r.push(Rj(s));
            else if ("bytes" === t.type) r.push(Cj(s));
          else {
            if ("tuple" === t.baseType || "array" === t.baseType) throw Error("not implemented");
            r.push(this.#n.encode([t.type], [s]))
          } else n.push(t), i.push(s)
        }), {
          data: this.#n.encode(n, i),
          topics: r
        }
      }
      decodeEventLog(t, e, r) {
        if ("string" == typeof t) {
          const e = this.getEvent(t);
          TR(e, "unknown event", "eventFragment", t), t = e
        }
        if (null != r && !t.anonymous) {
          const e = t.topicHash;
          TR(BR(r[0], 32) && r[0].toLowerCase() === e, "fragment/topic mismatch", "topics[0]", r[0]), r = r.slice(1)
        }
        const n = [],
          i = [],
          o = [];
        t.inputs.forEach((t, e) => {
          t.indexed ? "string" === t.type || "bytes" === t.type || "tuple" === t.baseType || "array" === t.baseType ? (n.push(I$.from({
            type: "bytes32",
            name: t.name
          })), o.push(!0)) : (n.push(t), o.push(!1)) : (i.push(t), o.push(!1))
        });
        const s = null != r ? this.#n.decode(n, RR(r)) : null,
          a = this.#n.decode(i, e, !0),
          u = [],
          c = [];
        let f = 0,
          l = 0;
        return t.inputs.forEach((t, e) => {
          let r = null;
          if (t.indexed)
            if (null == s) r = new L$(null);
            else if (o[e]) r = new L$(s[l++]);
          else try {
            r = s[l++]
          } catch (t) {
            r = t
          } else try {
            r = a[f++]
          } catch (t) {
            r = t
          }
          u.push(r), c.push(t.name || null)
        }), dD.fromItems(u, c)
      }
      parseTransaction(t) {
        const e = SR(t.data, "tx.data"),
          r = zR(null != t.value ? t.value : 0, "tx.value"),
          n = this.getFunction(CR(e.slice(0, 4)));
        if (!n) return null;
        const i = this.#n.decode(n.inputs, e.slice(4));
        return new D$(n, n.selector, i, r)
      }
      parseCallResult(t) {
        throw Error("@TODO")
      }
      parseLog(t) {
        const e = this.getEvent(t.topics[0]);
        return !e || e.anonymous ? null : new _$(e, e.topicHash, this.decodeEventLog(e, t.data, t.topics))
      }
      parseError(t) {
        const e = CR(t),
          r = this.getError(jR(e, 0, 4));
        if (!r) return null;
        const n = this.#n.decode(r.inputs, jR(e, 4));
        return new U$(r, r.selector, n)
      }
      static from(t) {
        return t instanceof z$ ? t : "string" == typeof t ? new z$(JSON.parse(t)) : "function" == typeof t.format ? new z$(t.format("json")) : new z$(t)
      }
    }
    var H$ = i(48287).Buffer;
    const G$ = t => oN.from(t),
      K$ = t => oN.from(t).serialized,
      V$ = t => SR(t),
      Z$ = {
        sighash: "sighash",
        minimal: "minimal",
        full: "full",
        json: "json"
      },
      q$ = Kj.isValidMnemonic;
    Jj.register((t, e, r) => Jj.Pu(t, H$.from(e), H$.from(r)));
    const J$ = 34,
      Y$ = "41",
      Q$ = 65,
      X$ = /^(41)/,
      tz = "m/44'/195'",
      ez = tz + "/0'/0/0";

    function rz(t) {
      return iR(t) ? AV(xC(t.replace(/^0x/, Y$))) : t
    }

    function nz(t) {
      return iR(t) ? t.toLowerCase().replace(/^0x/, Y$) : gC(TV(t)).toLowerCase()
    }

    function iz(t) {
      if (!az(t)) throw Error(`'${t}' is not a valid address string`);
      return function(t) {
        const e = (t = t.toLowerCase()).substring(2).split(""),
          r = new Uint8Array(40);
        for (let t = 0; 40 > t; t++) r[t] = e[t].charCodeAt(0);
        const n = xC(Cj(r).slice(2));
        for (let t = 0; 40 > t; t += 2) n[t >> 1] >> 4 >= 8 && (e[t] = e[t].toUpperCase()), (15 & n[t >> 1]) >= 8 && (e[t + 1] = e[t + 1].toUpperCase());
        return Y$ + e.join("")
      }(nz(t))
    }

    function oz(t) {
      if (!iR(t) || 42 !== t.length) return !1;
      try {
        return iz(t) === t
      } catch {
        return !1
      }
    }

    function sz(t, e = !1) {
      try {
        return FV(t, e)
      } catch {
        return !1
      }
    }

    function az(t) {
      if (!t || !rR(t)) return !1;
      if (42 === t.length) try {
        return az(AV(xC(t)))
      } catch {
        return !1
      }
      try {
        return CV(t)
      } catch {
        return !1
      }
    }
    const uz = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
      cz = {};
    for (let t = 0; t < uz.length; t++) cz[uz.charAt(t)] = t;
    const fz = 58;

    function lz(t) {
      if (0 === t.length) return "";
      let e, r;
      const n = [0];
      for (e = 0; e < t.length; e++) {
        for (r = 0; r < n.length; r++) n[r] <<= 8;
        n[0] += t[e];
        let i = 0;
        for (r = 0; r < n.length; ++r) n[r] += i, i = n[r] / fz | 0, n[r] %= fz;
        for (; i;) n.push(i % fz), i = i / fz | 0
      }
      for (e = 0; 0 === t[e] && e < t.length - 1; e++) n.push(0);
      return n.reverse().map(t => uz[t]).join("")
    }

    function hz(t) {
      if (0 === t.length) return [];
      let e, r;
      const n = [0];
      for (e = 0; e < t.length; e++) {
        const i = t[e];
        if (!(i in cz)) throw Error("Non-base58 character");
        for (r = 0; r < n.length; r++) n[r] *= fz;
        n[0] += cz[i];
        let o = 0;
        for (r = 0; r < n.length; ++r) n[r] += o, o = n[r] >> 8, n[r] &= 255;
        for (; o;) n.push(255 & o), o >>= 8
      }
      for (e = 0;
        "1" === t[e] && e < t.length - 1; e++) n.push(0);
      return n.reverse()
    }

    function dz(t, e) {
      return function() {
        return t.apply(e, arguments)
      }
    }
    var pz = i(65606);
    const {
      toString: bz
    } = Object.prototype, {
      getPrototypeOf: mz
    } = Object, {
      iterator: yz,
      toStringTag: gz
    } = Symbol, vz = (t => e => {
      const r = bz.call(e);
      return t[r] || (t[r] = r.slice(8, -1).toLowerCase())
    })(Object.create(null)), wz = t => (t = t.toLowerCase(), e => vz(e) === t), Az = t => e => typeof e === t, {
      isArray: Tz
    } = Array, Ez = Az("undefined"), Pz = wz("ArrayBuffer"), kz = Az("string"), xz = Az("function"), Iz = Az("number"), Sz = t => null !== t && "object" == typeof t, Oz = t => {
      if ("object" !== vz(t)) return !1;
      const e = mz(t);
      return !(null !== e && e !== Object.prototype && null !== Object.getPrototypeOf(e) || gz in t || yz in t)
    }, Bz = wz("Date"), Wz = wz("File"), Mz = wz("Blob"), Cz = wz("FileList"), Rz = wz("URLSearchParams"), [Nz, jz, _z, Dz] = ["ReadableStream", "Request", "Response", "Headers"].map(wz);

    function Uz(t, e, {
      allOwnKeys: r = !1
    } = {}) {
      if (null === t || typeof t > "u") return;
      let n, i;
      if ("object" != typeof t && (t = [t]), Tz(t))
        for (n = 0, i = t.length; i > n; n++) e.call(null, t[n], n, t);
      else {
        const i = r ? Object.getOwnPropertyNames(t) : Object.keys(t),
          o = i.length;
        let s;
        for (n = 0; o > n; n++) s = i[n], e.call(null, t[s], s, t)
      }
    }

    function Lz(t, e) {
      e = e.toLowerCase();
      const r = Object.keys(t);
      let n, i = r.length;
      for (; i-- > 0;)
        if (n = r[i], e === n.toLowerCase()) return n;
      return null
    }
    const Fz = "u" > typeof globalThis ? globalThis : "u" > typeof self ? self : "u" > typeof window ? window : global,
      $z = t => !Ez(t) && t !== Fz,
      zz = (t => e => t && e instanceof t)("u" > typeof Uint8Array && mz(Uint8Array)),
      Hz = wz("HTMLFormElement"),
      Gz = (({
        hasOwnProperty: t
      }) => (e, r) => t.call(e, r))(Object.prototype),
      Kz = wz("RegExp"),
      Vz = (t, e) => {
        const r = Object.getOwnPropertyDescriptors(t),
          n = {};
        Uz(r, (r, i) => {
          let o;
          !1 !== (o = e(r, i, t)) && (n[i] = o || r)
        }), Object.defineProperties(t, n)
      },
      Zz = wz("AsyncFunction"),
      qz = ((t, e) => {
        return t ? setImmediate : e ? (r = "axios@" + Math.random(), n = [], Fz.addEventListener("message", ({
          source: t,
          data: e
        }) => {
          t === Fz && e === r && n.length && n.shift()()
        }, !1), t => {
          n.push(t), Fz.postMessage(r, "*")
        }) : t => setTimeout(t);
        var r, n
      })("function" == typeof setImmediate, xz(Fz.postMessage)),
      Jz = "u" > typeof queueMicrotask ? queueMicrotask.bind(Fz) : "u" > typeof pz && pz.nextTick || qz,
      Yz = {
        isArray: Tz,
        isArrayBuffer: Pz,
        isBuffer: function(t) {
          return null !== t && !Ez(t) && null !== t.constructor && !Ez(t.constructor) && xz(t.constructor.isBuffer) && t.constructor.isBuffer(t)
        },
        isFormData: t => {
          let e;
          return t && ("function" == typeof FormData && t instanceof FormData || xz(t.append) && ("formdata" === (e = vz(t)) || "object" === e && xz(t.toString) && "[object FormData]" === t.toString()))
        },
        isArrayBufferView: function(t) {
          let e;
          return e = "u" > typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(t) : t && t.buffer && Pz(t.buffer), e
        },
        isString: kz,
        isNumber: Iz,
        isBoolean: t => !0 === t || !1 === t,
        isObject: Sz,
        isPlainObject: Oz,
        isReadableStream: Nz,
        isRequest: jz,
        isResponse: _z,
        isHeaders: Dz,
        isUndefined: Ez,
        isDate: Bz,
        isFile: Wz,
        isBlob: Mz,
        isRegExp: Kz,
        isFunction: xz,
        isStream: t => Sz(t) && xz(t.pipe),
        isURLSearchParams: Rz,
        isTypedArray: zz,
        isFileList: Cz,
        forEach: Uz,
        merge: function t() {
          const {
            caseless: e
          } = $z(this) && this || {}, r = {}, n = (n, i) => {
            const o = e && Lz(r, i) || i;
            Oz(r[o]) && Oz(n) ? r[o] = t(r[o], n) : Oz(n) ? r[o] = t({}, n) : Tz(n) ? r[o] = n.slice() : r[o] = n
          };
          for (let t = 0, e = arguments.length; e > t; t++) arguments[t] && Uz(arguments[t], n);
          return r
        },
        extend: (t, e, r, {
          allOwnKeys: n
        } = {}) => (Uz(e, (e, n) => {
          r && xz(e) ? t[n] = dz(e, r) : t[n] = e
        }, {
          allOwnKeys: n
        }), t),
        trim: t => t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""),
        stripBOM: t => (65279 === t.charCodeAt(0) && (t = t.slice(1)), t),
        inherits: (t, e, r, n) => {
          t.prototype = Object.create(e.prototype, n), t.prototype.constructor = t, Object.defineProperty(t, "super", {
            value: e.prototype
          }), r && Object.assign(t.prototype, r)
        },
        toFlatObject: (t, e, r, n) => {
          let i, o, s;
          const a = {};
          if (e = e || {}, null == t) return e;
          do {
            for (i = Object.getOwnPropertyNames(t), o = i.length; o-- > 0;) s = i[o], (!n || n(s, t, e)) && !a[s] && (e[s] = t[s], a[s] = !0);
            t = !1 !== r && mz(t)
          } while (t && (!r || r(t, e)) && t !== Object.prototype);
          return e
        },
        kindOf: vz,
        kindOfTest: wz,
        endsWith: (t, e, r) => {
          t += "", (void 0 === r || r > t.length) && (r = t.length), r -= e.length;
          const n = t.indexOf(e, r);
          return -1 !== n && n === r
        },
        toArray: t => {
          if (!t) return null;
          if (Tz(t)) return t;
          let e = t.length;
          if (!Iz(e)) return null;
          const r = Array(e);
          for (; e-- > 0;) r[e] = t[e];
          return r
        },
        forEachEntry: (t, e) => {
          const r = (t && t[yz]).call(t);
          let n;
          for (;
            (n = r.next()) && !n.done;) {
            const r = n.value;
            e.call(t, r[0], r[1])
          }
        },
        matchAll: (t, e) => {
          let r;
          const n = [];
          for (; null !== (r = t.exec(e));) n.push(r);
          return n
        },
        isHTMLForm: Hz,
        hasOwnProperty: Gz,
        hasOwnProp: Gz,
        reduceDescriptors: Vz,
        freezeMethods: t => {
          Vz(t, (e, r) => {
            if (xz(t) && -1 !== ["arguments", "caller", "callee"].indexOf(r)) return !1;
            const n = t[r];
            if (xz(n)) {
              if (e.enumerable = !1, "writable" in e) return void(e.writable = !1);
              e.set || (e.set = () => {
                throw Error("Can not rewrite read-only method '" + r + "'")
              })
            }
          })
        },
        toObjectSet: (t, e) => {
          const r = {},
            n = t => {
              t.forEach(t => {
                r[t] = !0
              })
            };
          return Tz(t) ? n(t) : n((t + "").split(e)), r
        },
        toCamelCase: t => t.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(t, e, r) {
          return e.toUpperCase() + r
        }),
        noop: () => {},
        toFiniteNumber: (t, e) => null != t && Number.isFinite(t = +t) ? t : e,
        findKey: Lz,
        global: Fz,
        isContextDefined: $z,
        isSpecCompliantForm: function(t) {
          return !!(t && xz(t.append) && "FormData" === t[gz] && t[yz])
        },
        toJSONObject: t => {
          const e = [, , , , , , , , , , ],
            r = (t, n) => {
              if (Sz(t)) {
                if (e.indexOf(t) >= 0) return;
                if (!("toJSON" in t)) {
                  e[n] = t;
                  const i = Tz(t) ? [] : {};
                  return Uz(t, (t, e) => {
                    const o = r(t, n + 1);
                    !Ez(o) && (i[e] = o)
                  }), e[n] = void 0, i
                }
              }
              return t
            };
          return r(t, 0)
        },
        isAsyncFn: Zz,
        isThenable: t => t && (Sz(t) || xz(t)) && xz(t.then) && xz(t.catch),
        setImmediate: qz,
        asap: Jz,
        isIterable: t => null != t && xz(t[yz])
      };

    function Qz(t, e, r, n, i) {
      Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error().stack, this.message = t, this.name = "AxiosError", e && (this.code = e), r && (this.config = r), n && (this.request = n), i && (this.response = i, this.status = i.status ? i.status : null)
    }
    Yz.inherits(Qz, Error, {
      toJSON: function() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: Yz.toJSONObject(this.config),
          code: this.code,
          status: this.status
        }
      }
    });
    const Xz = Qz.prototype,
      tH = {};
    ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(t => {
      tH[t] = {
        value: t
      }
    }), Object.defineProperties(Qz, tH), Object.defineProperty(Xz, "isAxiosError", {
      value: !0
    }), Qz.from = (t, e, r, n, i, o) => {
      const s = Object.create(Xz);
      return Yz.toFlatObject(t, s, function(t) {
        return t !== Error.prototype
      }, t => "isAxiosError" !== t), Qz.call(s, t.message, e, r, n, i), s.cause = t, s.name = t.name, o && Object.assign(s, o), s
    };
    const eH = Qz;
    var rH = i(48287).Buffer;

    function nH(t) {
      return Yz.isPlainObject(t) || Yz.isArray(t)
    }

    function iH(t) {
      return Yz.endsWith(t, "[]") ? t.slice(0, -2) : t
    }

    function oH(t, e, r) {
      return t ? t.concat(e).map(function(t, e) {
        return t = iH(t), !r && e ? "[" + t + "]" : t
      }).join(r ? "." : "") : e
    }
    const sH = Yz.toFlatObject(Yz, {}, null, function(t) {
        return /^is[A-Z]/.test(t)
      }),
      aH = function(t, e, r) {
        if (!Yz.isObject(t)) throw new TypeError("target must be an object");
        e = e || new FormData;
        const n = (r = Yz.toFlatObject(r, {
            metaTokens: !0,
            dots: !1,
            indexes: !1
          }, !1, function(t, e) {
            return !Yz.isUndefined(e[t])
          })).metaTokens,
          i = r.visitor || c,
          o = r.dots,
          s = r.indexes,
          a = (r.Blob || "u" > typeof Blob && Blob) && Yz.isSpecCompliantForm(e);
        if (!Yz.isFunction(i)) throw new TypeError("visitor must be a function");

        function u(t) {
          if (null === t) return "";
          if (Yz.isDate(t)) return t.toISOString();
          if (Yz.isBoolean(t)) return t.toString();
          if (!a && Yz.isBlob(t)) throw new eH("Blob is not supported. Use a Buffer instead.");
          return Yz.isArrayBuffer(t) || Yz.isTypedArray(t) ? a && "function" == typeof Blob ? new Blob([t]) : rH.from(t) : t
        }

        function c(t, r, i) {
          let a = t;
          if (t && !i && "object" == typeof t)
            if (Yz.endsWith(r, "{}")) r = n ? r : r.slice(0, -2), t = JSON.stringify(t);
            else if (Yz.isArray(t) && function(t) {
              return Yz.isArray(t) && !t.some(nH)
            }(t) || (Yz.isFileList(t) || Yz.endsWith(r, "[]")) && (a = Yz.toArray(t))) return r = iH(r), a.forEach(function(t, n) {
            !Yz.isUndefined(t) && null !== t && e.append(!0 === s ? oH([r], n, o) : null === s ? r : r + "[]", u(t))
          }), !1;
          return !!nH(t) || (e.append(oH(i, r, o), u(t)), !1)
        }
        const f = [],
          l = Object.assign(sH, {
            defaultVisitor: c,
            convertValue: u,
            isVisitable: nH
          });
        if (!Yz.isObject(t)) throw new TypeError("data must be an object");
        return function t(r, n) {
          if (!Yz.isUndefined(r)) {
            if (-1 !== f.indexOf(r)) throw Error("Circular reference detected in " + n.join("."));
            f.push(r), Yz.forEach(r, function(r, o) {
              !0 === (!(Yz.isUndefined(r) || null === r) && i.call(e, r, Yz.isString(o) ? o.trim() : o, n, l)) && t(r, n ? n.concat(o) : [o])
            }), f.pop()
          }
        }(t), e
      };

    function uH(t) {
      const e = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(t) {
        return e[t]
      })
    }

    function cH(t, e) {
      this.Dn = [], t && aH(t, this, e)
    }
    const fH = cH.prototype;
    fH.append = function(t, e) {
      this.Dn.push([t, e])
    }, fH.toString = function(t) {
      const e = t ? function(e) {
        return t.call(this, e, uH)
      } : uH;
      return this.Dn.map(function(t) {
        return e(t[0]) + "=" + e(t[1])
      }, "").join("&")
    };
    const lH = cH;

    function hH(t) {
      return encodeURIComponent(t).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
    }

    function dH(t, e, r) {
      if (!e) return t;
      const n = r && r.encode || hH;
      Yz.isFunction(r) && (r = {
        serialize: r
      });
      const i = r && r.serialize;
      let o;
      if (o = i ? i(e, r) : Yz.isURLSearchParams(e) ? e.toString() : new lH(e, r).toString(n), o) {
        const e = t.indexOf("#"); - 1 !== e && (t = t.slice(0, e)), t += (-1 === t.indexOf("?") ? "?" : "&") + o
      }
      return t
    }
    const pH = class {
        constructor() {
          this.handlers = []
        }
        use(t, e, r) {
          return this.handlers.push({
            fulfilled: t,
            rejected: e,
            synchronous: !!r && r.synchronous,
            runWhen: r ? r.runWhen : null
          }), this.handlers.length - 1
        }
        eject(t) {
          this.handlers[t] && (this.handlers[t] = null)
        }
        clear() {
          this.handlers && (this.handlers = [])
        }
        forEach(t) {
          Yz.forEach(this.handlers, function(e) {
            null !== e && t(e)
          })
        }
      },
      bH = {
        silentJSONParsing: !0,
        forcedJSONParsing: !0,
        clarifyTimeoutError: !1
      },
      mH = {
        isBrowser: !0,
        classes: {
          URLSearchParams: "u" > typeof URLSearchParams ? URLSearchParams : lH,
          FormData: "u" > typeof FormData ? FormData : null,
          Blob: "u" > typeof Blob ? Blob : null
        },
        protocols: ["http", "https", "file", "blob", "url", "data"]
      },
      yH = "u" > typeof window && "u" > typeof document,
      gH = "object" == typeof navigator && navigator || void 0,
      vH = yH && (!gH || 0 > ["ReactNative", "NativeScript", "NS"].indexOf(gH.product)),
      wH = "u" > typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts,
      AH = yH && window.location.href || "http://localhost",
      TH = {
        ...p,
        ...mH
      },
      EH = function(t) {
        function e(t, r, n, i) {
          let o = t[i++];
          if ("__proto__" === o) return !0;
          const s = Number.isFinite(+o),
            a = i >= t.length;
          return o = !o && Yz.isArray(n) ? n.length : o, a ? (Yz.hasOwnProp(n, o) ? n[o] = [n[o], r] : n[o] = r, !s) : ((!n[o] || !Yz.isObject(n[o])) && (n[o] = []), e(t, r, n[o], i) && Yz.isArray(n[o]) && (n[o] = function(t) {
            const e = {},
              r = Object.keys(t);
            let n;
            const i = r.length;
            let o;
            for (n = 0; i > n; n++) o = r[n], e[o] = t[o];
            return e
          }(n[o])), !s)
        }
        if (Yz.isFormData(t) && Yz.isFunction(t.entries)) {
          const r = {};
          return Yz.forEachEntry(t, (t, n) => {
            e(function(t) {
              return Yz.matchAll(/\w+|\[(\w*)]/g, t).map(t => "[]" === t[0] ? "" : t[1] || t[0])
            }(t), n, r, 0)
          }), r
        }
        return null
      },
      PH = {
        transitional: bH,
        adapter: ["xhr", "http", "fetch"],
        transformRequest: [function(t, e) {
          const r = e.getContentType() || "",
            n = r.indexOf("application/json") > -1,
            i = Yz.isObject(t);
          if (i && Yz.isHTMLForm(t) && (t = new FormData(t)), Yz.isFormData(t)) return n ? JSON.stringify(EH(t)) : t;
          if (Yz.isArrayBuffer(t) || Yz.isBuffer(t) || Yz.isStream(t) || Yz.isFile(t) || Yz.isBlob(t) || Yz.isReadableStream(t)) return t;
          if (Yz.isArrayBufferView(t)) return t.buffer;
          if (Yz.isURLSearchParams(t)) return e.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString();
          let o;
          if (i) {
            if (r.indexOf("application/x-www-form-urlencoded") > -1) return function(t, e) {
              return aH(t, new TH.classes.URLSearchParams, Object.assign({
                visitor: function(t, e, r, n) {
                  return TH.isNode && Yz.isBuffer(t) ? (this.append(e, t.toString("base64")), !1) : n.defaultVisitor.apply(this, arguments)
                }
              }, e))
            }(t, this.formSerializer).toString();
            if ((o = Yz.isFileList(t)) || r.indexOf("multipart/form-data") > -1) {
              const e = this.env && this.env.FormData;
              return aH(o ? {
                "files[]": t
              } : t, e && new e, this.formSerializer)
            }
          }
          return i || n ? (e.setContentType("application/json", !1), function(t) {
            if (Yz.isString(t)) try {
              return (0, JSON.parse)(t), Yz.trim(t)
            } catch (t) {
              if ("SyntaxError" !== t.name) throw t
            }
            return (0, JSON.stringify)(t)
          }(t)) : t
        }],
        transformResponse: [function(t) {
          const e = this.transitional || PH.transitional,
            r = e && e.forcedJSONParsing,
            n = "json" === this.responseType;
          if (Yz.isResponse(t) || Yz.isReadableStream(t)) return t;
          if (t && Yz.isString(t) && (r && !this.responseType || n)) {
            const r = !(e && e.silentJSONParsing) && n;
            try {
              return JSON.parse(t)
            } catch (t) {
              if (r) throw "SyntaxError" === t.name ? eH.from(t, eH.ERR_BAD_RESPONSE, this, null, this.response) : t
            }
          }
          return t
        }],
        timeout: 0,
        xsrfCookieName: "XSRF-TOKEN",
        xsrfHeaderName: "X-XSRF-TOKEN",
        maxContentLength: -1,
        maxBodyLength: -1,
        env: {
          FormData: TH.classes.FormData,
          Blob: TH.classes.Blob
        },
        validateStatus: function(t) {
          return t >= 200 && 300 > t
        },
        headers: {
          common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
          }
        }
      };
    Yz.forEach(["delete", "get", "head", "post", "put", "patch"], t => {
      PH.headers[t] = {}
    });
    const kH = PH,
      xH = Yz.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
      IH = Symbol("internals");

    function SH(t) {
      return t && (t + "").trim().toLowerCase()
    }

    function OH(t) {
      return !1 === t || null == t ? t : Yz.isArray(t) ? t.map(OH) : t + ""
    }

    function BH(t, e, r, n, i) {
      if (Yz.isFunction(n)) return n.call(this, e, r);
      if (i && (e = r), Yz.isString(e)) {
        if (Yz.isString(n)) return -1 !== e.indexOf(n);
        if (Yz.isRegExp(n)) return n.test(e)
      }
    }
    class WH {
      constructor(t) {
        t && this.set(t)
      }
      set(t, e, r) {
        const n = this;

        function i(t, e, r) {
          const i = SH(e);
          if (!i) throw Error("header name must be a non-empty string");
          const o = Yz.findKey(n, i);
          (!o || void 0 === n[o] || !0 === r || void 0 === r && !1 !== n[o]) && (n[o || e] = OH(t))
        }
        const o = (t, e) => Yz.forEach(t, (t, r) => i(t, r, e));
        if (Yz.isPlainObject(t) || t instanceof this.constructor) o(t, e);
        else if (Yz.isString(t) && (t = t.trim()) && !(t => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim()))(t)) o((t => {
          const e = {};
          let r, n, i;
          return t && t.split("\n").forEach(function(t) {
            i = t.indexOf(":"), r = t.substring(0, i).trim().toLowerCase(), n = t.substring(i + 1).trim(), !(!r || e[r] && xH[r]) && ("set-cookie" === r ? e[r] ? e[r].push(n) : e[r] = [n] : e[r] = e[r] ? e[r] + ", " + n : n)
          }), e
        })(t), e);
        else if (Yz.isObject(t) && Yz.isIterable(t)) {
          let r, n, i = {};
          for (const e of t) {
            if (!Yz.isArray(e)) throw TypeError("Object iterator must return a key-value pair");
            i[n = e[0]] = (r = i[n]) ? Yz.isArray(r) ? [...r, e[1]] : [r, e[1]] : e[1]
          }
          o(i, e)
        } else null != t && i(e, t, r);
        return this
      }
      get(t, e) {
        if (t = SH(t)) {
          const r = Yz.findKey(this, t);
          if (r) {
            const t = this[r];
            if (!e) return t;
            if (!0 === e) return function(t) {
              const e = Object.create(null),
                r = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
              let n;
              for (; n = r.exec(t);) e[n[1]] = n[2];
              return e
            }(t);
            if (Yz.isFunction(e)) return e.call(this, t, r);
            if (Yz.isRegExp(e)) return e.exec(t);
            throw new TypeError("parser must be boolean|regexp|function")
          }
        }
      }
      has(t, e) {
        if (t = SH(t)) {
          const r = Yz.findKey(this, t);
          return !(!r || void 0 === this[r] || e && !BH(0, this[r], r, e))
        }
        return !1
      }
      delete(t, e) {
        const r = this;
        let n = !1;

        function i(t) {
          if (t = SH(t)) {
            const i = Yz.findKey(r, t);
            i && (!e || BH(0, r[i], i, e)) && (delete r[i], n = !0)
          }
        }
        return Yz.isArray(t) ? t.forEach(i) : i(t), n
      }
      clear(t) {
        const e = Object.keys(this);
        let r = e.length,
          n = !1;
        for (; r--;) {
          const i = e[r];
          (!t || BH(0, this[i], i, t, !0)) && (delete this[i], n = !0)
        }
        return n
      }
      normalize(t) {
        const e = this,
          r = {};
        return Yz.forEach(this, (n, i) => {
          const o = Yz.findKey(r, i);
          if (o) return e[o] = OH(n), void delete e[i];
          const s = t ? function(t) {
            return t.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, e, r) => e.toUpperCase() + r)
          }(i) : (i + "").trim();
          s !== i && delete e[i], e[s] = OH(n), r[s] = !0
        }), this
      }
      concat(...t) {
        return this.constructor.concat(this, ...t)
      }
      toJSON(t) {
        const e = Object.create(null);
        return Yz.forEach(this, (r, n) => {
          null != r && !1 !== r && (e[n] = t && Yz.isArray(r) ? r.join(", ") : r)
        }), e
      } [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
      }
      toString() {
        return Object.entries(this.toJSON()).map(([t, e]) => t + ": " + e).join("\n")
      }
      getSetCookie() {
        return this.get("set-cookie") || []
      }
      get[Symbol.toStringTag]() {
        return "AxiosHeaders"
      }
      static from(t) {
        return t instanceof this ? t : new this(t)
      }
      static concat(t, ...e) {
        const r = new this(t);
        return e.forEach(t => r.set(t)), r
      }
      static accessor(t) {
        const e = (this[IH] = this[IH] = {
            accessors: {}
          }).accessors,
          r = this.prototype;

        function n(t) {
          const n = SH(t);
          e[n] || (function(t, e) {
            const r = Yz.toCamelCase(" " + e);
            ["get", "set", "has"].forEach(n => {
              Object.defineProperty(t, n + r, {
                value: function(t, r, i) {
                  return this[n].call(this, e, t, r, i)
                },
                configurable: !0
              })
            })
          }(r, t), e[n] = !0)
        }
        return Yz.isArray(t) ? t.forEach(n) : n(t), this
      }
    }
    WH.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Yz.reduceDescriptors(WH.prototype, ({
      value: t
    }, e) => {
      let r = e[0].toUpperCase() + e.slice(1);
      return {
        get: () => t,
        set(t) {
          this[r] = t
        }
      }
    }), Yz.freezeMethods(WH);
    const MH = WH;

    function CH(t, e) {
      const r = this || kH,
        n = e || r,
        i = MH.from(n.headers);
      let o = n.data;
      return Yz.forEach(t, function(t) {
        o = t.call(r, o, i.normalize(), e ? e.status : void 0)
      }), i.normalize(), o
    }

    function RH(t) {
      return !(!t || !t.Un)
    }

    function NH(t, e, r) {
      eH.call(this, t ?? "canceled", eH.ERR_CANCELED, e, r), this.name = "CanceledError"
    }
    Yz.inherits(NH, eH, {
      Un: !0
    });
    const jH = NH;

    function _H(t, e, r) {
      const n = r.config.validateStatus;
      r.status && n && !n(r.status) ? e(new eH("Request failed with status code " + r.status, [eH.ERR_BAD_REQUEST, eH.ERR_BAD_RESPONSE][Math.floor(r.status / 100) - 4], r.config, r.request, r)) : t(r)
    }
    const DH = (t, e, r = 3) => {
        let n = 0;
        const i = function(t, e) {
          const r = Array(t = t || 10),
            n = Array(t);
          let i, o = 0,
            s = 0;
          return e = void 0 !== e ? e : 1e3,
            function(a) {
              const u = Date.now(),
                c = n[s];
              i || (i = u), r[o] = a, n[o] = u;
              let f = s,
                l = 0;
              for (; f !== o;) l += r[f++], f %= t;
              if (o = (o + 1) % t, o === s && (s = (s + 1) % t), e > u - i) return;
              const h = c && u - c;
              return h ? Math.round(1e3 * l / h) : void 0
            }
        }(50, 250);
        return function(t, e) {
          let r, n, i = 0,
            o = 1e3 / e;
          const s = (e, o = Date.now()) => {
            i = o, r = null, n && (clearTimeout(n), n = null), t.apply(null, e)
          };
          return [(...t) => {
            const e = Date.now(),
              a = e - i;
            o > a ? (r = t, n || (n = setTimeout(() => {
              n = null, s(r)
            }, o - a))) : s(t, e)
          }, () => r && s(r)]
        }(r => {
          const o = r.loaded,
            s = r.lengthComputable ? r.total : void 0,
            a = o - n,
            u = i(a);
          n = o, t({
            loaded: o,
            total: s,
            progress: s ? o / s : void 0,
            bytes: a,
            rate: u || void 0,
            estimated: u && s && s >= o ? (s - o) / u : void 0,
            event: r,
            lengthComputable: null != s,
            [e ? "download" : "upload"]: !0
          })
        }, r)
      },
      UH = (t, e) => {
        const r = null != t;
        return [n => e[0]({
          lengthComputable: r,
          total: t,
          loaded: n
        }), e[1]]
      },
      LH = t => (...e) => Yz.asap(() => t(...e)),
      FH = TH.hasStandardBrowserEnv ? ((t, e) => r => (r = new URL(r, TH.origin), t.protocol === r.protocol && t.host === r.host && (e || t.port === r.port)))(new URL(TH.origin), TH.navigator && /(msie|trident)/i.test(TH.navigator.userAgent)) : () => !0,
      $H = TH.hasStandardBrowserEnv ? {
        write(t, e, r, n, i, o) {
          const s = [t + "=" + encodeURIComponent(e)];
          Yz.isNumber(r) && s.push("expires=" + new Date(r).toGMTString()), Yz.isString(n) && s.push("path=" + n), Yz.isString(i) && s.push("domain=" + i), !0 === o && s.push("secure"), document.cookie = s.join("; ")
        },
        read(t) {
          const e = document.cookie.match(RegExp("(^|;\\s*)(" + t + ")=([^;]*)"));
          return e ? decodeURIComponent(e[3]) : null
        },
        remove(t) {
          this.write(t, "", Date.now() - 864e5)
        }
      } : {
        write() {},
        read: () => null,
        remove() {}
      };

    function zH(t, e, r) {
      let n = ! function(t) {
        return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)
      }(e);
      return t && (n || 0 == r) ? function(t, e) {
        return e ? t.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : t
      }(t, e) : e
    }
    const HH = t => t instanceof MH ? {
      ...t
    } : t;

    function GH(t, e) {
      e = e || {};
      const r = {};

      function n(t, e, r, n) {
        return Yz.isPlainObject(t) && Yz.isPlainObject(e) ? Yz.merge.call({
          caseless: n
        }, t, e) : Yz.isPlainObject(e) ? Yz.merge({}, e) : Yz.isArray(e) ? e.slice() : e
      }

      function i(t, e, r, i) {
        return Yz.isUndefined(e) ? Yz.isUndefined(t) ? void 0 : n(void 0, t, 0, i) : n(t, e, 0, i)
      }

      function o(t, e) {
        if (!Yz.isUndefined(e)) return n(void 0, e)
      }

      function s(t, e) {
        return Yz.isUndefined(e) ? Yz.isUndefined(t) ? void 0 : n(void 0, t) : n(void 0, e)
      }

      function a(r, i, o) {
        return o in e ? n(r, i) : o in t ? n(void 0, r) : void 0
      }
      const u = {
        url: o,
        method: o,
        data: o,
        baseURL: s,
        transformRequest: s,
        transformResponse: s,
        paramsSerializer: s,
        timeout: s,
        timeoutMessage: s,
        withCredentials: s,
        withXSRFToken: s,
        adapter: s,
        responseType: s,
        xsrfCookieName: s,
        xsrfHeaderName: s,
        onUploadProgress: s,
        onDownloadProgress: s,
        decompress: s,
        maxContentLength: s,
        maxBodyLength: s,
        beforeRedirect: s,
        transport: s,
        httpAgent: s,
        httpsAgent: s,
        cancelToken: s,
        socketPath: s,
        responseEncoding: s,
        validateStatus: a,
        headers: (t, e, r) => i(HH(t), HH(e), 0, !0)
      };
      return Yz.forEach(Object.keys(Object.assign({}, t, e)), function(n) {
        const o = u[n] || i,
          s = o(t[n], e[n], n);
        Yz.isUndefined(s) && o !== a || (r[n] = s)
      }), r
    }
    const KH = t => {
        const e = GH({}, t);
        let r, {
          data: n,
          withXSRFToken: i,
          xsrfHeaderName: o,
          xsrfCookieName: s,
          headers: a,
          auth: u
        } = e;
        if (e.headers = a = MH.from(a), e.url = dH(zH(e.baseURL, e.url, e.allowAbsoluteUrls), t.params, t.paramsSerializer), u && a.set("Authorization", "Basic " + btoa((u.username || "") + ":" + (u.password ? unescape(encodeURIComponent(u.password)) : ""))), Yz.isFormData(n))
          if (TH.hasStandardBrowserEnv || TH.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0);
          else if (!1 !== (r = a.getContentType())) {
          const [t, ...e] = r ? r.split(";").map(t => t.trim()).filter(Boolean) : [];
          a.setContentType([t || "multipart/form-data", ...e].join("; "))
        }
        if (TH.hasStandardBrowserEnv && (i && Yz.isFunction(i) && (i = i(e)), i || !1 !== i && FH(e.url))) {
          const t = o && s && $H.read(s);
          t && a.set(o, t)
        }
        return e
      },
      VH = "u" > typeof XMLHttpRequest && function(t) {
        return new Promise(function(e, r) {
          const n = KH(t);
          let i = n.data;
          const o = MH.from(n.headers).normalize();
          let s, a, u, c, f, {
            responseType: l,
            onUploadProgress: h,
            onDownloadProgress: d
          } = n;

          function p() {
            c && c(), f && f(), n.cancelToken && n.cancelToken.unsubscribe(s), n.signal && n.signal.removeEventListener("abort", s)
          }
          let b = new XMLHttpRequest;

          function m() {
            if (!b) return;
            const n = MH.from("getAllResponseHeaders" in b && b.getAllResponseHeaders());
            _H(function(t) {
              e(t), p()
            }, function(t) {
              r(t), p()
            }, {
              data: l && "text" !== l && "json" !== l ? b.response : b.responseText,
              status: b.status,
              statusText: b.statusText,
              headers: n,
              config: t,
              request: b
            }), b = null
          }
          b.open(n.method.toUpperCase(), n.url, !0), b.timeout = n.timeout, "onloadend" in b ? b.onloadend = m : b.onreadystatechange = function() {
            !b || 4 !== b.readyState || 0 === b.status && (!b.responseURL || 0 !== b.responseURL.indexOf("file:")) || setTimeout(m)
          }, b.onabort = function() {
            b && (r(new eH("Request aborted", eH.ECONNABORTED, t, b)), b = null)
          }, b.onerror = function() {
            r(new eH("Network Error", eH.ERR_NETWORK, t, b)), b = null
          }, b.ontimeout = function() {
            let e = n.timeout ? "timeout of " + n.timeout + "ms exceeded" : "timeout exceeded";
            const i = n.transitional || bH;
            n.timeoutErrorMessage && (e = n.timeoutErrorMessage), r(new eH(e, i.clarifyTimeoutError ? eH.ETIMEDOUT : eH.ECONNABORTED, t, b)), b = null
          }, void 0 === i && o.setContentType(null), "setRequestHeader" in b && Yz.forEach(o.toJSON(), function(t, e) {
            b.setRequestHeader(e, t)
          }), Yz.isUndefined(n.withCredentials) || (b.withCredentials = !!n.withCredentials), l && "json" !== l && (b.responseType = n.responseType), d && ([u, f] = DH(d, !0), b.addEventListener("progress", u)), h && b.upload && ([a, c] = DH(h), b.upload.addEventListener("progress", a), b.upload.addEventListener("loadend", c)), (n.cancelToken || n.signal) && (s = e => {
            b && (r(!e || e.type ? new jH(null, t, b) : e), b.abort(), b = null)
          }, n.cancelToken && n.cancelToken.subscribe(s), n.signal && (n.signal.aborted ? s() : n.signal.addEventListener("abort", s)));
          const y = function(t) {
            const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(t);
            return e && e[1] || ""
          }(n.url);
          y && -1 === TH.protocols.indexOf(y) ? r(new eH("Unsupported protocol " + y + ":", eH.ERR_BAD_REQUEST, t)) : b.send(i || null)
        })
      },
      ZH = (t, e) => {
        const {
          length: r
        } = t = t ? t.filter(Boolean) : [];
        if (e || r) {
          let r, n = new AbortController;
          const i = function(t) {
            if (!r) {
              r = !0, s();
              const e = t instanceof Error ? t : this.reason;
              n.abort(e instanceof eH ? e : new jH(e instanceof Error ? e.message : e))
            }
          };
          let o = e && setTimeout(() => {
            o = null, i(new eH(`timeout ${e} of ms exceeded`, eH.ETIMEDOUT))
          }, e);
          const s = () => {
            t && (o && clearTimeout(o), o = null, t.forEach(t => {
              t.unsubscribe ? t.unsubscribe(i) : t.removeEventListener("abort", i)
            }), t = null)
          };
          t.forEach(t => t.addEventListener("abort", i));
          const {
            signal: a
          } = n;
          return a.unsubscribe = () => Yz.asap(s), a
        }
      },
      qH = function*(t, e) {
        let r = t.byteLength;
        if (!e || e > r) return void(yield t);
        let n, i = 0;
        for (; r > i;) n = i + e, yield t.slice(i, n), i = n
      },
      JH = (t, e, r, n) => {
        const i = async function*(t, e) {
          for await (const r of async function*(t) {
            if (t[Symbol.asyncIterator]) return void(yield* t);
            const e = t.getReader();
            try {
              for (;;) {
                const {
                  done: t,
                  value: r
                } = await e.read();
                if (t) break;
                yield r
              }
            } finally {
              await e.cancel()
            }
          }(t)) yield* qH(r, e)
        }(t, e);
        let o, s = 0,
          a = t => {
            o || (o = !0, n && n(t))
          };
        return new ReadableStream({
          async pull(t) {
            try {
              const {
                done: e,
                value: n
              } = await i.next();
              if (e) return a(), void t.close();
              let o = n.byteLength;
              if (r) {
                let t = s += o;
                r(t)
              }
              t.enqueue(new Uint8Array(n))
            } catch (t) {
              throw a(t), t
            }
          },
          cancel: t => (a(t), i.return())
        }, {
          highWaterMark: 2
        })
      },
      YH = "function" == typeof fetch && "function" == typeof Request && "function" == typeof Response,
      QH = YH && "function" == typeof ReadableStream,
      XH = YH && ("function" == typeof TextEncoder ? (t => e => t.encode(e))(new TextEncoder) : async t => new Uint8Array(await new Response(t).arrayBuffer())),
      tG = (t, ...e) => {
        try {
          return !!t(...e)
        } catch {
          return !1
        }
      },
      eG = QH && tG(() => {
        let t = !1;
        const e = new Request(TH.origin, {
          body: new ReadableStream,
          method: "POST",
          get duplex() {
            return t = !0, "half"
          }
        }).headers.has("Content-Type");
        return t && !e
      }),
      rG = QH && tG(() => Yz.isReadableStream(new Response("").body)),
      nG = {
        stream: rG && (t => t.body)
      };
    YH && (t => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
        !nG[e] && (nG[e] = Yz.isFunction(t[e]) ? t => t[e]() : (t, r) => {
          throw new eH(`Response type '${e}' is not supported`, eH.ERR_NOT_SUPPORT, r)
        })
      })
    })(new Response);
    const iG = {
      http: null,
      xhr: VH,
      fetch: YH && (async t => {
        let {
          url: e,
          method: r,
          data: n,
          signal: i,
          cancelToken: o,
          timeout: s,
          onDownloadProgress: a,
          onUploadProgress: u,
          responseType: c,
          headers: f,
          withCredentials: l = "same-origin",
          fetchOptions: h
        } = KH(t);
        c = c ? (c + "").toLowerCase() : "text";
        let d, p = ZH([i, o && o.toAbortSignal()], s);
        const b = p && p.unsubscribe && (() => {
          p.unsubscribe()
        });
        let m;
        try {
          if (u && eG && "get" !== r && "head" !== r && 0 !== (m = await (async (t, e) => Yz.toFiniteNumber(t.getContentLength()) ?? (async t => null == t ? 0 : Yz.isBlob(t) ? t.size : Yz.isSpecCompliantForm(t) ? (await new Request(TH.origin, {
              method: "POST",
              body: t
            }).arrayBuffer()).byteLength : Yz.isArrayBufferView(t) || Yz.isArrayBuffer(t) ? t.byteLength : (Yz.isURLSearchParams(t) && (t += ""), Yz.isString(t) ? (await XH(t)).byteLength : void 0))(e))(f, n))) {
            let t, r = new Request(e, {
              method: "POST",
              body: n,
              duplex: "half"
            });
            if (Yz.isFormData(n) && (t = r.headers.get("content-type")) && f.setContentType(t), r.body) {
              const [t, e] = UH(m, DH(LH(u)));
              n = JH(r.body, 65536, t, e)
            }
          }
          Yz.isString(l) || (l = l ? "include" : "omit");
          const i = "credentials" in Request.prototype;
          d = new Request(e, {
            ...h,
            signal: p,
            method: r.toUpperCase(),
            headers: f.normalize().toJSON(),
            body: n,
            duplex: "half",
            credentials: i ? l : void 0
          });
          let o = await fetch(d, h);
          const s = rG && ("stream" === c || "response" === c);
          if (rG && (a || s && b)) {
            const t = {};
            ["status", "statusText", "headers"].forEach(e => {
              t[e] = o[e]
            });
            const e = Yz.toFiniteNumber(o.headers.get("content-length")),
              [r, n] = a && UH(e, DH(LH(a), !0)) || [];
            o = new Response(JH(o.body, 65536, r, () => {
              n && n(), b && b()
            }), t)
          }
          c = c || "text";
          let y = await nG[Yz.findKey(nG, c) || "text"](o, t);
          return !s && b && b(), await new Promise((e, r) => {
            _H(e, r, {
              data: y,
              headers: MH.from(o.headers),
              status: o.status,
              statusText: o.statusText,
              config: t,
              request: d
            })
          })
        } catch (e) {
          throw b && b(), e && "TypeError" === e.name && /Load failed|fetch/i.test(e.message) ? Object.assign(new eH("Network Error", eH.ERR_NETWORK, t, d), {
            cause: e.cause || e
          }) : eH.from(e, e && e.code, t, d)
        }
      })
    };
    Yz.forEach(iG, (t, e) => {
      if (t) {
        try {
          Object.defineProperty(t, "name", {
            value: e
          })
        } catch {}
        Object.defineProperty(t, "adapterName", {
          value: e
        })
      }
    });
    const oG = t => "- " + t,
      sG = t => Yz.isFunction(t) || null === t || !1 === t,
      aG = t => {
        t = Yz.isArray(t) ? t : [t];
        const {
          length: e
        } = t;
        let r, n;
        const i = {};
        for (let o = 0; e > o; o++) {
          let e;
          if (r = t[o], n = r, !sG(r) && (n = iG[(e = r + "").toLowerCase()], void 0 === n)) throw new eH(`Unknown adapter '${e}'`);
          if (n) break;
          i[e || "#" + o] = n
        }
        if (!n) {
          const t = Object.entries(i).map(([t, e]) => `adapter ${t} ` + (!1 === e ? "is not supported by the environment" : "is not available in the build"));
          let r = e ? t.length > 1 ? "since :\n" + t.map(oG).join("\n") : " " + oG(t[0]) : "as no adapter specified";
          throw new eH("There is no suitable adapter to dispatch the request " + r, "ERR_NOT_SUPPORT")
        }
        return n
      };

    function uG(t) {
      if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted) throw new jH(null, t)
    }

    function cG(t) {
      return uG(t), t.headers = MH.from(t.headers), t.data = CH.call(t, t.transformRequest), -1 !== ["post", "put", "patch"].indexOf(t.method) && t.headers.setContentType("application/x-www-form-urlencoded", !1), aG(t.adapter || kH.adapter)(t).then(function(e) {
        return uG(t), e.data = CH.call(t, t.transformResponse, e), e.headers = MH.from(e.headers), e
      }, function(e) {
        return RH(e) || (uG(t), e && e.response && (e.response.data = CH.call(t, t.transformResponse, e.response), e.response.headers = MH.from(e.response.headers))), Promise.reject(e)
      })
    }
    const fG = "1.10.0",
      lG = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((t, e) => {
      lG[t] = function(r) {
        return typeof r === t || "a" + (1 > e ? "n " : " ") + t
      }
    });
    const hG = {};
    lG.transitional = function(t, e, r) {
      function n(t, e) {
        return "[Axios v" + fG + "] Transitional option '" + t + "'" + e + (r ? ". " + r : "")
      }
      return (r, i, o) => {
        if (!1 === t) throw new eH(n(i, " has been removed" + (e ? " in " + e : "")), eH.ERR_DEPRECATED);
        return e && !hG[i] && (hG[i] = !0, console.warn(n(i, " has been deprecated since v" + e + " and will be removed in the near future"))), !t || t(r, i, o)
      }
    }, lG.spelling = function(t) {
      return (e, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0)
    };
    const dG = {
        assertOptions: function(t, e, r) {
          if ("object" != typeof t) throw new eH("options must be an object", eH.ERR_BAD_OPTION_VALUE);
          const n = Object.keys(t);
          let i = n.length;
          for (; i-- > 0;) {
            const o = n[i],
              s = e[o];
            if (s) {
              const e = t[o],
                r = void 0 === e || s(e, o, t);
              if (!0 !== r) throw new eH("option " + o + " must be " + r, eH.ERR_BAD_OPTION_VALUE);
              continue
            }
            if (!0 !== r) throw new eH("Unknown option " + o, eH.ERR_BAD_OPTION)
          }
        },
        validators: lG
      },
      pG = dG.validators;
    class bG {
      constructor(t) {
        this.defaults = t || {}, this.interceptors = {
          request: new pH,
          response: new pH
        }
      }
      async request(t, e) {
        try {
          return await this.Ln(t, e)
        } catch (t) {
          if (t instanceof Error) {
            let e = {};
            Error.captureStackTrace ? Error.captureStackTrace(e) : e = Error();
            const r = e.stack ? e.stack.replace(/^.+\n/, "") : "";
            try {
              t.stack ? r && !(t.stack + "").endsWith(r.replace(/^.+\n.+\n/, "")) && (t.stack += "\n" + r) : t.stack = r
            } catch {}
          }
          throw t
        }
      }
      Ln(t, e) {
        "string" == typeof t ? (e = e || {}).url = t : e = t || {}, e = GH(this.defaults, e);
        const {
          transitional: r,
          paramsSerializer: n,
          headers: i
        } = e;
        void 0 !== r && dG.assertOptions(r, {
          silentJSONParsing: pG.transitional(pG.boolean),
          forcedJSONParsing: pG.transitional(pG.boolean),
          clarifyTimeoutError: pG.transitional(pG.boolean)
        }, !1), null != n && (Yz.isFunction(n) ? e.paramsSerializer = {
          serialize: n
        } : dG.assertOptions(n, {
          encode: pG.function,
          serialize: pG.function
        }, !0)), void 0 !== e.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? e.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : e.allowAbsoluteUrls = !0), dG.assertOptions(e, {
          baseUrl: pG.spelling("baseURL"),
          withXsrfToken: pG.spelling("withXSRFToken")
        }, !0), e.method = (e.method || this.defaults.method || "get").toLowerCase();
        let o = i && Yz.merge(i.common, i[e.method]);
        i && Yz.forEach(["delete", "get", "head", "post", "put", "patch", "common"], t => {
          delete i[t]
        }), e.headers = MH.concat(o, i);
        const s = [];
        let a = !0;
        this.interceptors.request.forEach(function(t) {
          "function" == typeof t.runWhen && !1 === t.runWhen(e) || (a = a && t.synchronous, s.unshift(t.fulfilled, t.rejected))
        });
        const u = [];
        this.interceptors.response.forEach(function(t) {
          u.push(t.fulfilled, t.rejected)
        });
        let c, f, l = 0;
        if (!a) {
          const t = [cG.bind(this), void 0];
          for (t.unshift.apply(t, s), t.push.apply(t, u), f = t.length, c = Promise.resolve(e); f > l;) c = c.then(t[l++], t[l++]);
          return c
        }
        f = s.length;
        let h = e;
        for (l = 0; f > l;) {
          const t = s[l++],
            e = s[l++];
          try {
            h = t(h)
          } catch (t) {
            e.call(this, t);
            break
          }
        }
        try {
          c = cG(h)
        } catch (t) {
          return Promise.reject(t)
        }
        for (l = 0, f = u.length; f > l;) c = c.then(u[l++], u[l++]);
        return c
      }
      getUri(t) {
        return dH(zH((t = GH(this.defaults, t)).baseURL, t.url, t.allowAbsoluteUrls), t.params, t.paramsSerializer)
      }
    }
    Yz.forEach(["delete", "get", "head", "options"], function(t) {
      bG.prototype[t] = function(e, r) {
        return this.request(GH(r || {}, {
          method: t,
          url: e,
          data: (r || {}).data
        }))
      }
    }), Yz.forEach(["post", "put", "patch"], function(t) {
      function e(e) {
        return function(r, n, i) {
          return this.request(GH(i || {}, {
            method: t,
            headers: e ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url: r,
            data: n
          }))
        }
      }
      bG.prototype[t] = e(), bG.prototype[t + "Form"] = e(!0)
    });
    const mG = bG;
    class yG {
      constructor(t) {
        if ("function" != typeof t) throw new TypeError("executor must be a function.");
        let e;
        this.promise = new Promise(function(t) {
          e = t
        });
        const r = this;
        this.promise.then(t => {
          if (!r.$n) return;
          let e = r.$n.length;
          for (; e-- > 0;) r.$n[e](t);
          r.$n = null
        }), this.promise.then = t => {
          let e;
          const n = new Promise(t => {
            r.subscribe(t), e = t
          }).then(t);
          return n.cancel = function() {
            r.unsubscribe(e)
          }, n
        }, t(function(t, n, i) {
          r.reason || (r.reason = new jH(t, n, i), e(r.reason))
        })
      }
      throwIfRequested() {
        if (this.reason) throw this.reason
      }
      subscribe(t) {
        this.reason ? t(this.reason) : this.$n ? this.$n.push(t) : this.$n = [t]
      }
      unsubscribe(t) {
        if (!this.$n) return;
        const e = this.$n.indexOf(t); - 1 !== e && this.$n.splice(e, 1)
      }
      toAbortSignal() {
        const t = new AbortController,
          e = e => {
            t.abort(e)
          };
        return this.subscribe(e), t.signal.unsubscribe = () => this.unsubscribe(e), t.signal
      }
      static source() {
        let t;
        return {
          token: new yG(function(e) {
            t = e
          }),
          cancel: t
        }
      }
    }
    const gG = yG,
      vG = {
        Continue: 100,
        SwitchingProtocols: 101,
        Processing: 102,
        EarlyHints: 103,
        Ok: 200,
        Created: 201,
        Accepted: 202,
        NonAuthoritativeInformation: 203,
        NoContent: 204,
        ResetContent: 205,
        PartialContent: 206,
        MultiStatus: 207,
        AlreadyReported: 208,
        ImUsed: 226,
        MultipleChoices: 300,
        MovedPermanently: 301,
        Found: 302,
        SeeOther: 303,
        NotModified: 304,
        UseProxy: 305,
        Unused: 306,
        TemporaryRedirect: 307,
        PermanentRedirect: 308,
        BadRequest: 400,
        Unauthorized: 401,
        PaymentRequired: 402,
        Forbidden: 403,
        NotFound: 404,
        MethodNotAllowed: 405,
        NotAcceptable: 406,
        ProxyAuthenticationRequired: 407,
        RequestTimeout: 408,
        Conflict: 409,
        Gone: 410,
        LengthRequired: 411,
        PreconditionFailed: 412,
        PayloadTooLarge: 413,
        UriTooLong: 414,
        UnsupportedMediaType: 415,
        RangeNotSatisfiable: 416,
        ExpectationFailed: 417,
        ImATeapot: 418,
        MisdirectedRequest: 421,
        UnprocessableEntity: 422,
        Locked: 423,
        FailedDependency: 424,
        TooEarly: 425,
        UpgradeRequired: 426,
        PreconditionRequired: 428,
        TooManyRequests: 429,
        RequestHeaderFieldsTooLarge: 431,
        UnavailableForLegalReasons: 451,
        InternalServerError: 500,
        NotImplemented: 501,
        BadGateway: 502,
        ServiceUnavailable: 503,
        GatewayTimeout: 504,
        HttpVersionNotSupported: 505,
        VariantAlsoNegotiates: 506,
        InsufficientStorage: 507,
        LoopDetected: 508,
        NotExtended: 510,
        NetworkAuthenticationRequired: 511
      };
    Object.entries(vG).forEach(([t, e]) => {
      vG[e] = t
    });
    const wG = vG,
      AG = function t(e) {
        const r = new mG(e),
          n = dz(mG.prototype.request, r);
        return Yz.extend(n, mG.prototype, r, {
          allOwnKeys: !0
        }), Yz.extend(n, r, null, {
          allOwnKeys: !0
        }), n.create = function(r) {
          return t(GH(e, r))
        }, n
      }(kH);
    AG.Axios = mG, AG.CanceledError = jH, AG.CancelToken = gG, AG.isCancel = RH, AG.VERSION = fG, AG.toFormData = aH, AG.AxiosError = eH, AG.Cancel = AG.CanceledError, AG.all = function(t) {
      return Promise.all(t)
    }, AG.spread = function(t) {
      return function(e) {
        return t.apply(null, e)
      }
    }, AG.isAxiosError = function(t) {
      return Yz.isObject(t) && !0 === t.isAxiosError
    }, AG.mergeConfig = GH, AG.AxiosHeaders = MH, AG.formToJSON = t => EH(Yz.isHTMLForm(t) ? new FormData(t) : t), AG.getAdapter = aG, AG.HttpStatusCode = wG, AG.default = AG;
    const TG = AG;
    class EG {
      host;
      timeout;
      user;
      password;
      headers;
      statusPage;
      instance;
      constructor(t, e = 3e4, r = "", n = "", i = {}, o = "/") {
        if (!JC(t)) throw Error("Invalid URL provided to HttpProvider");
        if (isNaN(e) || 0 > e) throw Error("Invalid timeout duration provided");
        if (!YC(i)) throw Error("Invalid headers object provided");
        t = t.replace(/\/+$/, ""), this.host = t, this.timeout = e, this.user = r, this.password = n, this.headers = i, this.statusPage = o, this.instance = TG.create({
          baseURL: t,
          timeout: e,
          headers: i,
          auth: r ? {
            username: r,
            password: n
          } : void 0
        })
      }
      setStatusPage(t = "/") {
        this.statusPage = t
      }
      async isConnected(t = this.statusPage) {
        return this.request(t).then(t => aR(t, "blockID", "block_header")).catch(() => !1)
      }
      request(t, e = {}, r = "get") {
        return r = r.toLowerCase(), this.instance.request({
          data: "post" == r && Object.keys(e).length ? e : null,
          params: "get" == r && e,
          url: t,
          method: r
        }).then(({
          data: t
        }) => t)
      }
    }
    const PG = {
      HttpProvider: EG
    };
    var kG = i(42575),
      xG = i(43817);
    const IG = new lU;

    function SG(t) {
      return iV.address.toHex(t).replace(X$, "0x")
    }

    function OG(t, e, r, n = !1) {
      if (n && r.replace(/^0x/, "").length % 64 == 8 && (r = "0x" + r.replace(/^0x/, "").substring(8)), r.replace(/^0x/, "").length % 64) throw Error("The encoded string is not valid. Its length must be a multiple of 64.");
      return e = e.map(t => (/trcToken/.test(t) && (t = t.replace(/trcToken/, "uint256")), t)), IG.decode(e, r).reduce((r, n, i) => ("address" == e[i] && (n = Y$ + n.substr(2).toLowerCase()), t.length ? r[t[i]] = n : r.push(n), r), t.length ? {} : [])
    }

    function BG(t, e) {
      for (let r = 0; r < t.length; r++) "address" === t[r] && (e[r] = iV.address.toHex(e[r]).replace(X$, "0x"));
      return IG.encode(t, e)
    }

    function WG(t) {
      const e = t.match(/([a-zA-Z0-9])(\[.*\])/);
      return e ? e[2] : ""
    }

    function MG(t) {
      return (WG(t).match(/\]\[/g) || []).length + 1
    }

    function CG(t, e) {
      const r = [],
        n = t => t && 0 === t.type.indexOf("tuple") && t.components ? `tuple(${t.components.map(t=>n(t)).join(",")})${WG(t.type)}` : /trcToken/.test(t.type) ? t.type.replace(/trcToken/, "uint256") : t.type,
        i = t => Array.isArray(t) ? (t.forEach((e, r) => {
          t[r] = i(e)
        }), t) : SG(t),
        o = (t, e, r) => {
          r > 1 ? e.length && e.forEach(e => {
            o(t, e, r - 1)
          }) : e.length && r && e.forEach(e => {
            s(t, e)
          })
        },
        s = (t = [], e) => {
          t.length && t.forEach((t, r) => {
            const n = t.type;
            if (e[r])
              if ("address" === n) e[r] = SG(e[r]);
              else if ("address[" === n.match(/^([^\x5b]*)(\x5b|$)/)[0]) i(e[r]);
            else if (0 === n.indexOf("tuple"))
              if (WG(n)) {
                const i = MG(n);
                o(t.components, e[r], i)
              } else s(t.components, e[r])
          })
        };
      if (t.inputs && t.inputs.length)
        for (let i = 0; i < t.inputs.length; i++) {
          const o = t.inputs[i].type;
          "bool" === o && "false" === e[i] && (e[i] = !1), r.push(0 === o.indexOf("tuple") ? n(t.inputs[i]) : o), e.length < r.length && e.push("")
        }
      return s(t.inputs, e), (t => {
        for (let e = 0; e < t.length; e++) {
          const r = t[e];
          /trcToken/.test(r) && (t[e] = r.replace(/trcToken/, "uint256"))
        }
      })(r), IG.encode(r, e)
    }

    function RG(t, e) {
      const r = t => Array.isArray(t) ? (t.forEach((e, n) => {
          t[n] = r(e)
        }), t) : iV.address.toHex(t),
        n = (t, e, r) => {
          r > 1 ? e.length && e.forEach(e => {
            n(t, e, r - 1)
          }) : e.length && r && e.forEach(e => {
            o(t, e)
          })
        },
        i = t => {
          const e = t.name ? " " + t.name : "";
          return t && 0 === t.type.indexOf("tuple") && t.components ? `tuple(${t.components.map(t=>i(t)).join(",")})${WG(t.type)}${e}` : /trcToken/.test(t.type) ? t.type.replace(/trcToken/, "uint256") + e : t.type + e
        },
        o = (t, e) => {
          t.length && t.forEach((t, i) => {
            const {
              type: s,
              name: a
            } = t;
            if (e[i])
              if ("address" === s) e[i] = iV.address.toHex(e[i]), a && (e[a] = iV.address.toHex(e[i]));
              else if ("address[" === s.match(/^([^\x5b]*)(\x5b|$)/)[0]) r(e[i]), a && (e[a] = r(e[i]));
            else if (0 === s.indexOf("tuple")) {
              if (WG(s)) {
                const r = MG(s);
                n(t.components, e[i], r)
              } else o(t.components, e[i]);
              a && (e[a] = e[i])
            } else a && (e[a] = e[i]);
            else a && (e[a] = e[i])
          })
        };
      if ("outputs" in t && t.outputs && t.outputs.length > 0) {
        const r = [];
        for (let e = 0; e < t.outputs.length; e++) {
          const n = t.outputs[e].type,
            o = t.outputs[e].name ? " " + t.outputs[e].name : "";
          r.push(0 === n.indexOf("tuple") ? i(t.outputs[e]) : n + o)
        }(t => {
          for (let e = 0; e < t.length; e++) {
            const r = t[e];
            /^trcToken/.test(r) && (t[e] = r.replace(/^trcToken/, "uint256"))
          }
        })(r), (!e || !e.length) && (e = new Uint8Array(32 * t.outputs.length));
        const n = IG.decode(r, e).toArray(!0);
        return o(t.outputs, n), n
      }
      return []
    }
    class NG {
      invalid(t) {
        return t.msg || `Invalid ${t.name}${"address"===t.type?" address":""} provided`
      }
      notPositive(t) {
        return t.name + " must be a positive integer"
      }
      notEqual(t) {
        return t.msg || `${t.names?.[0]} can not be equal to ${t.names?.[1]}`
      }
      notValid(t) {
        const e = {};
        let r = !1;
        for (const n of t) {
          const {
            name: t,
            names: i,
            value: o,
            type: s,
            gt: a,
            lt: u,
            gte: c,
            lte: f,
            optional: l
          } = n;
          if (!l || lR(o) && ("boolean" === s || !1 !== o)) {
            switch (e[t] = n.value, s) {
              case "address":
                az(o) ? e[t] = nz(o) : r = !0;
                break;
              case "integer":
                (!oR(o) || "number" == typeof a && a >= o || "number" == typeof u && o >= u || "number" == typeof c && c > o || "number" == typeof f && o > f) && (r = !0);
                break;
              case "positive-integer":
                if (!oR(o) || 0 >= o) throw Error(this.notPositive(n));
                break;
              case "tokenId":
              case "not-empty-string":
                (!rR(o) || !o.length) && (r = !0);
                break;
              case "notEmptyObject":
                (!YC(o) || !Object.keys(o).length) && (r = !0);
                break;
              case "notEqual":
                if (i && e[i[0]] === e[i[1]]) throw Error(this.notEqual(n));
                break;
              case "resource":
                ["BANDWIDTH", "ENERGY"].includes(o) || (r = !0);
                break;
              case "url":
                JC(o) || (r = !0);
                break;
              case "hex":
                iR(o) || (r = !0);
                break;
              case "array":
                Array.isArray(o) || (r = !0);
                break;
              case "boolean":
                tR(o) || (r = !0);
                break;
              case "string":
                (!rR(o) || "number" == typeof a && o.length <= a || "number" == typeof u && o.length >= u || "number" == typeof c && o.length < c || "number" == typeof f && o.length > f) && (r = !0)
            }
            if (r) throw Error(this.invalid(n))
          }
        }
        return !1
      }
    }
    var jG, _G, DG;
    ! function(t) {
      t.AccountCreateContract = "AccountCreateContract", t.TransferContract = "TransferContract", t.TransferAssetContract = "TransferAssetContract", t.VoteAssetContract = "VoteAssetContract", t.VoteWitnessContract = "VoteWitnessContract", t.WitnessCreateContract = "WitnessCreateContract", t.AssetIssueContract = "AssetIssueContract", t.WitnessUpdateContract = "WitnessUpdateContract", t.ParticipateAssetIssueContract = "ParticipateAssetIssueContract", t.AccountUpdateContract = "AccountUpdateContract", t.FreezeBalanceContract = "FreezeBalanceContract", t.UnfreezeBalanceContract = "UnfreezeBalanceContract", t.CancelAllUnfreezeV2Contract = "CancelAllUnfreezeV2Contract", t.WithdrawBalanceContract = "WithdrawBalanceContract", t.UnfreezeAssetContract = "UnfreezeAssetContract", t.UpdateAssetContract = "UpdateAssetContract", t.ProposalCreateContract = "ProposalCreateContract", t.ProposalApproveContract = "ProposalApproveContract", t.ProposalDeleteContract = "ProposalDeleteContract", t.SetAccountIdContract = "SetAccountIdContract", t.CustomContract = "CustomContract", t.CreateSmartContract = "CreateSmartContract", t.TriggerSmartContract = "TriggerSmartContract", t.GetContract = "GetContract", t.UpdateSettingContract = "UpdateSettingContract", t.ExchangeCreateContract = "ExchangeCreateContract", t.ExchangeInjectContract = "ExchangeInjectContract", t.ExchangeWithdrawContract = "ExchangeWithdrawContract", t.ExchangeTransactionContract = "ExchangeTransactionContract", t.UpdateEnergyLimitContract = "UpdateEnergyLimitContract", t.AccountPermissionUpdateContract = "AccountPermissionUpdateContract", t.ClearABIContract = "ClearABIContract", t.UpdateBrokerageContract = "UpdateBrokerageContract", t.ShieldedTransferContract = "ShieldedTransferContract", t.MarketSellAssetContract = "MarketSellAssetContract", t.MarketCancelOrderContract = "MarketCancelOrderContract", t.FreezeBalanceV2Contract = "FreezeBalanceV2Contract", t.UnfreezeBalanceV2Contract = "UnfreezeBalanceV2Contract", t.WithdrawExpireUnfreezeContract = "WithdrawExpireUnfreezeContract", t.DelegateResourceContract = "DelegateResourceContract", t.UnDelegateResourceContract = "UnDelegateResourceContract", t.UNRECOGNIZED = "UNRECOGNIZED"
    }(jG || (jG = {})),
    function(t) {
      t[t.Owner = 0] = "Owner", t[t.Witness = 1] = "Witness", t[t.Active = 2] = "Active", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED"
    }(_G || (_G = {})),
    function(t) {
      t[t.Normal = 0] = "Normal", t[t.AssetIssue = 1] = "AssetIssue", t[t.Contract = 2] = "Contract", t[t.UNRECOGNIZED = -1] = "UNRECOGNIZED"
    }(DG || (DG = {}));
    var UG = i(41653),
      LG = (i(99135), i(49026), i(73622), i(82237), i(38108), i(71195), i(30637), i(49919), i(96760), i(30121), i(48287).Buffer);
    const {
      Transaction: FG,
      Permission: $G,
      Key: zG
    } = globalThis.TronWebProto, {
      TransferContract: HG,
      FreezeBalanceContract: GG,
      UnfreezeBalanceContract: KG,
      WithdrawBalanceContract: VG,
      FreezeBalanceV2Contract: ZG,
      UnfreezeBalanceV2Contract: qG,
      WithdrawExpireUnfreezeContract: JG,
      DelegateResourceContract: YG,
      UnDelegateResourceContract: QG
    } = globalThis.TronWebProto, {
      TransferAssetContract: XG,
      ParticipateAssetIssueContract: tK,
      AssetIssueContract: eK,
      UpdateAssetContract: rK
    } = globalThis.TronWebProto, {
      TriggerSmartContract: nK,
      ClearABIContract: iK,
      UpdateEnergyLimitContract: oK,
      UpdateSettingContract: sK,
      CreateSmartContract: aK,
      SmartContract: uK
    } = globalThis.TronWebProto, {
      ResourceCode: cK
    } = globalThis.TronWebProto, {
      WitnessCreateContract: fK,
      VoteWitnessContract: lK
    } = globalThis.TronWebProto, {
      UpdateBrokerageContract: hK
    } = globalThis.TronWebProto, {
      AccountCreateContract: dK,
      AccountUpdateContract: pK,
      SetAccountIdContract: bK,
      AccountPermissionUpdateContract: mK
    } = globalThis.TronWebProto, {
      ProposalCreateContract: yK,
      ProposalDeleteContract: gK,
      ProposalApproveContract: vK
    } = globalThis.TronWebProto, {
      ExchangeCreateContract: wK,
      ExchangeInjectContract: AK,
      ExchangeWithdrawContract: TK,
      ExchangeTransactionContract: EK
    } = globalThis.TronWebProto, PK = t => t && 0 !== t.length ? new Uint8Array(oV.address.toHex(t).match(/.{1,2}/g).map(t => parseInt(t, 16))) : new Uint8Array([]), kK = t => t && 0 !== t.length ? new Uint8Array((iR(t) ? t : oV.toHex(t)).replace(/^0x/, "").match(/.{1,2}/g).map(t => parseInt(t, 16))) : new Uint8Array([]), xK = (t, e) => kK(e ? oV.fromUtf8(t).replace(/^0x/, "") : t.replace(/^0x/, "")), IK = (t, e, r, n) => {
      const i = new UG.Any;
      i.pack(t.serializeBinary(), "protocol." + r);
      const o = new FG.Contract;
      o.setType(e), o.setParameter(i), n && o.setPermissionId(n);
      const s = new FG.raw;
      s.addContract(o);
      const a = new FG;
      return a.setRawData(s), a
    }, SK = (t, e, r) => {
      switch (t.type) {
        case "TransferContract":
          return ((t, e) => {
            const {
              to_address: r,
              owner_address: n,
              amount: i
            } = t, o = new HG;
            return o.setToAddress(PK(r)), o.setOwnerAddress(PK(n)), o.setAmount(i), IK(o, FG.Contract.ContractType.TRANSFERCONTRACT, "TransferContract", e.Permission_id)
          })(e, r);
        case "TransferAssetContract":
          return ((t, e) => {
            const {
              to_address: r,
              owner_address: n,
              amount: i,
              asset_name: o
            } = t, s = new XG;
            return s.setToAddress(PK(r)), s.setOwnerAddress(PK(n)), s.setAssetName(xK(o, e.visible)), s.setAmount(i), IK(s, FG.Contract.ContractType.TRANSFERASSETCONTRACT, "TransferAssetContract", e.Permission_id)
          })(e, r);
        case "ParticipateAssetIssueContract":
          return ((t, e) => {
            const r = new tK;
            return r.setToAddress(PK(t.to_address)), r.setOwnerAddress(PK(t.owner_address)), r.setAssetName(xK(t.asset_name, e.visible)), r.setAmount(t.amount), IK(r, FG.Contract.ContractType.PARTICIPATEASSETISSUECONTRACT, "ParticipateAssetIssueContract", e.Permission_id)
          })(e, r);
        case "TriggerSmartContract":
          return ((t, e) => {
            const r = new nK,
              {
                owner_address: n,
                contract_address: i,
                parameter: o = "",
                function_selector: s,
                call_value: a,
                call_token_value: u,
                token_id: c,
                data: f
              } = t;
            if (r.setOwnerAddress(PK(n)), r.setContractAddress(PK(i)), r.setCallValue(a), f) r.setData(kK(f));
            else if (s) {
              const t = ((t, e = !0) => (e ? "0x" : "") + Cj(LG.from(t, "utf-8")).toString().substring(2))(s).substring(2, 10) + o;
              r.setData(kK(t))
            }
            return c && r.setTokenId(c), u && r.setCallTokenValue(u), IK(r, FG.Contract.ContractType.TRIGGERSMARTCONTRACT, "TriggerSmartContract", e.Permission_id)
          })(e, r);
        case "FreezeBalanceContract":
          return ((t, e) => {
            const r = new GG,
              {
                owner_address: n,
                frozen_balance: i,
                frozen_duration: o,
                resource: s,
                receiver_address: a
              } = t;
            return r.setOwnerAddress(PK(n)), r.setFrozenBalance(i), r.setFrozenDuration(o), s && r.setResource(cK[s]), a && r.setReceiverAddress(PK(a)), IK(r, FG.Contract.ContractType.FREEZEBALANCECONTRACT, "FreezeBalanceContract", e.Permission_id)
          })(e, r);
        case "UnfreezeBalanceContract":
          return ((t, e) => {
            const r = new KG,
              {
                owner_address: n,
                resource: i,
                receiver_address: o
              } = t;
            return r.setOwnerAddress(PK(n)), i && r.setResource(cK[i]), o && r.setReceiverAddress(PK(o)), IK(r, FG.Contract.ContractType.UNFREEZEBALANCECONTRACT, "UnfreezeBalanceContract", e.Permission_id)
          })(e, r);
        case "WithdrawBalanceContract":
          return ((t, e) => {
            const r = new VG,
              {
                owner_address: n
              } = t;
            return r.setOwnerAddress(PK(n)), IK(r, FG.Contract.ContractType.WITHDRAWBALANCECONTRACT, "WithdrawBalanceContract", e.Permission_id)
          })(e, r);
        case "FreezeBalanceV2Contract":
          return ((t, e) => {
            const r = new ZG,
              {
                owner_address: n,
                frozen_balance: i,
                resource: o
              } = t;
            return r.setOwnerAddress(PK(n)), r.setFrozenBalance(i), r.setResource(cK[o]), IK(r, FG.Contract.ContractType.FREEZEBALANCEV2CONTRACT, "FreezeBalanceV2Contract", e.Permission_id)
          })(e, r);
        case "CancelAllUnfreezeV2Contract":
          return ((t, e) => {
            const r = new JG,
              {
                owner_address: n
              } = t;
            return r.setOwnerAddress(PK(n)), IK(r, FG.Contract.ContractType.CANCELALLUNFREEZEV2CONTRACT, "CancelAllUnfreezeV2Contract", e.Permission_id)
          })(e, r);
        case "UnfreezeBalanceV2Contract":
          return ((t, e) => {
            const r = new qG,
              {
                owner_address: n,
                unfreeze_balance: i,
                resource: o
              } = t;
            return r.setOwnerAddress(PK(n)), r.setUnfreezeBalance(i), r.setResource(cK[o]), IK(r, FG.Contract.ContractType.UNFREEZEBALANCEV2CONTRACT, "UnfreezeBalanceV2Contract", e.Permission_id)
          })(e, r);
        case "DelegateResourceContract":
          return ((t, e) => {
            const r = new YG,
              {
                owner_address: n,
                receiver_address: i,
                balance: o,
                resource: s,
                lock: a = !1,
                lock_period: u
              } = t;
            return r.setOwnerAddress(PK(n)), r.setBalance(o), r.setResource(cK[s]), r.setLock(a), r.setLockPeriod(u), r.setReceiverAddress(PK(i)), IK(r, FG.Contract.ContractType.DELEGATERESOURCECONTRACT, "DelegateResourceContract", e.Permission_id)
          })(e, r);
        case "UnDelegateResourceContract":
          return ((t, e) => {
            const r = new QG,
              {
                owner_address: n,
                receiver_address: i,
                balance: o,
                resource: s
              } = t;
            return r.setOwnerAddress(PK(n)), r.setBalance(o), r.setResource(cK[s]), r.setReceiverAddress(PK(i)), IK(r, FG.Contract.ContractType.UNDELEGATERESOURCECONTRACT, "UnDelegateResourceContract", e.Permission_id)
          })(e, r);
        case "WithdrawExpireUnfreezeContract":
          return ((t, e) => {
            const r = new JG,
              {
                owner_address: n
              } = t;
            return r.setOwnerAddress(PK(n)), IK(r, FG.Contract.ContractType.WITHDRAWEXPIREUNFREEZECONTRACT, "WithdrawExpireUnfreezeContract", e.Permission_id)
          })(e, r);
        case "WitnessCreateContract":
          return ((t, e) => {
            const r = new fK,
              {
                owner_address: n,
                url: i
              } = t;
            return r.setOwnerAddress(PK(n)), r.setUrl(kK(i.replace(/^0x/, ""))), IK(r, FG.Contract.ContractType.WITNESSCREATECONTRACT, "WitnessCreateContract", e.Permission_id)
          })(e, r);
        case "VoteWitnessContract":
          return ((t, e) => {
            const r = new lK,
              {
                owner_address: n,
                votes: i
              } = t;
            return r.setOwnerAddress(PK(n)), i.forEach(t => {
              const e = new lK.Vote,
                {
                  vote_address: n,
                  vote_count: i
                } = t;
              e.setVoteAddress(PK(n));
              const o = parseInt(i);
              e.setVoteCount(o), r.addVotes(e)
            }), IK(r, FG.Contract.ContractType.VOTEWITNESSCONTRACT, "VoteWitnessContract", e.Permission_id)
          })(e, r);
        case "CreateSmartContract":
          return ((t, e) => {
            const r = t?.new_contract ? {
                owner_address: t.owner_address,
                call_token_value: t.call_token_value,
                token_id: t.token_id,
                ...t.new_contract
              } : t,
              {
                owner_address: n,
                consume_user_resource_percent: i,
                origin_energy_limit: o,
                abi: s,
                bytecode: a = "",
                parameter: u = "",
                call_value: c,
                call_token_value: f,
                token_id: l,
                name: h
              } = r;
            let {
              origin_address: d
            } = r;
            const p = new aK;
            p.setOwnerAddress(PK(n)), l && p.setTokenId(l), f && p.setCallTokenValue(f);
            const b = new uK;
            if (s) {
              let t;
              t = "string" == typeof s ? JSON.parse(s) : s?.entrys || [];
              const e = new uK.ABI,
                r = t => {
                  const e = new uK.ABI.Entry.Param,
                    {
                      indexed: r,
                      name: n,
                      type: i
                    } = t;
                  return !0 === r && e.setIndexed(!0), e.setName(n), e.setType(i), e
                },
                n = t.map(t => {
                  const {
                    anonymous: e,
                    constant: n,
                    name: i,
                    inputs: o,
                    outputs: s,
                    type: a,
                    payable: u,
                    stateMutability: c
                  } = t, f = new uK.ABI.Entry;
                  return f.setAnonymous(e), f.setConstant(n), f.setName(i), o && f.setInputsList(o.map(t => r(t))), s && f.setOutputsList(s.map(t => r(t))), a && f.setType(uK.ABI.Entry.EntryType[a.toUpperCase()]), f.setPayable(u), c && f.setStatemutability(uK.ABI.Entry.StateMutabilityType[c.toUpperCase()]), f
                });
              e.setEntrysList(n), b.setAbi(e)
            }
            if (c && b.setCallValue(c), b.setConsumeUserResourcePercent(i), b.setOriginEnergyLimit(o), d || (d = n), b.setOriginAddress(PK(d)), a) {
              const t = a.replace(/^0x/, "") + u.replace(/^0x/, "");
              b.setBytecode(kK(t))
            }
            return b.setName(h), p.setNewContract(b), IK(p, FG.Contract.ContractType.CREATESMARTCONTRACT, "CreateSmartContract", e.Permission_id)
          })(e, r);
        case "ClearABIContract":
          return ((t, e) => {
            const {
              contract_address: r,
              owner_address: n
            } = t, i = new iK;
            return i.setOwnerAddress(PK(n)), i.setContractAddress(PK(r)), IK(i, FG.Contract.ContractType.CLEARABICONTRACT, "ClearABIContract", e.Permission_id)
          })(e, r);
        case "UpdateBrokerageContract":
          return ((t, e) => {
            const {
              brokerage: r,
              owner_address: n
            } = t, i = new hK;
            return i.setOwnerAddress(PK(n)), i.setBrokerage(r), IK(i, FG.Contract.ContractType.UPDATEBROKERAGECONTRACT, "UpdateBrokerageContract", e.Permission_id)
          })(e, r);
        case "AssetIssueContract":
          return ((t, e) => {
            const {
              owner_address: r,
              name: n,
              abbr: i,
              description: o,
              url: s,
              total_supply: a,
              trx_num: u,
              num: c,
              start_time: f,
              end_time: l,
              precision: h,
              free_asset_net_limit: d,
              public_free_asset_net_limit: p,
              public_free_asset_net_usage: b = 0,
              public_latest_free_net_time: m = 0,
              vote_score: y = 0,
              frozen_supply: g
            } = t, v = new eK;
            if (v.setOwnerAddress(PK(r)), n && v.setName(kK(n.replace(/^0x/, ""))), i && v.setAbbr(kK(i.replace(/^0x/, ""))), v.setTotalSupply(a), v.setNum(c), v.setEndTime(l), v.setStartTime(f), v.setTrxNum(u), v.setVoteScore(y), h && v.setPrecision(h), m && v.setPublicLatestFreeNetTime(m), o && v.setDescription(kK(o.replace(/^0x/, ""))), s && v.setUrl(kK(s.replace(/^0x/, ""))), v.setPublicFreeAssetNetUsage(b), v.setFreeAssetNetLimit(d), v.setPublicFreeAssetNetLimit(p), g) {
              const t = new eK.FrozenSupply;
              t.setFrozenAmount(g.length ? g[0].frozen_amount : g.frozen_amount), t.setFrozenDays(g.length ? g[0].frozen_days : g.frozen_days), v.addFrozenSupply(t)
            }
            return IK(v, FG.Contract.ContractType.ASSETISSUECONTRACT, "AssetIssueContract", e.Permission_id)
          })(e, r);
        case "AccountCreateContract":
          return ((t, e) => {
            const r = new dK,
              {
                account_address: n,
                owner_address: i
              } = t;
            return r.setOwnerAddress(PK(i)), r.setAccountAddress(PK(n.replace(/^0x/, ""))), IK(r, FG.Contract.ContractType.ACCOUNTCREATECONTRACT, "AccountCreateContract", e.Permission_id)
          })(e, r);
        case "AccountUpdateContract":
          return ((t, e) => {
            const r = new pK,
              {
                account_name: n,
                owner_address: i
              } = t;
            return r.setOwnerAddress(PK(i)), r.setAccountName(kK(n.replace(/^0x/, ""))), IK(r, FG.Contract.ContractType.ACCOUNTUPDATECONTRACT, "AccountUpdateContract", e.Permission_id)
          })(e, r);
        case "SetAccountIdContract":
          return ((t, e) => {
            const r = new bK,
              {
                account_id: n,
                owner_address: i
              } = t;
            return r.setOwnerAddress(PK(i)), r.setAccountId(kK(n.replace(/^0x/, ""))), IK(r, FG.Contract.ContractType.SETACCOUNTIDCONTRACT, "SetAccountIdContract", e.Permission_id)
          })(e, r);
        case "ProposalCreateContract":
          return ((t, e) => {
            const r = new yK,
              {
                owner_address: n,
                parameters: i
              } = t;
            return r.setOwnerAddress(PK(n)), i.forEach(t => {
              r.getParametersMap().set(t.key, t.value)
            }), IK(r, FG.Contract.ContractType.PROPOSALCREATECONTRACT, "ProposalCreateContract", e.Permission_id)
          })(e, r);
        case "ProposalDeleteContract":
          return ((t, e) => {
            const r = new gK,
              {
                owner_address: n,
                proposal_id: i
              } = t;
            return r.setOwnerAddress(PK(n)), r.setProposalId(i), IK(r, FG.Contract.ContractType.PROPOSALDELETECONTRACT, "ProposalDeleteContract", e.Permission_id)
          })(e, r);
        case "ProposalApproveContract":
          return ((t, e) => {
            const r = new vK,
              {
                owner_address: n,
                proposal_id: i,
                is_add_approval: o
              } = t;
            return r.setOwnerAddress(PK(n)), r.setProposalId(i), r.setIsAddApproval(o), IK(r, FG.Contract.ContractType.PROPOSALAPPROVECONTRACT, "ProposalApproveContract", e.Permission_id)
          })(e, r);
        case "ExchangeCreateContract":
          return ((t, e) => {
            const r = new wK,
              {
                owner_address: n,
                first_token_id: i,
                first_token_balance: o,
                second_token_id: s,
                second_token_balance: a
              } = t;
            return r.setOwnerAddress(PK(n)), r.setFirstTokenId(xK(i, e.visible)), r.setFirstTokenBalance(o), r.setSecondTokenId(xK(s, e.visible)), r.setSecondTokenBalance(a), IK(r, FG.Contract.ContractType.EXCHANGECREATECONTRACT, "ExchangeCreateContract", e.Permission_id)
          })(e, r);
        case "ExchangeInjectContract":
          return ((t, e) => {
            const r = new AK,
              {
                owner_address: n,
                exchange_id: i,
                token_id: o,
                quant: s
              } = t;
            return r.setOwnerAddress(PK(n)), r.setExchangeId(i), r.setTokenId(xK(o, e.visible)), r.setQuant(s), IK(r, FG.Contract.ContractType.EXCHANGEINJECTCONTRACT, "ExchangeInjectContract", e.Permission_id)
          })(e, r);
        case "ExchangeWithdrawContract":
          return ((t, e) => {
            const r = new TK,
              {
                owner_address: n,
                exchange_id: i,
                token_id: o,
                quant: s
              } = t;
            return r.setOwnerAddress(PK(n)), r.setExchangeId(i), r.setTokenId(xK(o, e.visible)), r.setQuant(s), IK(r, FG.Contract.ContractType.EXCHANGEWITHDRAWCONTRACT, "ExchangeWithdrawContract", e.Permission_id)
          })(e, r);
        case "ExchangeTransactionContract":
          return ((t, e) => {
            const r = new EK,
              {
                owner_address: n,
                exchange_id: i,
                token_id: o,
                quant: s,
                expected: a
              } = t;
            return r.setOwnerAddress(PK(n)), r.setExchangeId(i), r.setTokenId(xK(o, e.visible)), r.setQuant(s), r.setExpected(a), IK(r, FG.Contract.ContractType.EXCHANGETRANSACTIONCONTRACT, "ExchangeTransactionContract", e.Permission_id)
          })(e, r);
        case "UpdateSettingContract":
          return ((t, e) => {
            const r = new sK,
              {
                owner_address: n,
                contract_address: i,
                consume_user_resource_percent: o
              } = t;
            return r.setOwnerAddress(PK(n)), r.setContractAddress(PK(i)), r.setConsumeUserResourcePercent(o), IK(r, FG.Contract.ContractType.UPDATESETTINGCONTRACT, "UpdateSettingContract", e.Permission_id)
          })(e, r);
        case "UpdateEnergyLimitContract":
          return ((t, e) => {
            const r = new oK,
              {
                owner_address: n,
                contract_address: i,
                origin_energy_limit: o
              } = t;
            return r.setOwnerAddress(PK(n)), r.setContractAddress(PK(i)), r.setOriginEnergyLimit(o), IK(r, FG.Contract.ContractType.UPDATEENERGYLIMITCONTRACT, "UpdateEnergyLimitContract", e.Permission_id)
          })(e, r);
        case "AccountPermissionUpdateContract":
          return ((t, e) => {
            const r = new mK,
              {
                owner_address: n,
                owner: i,
                witness: o,
                actives: s
              } = t;
            r.setOwnerAddress(PK(n));
            const a = t => {
              const e = new $G,
                {
                  type: r,
                  id: n,
                  permission_name: i,
                  threshold: o,
                  parentId: s,
                  operations: a,
                  keys: u
                } = t;
              return e.setType((t => isNaN(t) ? "Active" === t ? 2 : "Witness" === t ? 1 : 0 : t)(r)), e.setId(n), e.setPermissionName(i), e.setThreshold(o), s && e.setParentId(s), a && e.setOperations(kK(a)), u && e.setKeysList(u.map(t => {
                const e = new zG;
                return e.setAddress(PK(t.address)), e.setWeight(t.weight), e
              })), e
            };
            return i && r.setOwner(a(i)), o && r.setWitness(a(o)), s && (Array.isArray(s) ? r.setActivesList(s.map(t => a(t))) : r.setActivesList([a(s)])), IK(r, FG.Contract.ContractType.ACCOUNTPERMISSIONUPDATECONTRACT, "AccountPermissionUpdateContract", e.Permission_id)
          })(e, r);
        case "UpdateAssetContract":
          return ((t, e) => {
            const r = new rK,
              {
                owner_address: n,
                description: i,
                url: o,
                new_limit: s,
                new_public_limit: a
              } = t;
            return r.setOwnerAddress(PK(n)), i && r.setDescription(kK(i.replace(/^0x/, ""))), o && r.setUrl(kK(o.replace(/^0x/, ""))), s && r.setNewLimit(s), a && r.setNewPublicLimit(a), IK(r, FG.Contract.ContractType.UPDATEASSETCONTRACT, "UpdateAssetContract", e.Permission_id)
          })(e, r)
      }
    }, OK = t => {
      const e = t.raw_data,
        r = e.contract[0],
        n = r.parameter.value,
        i = {
          Permission_id: r.Permission_id,
          visible: t.visible
        },
        o = SK(r, n, i),
        s = o.getRawData();
      return s.setRefBlockBytes(kK(e.ref_block_bytes)), s.setRefBlockHash(kK(e.ref_block_hash)), e.data && s.setData(kK(e.data)), e.fee_limit && s.setFeeLimit(e.fee_limit), e.expiration && s.setExpiration(e.expiration), e.timestamp && s.setTimestamp(e.timestamp), o.setRawData(s), o
    }, BK = (t, e = {}, r = {}) => {
      const n = t.raw_data,
        i = n.contract[0],
        o = SK(i, e, {
          Permission_id: e?.Permission_id
        }),
        s = o.getRawData();
      return s.setRefBlockBytes(kK(n.ref_block_bytes)), s.setRefBlockHash(kK(n.ref_block_hash)), r.data && s.setData(kK(r.data.replace(/^0x/, ""))), (r.fee_limit || e.fee_limit) && s.setFeeLimit(r.fee_limit || e.fee_limit), n.expiration && s.setExpiration(n.expiration), n.timestamp && s.setTimestamp(n.timestamp), o.setRawData(s), o
    }, WK = (t, e) => {
      const r = e.getRawData().serializeBinary(),
        n = gC(r),
        i = oj(r);
      return n.toLowerCase() === t.raw_data_hex.toLowerCase() && i.replace(/^0x/, "").toLowerCase() === t.txID.replace(/^0x/, "").toLowerCase()
    }, MK = t => gC(t.getRawData().serializeBinary()), CK = t => {
      const e = OK(t);
      return WK(t, e)
    }, RK = (t, e, r) => {
      const n = BK(t, e, r);
      return WK(t, n)
    }, NK = t => oj(t.getRawData().serializeBinary()), jK = t => {
      const [e, r] = (t => {
        const e = FG.raw.deserializeBinary(xC(t)),
          r = e.getContractList()[0],
          n = r.getParameter().getValue();
        return [{
          contract: [{
            parameter: {
              value: {},
              type_url: r.getParameter().getTypeUrl()
            },
            type: r.getType(),
            Permission_id: r.getPermissionId()
          }],
          data: gC(e.getData()),
          fee_limit: e.getFeeLimit(),
          ref_block_bytes: gC(e.getRefBlockBytes_asU8()),
          ref_block_hash: gC(e.getRefBlockHash_asU8()),
          expiration: e.getExpiration(),
          timestamp: e.getTimestamp()
        }, n]
      })(t), n = nK.deserializeBinary(r);
      return e.contract[0].parameter.value = {
        owner_address: gC(n.getOwnerAddress_asU8()),
        contract_address: gC(n.getContractAddress_asU8()),
        call_value: n.getCallValue(),
        data: gC(n.getData_asU8()),
        call_token_value: n.getCallTokenValue(),
        token_id: n.getTokenId()
      }, e
    };
    var _K = i(48287).Buffer;

    function DK(t) {
      return iV.fromUtf8(t).replace(/^0x/, "")
    }

    function UK(t) {
      return JSON.parse(JSON.stringify(t))
    }

    function LK(t) {
      return t.request("wallet/getblock", {
        detail: !1
      }, "post").then(t => ({
        ref_block_bytes: t.block_header.raw_data.number.toString(16).slice(-4).padStart(4, "0"),
        ref_block_hash: t.blockID.slice(16, 32),
        expiration: t.block_header.raw_data.timestamp + 6e4,
        timestamp: t.block_header.raw_data.timestamp
      }))
    }

    function FK(t = {}) {
      if (typeof t.ref_block_bytes > "u" && typeof t.ref_block_hash > "u" && typeof t.expiration > "u" && typeof t.timestamp > "u") return !1;
      if ("string" != typeof t.ref_block_bytes) throw Error("Invalid ref_block_bytes provided.");
      if ("string" != typeof t.ref_block_hash) throw Error("Invalid ref_block_hash provided.");
      if ("number" != typeof t.expiration) throw Error("Invalid expiration provided.");
      if ("number" != typeof t.timestamp) throw Error("Invalid timestamp provided.");
      return !0
    }
    async function $K(t, e, r, n, i = {}) {
      const o = {
        visible: !1,
        txID: "",
        raw_data_hex: "",
        raw_data: {
          contract: [{
            parameter: {
              value: r,
              type_url: "type.googleapis.com/protocol." + e
            },
            type: e
          }],
          ...FK(i) ? {} : await LK(t.fullNode),
          ...i
        }
      };
      n && (o.raw_data.contract[0].Permission_id = n);
      const s = OK(o);
      return o.txID = NK(s).replace(/^0x/, ""), o.raw_data_hex = MK(s).toLowerCase(), o
    }

    function zK(t = {}) {
      const e = {};
      return FK(t.blockHeader) && (e.ref_block_bytes = t.blockHeader.ref_block_bytes, e.ref_block_hash = t.blockHeader.ref_block_hash, e.expiration = t.blockHeader.expiration, e.timestamp = t.blockHeader.timestamp), e
    }
    var HK = i(48287).Buffer;
    class GK {
      tronWeb;
      validator;
      constructor(t) {
        if (!(t && t instanceof iV)) throw Error("Expected instance of TronWeb");
        this.tronWeb = t, this.validator = new NG
      }
      async sendTrx(t, e = 0, r = this.tronWeb.defaultAddress.hex, n = {}) {
        e = parseInt(e), this.validator.notValid([{
          name: "recipient",
          type: "address",
          value: t
        }, {
          name: "origin",
          type: "address",
          value: r
        }, {
          names: ["recipient", "origin"],
          type: "notEqual",
          msg: "Cannot transfer TRX to the same account"
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: e
        }]);
        const i = {
            to_address: nz(t),
            owner_address: nz(r),
            amount: e
          },
          o = zK(n);
        return $K(this.tronWeb, jG.TransferContract, i, n?.permissionId, o)
      }
      async sendToken(t, e = 0, r, n = this.tronWeb.defaultAddress.hex, i = {}) {
        e = parseInt(e), this.validator.notValid([{
          name: "recipient",
          type: "address",
          value: t
        }, {
          name: "origin",
          type: "address",
          value: n
        }, {
          names: ["recipient", "origin"],
          type: "notEqual",
          msg: "Cannot transfer tokens to the same account"
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: e
        }, {
          name: "token ID",
          type: "tokenId",
          value: r
        }]);
        const o = {
            to_address: nz(t),
            owner_address: nz(n),
            asset_name: DK(r),
            amount: e
          },
          s = zK(i);
        return $K(this.tronWeb, jG.TransferAssetContract, o, i?.permissionId, s)
      }
      async purchaseToken(t, e, r = 0, n = this.tronWeb.defaultAddress.hex, i = {}) {
        this.validator.notValid([{
          name: "buyer",
          type: "address",
          value: n
        }, {
          name: "issuer",
          type: "address",
          value: t
        }, {
          names: ["buyer", "issuer"],
          type: "notEqual",
          msg: "Cannot purchase tokens from same account"
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: r
        }, {
          name: "token ID",
          type: "tokenId",
          value: e
        }]);
        const o = {
            to_address: nz(t),
            owner_address: nz(n),
            asset_name: DK(e),
            amount: parseInt(r)
          },
          s = zK(i);
        return $K(this.tronWeb, jG.ParticipateAssetIssueContract, o, i?.permissionId, s)
      }
      async freezeBalance(t = 0, e = 3, r = "BANDWIDTH", n = this.tronWeb.defaultAddress.hex, i, o = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: n
        }, {
          name: "receiver",
          type: "address",
          value: i,
          optional: !0
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: t
        }, {
          name: "duration",
          type: "integer",
          gte: 3,
          value: e
        }, {
          name: "resource",
          type: "resource",
          value: r,
          msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const s = {
          owner_address: nz(n),
          frozen_balance: parseInt(t),
          frozen_duration: parseInt(e + "")
        };
        "BANDWIDTH" !== r && (s.resource = r), lR(i) && nz(i) !== nz(n) && (s.receiver_address = nz(i));
        const a = zK(o);
        return $K(this.tronWeb, jG.FreezeBalanceContract, s, o?.permissionId, a)
      }
      async unfreezeBalance(t = "BANDWIDTH", e = this.tronWeb.defaultAddress.hex, r, n = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: e
        }, {
          name: "receiver",
          type: "address",
          value: r,
          optional: !0
        }, {
          name: "resource",
          type: "resource",
          value: t,
          msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const i = {
          owner_address: nz(e)
        };
        "BANDWIDTH" !== t && (i.resource = t), lR(r) && nz(r) !== nz(e) && (i.receiver_address = nz(r));
        const o = zK(n);
        return $K(this.tronWeb, jG.UnfreezeBalanceContract, i, n?.permissionId, o)
      }
      async freezeBalanceV2(t = 0, e = "BANDWIDTH", r = this.tronWeb.defaultAddress.hex, n = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: r
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: t
        }, {
          name: "resource",
          type: "resource",
          value: e,
          msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const i = {
          owner_address: nz(r),
          frozen_balance: parseInt(t)
        };
        "BANDWIDTH" !== e && (i.resource = e);
        const o = zK(n);
        return $K(this.tronWeb, jG.FreezeBalanceV2Contract, i, n?.permissionId, o)
      }
      async unfreezeBalanceV2(t = 0, e = "BANDWIDTH", r = this.tronWeb.defaultAddress.hex, n = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: r
        }, {
          name: "amount",
          type: "integer",
          gt: 0,
          value: t
        }, {
          name: "resource",
          type: "resource",
          value: e,
          msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]);
        const i = {
          owner_address: nz(r),
          unfreeze_balance: parseInt(t)
        };
        "BANDWIDTH" !== e && (i.resource = e);
        const o = zK(n);
        return $K(this.tronWeb, jG.UnfreezeBalanceV2Contract, i, n?.permissionId, o)
      }
      async cancelUnfreezeBalanceV2(t = this.tronWeb.defaultAddress.hex, e = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }]);
        const r = {
            owner_address: nz(t)
          },
          n = zK(e);
        return $K(this.tronWeb, jG.CancelAllUnfreezeV2Contract, r, e?.permissionId, n)
      }
      async delegateResource(t = 0, e, r = "BANDWIDTH", n = this.tronWeb.defaultAddress.hex, i = !1, o, s = {}) {
        if (this.validator.notValid([{
            name: "amount",
            type: "integer",
            gt: 0,
            value: t
          }, {
            name: "resource",
            type: "resource",
            value: r,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
          }, {
            name: "receiver",
            type: "address",
            value: e
          }, {
            name: "origin",
            type: "address",
            value: n
          }, {
            name: "lock",
            type: "boolean",
            value: i
          }, {
            name: "lock period",
            type: "integer",
            gte: 0,
            value: o,
            optional: !0
          }]), nz(e) === nz(n)) throw Error("Receiver address must not be the same as owner address");
        const a = {
          owner_address: nz(n),
          receiver_address: nz(e),
          balance: parseInt(t)
        };
        "BANDWIDTH" !== r && (a.resource = r), i && (a.lock = i, lR(o) && (a.lock_period = o));
        const u = zK(s);
        return $K(this.tronWeb, jG.DelegateResourceContract, a, s?.permissionId, u)
      }
      async undelegateResource(t = 0, e, r = "BANDWIDTH", n = this.tronWeb.defaultAddress.hex, i = {}) {
        if (this.validator.notValid([{
            name: "origin",
            type: "address",
            value: n
          }, {
            name: "receiver",
            type: "address",
            value: e
          }, {
            name: "amount",
            type: "integer",
            gt: 0,
            value: t
          }, {
            name: "resource",
            type: "resource",
            value: r,
            msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
          }]), nz(e) === nz(n)) throw Error("Receiver address must not be the same as owner address");
        const o = {
          owner_address: nz(n),
          receiver_address: nz(e),
          balance: parseInt(t)
        };
        "BANDWIDTH" !== r && (o.resource = r);
        const s = zK(i);
        return $K(this.tronWeb, jG.UnDelegateResourceContract, o, i?.permissionId, s)
      }
      async withdrawExpireUnfreeze(t = this.tronWeb.defaultAddress.hex, e = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }]);
        const r = {
            owner_address: nz(t)
          },
          n = zK(e);
        return $K(this.tronWeb, jG.WithdrawExpireUnfreezeContract, r, e?.permissionId, n)
      }
      async withdrawBlockRewards(t = this.tronWeb.defaultAddress.hex, e = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }]);
        const r = {
            owner_address: nz(t)
          },
          n = zK(e);
        return $K(this.tronWeb, jG.WithdrawBalanceContract, r, e?.permissionId, n)
      }
      async applyForSR(t = this.tronWeb.defaultAddress.hex, e = "", r = {}) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }, {
          name: "url",
          type: "url",
          value: e,
          msg: "Invalid url provided"
        }, {
          name: "url",
          type: "string",
          value: e,
          lte: 256,
          msg: "Invalid url provided"
        }]);
        const n = {
            owner_address: nz(t),
            url: DK(e)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.WitnessCreateContract, n, r?.permissionId, i)
      }
      async vote(t = {}, e = this.tronWeb.defaultAddress.hex, r = {}) {
        this.validator.notValid([{
          name: "voter",
          type: "address",
          value: e
        }, {
          name: "votes",
          type: "notEmptyObject",
          value: t
        }]);
        const n = Object.entries(t);
        for (const [t, e] of n) this.validator.notValid([{
          name: "SR",
          type: "address",
          value: t
        }, {
          name: "vote count",
          type: "integer",
          gt: 0,
          value: e,
          msg: "Invalid vote count provided for SR: " + t
        }]);
        const i = n.map(([t, e]) => ({
            vote_address: nz(t),
            vote_count: parseInt(e)
          })),
          o = {
            owner_address: nz(e),
            votes: i
          },
          s = zK(r);
        return $K(this.tronWeb, jG.VoteWitnessContract, o, r?.permissionId, s)
      }
      async createSmartContract(t = {}, e = this.tronWeb.defaultAddress.hex) {
        const r = t.feeLimit || this.tronWeb.feeLimit;
        let n = t.userFeePercentage;
        "number" != typeof n && !n && (n = 100);
        const i = t.originEnergyLimit || 1e7,
          o = t.callValue || 0,
          s = t.tokenValue,
          a = t.tokenId || t.token_id;
        let {
          abi: u
        } = t;
        const {
          parameters: c = []
        } = t;
        let f = "";
        const {
          bytecode: l = !1,
          name: h = ""
        } = t;
        if (u && rR(u)) try {
          u = JSON.parse(u)
        } catch {
          throw Error("Invalid options.abi provided")
        }
        const d = u;
        let p = d;
        if (d.entrys && (p = d.entrys), !QC(p)) throw Error("Invalid options.abi provided");
        const b = p.some(t => "constructor" === t.type && "payable" === t.stateMutability.toLowerCase());
        if (this.validator.notValid([{
            name: "bytecode",
            type: "hex",
            value: l
          }, {
            name: "feeLimit",
            type: "integer",
            value: r,
            gt: 0
          }, {
            name: "callValue",
            type: "integer",
            value: o,
            gte: 0
          }, {
            name: "userFeePercentage",
            type: "integer",
            value: n,
            gte: 0,
            lte: 100
          }, {
            name: "originEnergyLimit",
            type: "integer",
            value: i,
            gte: 0,
            lte: 1e7
          }, {
            name: "parameters",
            type: "array",
            value: c
          }, {
            name: "issuer",
            type: "address",
            value: e
          }, {
            name: "tokenValue",
            type: "integer",
            value: s,
            gte: 0,
            optional: !0
          }, {
            name: "tokenId",
            type: "integer",
            value: a,
            gte: 0,
            optional: !0
          }]), !b && (o > 0 || s > 0)) throw Error("When contract is not payable, options.callValue and options.tokenValue must be 0");
        const {
          rawParameter: m,
          funcABIV2: y,
          parametersV2: g
        } = t;
        if (m && rR(m)) f = m.replace(/^(0x)/, "");
        else if (y) f = CG(y, g).replace(/^(0x)/, "");
        else {
          let t = p.find(t => "constructor" === t.type);
          if ("u" > typeof t && t) {
            const e = new lU,
              r = [],
              n = [];
            if (t = t.inputs, c.length != t.length) throw Error(`constructor needs ${t.length} but ${c.length} provided`);
            for (let e = 0; e < c.length; e++) {
              let i = t[e].type,
                o = c[e];
              if (!i || !rR(i) || !i.length) throw Error("Invalid parameter type provided: " + i);
              const s = t => QC(t) ? t.map(t => s(t)) : nz(t).replace(X$, "0x");
              "address" === i || "address[" === i.match(/^([^\x5b]*)(\x5b|$)/)?.[0] ? o = s(o) : /trcToken/.test(i) && (i = i.replace(/trcToken/, "uint256")), r.push(i), n.push(o)
            }
            try {
              f = e.encode(r, n).replace(/^(0x)/, "")
            } catch (t) {
              throw Error(t)
            }
          } else f = ""
        }
        const v = {
          owner_address: nz(e),
          fee_limit: parseInt(r),
          call_value: parseInt(o),
          consume_user_resource_percent: n,
          origin_energy_limit: i,
          abi: JSON.stringify(u),
          bytecode: l,
          parameter: f,
          name: h
        };
        lR(s) && (v.call_token_value = parseInt(s)), lR(a) && (v.token_id = parseInt(a));
        const w = {};
        w.owner_address = v.owner_address, lR(v.call_token_value) && (w.call_token_value = v.call_token_value), lR(v.token_id) && (w.token_id = v.token_id);
        const A = w.new_contract = {};
        v.abi ? A.abi = {
          entrys: JSON.parse(v.abi)
        } : A.abi = {}, v.call_value && (A.call_value = v.call_value), A.consume_user_resource_percent = v.consume_user_resource_percent, A.origin_energy_limit = v.origin_energy_limit, A.origin_address = v.origin_address ?? v.owner_address, v.bytecode + v.parameter && (A.bytecode = (v.bytecode + v.parameter).replace(/^0x/, "")), lR(v.name) && (A.name = v.name);
        const T = zK(t),
          E = await $K(this.tronWeb, jG.CreateSmartContract, w, t?.permissionId, {
            ...T,
            fee_limit: v.fee_limit
          });
        return E.contract_address = function(t, e) {
          return "41" + Cj(_K.from(e + t, "hex")).toString().substring(2).slice(24)
        }(v.owner_address, E.txID), E
      }
      async triggerSmartContract(t, e, r, n, i) {
        const o = [t, e, r, n, i];
        return "object" != typeof o[2] && (o[2] = {
          feeLimit: o[2],
          callValue: o[3]
        }, o.splice(3, 1)), o[2]?.txLocal ? this.Cu(...o) : this.Ru(...o)
      }
      async triggerConstantContract(t, e, r = {}, n = [], i = this.tronWeb.defaultAddress.hex) {
        return r.Nu = !0, this.Ru(t, e, r, n, i)
      }
      async triggerConfirmedConstantContract(t, e, r = {}, n = [], i = this.tronWeb.defaultAddress.hex) {
        return r.Nu = !0, r.confirmed = !0, this.Ru(t, e, r, n, i)
      }
      async estimateEnergy(t, e, r = {}, n = [], i = this.tronWeb.defaultAddress.hex) {
        return r.estimateEnergy = !0, await this.Ru(t, e, r, n, i)
      }
      async deployConstantContract(t = {
        input: "",
        ownerAddress: ""
      }) {
        const {
          input: e,
          ownerAddress: r,
          tokenId: n,
          tokenValue: i,
          callValue: o = 0
        } = t;
        this.validator.notValid([{
          name: "input",
          type: "not-empty-string",
          value: e
        }, {
          name: "callValue",
          type: "integer",
          value: o,
          gte: 0
        }, {
          name: "owner",
          type: "address",
          value: r
        }, {
          name: "tokenValue",
          type: "integer",
          value: i,
          gte: 0,
          optional: !0
        }, {
          name: "tokenId",
          type: "integer",
          value: n,
          gte: 0,
          optional: !0
        }]);
        const s = {
          data: e,
          owner_address: nz(r),
          call_value: o
        };
        n && (s.token_id = n), i && (s.call_token_value = i);
        const a = `wallet${t.confirmed?"solidity":""}/estimateenergy`,
          u = await this.tronWeb[t.confirmed ? "solidityNode" : "fullNode"].request(a, s, "post");
        if (u.Error) throw Error(u.Error);
        if (u.result && u.result.message) throw Error(this.tronWeb.toUtf8(u.result.message));
        return u
      }
      ju(t, e, r, n, i, o, s, a, u) {
        const c = {
          contract_address: nz(t),
          owner_address: nz(i)
        };
        if (e && rR(e)) {
          let t;
          if (e = e.replace(/\s*/g, ""), n.length) {
            const e = new lU;
            let r = [];
            const i = [];
            for (let t = 0; t < n.length; t++) {
              let {
                value: e
              } = n[t];
              const {
                type: o
              } = n[t];
              if (!o || !rR(o) || !o.length) throw Error("Invalid parameter type provided: " + o);
              const s = t => QC(t) ? t.map(t => s(t)) : nz(t).replace(X$, "0x");
              ("address" === o || "address[" === o.match(/^([^\x5b]*)(\x5b|$)/)?.[0]) && (e = s(e)), r.push(o), i.push(e)
            }
            try {
              r = r.map(t => (/trcToken/.test(t) && (t = t.replace(/trcToken/, "uint256")), t)), t = e.encode(r, i).replace(/^(0x)/, "")
            } catch (t) {
              throw Error(t)
            }
          } else t = "";
          r.funcABIV2 && (t = CG(r.funcABIV2, r.parametersV2).replace(/^(0x)/, "")), r.shieldedParameter && rR(r.shieldedParameter) && (t = r.shieldedParameter.replace(/^(0x)/, "")), r.rawParameter && rR(r.rawParameter) && (t = r.rawParameter.replace(/^(0x)/, "")), c.function_selector = e, c.parameter = t
        } else r.input && (c.data = r.input);
        return c.call_value = parseInt(a), lR(o) && (c.call_token_value = parseInt(o)), lR(s) && (c.token_id = parseInt(s)), r.Nu || r.estimateEnergy || (c.fee_limit = parseInt(u)), r.permissionId && (c.Permission_id = r.permissionId), c
      }
      async Cu(t, e, r = {}, n = [], i = this.tronWeb.defaultAddress.hex) {
        const {
          tokenValue: o,
          tokenId: s,
          callValue: a,
          feeLimit: u
        } = Object.assign({
          callValue: 0,
          feeLimit: this.tronWeb.feeLimit
        }, r);
        this.validator.notValid([{
          name: "feeLimit",
          type: "integer",
          value: u,
          gt: 0
        }, {
          name: "callValue",
          type: "integer",
          value: a,
          gte: 0
        }, {
          name: "parameters",
          type: "array",
          value: n
        }, {
          name: "contract",
          type: "address",
          value: t
        }, {
          name: "issuer",
          type: "address",
          value: i,
          optional: !0
        }, {
          name: "tokenValue",
          type: "integer",
          value: o,
          gte: 0,
          optional: !0
        }, {
          name: "tokenId",
          type: "integer",
          value: s,
          gte: 0,
          optional: !0
        }]);
        const c = this.ju(t, e, r, n, i, o, s, a, u);
        c.function_selector && (c.data = Cj(HK.from(c.function_selector, "utf-8")).toString().substring(2, 10) + c.parameter);
        const f = {
          data: c.data,
          owner_address: c.owner_address,
          contract_address: c.contract_address
        };
        c.call_value && (f.call_value = c.call_value), c.call_token_value && (f.call_token_value = c.call_token_value), c.token_id && (f.token_id = c.token_id);
        const l = zK(r);
        return {
          result: {
            result: !0
          },
          transaction: await $K(this.tronWeb, jG.TriggerSmartContract, f, r.permissionId, {
            ...l,
            fee_limit: c.fee_limit
          })
        }
      }
      async Ru(t, e, r = {}, n = [], i = this.tronWeb.defaultAddress.hex) {
        const {
          tokenValue: o,
          tokenId: s,
          callValue: a,
          feeLimit: u
        } = Object.assign({
          callValue: 0,
          feeLimit: this.tronWeb.feeLimit
        }, r);
        this.validator.notValid([{
          name: "feeLimit",
          type: "integer",
          value: u,
          gt: 0
        }, {
          name: "callValue",
          type: "integer",
          value: a,
          gte: 0
        }, {
          name: "parameters",
          type: "array",
          value: n
        }, {
          name: "contract",
          type: "address",
          value: t
        }, {
          name: "issuer",
          type: "address",
          value: i,
          optional: !0
        }, {
          name: "tokenValue",
          type: "integer",
          value: o,
          gte: 0,
          optional: !0
        }, {
          name: "tokenId",
          type: "integer",
          value: s,
          gte: 0,
          optional: !0
        }]);
        const c = this.ju(t, e, r, n, i, o, s, a, u);
        let f = "triggersmartcontract";
        return r.Nu ? f = "triggerconstantcontract" : r.estimateEnergy && (f = "estimateenergy"), f = `wallet${r.confirmed?"solidity":""}/${f}`,
          function(t, e, r) {
            if (t.Error) throw Error(t.Error);
            if (t.result && t.result.message) throw Error(iV.toUtf8(t.result.message));
            if (!r.Nu && !r.estimateEnergy) {
              if (RK(t.transaction, e, r)) return t;
              throw Error("Invalid transaction")
            }
            return t
          }(await this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request(f, c, "post"), c, r)
      }
      async clearABI(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        if (!iV.isAddress(t)) throw Error("Invalid contract address provided");
        if (!iV.isAddress(e)) throw Error("Invalid owner address provided");
        const n = {
          contract_address: nz(t),
          owner_address: nz(e)
        };
        this.tronWeb.trx.cache.contracts[t] && delete this.tronWeb.trx.cache.contracts[t];
        const i = zK(r);
        return $K(this.tronWeb, jG.ClearABIContract, n, r?.permissionId, i)
      }
      async updateBrokerage(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        if (!lR(t)) throw Error("Invalid brokerage provided");
        if (!oR(t) || 0 > t || t > 100) throw Error("Brokerage must be an integer between 0 and 100");
        if (!iV.isAddress(e)) throw Error("Invalid owner address provided");
        const n = {
            brokerage: parseInt(t),
            owner_address: nz(e)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.UpdateBrokerageContract, n, r?.permissionId, i)
      }
      async createToken(t = {}, e = this.tronWeb.defaultAddress.hex) {
        const {
          name: r = !1,
          abbreviation: n = !1,
          description: i = "",
          url: o = !1,
          totalSupply: s = 0,
          trxRatio: a = 1,
          tokenRatio: u = 1,
          saleStart: c = Date.now(),
          saleEnd: f = !1,
          freeBandwidth: l = 0,
          freeBandwidthLimit: h = 0,
          frozenAmount: d = 0,
          frozenDuration: p = 0,
          voteScore: b,
          precision: m
        } = t;
        if (this.validator.notValid([{
            name: "Supply amount",
            type: "positive-integer",
            value: s
          }, {
            name: "TRX ratio",
            type: "positive-integer",
            value: a
          }, {
            name: "Token ratio",
            type: "positive-integer",
            value: u
          }, {
            name: "token abbreviation",
            type: "string",
            value: n,
            lte: 32,
            gt: 0
          }, {
            name: "token name",
            type: "not-empty-string",
            value: r
          }, {
            name: "token description",
            type: "string",
            value: i,
            lte: 200
          }, {
            name: "token url",
            type: "url",
            value: o
          }, {
            name: "token url",
            type: "string",
            value: o,
            lte: 256
          }, {
            name: "issuer",
            type: "address",
            value: e
          }, {
            name: "sale start timestamp",
            type: "integer",
            value: c,
            gte: Date.now()
          }, {
            name: "sale end timestamp",
            type: "integer",
            value: f,
            gt: c
          }, {
            name: "Frozen supply",
            type: "integer",
            value: d,
            gte: 0
          }, {
            name: "Frozen duration",
            type: "integer",
            value: p,
            gte: 0
          }]), lR(b) && (!oR(b) || 0 >= b)) throw Error("voteScore must be a positive integer greater than 0");
        if (lR(m) && (!oR(m) || 0 > m || m > 6)) throw Error("precision must be a positive integer >= 0 and <= 6");
        const y = {
          owner_address: nz(e),
          name: DK(r),
          abbr: DK(n),
          description: DK(i),
          url: DK(o),
          total_supply: parseInt(s),
          trx_num: parseInt(a),
          num: parseInt(u),
          start_time: parseInt(c),
          end_time: parseInt(f),
          frozen_supply: [{
            frozen_amount: parseInt(d),
            frozen_days: parseInt(p)
          }]
        };
        ["name", "abbr", "description", "url"].forEach(t => {
          y[t] || delete y[t]
        }), parseInt(d) > 0 || delete y.frozen_supply, l && !isNaN(parseInt(l)) && parseInt(l) >= 0 && (y.free_asset_net_limit = parseInt(l)), h && !isNaN(parseInt(h)) && parseInt(h) >= 0 && (y.public_free_asset_net_limit = parseInt(h)), m && !isNaN(parseInt(m)) && (y.precision = parseInt(m)), b && !isNaN(parseInt(b)) && (y.vote_score = parseInt(b));
        const g = zK(t);
        return $K(this.tronWeb, jG.AssetIssueContract, y, t?.permissionId, g)
      }
      async createAccount(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        this.validator.notValid([{
          name: "account",
          type: "address",
          value: t
        }, {
          name: "origin",
          type: "address",
          value: e
        }]);
        const n = {
            owner_address: nz(e),
            account_address: nz(t)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.AccountCreateContract, n, r?.permissionId, i)
      }
      async updateAccount(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        this.validator.notValid([{
          name: "Name",
          type: "string",
          lte: 200,
          gt: 0,
          value: t,
          msg: "Invalid accountName"
        }, {
          name: "origin",
          type: "address",
          value: e
        }]);
        const n = {
            account_name: DK(t),
            owner_address: nz(e)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.AccountUpdateContract, n, r?.permissionId, i)
      }
      async setAccountId(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        t && rR(t) && t.startsWith("0x") && (t = t.slice(2)), this.validator.notValid([{
          name: "accountId",
          type: "hex",
          value: t
        }, {
          name: "accountId",
          type: "string",
          lte: 32,
          gte: 8,
          value: t
        }, {
          name: "origin",
          type: "address",
          value: e
        }]);
        const n = {
            account_id: t,
            owner_address: nz(e)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.SetAccountIdContract, n, r?.permissionId, i)
      }
      async updateToken(t = {}, e = this.tronWeb.defaultAddress.hex) {
        const {
          description: r = "",
          url: n = !1,
          freeBandwidth: i = 0,
          freeBandwidthLimit: o = 0
        } = t;
        this.validator.notValid([{
          name: "token description",
          type: "string",
          value: r,
          lte: 200
        }, {
          name: "token url",
          type: "url",
          value: n
        }, {
          name: "token url",
          type: "string",
          value: n,
          lte: 256
        }, {
          name: "issuer",
          type: "address",
          value: e
        }]);
        const s = {
          owner_address: nz(e),
          description: DK(r),
          url: DK(n)
        };
        i && !isNaN(parseInt(i)) && parseInt(i) >= 0 && (s.new_limit = parseInt(i)), o && !isNaN(parseInt(o)) && parseInt(o) >= 0 && (s.new_public_limit = parseInt(o));
        const a = zK(t);
        return $K(this.tronWeb, jG.UpdateAssetContract, s, t?.permissionId, a)
      }
      async sendAsset(t, e = 0, r, n = this.tronWeb.defaultAddress.hex, i = {}) {
        return this.sendToken(t, e, r, n, i)
      }
      async purchaseAsset(t, e, r = 0, n = this.tronWeb.defaultAddress.hex, i = {}) {
        return this.purchaseToken(t, e, r, n, i)
      }
      async createAsset(t, e) {
        return this.createToken(t, e)
      }
      async updateAsset(t = {}, e = this.tronWeb.defaultAddress.hex) {
        return this.updateToken(t, e)
      }
      async createProposal(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        this.validator.notValid([{
          name: "issuer",
          type: "address",
          value: e
        }]);
        const n = "Invalid proposal parameters provided";
        if (!t) throw Error(n);
        const i = QC(t) ? t : [t];
        for (const t of i)
          if (!YC(t)) throw Error(n);
        const o = {
            owner_address: nz(e),
            parameters: i
          },
          s = zK(r);
        return $K(this.tronWeb, jG.ProposalCreateContract, o, r?.permissionId, s)
      }
      async deleteProposal(t, e = this.tronWeb.defaultAddress.hex, r = {}) {
        this.validator.notValid([{
          name: "issuer",
          type: "address",
          value: e
        }, {
          name: "proposalID",
          type: "integer",
          value: t,
          gte: 0
        }]);
        const n = {
            owner_address: nz(e),
            proposal_id: parseInt(t)
          },
          i = zK(r);
        return $K(this.tronWeb, jG.ProposalDeleteContract, n, r?.permissionId, i)
      }
      async voteProposal(t, e = !1, r = this.tronWeb.defaultAddress.hex, n = {}) {
        this.validator.notValid([{
          name: "voter",
          type: "address",
          value: r
        }, {
          name: "proposalID",
          type: "integer",
          value: t,
          gte: 0
        }, {
          name: "has approval",
          type: "boolean",
          value: e
        }]);
        const i = {
            owner_address: nz(r),
            proposal_id: parseInt(t),
            is_add_approval: e
          },
          o = zK(n);
        return $K(this.tronWeb, jG.ProposalApproveContract, i, n?.permissionId, o)
      }
      async createTRXExchange(t, e, r, n = this.tronWeb.defaultAddress.hex, i = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: n
        }, {
          name: "token name",
          type: "not-empty-string",
          value: t
        }, {
          name: "token balance",
          type: "positive-integer",
          value: e
        }, {
          name: "trx balance",
          type: "positive-integer",
          value: r
        }]);
        const o = {
            owner_address: nz(n),
            first_token_id: DK(t),
            first_token_balance: e,
            second_token_id: "5f",
            second_token_balance: r
          },
          s = zK(i);
        return $K(this.tronWeb, jG.ExchangeCreateContract, o, i?.permissionId, s)
      }
      async createTokenExchange(t, e, r, n, i = this.tronWeb.defaultAddress.hex, o = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: i
        }, {
          name: "first token name",
          type: "not-empty-string",
          value: t
        }, {
          name: "second token name",
          type: "not-empty-string",
          value: r
        }, {
          name: "first token balance",
          type: "positive-integer",
          value: e
        }, {
          name: "second token balance",
          type: "positive-integer",
          value: n
        }]);
        const s = {
            owner_address: nz(i),
            first_token_id: DK(t),
            first_token_balance: e,
            second_token_id: DK(r),
            second_token_balance: n
          },
          a = zK(o);
        return $K(this.tronWeb, jG.ExchangeCreateContract, s, o?.permissionId, a)
      }
      async injectExchangeTokens(t, e, r, n = this.tronWeb.defaultAddress.hex, i = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: n
        }, {
          name: "token name",
          type: "not-empty-string",
          value: e
        }, {
          name: "token amount",
          type: "integer",
          value: r,
          gte: 1
        }, {
          name: "exchangeID",
          type: "integer",
          value: t,
          gte: 0
        }]);
        const o = {
            owner_address: nz(n),
            exchange_id: parseInt(t),
            token_id: DK(e),
            quant: parseInt(r)
          },
          s = zK(i);
        return $K(this.tronWeb, jG.ExchangeInjectContract, o, i?.permissionId, s)
      }
      async withdrawExchangeTokens(t, e, r, n = this.tronWeb.defaultAddress.hex, i = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: n
        }, {
          name: "token name",
          type: "not-empty-string",
          value: e
        }, {
          name: "token amount",
          type: "integer",
          value: r,
          gte: 1
        }, {
          name: "exchangeID",
          type: "integer",
          value: t,
          gte: 0
        }]);
        const o = {
            owner_address: nz(n),
            exchange_id: parseInt(t),
            token_id: DK(e),
            quant: parseInt(r)
          },
          s = zK(i);
        return $K(this.tronWeb, jG.ExchangeWithdrawContract, o, i?.permissionId, s)
      }
      async tradeExchangeTokens(t, e, r, n, i = this.tronWeb.defaultAddress.hex, o = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: i
        }, {
          name: "token name",
          type: "not-empty-string",
          value: e
        }, {
          name: "tokenAmountSold",
          type: "integer",
          value: r,
          gte: 1
        }, {
          name: "tokenAmountExpected",
          type: "integer",
          value: n,
          gte: 1
        }, {
          name: "exchangeID",
          type: "integer",
          value: t,
          gte: 0
        }]);
        const s = {
            owner_address: nz(i),
            exchange_id: parseInt(t),
            token_id: iV.fromAscii(e).replace(/^0x/, ""),
            quant: parseInt(r),
            expected: parseInt(n)
          },
          a = zK(o);
        return $K(this.tronWeb, jG.ExchangeTransactionContract, s, o?.permissionId, a)
      }
      async updateSetting(t, e, r = this.tronWeb.defaultAddress.hex, n = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: r
        }, {
          name: "contract",
          type: "address",
          value: t
        }, {
          name: "userFeePercentage",
          type: "integer",
          value: e,
          gte: 0,
          lte: 100
        }]);
        const i = {
            owner_address: nz(r),
            contract_address: nz(t),
            consume_user_resource_percent: e
          },
          o = zK(n);
        return $K(this.tronWeb, jG.UpdateSettingContract, i, n?.permissionId, o)
      }
      async updateEnergyLimit(t, e = 0, r = this.tronWeb.defaultAddress.hex, n = {}) {
        this.validator.notValid([{
          name: "owner",
          type: "address",
          value: r
        }, {
          name: "contract",
          type: "address",
          value: t
        }, {
          name: "originEnergyLimit",
          type: "integer",
          value: e,
          gte: 0,
          lte: 1e7
        }]);
        const i = {
            owner_address: nz(r),
            contract_address: nz(t),
            origin_energy_limit: e
          },
          o = zK(n);
        return $K(this.tronWeb, jG.UpdateEnergyLimitContract, i, n?.permissionId, o)
      }
      checkPermissions(t, e) {
        if (t) {
          if (t.type !== e || !t.permission_name || !rR(t.permission_name) || !oR(t.threshold) || 1 > t.threshold || !t.keys) return !1;
          for (const r of t.keys)
            if (!iV.isAddress(r.address) || !oR(r.weight) || r.weight > t.threshold || 1 > r.weight || 2 === e && !t.operations) return !1
        }
        return !0
      }
      async updateAccountPermissions(t = this.tronWeb.defaultAddress.hex, e, r, n, i = {}) {
        if (!iV.isAddress(t)) throw Error("Invalid ownerAddress provided");
        if (!this.checkPermissions(e, 0)) throw Error("Invalid ownerPermissions provided");
        if (!this.checkPermissions(r, 1)) throw Error("Invalid witnessPermissions provided");
        Array.isArray(n) || (n = [n]);
        for (const t of n)
          if (!this.checkPermissions(t, 2)) throw Error("Invalid activesPermissions provided");
        const o = {
          owner_address: nz(t)
        };
        if (e) {
          const t = UK(e);
          "type" in t && delete t.type, t.keys = t.keys?.map(({
            address: t,
            weight: e
          }) => ({
            address: this.tronWeb.address.toHex(t),
            weight: e
          })), o.owner = t
        }
        if (r) {
          const t = UK(r);
          t.type = "Witness", t.keys = t.keys.map(({
            address: t,
            weight: e
          }) => ({
            address: this.tronWeb.address.toHex(t),
            weight: e
          })), o.witness = t
        }
        if (n) {
          const t = UK(n);
          t.forEach(t => {
            t.type = "Active"
          }), t.forEach(t => {
            t.keys = t.keys.map(({
              address: t,
              weight: e
            }) => ({
              address: this.tronWeb.address.toHex(t),
              weight: e
            }))
          }), o.actives = t
        }
        const s = zK(i);
        return $K(this.tronWeb, jG.AccountPermissionUpdateContract, o, i?.permissionId, s)
      }
      async newTxID(t, e = {}) {
        if (e?.txLocal) {
          const e = t.raw_data.contract[0];
          try {
            const r = await $K(this.tronWeb, e.type, e.parameter.value, e.Permission_id, {
              fee_limit: t.raw_data.fee_limit,
              data: t.raw_data.data,
              ref_block_bytes: t.raw_data.ref_block_bytes,
              ref_block_hash: t.raw_data.ref_block_hash,
              expiration: t.raw_data.expiration,
              timestamp: t.raw_data.timestamp
            });
            return r.signature = t.signature, r.visible = t.visible, r
          } catch {
            throw Error("Error generating a new transaction id.")
          }
        }
        try {
          const e = await this.tronWeb.fullNode.request("wallet/getsignweight", t, "post");
          return "boolean" == typeof t.visible && (e.transaction.transaction.visible = t.visible),
            function(t, e, r) {
              if (t.Error) throw Error(t.Error);
              if (t.result && t.result.message) throw Error(iV.toUtf8(t.result.message));
              if (RK(t, e, r)) return t;
              throw Error("Invalid transaction")
            }(e.transaction.transaction, {
              ...t.raw_data.contract[0].parameter.value,
              Permission_id: t.raw_data.contract[0].Permission_id
            }, {
              data: t.raw_data.data,
              fee_limit: t.raw_data.fee_limit
            })
        } catch {
          throw Error("Error generating a new transaction id.")
        }
      }
      async alterTransaction(t, e = {}) {
        if (Reflect.has(t, "signature")) throw Error("You can not extend the expiration of a signed transaction.");
        if (e.data) {
          if ("hex" !== e.dataFormat && (e.data = iV.toHex(e.data)), e.data = e.data.replace(/^0x/, ""), 0 === e.data.length) throw Error("Invalid data provided");
          t.raw_data.data = e.data
        }
        if (e.extension) {
          if (e.extension = parseInt(1e3 * e.extension), isNaN(e.extension) || t.raw_data.expiration + e.extension <= Date.now() + 3e3) throw Error("Invalid extension provided");
          t.raw_data.expiration += e.extension
        }
        return await this.newTxID(t, {
          txLocal: e.txLocal
        })
      }
      async extendExpiration(t, e, r = {}) {
        return await this.alterTransaction(t, {
          extension: e,
          txLocal: r?.txLocal
        })
      }
      async addUpdateData(t, e, r = "utf8", n = {}) {
        return this.alterTransaction(t, {
          data: e,
          dataFormat: r,
          txLocal: n?.txLocal
        })
      }
    }
    const KK = "TRON Signed Message:\n32",
      VK = "Ethereum Signed Message:\n32";

    function ZK(t) {
      return iV.address.toHex(t)
    }
    class qK {
      tronWeb;
      cache;
      validator;
      signMessage;
      sendAsset;
      send;
      sendTrx;
      broadcast;
      broadcastHex;
      signTransaction;
      constructor(t) {
        this.tronWeb = t, this.cache = {
          contracts: {}
        }, this.validator = new NG, this.signMessage = this.sign, this.sendAsset = this.sendToken, this.send = this.sendTransaction, this.sendTrx = this.sendTransaction, this.broadcast = this.sendRawTransaction, this.broadcastHex = this.sendHexTransaction, this.signTransaction = this.sign
      }
      _u(t) {
        return {
          ...t,
          name: this.tronWeb.toUtf8(t.name),
          abbr: t.abbr && this.tronWeb.toUtf8(t.abbr),
          description: t.description && this.tronWeb.toUtf8(t.description),
          url: t.url && this.tronWeb.toUtf8(t.url)
        }
      }
      getCurrentBlock() {
        return this.tronWeb.fullNode.request("wallet/getnowblock")
      }
      getConfirmedCurrentBlock() {
        return this.tronWeb.solidityNode.request("walletsolidity/getnowblock")
      }
      async getBlock(t = this.tronWeb.defaultBlock) {
        if (!1 === t) throw Error("No block identifier provided");
        return "earliest" == t && (t = 0), "latest" == t ? this.getCurrentBlock() : isNaN(+t) && YV.isHex(t.toString()) ? this.getBlockByHash(t) : this.getBlockByNumber(t)
      }
      async getBlockByHash(t) {
        const e = await this.tronWeb.fullNode.request("wallet/getblockbyid", {
          value: t
        }, "post");
        if (!Object.keys(e).length) throw Error("Block not found");
        return e
      }
      async getBlockByNumber(t) {
        if (!YV.isInteger(t) || 0 > t) throw Error("Invalid block number provided");
        return this.tronWeb.fullNode.request("wallet/getblockbynum", {
          num: parseInt(t)
        }, "post").then(t => {
          if (!Object.keys(t).length) throw Error("Block not found");
          return t
        })
      }
      async getBlockTransactionCount(t = this.tronWeb.defaultBlock) {
        const {
          transactions: e = []
        } = await this.getBlock(t);
        return e.length
      }
      async getTransactionFromBlock(t = this.tronWeb.defaultBlock, e) {
        const {
          transactions: r
        } = await this.getBlock(t);
        if (!r) throw Error("Transaction not found in block");
        if (e >= 0 && e < r.length) return r[e];
        throw Error("Invalid transaction index provided")
      }
      async getTransactionsFromBlock(t = this.tronWeb.defaultBlock) {
        const {
          transactions: e
        } = await this.getBlock(t);
        if (!e) throw Error("Transaction not found in block");
        return e
      }
      async getTransaction(t) {
        const e = await this.tronWeb.fullNode.request("wallet/gettransactionbyid", {
          value: t
        }, "post");
        if (!Object.keys(e).length) throw Error("Transaction not found");
        return e
      }
      async getConfirmedTransaction(t) {
        const e = await this.tronWeb.solidityNode.request("walletsolidity/gettransactionbyid", {
          value: t
        }, "post");
        if (!Object.keys(e).length) throw Error("Transaction not found");
        return e
      }
      getUnconfirmedTransactionInfo(t) {
        return this.tronWeb.fullNode.request("wallet/gettransactioninfobyid", {
          value: t
        }, "post")
      }
      getTransactionInfo(t) {
        return this.tronWeb.solidityNode.request("walletsolidity/gettransactioninfobyid", {
          value: t
        }, "post")
      }
      getTransactionsToAddress(t = this.tronWeb.defaultAddress.hex, e = 30, r = 0) {
        return this.getTransactionsRelated(this.tronWeb.address.toHex(t), "to", e, r)
      }
      getTransactionsFromAddress(t = this.tronWeb.defaultAddress.hex, e = 30, r = 0) {
        return this.getTransactionsRelated(this.tronWeb.address.toHex(t), "from", e, r)
      }
      async getTransactionsRelated(t = this.tronWeb.defaultAddress.hex, e = "all", r = 30, n = 0) {
        if (!["to", "from", "all"].includes(e)) throw Error('Invalid direction provided: Expected "to", "from" or "all"');
        if ("all" == e) {
          const [e, i] = await Promise.all([this.getTransactionsRelated(t, "from", r, n), this.getTransactionsRelated(t, "to", r, n)]);
          return [...e.map(t => (t.direction = "from", t)), ...i.map(t => (t.direction = "to", t))].sort((t, e) => e.raw_data.timestamp - t.raw_data.timestamp)
        }
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        if (!YV.isInteger(r) || 0 > r || n && 1 > r) throw Error("Invalid limit provided");
        if (!YV.isInteger(n) || 0 > n) throw Error("Invalid offset provided");
        return t = this.tronWeb.address.toHex(t), this.tronWeb.solidityNode.request(`walletextension/gettransactions${e}this`, {
          account: {
            address: t
          },
          offset: n,
          limit: r
        }, "post").then(({
          transaction: t
        }) => t)
      }
      async getAccount(t = this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return t = this.tronWeb.address.toHex(t), this.tronWeb.solidityNode.request("walletsolidity/getaccount", {
          address: t
        }, "post")
      }
      getAccountById(t) {
        return this.getAccountInfoById(t, {
          confirmed: !0
        })
      }
      async getAccountInfoById(t, e) {
        return this.validator.notValid([{
          name: "accountId",
          type: "hex",
          value: t
        }, {
          name: "accountId",
          type: "string",
          lte: 32,
          gte: 8,
          value: t
        }]), t.startsWith("0x") && (t = t.slice(2)), this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(`wallet${e.confirmed?"solidity":""}/getaccountbyid`, {
          account_id: t
        }, "post")
      }
      async getBalance(t = this.tronWeb.defaultAddress.hex) {
        const {
          balance: e = 0
        } = await this.getAccount(t);
        return e
      }
      async getUnconfirmedAccount(t = this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return t = this.tronWeb.address.toHex(t), this.tronWeb.fullNode.request("wallet/getaccount", {
          address: t
        }, "post")
      }
      getUnconfirmedAccountById(t) {
        return this.getAccountInfoById(t, {
          confirmed: !1
        })
      }
      async getUnconfirmedBalance(t = this.tronWeb.defaultAddress.hex) {
        const {
          balance: e = 0
        } = await this.getUnconfirmedAccount(t);
        return e
      }
      async getBandwidth(t = this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return t = this.tronWeb.address.toHex(t), this.tronWeb.fullNode.request("wallet/getaccountnet", {
          address: t
        }, "post").then(({
          freeNetUsed: t = 0,
          freeNetLimit: e = 0,
          NetUsed: r = 0,
          NetLimit: n = 0
        }) => e - t + (n - r))
      }
      async getTokensIssuedByAddress(t = this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return t = this.tronWeb.address.toHex(t), this.tronWeb.fullNode.request("wallet/getassetissuebyaccount", {
          address: t
        }, "post").then(({
          assetIssue: t
        }) => t ? t.map(t => this._u(t)).reduce((t, e) => (t[e.name] = e, t), {}) : {})
      }
      async getTokenFromID(t) {
        if (YV.isInteger(t) && (t = t.toString()), !YV.isString(t) || !t.length) throw Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuebyname", {
          value: this.tronWeb.fromUtf8(t)
        }, "post").then(t => {
          if (!t.name) throw Error("Token does not exist");
          return this._u(t)
        })
      }
      async listNodes() {
        const {
          nodes: t = []
        } = await this.tronWeb.fullNode.request("wallet/listnodes");
        return t.map(({
          address: {
            host: t,
            port: e
          }
        }) => `${this.tronWeb.toUtf8(t)}:${e}`)
      }
      async getBlockRange(t = 0, e = 30) {
        if (!YV.isInteger(t) || 0 > t) throw Error("Invalid start of range provided");
        if (!YV.isInteger(e) || t > e) throw Error("Invalid end of range provided");
        if (e + 1 - t > 100) throw Error("Invalid range size, which should be no more than 100.");
        return this.tronWeb.fullNode.request("wallet/getblockbylimitnext", {
          startNum: parseInt(t),
          endNum: parseInt(e) + 1
        }, "post").then(({
          block: t = []
        }) => t)
      }
      async listSuperRepresentatives() {
        const {
          witnesses: t = []
        } = await this.tronWeb.fullNode.request("wallet/listwitnesses");
        return t
      }
      async listTokens(t = 0, e = 0) {
        if (!YV.isInteger(t) || 0 > t || e && 1 > t) throw Error("Invalid limit provided");
        if (!YV.isInteger(e) || 0 > e) throw Error("Invalid offset provided");
        return t ? this.tronWeb.fullNode.request("wallet/getpaginatedassetissuelist", {
          offset: parseInt(e),
          limit: parseInt(t)
        }, "post").then(({
          assetIssue: t = []
        }) => t.map(t => this._u(t))) : this.tronWeb.fullNode.request("wallet/getassetissuelist").then(({
          assetIssue: t = []
        }) => t.map(t => this._u(t)))
      }
      async timeUntilNextVoteCycle() {
        const {
          num: t = -1
        } = await this.tronWeb.fullNode.request("wallet/getnextmaintenancetime");
        if (-1 == t) throw Error("Failed to get time until next vote cycle");
        return Math.floor(t / 1e3)
      }
      async getContract(t) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid contract address provided");
        if (this.cache.contracts[t]) return this.cache.contracts[t];
        t = this.tronWeb.address.toHex(t);
        const e = await this.tronWeb.fullNode.request("wallet/getcontract", {
          value: t
        });
        if (e.Error) throw Error("Contract does not exist");
        return this.cache.contracts[t] = e, e
      }
      ecRecover(t) {
        return qK.ecRecover(t)
      }
      static ecRecover(t) {
        if (!CK(t)) throw Error("Invalid transaction");
        if (!t.signature?.length) throw Error("Transaction is not signed");
        if (1 === t.signature.length) {
          const e = PV(t.txID, t.signature[0]);
          return iV.address.fromHex(e)
        }
        return t.signature.map(e => {
          const r = PV(t.txID, e);
          return iV.address.fromHex(r)
        })
      }
      async verifyMessage(t, e, r = this.tronWeb.defaultAddress.base58, n = !0) {
        if (!YV.isHex(t)) throw Error("Expected hex message input");
        if (qK.verifySignature(t, r, e, n)) return !0;
        throw Error("Signature does not match")
      }
      static verifySignature(t, e, r, n = !0) {
        t = t.replace(/^0x/, "");
        const i = [...dj(n ? KK : VK), ...YV.code.hexStr2byteArray(t)],
          o = nD(Cj(new Uint8Array(i)), oN.from("0x" + r.replace(/^0x/, ""))),
          s = Y$ + o.substr(2);
        return iV.address.fromHex(s) == iV.address.fromHex(e)
      }
      async verifyMessageV2(t, e) {
        return qK.verifyMessageV2(t, e)
      }
      static verifyMessageV2(t, e) {
        return YV.message.verifyMessage(t, e)
      }
      verifyTypedData(t, e, r, n, i = this.tronWeb.defaultAddress.base58) {
        if (qK.verifyTypedData(t, e, r, n, i)) return !0;
        throw Error("Signature does not match")
      }
      static verifyTypedData(t, e, r, n, i) {
        const o = nD(YV.Du.hash(t, e, r), oN.from("0x" + n.replace(/^0x/, ""))),
          s = Y$ + o.substr(2);
        return iV.address.fromHex(s) == iV.address.fromHex(i)
      }
      async sign(t, e = this.tronWeb.defaultPrivateKey, r = !0, n = !1) {
        if (YV.isString(t)) {
          if (!YV.isHex(t)) throw Error("Expected hex message input");
          return qK.signString(t, e, r)
        }
        if (!YV.isObject(t)) throw Error("Invalid transaction provided");
        if (!n && t.signature) throw Error("Transaction is already signed");
        if (!n) {
          if (this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(e)).toLowerCase() !== this.tronWeb.address.toHex(t.raw_data.contract[0].parameter.value.owner_address)) throw Error("Private key does not match address in transaction");
          if (!CK(t)) throw Error("Invalid transaction")
        }
        return YV.crypto.signTransaction(e, t)
      }
      static signString(t, e, r = !0) {
        t = t.replace(/^0x/, "");
        const n = "0x" + e.replace(/^0x/, ""),
          i = new eD(n),
          o = [...dj(r ? KK : VK), ...YV.code.hexStr2byteArray(t)],
          s = Cj(new Uint8Array(o)),
          a = i.sign(s);
        return "0x" + a.r.substring(2) + a.s.substring(2) + (+a.v).toString(16)
      }
      signMessageV2(t, e = this.tronWeb.defaultPrivateKey) {
        return qK.signMessageV2(t, e)
      }
      static signMessageV2(t, e) {
        return YV.message.signMessage(t, e)
      }
      Zn(t, e, r, n = this.tronWeb.defaultPrivateKey) {
        return qK.Zn(t, e, r, n)
      }
      static Zn(t, e, r, n) {
        return YV.crypto.Zn(t, e, r, n)
      }
      async multiSign(t, e = this.tronWeb.defaultPrivateKey, r = 0) {
        if (!YV.isObject(t) || !t.raw_data || !t.raw_data.contract) throw Error("Invalid transaction provided");
        if (!t.raw_data.contract[0].Permission_id && r > 0) {
          t.raw_data.contract[0].Permission_id = r;
          const n = this.tronWeb.address.toHex(this.tronWeb.address.fromPrivateKey(e)).toLowerCase(),
            i = await this.getSignWeight(t, r);
          if ("PERMISSION_ERROR" === i.result.code) throw Error(i.result.message);
          let o = !1;
          if (i.permission.keys.map(t => {
              t.address === n && (o = !0)
            }), !o) throw Error(e + " has no permission to sign");
          if (i.approved_list && -1 != i.approved_list.indexOf(n)) throw Error(e + " already sign transaction");
          if (!i.transaction || !i.transaction.transaction) throw Error("Invalid transaction provided");
          t = i.transaction.transaction, r > 0 && (t.raw_data.contract[0].Permission_id = r)
        }
        if (!CK(t)) throw Error("Invalid transaction");
        return YV.crypto.signTransaction(e, t)
      }
      async getApprovedList(t) {
        if (!YV.isObject(t)) throw Error("Invalid transaction provided");
        return this.tronWeb.fullNode.request("wallet/getapprovedlist", t, "post")
      }
      async getSignWeight(t, e) {
        if (!YV.isObject(t) || !t.raw_data || !t.raw_data.contract) throw Error("Invalid transaction provided");
        return YV.isInteger(e) ? t.raw_data.contract[0].Permission_id = parseInt(e) : "number" != typeof t.raw_data.contract[0].Permission_id && (t.raw_data.contract[0].Permission_id = 0), this.tronWeb.fullNode.request("wallet/getsignweight", t, "post")
      }
      async sendRawTransaction(t) {
        if (!YV.isObject(t)) throw Error("Invalid transaction provided");
        if (!t.signature || !YV.isArray(t.signature)) throw Error("Transaction is not signed");
        return {
          ...await this.tronWeb.fullNode.request("wallet/broadcasttransaction", t, "post"),
          transaction: t
        }
      }
      async sendHexTransaction(t) {
        if (!YV.isHex(t)) throw Error("Invalid hex transaction provided");
        const e = {
            transaction: t
          },
          r = await this.tronWeb.fullNode.request("wallet/broadcasthex", e, "post");
        return r.result ? {
          ...r,
          transaction: JSON.parse(r.transaction),
          hexTransaction: t
        } : r
      }
      async sendTransaction(t, e, r = {}) {
        if ("string" == typeof r && (r = {
            privateKey: r
          }), !this.tronWeb.isAddress(t)) throw Error("Invalid recipient provided");
        if (!YV.isInteger(e) || 0 >= e) throw Error("Invalid amount provided");
        if (!(r = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...r
          }).privateKey && !r.address) throw Error("Function requires either a private key or address to be set");
        const n = r.privateKey ? this.tronWeb.address.fromPrivateKey(r.privateKey) : r.address,
          i = await this.tronWeb.transactionBuilder.sendTrx(t, e, n),
          o = await this.sign(i, r.privateKey);
        return await this.sendRawTransaction(o)
      }
      async sendToken(t, e, r, n = {}) {
        if ("string" == typeof n && (n = {
            privateKey: n
          }), !this.tronWeb.isAddress(t)) throw Error("Invalid recipient provided");
        if (!YV.isInteger(e) || 0 >= e) throw Error("Invalid amount provided");
        if (YV.isInteger(r) && (r = r.toString()), !YV.isString(r)) throw Error("Invalid token ID provided");
        if (!(n = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...n
          }).privateKey && !n.address) throw Error("Function requires either a private key or address to be set");
        const i = n.privateKey ? this.tronWeb.address.fromPrivateKey(n.privateKey) : n.address,
          o = await this.tronWeb.transactionBuilder.sendToken(t, e, r, i),
          s = await this.sign(o, n.privateKey);
        return await this.sendRawTransaction(s)
      }
      async freezeBalance(t = 0, e = 3, r = "BANDWIDTH", n = {}, i) {
        if ("string" == typeof n && (n = {
            privateKey: n
          }), !["BANDWIDTH", "ENERGY"].includes(r)) throw Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
        if (!YV.isInteger(t) || 0 >= t) throw Error("Invalid amount provided");
        if (!YV.isInteger(e) || 3 > e) throw Error("Invalid duration provided, minimum of 3 days");
        if (!(n = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...n
          }).privateKey && !n.address) throw Error("Function requires either a private key or address to be set");
        const o = n.privateKey ? this.tronWeb.address.fromPrivateKey(n.privateKey) : n.address,
          s = await this.tronWeb.transactionBuilder.freezeBalance(t, e, r, o, i),
          a = await this.sign(s, n.privateKey);
        return await this.sendRawTransaction(a)
      }
      async unfreezeBalance(t = "BANDWIDTH", e = {}, r) {
        if ("string" == typeof e && (e = {
            privateKey: e
          }), !["BANDWIDTH", "ENERGY"].includes(t)) throw Error('Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"');
        if (!(e = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...e
          }).privateKey && !e.address) throw Error("Function requires either a private key or address to be set");
        const n = e.privateKey ? this.tronWeb.address.fromPrivateKey(e.privateKey) : e.address,
          i = await this.tronWeb.transactionBuilder.unfreezeBalance(t, n, r),
          o = await this.sign(i, e.privateKey);
        return await this.sendRawTransaction(o)
      }
      async updateAccount(t, e = {}) {
        if ("string" == typeof e && (e = {
            privateKey: e
          }), !YV.isString(t) || !t.length) throw Error("Name must be a string");
        if (!(e = {
            privateKey: this.tronWeb.defaultPrivateKey,
            address: this.tronWeb.defaultAddress.hex,
            ...e
          }).privateKey && !e.address) throw Error("Function requires either a private key or address to be set");
        const r = e.privateKey ? this.tronWeb.address.fromPrivateKey(e.privateKey) : e.address,
          n = await this.tronWeb.transactionBuilder.updateAccount(t, r),
          i = await this.sign(n, e.privateKey);
        return await this.sendRawTransaction(i)
      }
      async getProposal(t) {
        if (!YV.isInteger(t) || 0 > t) throw Error("Invalid proposalID provided");
        return this.tronWeb.fullNode.request("wallet/getproposalbyid", {
          id: parseInt(t)
        }, "post")
      }
      async listProposals() {
        const {
          proposals: t = []
        } = await this.tronWeb.fullNode.request("wallet/listproposals", {}, "post");
        return t
      }
      async getChainParameters() {
        const {
          chainParameter: t = []
        } = await this.tronWeb.fullNode.request("wallet/getchainparameters", {}, "post");
        return t
      }
      async getAccountResources(t = this.tronWeb.defaultAddress.hex) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return this.tronWeb.fullNode.request("wallet/getaccountresource", {
          address: this.tronWeb.address.toHex(t)
        }, "post")
      }
      async getDelegatedResourceV2(t = this.tronWeb.defaultAddress.hex, e = this.tronWeb.defaultAddress.hex, r = {
        confirmed: !0
      }) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        if (!this.tronWeb.isAddress(e)) throw Error("Invalid address provided");
        return this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request(`wallet${r.confirmed?"solidity":""}/getdelegatedresourcev2`, {
          fromAddress: ZK(t),
          toAddress: ZK(e)
        }, "post")
      }
      async getDelegatedResourceAccountIndexV2(t = this.tronWeb.defaultAddress.hex, e = {
        confirmed: !0
      }) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(`wallet${e.confirmed?"solidity":""}/getdelegatedresourceaccountindexv2`, {
          value: ZK(t)
        }, "post")
      }
      async getCanDelegatedMaxSize(t = this.tronWeb.defaultAddress.hex, e = "BANDWIDTH", r = {
        confirmed: !0
      }) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return this.validator.notValid([{
          name: "resource",
          type: "resource",
          value: e,
          msg: 'Invalid resource provided: Expected "BANDWIDTH" or "ENERGY"'
        }]), this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request(`wallet${r.confirmed?"solidity":""}/getcandelegatedmaxsize`, {
          owner_address: ZK(t),
          type: "ENERGY" === e ? 1 : 0
        }, "post")
      }
      async getAvailableUnfreezeCount(t = this.tronWeb.defaultAddress.hex, e = {
        confirmed: !0
      }) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        return this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(`wallet${e.confirmed?"solidity":""}/getavailableunfreezecount`, {
          owner_address: ZK(t)
        }, "post")
      }
      async getCanWithdrawUnfreezeAmount(t = this.tronWeb.defaultAddress.hex, e = Date.now(), r = {
        confirmed: !0
      }) {
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid address provided");
        if (!YV.isInteger(e) || 0 > e) throw Error("Invalid timestamp provided");
        return this.tronWeb[r.confirmed ? "solidityNode" : "fullNode"].request(`wallet${r.confirmed?"solidity":""}/getcanwithdrawunfreezeamount`, {
          owner_address: ZK(t),
          timestamp: e
        }, "post")
      }
      async getExchangeByID(t) {
        if (!YV.isInteger(t) || 0 > t) throw Error("Invalid exchangeID provided");
        return this.tronWeb.fullNode.request("wallet/getexchangebyid", {
          id: t
        }, "post")
      }
      async listExchanges() {
        return this.tronWeb.fullNode.request("wallet/listexchanges", {}, "post").then(({
          exchanges: t = []
        }) => t)
      }
      async listExchangesPaginated(t = 10, e = 0) {
        return this.tronWeb.fullNode.request("wallet/getpaginatedexchangelist", {
          limit: t,
          offset: e
        }, "post").then(({
          exchanges: t = []
        }) => t)
      }
      async getNodeInfo() {
        return this.tronWeb.fullNode.request("wallet/getnodeinfo", {}, "post")
      }
      async getTokenListByName(t) {
        if (YV.isInteger(t) && (t = t.toString()), !YV.isString(t) || !t.length) throw Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuelistbyname", {
          value: this.tronWeb.fromUtf8(t)
        }, "post").then(t => {
          if (Array.isArray(t.assetIssue)) return t.assetIssue.map(t => this._u(t));
          if (!t.name) throw Error("Token does not exist");
          return this._u(t)
        })
      }
      getTokenByID(t) {
        if (YV.isInteger(t) && (t = t.toString()), !YV.isString(t) || !t.length) throw Error("Invalid token ID provided");
        return this.tronWeb.fullNode.request("wallet/getassetissuebyid", {
          value: t
        }, "post").then(t => {
          if (!t.name) throw Error("Token does not exist");
          return this._u(t)
        })
      }
      async getReward(t, e = {}) {
        return e.confirmed = !0, this.Uu(t, e)
      }
      async getUnconfirmedReward(t, e = {}) {
        return e.confirmed = !1, this.Uu(t, e)
      }
      async getBrokerage(t, e = {}) {
        return e.confirmed = !0, this.Lu(t, e)
      }
      async getUnconfirmedBrokerage(t, e = {}) {
        return e.confirmed = !1, this.Lu(t, e)
      }
      async Uu(t = this.tronWeb.defaultAddress.hex, e) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }]);
        const r = {
          address: ZK(t)
        };
        return this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(`wallet${e.confirmed?"solidity":""}/getReward`, r, "post").then((t = {
          reward: void 0
        }) => {
          if (typeof t.reward > "u") throw Error("Not found.");
          return t.reward
        })
      }
      async Lu(t = this.tronWeb.defaultAddress.hex, e) {
        this.validator.notValid([{
          name: "origin",
          type: "address",
          value: t
        }]);
        const r = {
          address: ZK(t)
        };
        return this.tronWeb[e.confirmed ? "solidityNode" : "fullNode"].request(`wallet${e.confirmed?"solidity":""}/getBrokerage`, r, "post").then((t = {}) => {
          if (typeof t.brokerage > "u") throw Error("Not found.");
          return t.brokerage
        })
      }
      async getBandwidthPrices() {
        return this.tronWeb.fullNode.request("wallet/getbandwidthprices", {}, "post").then((t = {}) => {
          if (typeof t.prices > "u") throw Error("Not found.");
          return t.prices
        })
      }
      async getEnergyPrices() {
        return this.tronWeb.fullNode.request("wallet/getenergyprices", {}, "post").then((t = {}) => {
          if (typeof t.prices > "u") throw Error("Not found.");
          return t.prices
        })
      }
    }
    const JK = (t, e) => RG(t, e);
    class YK {
      tronWeb;
      contract;
      abi;
      name;
      inputs;
      outputs;
      functionSelector;
      signature;
      defaultOptions;
      constructor(t, e) {
        this.tronWeb = t.tronWeb, this.contract = t, this.abi = e, this.name = e.name || e.type, this.inputs = e.inputs || [], this.outputs = [], "outputs" in e && e.outputs && (this.outputs = e.outputs), this.functionSelector = (t => {
          if ("stateMutability" in t && (t.stateMutability = t.stateMutability ? t.stateMutability.toLowerCase() : "nonpayable"), t.type = t.type ? t.type.toLowerCase() : "", "fallback" === t.type || "receive" === t.type) return "0x";
          const e = new YV.ethersUtils.Interface([t]);
          let r;
          if (r = "event" === t.type ? e.getEvent(t.name) : e.getFunction(t.name), r) return r.format("sighash");
          throw Error("unknown function")
        })(e), this.signature = $V(this.functionSelector, !1).slice(0, 8), this.defaultOptions = {
          feeLimit: this.tronWeb.feeLimit,
          callValue: 0,
          userFeePercentage: 100,
          shouldPollResponse: !1
        }
      }
      decodeInput(t) {
        const e = JSON.parse(JSON.stringify(this.abi));
        return e.outputs = e.inputs, JK(e, "0x" + t)
      }
      onMethod(...t) {
        let e = "";
        return this.abi && !/event/i.test(this.abi.type) && (e = CG(this.abi, t)), {
          call: async (t = {}) => (t = {
            ...t,
            rawParameter: e
          }, await this.Fu([], [], t)),
          send: async (t = {}, r = this.tronWeb.defaultPrivateKey) => (t = {
            ...t,
            rawParameter: e
          }, await this.ii([], [], t, r))
        }
      }
      async Fu(t, e, r = {}) {
        if (t.length !== e.length) throw Error("Invalid argument count provided");
        if (!this.contract.address) throw Error("Smart contract is missing address");
        if (!this.contract.deployed) throw Error("Calling smart contracts requires you to load the contract first");
        if ("stateMutability" in this.abi) {
          const {
            stateMutability: t
          } = this.abi;
          if (t && !["pure", "view"].includes(t.toLowerCase())) throw Error(`Methods with state mutability "${t}" must use send()`)
        }
        r = {
          ...this.defaultOptions,
          from: this.tronWeb.defaultAddress.hex,
          ...r,
          Nu: !0
        };
        const n = e.map((e, r) => ({
            type: t[r],
            value: e
          })),
          i = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, r, n, r.from ? this.tronWeb.address.toHex(r.from) : void 0);
        if (!YV.hasProperty(i, "constant_result")) throw Error("Failed to execute");
        const o = i.constant_result[0].length;
        if (0 === o || o % 64 == 8) {
          let t = "The call has been reverted or has thrown an error.";
          if (0 !== o) {
            t += " Error message: ";
            let e = "";
            const r = i.constant_result[0].substring(8);
            for (let t = 0; o - 8 > t; t += 64) e += this.tronWeb.toUtf8(r.substring(t, t + 64));
            t += e.replace(/(\u0000|\u000b|\f)+/g, " ").replace(/ +/g, " ").replace(/\s+$/g, "")
          }
          throw Error(t)
        }
        let s = JK(this.abi, "0x" + i.constant_result[0]);
        return 1 === s.length && 1 === Object.keys(s).length && (s = s[0]), s
      }
      async ii(t, e, r = {}, n = this.tronWeb.defaultPrivateKey) {
        if (t.length !== e.length) throw Error("Invalid argument count provided");
        if (!this.contract.address) throw Error("Smart contract is missing address");
        if (!this.contract.deployed) throw Error("Calling smart contracts requires you to load the contract first");
        const {
          stateMutability: i
        } = this.abi;
        if (["pure", "view"].includes(i.toLowerCase())) throw Error(`Methods with state mutability "${i}" must use call()`);
        ["payable"].includes(i.toLowerCase()) || (r.callValue = 0), r = {
          ...this.defaultOptions,
          from: this.tronWeb.defaultAddress.hex,
          ...r
        };
        const o = e.map((e, r) => ({
            type: t[r],
            value: e
          })),
          s = n ? this.tronWeb.address.fromPrivateKey(n) : this.tronWeb.defaultAddress.base58,
          a = await this.tronWeb.transactionBuilder.triggerSmartContract(this.contract.address, this.functionSelector, r, o, this.tronWeb.address.toHex(s));
        if (!a.result || !a.result.result) throw Error("Unknown error: " + JSON.stringify(a, null, 2));
        const u = await this.tronWeb.trx.sign(a.transaction, n);
        if (!u.signature) throw Error(n ? "Invalid private key provided" : "Transaction was not signed properly");
        const c = await this.tronWeb.trx.sendRawTransaction(u);
        if (c.code) {
          const t = {
            error: c.code,
            message: c.code
          };
          c.message && (t.message = this.tronWeb.toUtf8(c.message));
          const e = Error(t.message);
          throw e.error = c.code, e
        }
        if (!r.shouldPollResponse) return u.txID;
        const f = async t => {
          if (t === (r.pollTimes || 20)) {
            const t = Error("Cannot find result in solidity node");
            throw t.error = "Cannot find result in solidity node", t.transaction = u, t
          }
          const e = await this.tronWeb.trx.getTransactionInfo(u.txID);
          if (!Object.keys(e).length) return await new Promise(t => setTimeout(t, 3e3)), f(t + 1);
          if (e.result && "FAILED" === e.result) {
            const t = Error(this.tronWeb.toUtf8(e.resMessage));
            throw t.error = this.tronWeb.toUtf8(e.resMessage), t.transaction = u, t.output = e, t
          }
          if (!YV.hasProperty(e, "contractResult")) {
            const t = Error("Failed to execute: " + JSON.stringify(e, null, 2));
            throw t.error = "Failed to execute: " + JSON.stringify(e, null, 2), t.transaction = u, t.output = e, t
          }
          if (r.rawResponse) return e;
          let n = JK(this.abi, "0x" + e.contractResult[0]);
          return 1 === n.length && 1 === Object.keys(n).length && (n = n[0]), r.keepTxID ? [u.txID, n] : n
        };
        return f(0)
      }
    }
    class QK {
      tronWeb;
      abi;
      address;
      eventListener;
      bytecode;
      deployed;
      lastBlock;
      methods;
      methodInstances;
      props;
      constructor(t, e = [], r) {
        if (!(t && t instanceof iV)) throw Error("Expected instance of TronWeb");
        this.tronWeb = t, this.address = r, this.abi = e, this.eventListener = !1, this.bytecode = !1, this.deployed = !1, this.lastBlock = !1, this.methods = {}, this.methodInstances = {}, this.props = [], YV.address.isAddress(r) ? this.deployed = !0 : this.address = !1, this.loadAbi(e)
      }
      hasProperty(t) {
        return this.hasOwnProperty(t) || this.__proto__.hasOwnProperty(t)
      }
      loadAbi(t) {
        this.abi = t, this.methods = {}, this.props.forEach(t => delete this[t]), t.forEach(t => {
          if (!t.type || /constructor|error/i.test(t.type)) return;
          const e = new YK(this, t),
            r = e.onMethod.bind(e),
            {
              name: n,
              functionSelector: i,
              signature: o
            } = e;
          this.methods[n] = r, this.methods[i] = r, this.methods[o] = r, this.methodInstances[n] = e, this.methodInstances[i] = e, this.methodInstances[o] = e, this.hasProperty(n) || (this[n] = r, this.props.push(n)), this.hasProperty(i) || (this[i] = r, this.props.push(i)), this.hasProperty(o) || (this[o] = r, this.props.push(o))
        })
      }
      decodeInput(t) {
        const e = t.substring(0, 8),
          r = t.substring(8);
        if (!this.methodInstances[e]) throw Error("Contract method " + e + " not found");
        return {
          name: this.methodInstances[e].name,
          params: this.methodInstances[e].decodeInput(r)
        }
      }
      async new(t, e = this.tronWeb.defaultPrivateKey) {
        const r = this.tronWeb.address.fromPrivateKey(e),
          n = await this.tronWeb.transactionBuilder.createSmartContract(t, r),
          i = await this.tronWeb.trx.sign(n, e),
          o = await this.tronWeb.trx.sendRawTransaction(i);
        if (o.code) throw {
          error: o.code,
          message: this.tronWeb.toUtf8(o.message)
        };
        return await YV.sleep(3e3), this.at(i.contract_address)
      }
      async at(t) {
        try {
          const e = await this.tronWeb.trx.getContract(t);
          if (!e.contract_address) throw Error("Unknown error: " + JSON.stringify(e, null, 2));
          return this.address = e.contract_address, this.bytecode = e.bytecode, this.deployed = !0, this.loadAbi(e.abi && e.abi.entrys ? e.abi.entrys : []), this
        } catch (t) {
          throw t.toString().includes("does not exist") ? Error("Contract has not been deployed on the network") : Error(t)
        }
      }
    }
    class XK {
      tronWeb;
      pluginNoOverride;
      disablePlugins;
      constructor(t, e = {}) {
        if (!(t && t instanceof iV)) throw Error("Expected instance of TronWeb");
        this.tronWeb = t, this.pluginNoOverride = ["register"], this.disablePlugins = !!e.disablePlugins
      }
      register(t, e) {
        let r = {
          requires: "0.0.0",
          components: {}
        };
        const n = {
          libs: [],
          plugged: [],
          skipped: [],
          error: void 0
        };
        if (this.disablePlugins) return n.error = "This instance of TronWeb has plugins disabled.", n;
        const i = new t(this.tronWeb);
        if (YV.isFunction(i.pluginInterface) && (r = i.pluginInterface(e)), !xG.satisfies(iV.version, r.requires)) throw Error("The plugin is not compatible with this version of TronWeb");
        if (r.fullClass) {
          const e = i.constructor.name,
            r = e.substring(0, 1).toLowerCase() + e.substring(1);
          e !== r && (Object.assign(iV, {
            [e]: t
          }), Object.assign(this.tronWeb, {
            [r]: i
          }), n.libs.push(e))
        } else
          for (const t in r.components) {
            if (!this.tronWeb.hasOwnProperty(t)) continue;
            const e = r.components[t],
              i = this.tronWeb[t].pluginNoOverride || [];
            for (const r in e) "constructor" === r || this.tronWeb[t][r] && (i.includes(r) || /^_/.test(r)) ? n.skipped.push(r) : (this.tronWeb[t][r] = e[r].bind(this.tronWeb[t]), n.plugged.push(r))
          }
        return n
      }
    }
    class tV {
      tronWeb;
      constructor(t) {
        if (!(t && t instanceof iV)) throw Error("Expected instance of TronWeb");
        this.tronWeb = t
      }
      setServer(t, e = "healthcheck") {
        if (!t) return this.tronWeb.eventServer = void 0;
        if (YV.isString(t) && (t = new EG(t)), !this.tronWeb.isValidProvider(t)) throw Error("Invalid event server provided");
        this.tronWeb.eventServer = t, this.tronWeb.eventServer.isConnected = () => this.tronWeb.eventServer.request(e).then(() => !0).catch(() => !1)
      }
      async getEventsByContractAddress(t, e = {}) {
        const r = Object.assign({
            limit: 20
          }, e),
          {
            eventName: n,
            blockNumber: i,
            onlyUnconfirmed: o,
            onlyConfirmed: s,
            minBlockTimestamp: a,
            maxBlockTimestamp: u,
            orderBy: c,
            fingerprint: f
          } = r;
        let {
          limit: l
        } = r;
        if (!this.tronWeb.eventServer) throw Error("No event server configured");
        if (!this.tronWeb.isAddress(t)) throw Error("Invalid contract address provided");
        if ("u" > typeof a && !YV.isInteger(a)) throw Error("Invalid minBlockTimestamp provided");
        if ("u" > typeof u && !YV.isInteger(u)) throw Error("Invalid maxBlockTimestamp provided");
        YV.isInteger(l) && l > 200 && (console.warn("Defaulting to maximum accepted limit: 200"), l = 200);
        const h = {};
        n && (h.event_name = n), i && (h.block_number = i), "boolean" == typeof o && (h.only_unconfirmed = o), "boolean" == typeof s && (h.only_confirmed = s), a && (h.min_block_timestamp = a), u && (h.max_block_timestamp = u), c && (h.order_by = c), f && (h.fingerprint = f), YV.isInteger(l) && (h.limit = l);
        const d = await this.tronWeb.eventServer.request(`v1/contracts/${this.tronWeb.address.fromHex(t)}/events?${new URLSearchParams(h).toString()}`);
        if (d.success) return d;
        throw Error(d.error)
      }
      async getEventsByTransactionID(t, e = {}) {
        if (!this.tronWeb.eventServer) throw Error("No event server configured");
        const r = {};
        return "boolean" == typeof e.only_unconfirmed && (r.only_unconfirmed = e.only_unconfirmed), "boolean" == typeof e.only_confirmed && (r.only_confirmed = e.only_confirmed), this.tronWeb.eventServer.request(`v1/transactions/${t}/events?${new URLSearchParams(r).toString()}`).then(t => {
          if (t.success) return t;
          throw Error(JSON.parse(t.error).message)
        })
      }
      async getEventsByBlockNumber(t, e = {}) {
        if (!this.tronWeb.eventServer) throw Error("No event server configured");
        const r = {};
        return "boolean" == typeof e.only_confirmed && (r.only_confirmed = e.only_confirmed), e.limit && (r.limit = e.limit), e.fingerprint && (r.fingerprint = e.fingerprint), this.tronWeb.eventServer.request(`v1/blocks/${t}/events?${new URLSearchParams(r).toString()}`).then(t => {
          if (t.success) return t;
          throw Error(t.error)
        })
      }
      async getEventsOfLatestBlock(t = {}) {
        if (!this.tronWeb.eventServer) throw Error("No event server configured");
        const e = {};
        return "boolean" == typeof t.only_confirmed && (e.only_confirmed = t.only_confirmed), this.tronWeb.eventServer.request("v1/blocks/latest/events?" + new URLSearchParams(e).toString()).then(t => {
          if (t.success) return t;
          throw Error(t.error)
        })
      }
    }
    var eV = i(48287).Buffer;
    const rV = "4.7.1";

    function nV(t) {
      return !(!t || "object" != typeof t || !t.fullNode && !t.fullHost)
    }
    class iV extends kG {
      providers;
      BigNumber;
      transactionBuilder;
      trx;
      plugin;
      event;
      version;
      static version = "6.0.1";
      utils;
      defaultBlock;
      defaultPrivateKey;
      defaultAddress;
      fullnodeVersion;
      feeLimit;
      fullNode;
      solidityNode;
      eventServer;
      constructor(t, e = "", r, n = "") {
        super();
        let i, o = !1,
          s = !1;
        nV(t) ? (i = t.fullNode || t.fullHost, e = t.solidityNode || t.fullHost, r = t.eventServer || t.fullHost, o = t.headers || !1, s = t.eventHeaders || o, n = t.privateKey) : i = t, YV.isString(i) && (i = new PG.HttpProvider(i)), YV.isString(e) && (e = new PG.HttpProvider(e)), YV.isString(r) && (r = new PG.HttpProvider(r)), this.event = new tV(this), this.transactionBuilder = new GK(this), this.trx = new qK(this), this.plugin = new XK(this, {
          disablePlugins: !!nV(t) && t.disablePlugins
        }), this.utils = YV, this.setFullNode(i), this.setSolidityNode(e), this.setEventServer(r), this.providers = PG, this.BigNumber = ZC, this.defaultBlock = !1, this.defaultPrivateKey = !1, this.defaultAddress = {
          hex: !1,
          base58: !1
        }, this.version = iV.version, this.sha3 = iV.sha3, this.fromUtf8 = iV.fromUtf8, this.address = iV.address, this.toAscii = iV.toAscii, this.toUtf8 = iV.toUtf8, this.isAddress = iV.isAddress, this.fromAscii = iV.fromAscii, this.toHex = iV.toHex, this.toBigNumber = iV.toBigNumber, this.toDecimal = iV.toDecimal, this.fromDecimal = iV.fromDecimal, this.toSun = iV.toSun, this.fromSun = iV.fromSun, this.createAccount = iV.createAccount, this.createRandom = iV.createRandom, this.fromMnemonic = iV.fromMnemonic, n && this.setPrivateKey(n), this.fullnodeVersion = rV, this.feeLimit = 15e7, o && this.setFullNodeHeader(o), s && this.setEventHeader(s)
      }
      async getFullnodeVersion() {
        try {
          const t = await this.trx.getNodeInfo();
          this.fullnodeVersion = t.configNodeInfo.codeVersion, 2 === this.fullnodeVersion.split(".").length && (this.fullnodeVersion += ".0")
        } catch {
          this.fullnodeVersion = rV
        }
      }
      setDefaultBlock(t = !1) {
        if ([!1, "latest", "earliest", 0].includes(t)) return this.defaultBlock = t;
        if (!YV.isInteger(t) || !t) throw Error("Invalid block ID provided");
        return this.defaultBlock = Math.abs(t)
      }
      setPrivateKey(t) {
        try {
          this.setAddress(iV.address.fromPrivateKey(t))
        } catch {
          throw Error("Invalid private key provided")
        }
        this.defaultPrivateKey = t, this.emit("privateKeyChanged", t)
      }
      setAddress(t) {
        if (!iV.isAddress(t)) throw Error("Invalid address provided");
        const e = iV.address.toHex(t),
          r = iV.address.fromHex(t);
        this.defaultPrivateKey && iV.address.fromPrivateKey(this.defaultPrivateKey) !== r && (this.defaultPrivateKey = !1), this.defaultAddress = {
          hex: e,
          base58: r
        }, this.emit("addressChanged", {
          hex: e,
          base58: r
        })
      }
      fullnodeSatisfies(t) {
        return xG.satisfies(this.fullnodeVersion, t)
      }
      isValidProvider(t) {
        return Object.values(PG).some(e => t instanceof e)
      }
      setFullNode(t) {
        if (rR(t) && (t = new PG.HttpProvider(t)), !this.isValidProvider(t)) throw Error("Invalid full node provided");
        this.fullNode = t, this.fullNode.setStatusPage("wallet/getnowblock")
      }
      setSolidityNode(t) {
        if (YV.isString(t) && (t = new PG.HttpProvider(t)), !this.isValidProvider(t)) throw Error("Invalid solidity node provided");
        this.solidityNode = t, this.solidityNode.setStatusPage("walletsolidity/getnowblock")
      }
      setEventServer(t, e) {
        this.event.setServer(t, e)
      }
      setHeader(t = {}) {
        const e = new PG.HttpProvider(this.fullNode.host, 3e4, "", "", t),
          r = new PG.HttpProvider(this.solidityNode.host, 3e4, "", "", t),
          n = new PG.HttpProvider(this.eventServer.host, 3e4, "", "", t);
        this.setFullNode(e), this.setSolidityNode(r), this.setEventServer(n)
      }
      setFullNodeHeader(t = {}) {
        const e = new PG.HttpProvider(this.fullNode.host, 3e4, "", "", t),
          r = new PG.HttpProvider(this.solidityNode.host, 3e4, "", "", t);
        this.setFullNode(e), this.setSolidityNode(r)
      }
      setEventHeader(t = {}) {
        const e = new PG.HttpProvider(this.eventServer.host, 3e4, "", "", t);
        this.setEventServer(e)
      }
      currentProviders() {
        return {
          fullNode: this.fullNode,
          solidityNode: this.solidityNode,
          eventServer: this.eventServer
        }
      }
      currentProvider() {
        return this.currentProviders()
      }
      getEventResult(...t) {
        return this.event.getEventsByContractAddress(...t)
      }
      getEventByTransactionID(...t) {
        return this.event.getEventsByTransactionID(...t)
      }
      contract(t = [], e) {
        return new QK(this, t, e)
      }
      address;
      static get address() {
        return {
          fromHex: t => rz(t),
          toHex: t => nz(t),
          toChecksumAddress: t => iz(t),
          isChecksumAddress: t => oz(t),
          fromPrivateKey: (t, e = !1) => sz(t, e)
        }
      }
      sha3;
      static sha3(t, e = !0) {
        return (e ? "0x" : "") + Cj(eV.from(t, "utf-8")).toString().substring(2)
      }
      toHex;
      static toHex(t) {
        if (YV.isBoolean(t)) return iV.fromDecimal(+t);
        if (YV.isBigNumber(t)) return iV.fromDecimal(t);
        if ("object" == typeof t) return iV.fromUtf8(JSON.stringify(t));
        if (YV.isString(t)) {
          if (/^(-|)0x/.test(t)) return t;
          if (!isFinite(t) || /^\s*$/.test(t)) return iV.fromUtf8(t)
        }
        const e = iV.fromDecimal(t);
        if ("0xNaN" === e) throw Error("The passed value is not convertible to a hex string");
        return e
      }
      toUtf8;
      static toUtf8(t) {
        if (YV.isHex(t)) return t = t.replace(/^0x/, ""), eV.from(t, "hex").toString("utf8");
        throw Error("The passed value is not a valid hex string")
      }
      fromUtf8;
      static fromUtf8(t) {
        if (!YV.isString(t)) throw Error("The passed value is not a valid utf-8 string");
        return "0x" + eV.from(t, "utf8").toString("hex")
      }
      toAscii;
      static toAscii(t) {
        if (YV.isHex(t)) {
          let e = "",
            r = 0;
          const n = t.length;
          for ("0x" === t.substring(0, 2) && (r = 2); n > r; r += 2) {
            const n = parseInt(t.substr(r, 2), 16);
            e += String.fromCharCode(n)
          }
          return e
        }
        throw Error("The passed value is not a valid hex string")
      }
      fromAscii;
      static fromAscii(t, e) {
        if (!YV.isString(t)) throw Error("The passed value is not a valid utf-8 string");
        return "0x" + eV.from(t, "ascii").toString("hex").padEnd(e, "0")
      }
      toDecimal;
      static toDecimal(t) {
        return iV.toBigNumber(t).toNumber()
      }
      fromDecimal;
      static fromDecimal(t) {
        const e = iV.toBigNumber(t),
          r = e.toString(16);
        return e.isLessThan(0) ? "-0x" + r.substr(1) : "0x" + r
      }
      fromSun;
      static fromSun(t) {
        const e = iV.toBigNumber(t).div(1e6);
        return YV.isBigNumber(t) ? e : e.toString(10)
      }
      toSun;
      static toSun(t) {
        const e = iV.toBigNumber(t).times(1e6);
        return YV.isBigNumber(t) ? e : e.toString(10)
      }
      toBigNumber;
      static toBigNumber(t = 0) {
        return YV.isBigNumber(t) ? t : YV.isString(t) && /^(-|)0x/.test(t) ? new ZC(t.replace("0x", ""), 16) : new ZC(t.toString(10), 10)
      }
      isAddress;
      static isAddress(t = "") {
        return az(t)
      }
      createAccount;
      static async createAccount() {
        return YV.accounts.generateAccount()
      }
      createRandom;
      static createRandom(...t) {
        return YV.accounts.generateRandom(...t)
      }
      fromMnemonic;
      static fromMnemonic(...t) {
        return YV.accounts.generateAccountWithMnemonic(...t)
      }
      async isConnected() {
        return {
          fullNode: await this.fullNode.isConnected(),
          solidityNode: await this.solidityNode.isConnected(),
          eventServer: this.eventServer && await this.eventServer.isConnected()
        }
      }
    }
    const oV = iV,
      sV = new Uint8Array(32);
    sV.fill(0);
    const aV = BigInt(-1),
      uV = BigInt(0),
      cV = BigInt(1),
      fV = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),
      lV = ZR(cV, 32),
      hV = ZR(uV, 32),
      dV = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      },
      pV = ["name", "version", "chainId", "verifyingContract", "salt"];

    function bV(t) {
      return function(e) {
        return TR("string" == typeof e, "invalid domain value for " + JSON.stringify(t), "domain." + t, e), e
      }
    }
    const mV = {
      name: bV("name"),
      version: bV("version"),
      chainId: function(t) {
        const e = zR(t, "domain.chainId");
        return TR(e >= 0, "invalid chain ID", "domain.chainId", t), Number.isSafeInteger(e) ? +e : JR(e)
      },
      verifyingContract: function(t) {
        try {
          return function(t) {
            return iV.address.toHex(t)
          }(t).toLowerCase()
        } catch {}
        TR(!1, 'invalid domain value "verifyingContract"', "domain.verifyingContract", t)
      },
      salt: function(t) {
        const e = SR(t, "domain.salt");
        return TR(32 === e.length, 'invalid domain value "salt"', "domain.salt", t), CR(e)
      }
    };

    function yV(t) {
      {
        const e = t.match(/^(u?)int(\d*)$/);
        if (e) {
          const r = "" === e[1],
            n = parseInt(e[2] || "256");
          TR(n % 8 == 0 && 0 !== n && 256 >= n && (null == e[2] || e[2] === n + ""), "invalid numeric width", "type", t);
          const i = $R(fV, r ? n - 1 : n),
            o = r ? (i + cV) * aV : uV;
          return function(e) {
            const n = zR(e, "value");
            return TR(n >= o && i >= n, "value out-of-bounds for " + t, "value", n), ZR(r ? FR(n, 256) : n, 32)
          }
        }
      } {
        const e = t.match(/^bytes(\d+)$/);
        if (e) {
          const r = parseInt(e[1]);
          return TR(0 !== r && 32 >= r && e[1] === r + "", "invalid bytes width", "type", t),
            function(e) {
              return TR(SR(e).length === r, "invalid length for " + t, "value", e),
                function(t) {
                  const e = SR(t),
                    r = e.length % 32;
                  return r ? RR([e, sV.slice(r)]) : CR(e)
                }(e)
            }
        }
      }
      switch (t) {
        case "trcToken":
          return yV("uint256");
        case "address":
          return function(t) {
            return _R(function(t) {
              return iV.address.toHex(t).replace(X$, "0x")
            }(t), 32)
          };
        case "bool":
          return function(t) {
            return t ? lV : hV
          };
        case "bytes":
          return function(t) {
            return Cj(t)
          };
        case "string":
          return function(t) {
            return Rj(t)
          }
      }
      return null
    }

    function gV(t, e) {
      return `${t}(${e.map(({name:t,type:e})=>e+" "+t).join(",")})`
    }
    class vV {
      primaryType;
      #t;
      get types() {
        return JSON.parse(this.#t)
      }
      #e;
      #r;
      constructor(t) {
        this.#t = JSON.stringify(t), this.#e = new Map, this.#r = new Map;
        const e = new Map,
          r = new Map,
          n = new Map;
        Object.keys(t).forEach(t => {
          e.set(t, new Set), r.set(t, []), n.set(t, new Set)
        });
        for (const n in t) {
          const i = new Set;
          for (const o of t[n]) {
            TR(!i.has(o.name), `duplicate variable name ${JSON.stringify(o.name)} in ${JSON.stringify(n)}`, "types", t), i.add(o.name);
            const s = o.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
            TR(s !== n, "circular type reference to " + JSON.stringify(s), "types", t), !yV(s) && (TR(r.has(s), "unknown type " + JSON.stringify(s), "types", t), r.get(s).push(n), e.get(n).add(s))
          }
        }
        const i = Array.from(r.keys()).filter(t => 0 === r.get(t).length);
        TR(0 !== i.length, "missing primary type", "types", t), TR(1 === i.length, "ambiguous primary types or unused types: " + i.map(t => JSON.stringify(t)).join(", "), "types", t), yR(this, {
            primaryType: i[0]
          }),
          function i(o, s) {
            TR(!s.has(o), "circular type reference to " + JSON.stringify(o), "types", t), s.add(o);
            for (const t of e.get(o))
              if (r.has(t)) {
                i(t, s);
                for (const e of s) n.get(e).add(t)
              } s.delete(o)
          }(this.primaryType, new Set);
        for (const [e, r] of n) {
          const n = Array.from(r);
          n.sort(), this.#e.set(e, gV(e, t[e]) + n.map(e => gV(e, t[e])).join(""))
        }
      }
      getEncoder(t) {
        let e = this.#r.get(t);
        return e || (e = this.#n(t), this.#r.set(t, e)), e
      }
      #n(t) {
        {
          const e = yV(t);
          if (e) return e
        }
        const e = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (e) {
          const t = e[1],
            r = this.getEncoder(t);
          return n => {
            TR(!e[3] || parseInt(e[3]) === n.length, "array length mismatch; expected length " + parseInt(e[3]), "value", n);
            let i = n.map(r);
            return this.#e.has(t) && (i = i.map(Cj)), Cj(RR(i))
          }
        }
        const r = this.types[t];
        if (r) {
          const e = Rj(this.#e.get(t));
          return t => {
            const n = r.map(({
              name: e,
              type: r
            }) => {
              const n = this.getEncoder(r)(t[e]);
              return this.#e.has(r) ? Cj(n) : n
            });
            return n.unshift(e), RR(n)
          }
        }
        TR(!1, "unknown type: " + t, "type", t)
      }
      encodeType(t) {
        const e = this.#e.get(t);
        return TR(e, "unknown type: " + JSON.stringify(t), "name", t), e
      }
      encodeData(t, e) {
        return this.getEncoder(t)(e)
      }
      hashStruct(t, e) {
        return Cj(this.encodeData(t, e))
      }
      encode(t) {
        return this.encodeData(this.primaryType, t)
      }
      hash(t) {
        return this.hashStruct(this.primaryType, t)
      }
      Ou(t, e, r) {
        if (yV(t)) return r(t, e);
        const n = t.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (n) return TR(!n[3] || parseInt(n[3]) === e.length, "array length mismatch; expected length " + parseInt(n[3]), "value", e), e.map(t => this.Ou(n[1], t, r));
        const i = this.types[t];
        if (i) return i.reduce((t, {
          name: n,
          type: i
        }) => (t[n] = this.Ou(i, e[n], r), t), {});
        TR(!1, "unknown type: " + t, "type", t)
      }
      visit(t, e) {
        return this.Ou(this.primaryType, t, e)
      }
      static from(t) {
        return new vV(t)
      }
      static getPrimaryType(t) {
        return vV.from(t).primaryType
      }
      static hashStruct(t, e, r) {
        return vV.from(e).hashStruct(t, r)
      }
      static hashDomain(t) {
        const e = [];
        for (const r in t) {
          if (null == t[r]) continue;
          const n = dV[r];
          TR(n, "invalid typed-data domain key: " + JSON.stringify(r), "domain", t), e.push({
            name: r,
            type: n
          })
        }
        return e.sort((t, e) => pV.indexOf(t.name) - pV.indexOf(e.name)), vV.hashStruct("EIP712Domain", {
          EIP712Domain: e
        }, t)
      }
      static encode(t, e, r) {
        return RR(["0x1901", vV.hashDomain(t), vV.from(e).hash(r)])
      }
      static hash(t, e, r) {
        return Cj(vV.encode(t, e, r))
      }
      static async resolveNames(t, e, r, n) {
        t = Object.assign({}, t);
        for (const e in t) null == t[e] && delete t[e];
        const i = {};
        t.verifyingContract && !BR(t.verifyingContract, 20) && (i[t.verifyingContract] = "0x");
        const o = vV.from(e);
        o.visit(r, (t, e) => ("address" === t && !BR(e, 20) && (i[e] = "0x"), e));
        for (const t in i) i[t] = await n(t);
        return t.verifyingContract && i[t.verifyingContract] && (t.verifyingContract = i[t.verifyingContract]), {
          domain: t,
          value: r = o.visit(r, (t, e) => "address" === t && i[e] ? i[e] : e)
        }
      }
      static getPayload(t, e, r) {
        vV.hashDomain(t);
        const n = {},
          i = [];
        pV.forEach(e => {
          const r = t[e];
          null != r && (n[e] = mV[e](r), i.push({
            name: e,
            type: dV[e]
          }))
        });
        const o = vV.from(e),
          s = Object.assign({}, e);
        return TR(null == s.EIP712Domain, "types must not contain EIP712Domain type", "types.EIP712Domain", e), s.EIP712Domain = i, o.encode(r), {
          types: s,
          domain: n,
          primaryType: o.primaryType,
          message: o.visit(r, (t, e) => {
            if (t.match(/^bytes(\d*)/)) return CR(SR(e));
            if (t.match(/^u?int/)) return zR(e).toString();
            switch (t) {
              case "trcToken":
                return zR(e).toString();
              case "address":
                return e.toLowerCase();
              case "bool":
                return !!e;
              case "string":
                return TR("string" == typeof e, "invalid string", "value", e), e
            }
            TR(!1, "unsupported type", "type", t)
          })
        }
      }
    }
    var wV = i(48287).Buffer;

    function AV(t) {
      const e = UV(t);
      let r = UV(e).slice(0, 4);
      return r = t.concat(r), lz(r)
    }

    function TV(t) {
      if ("string" != typeof t || 4 >= t.length) return !1;
      let e = hz(t);
      if (4 >= t.length) return !1;
      const r = e.length - 4,
        n = e.slice(r);
      e = e.slice(0, r);
      const i = UV(e),
        o = UV(i).slice(0, 4);
      if (n[0] == o[0] && n[1] == o[1] && n[2] == o[2] && n[3] == o[3]) return e;
      throw Error("Invalid address provided")
    }

    function EV(t, e) {
      "string" == typeof t && (t = xC(t));
      const r = DV(xC(e.txID), t);
      return Array.isArray(e.signature) ? e.signature.includes(r) || e.signature.push(r) : e.signature = [r], e
    }

    function PV(t, e) {
      t = "0x" + t.replace(/^0x/, ""), e = "0x" + e.replace(/^0x/, "");
      const r = nD(V$(t), oN.from(e));
      return Y$ + r.substring(2)
    }

    function kV(t) {
      return btoa(String.fromCharCode(...t))
    }

    function xV(t, e) {
      return "string" == typeof t && (t = xC(t)), DV(UV(e), t)
    }

    function IV(t, e, r, n) {
      const i = "0x" + n.replace(/^0x/, ""),
        o = new eD(i),
        s = vV.hash(t, e, r),
        a = o.sign(s);
      return "0x" + a.r.substring(2) + a.s.substring(2) + (+a.v).toString(16)
    }

    function SV(t) {
      const e = vC(t);
      return globalThis.proto.protocol.Transaction.deserializeBinary(e).getRawData().serializeBinary()
    }

    function OV() {
      let t = gC(Nk.utils.randomPrivateKey());
      return t = t.padStart(64, "0"), xC(t)
    }

    function BV(t) {
      65 === t.length && (t = t.slice(1));
      const e = Cj(new Uint8Array(t)).toString().substring(2);
      return xC(Y$ + e.substring(24))
    }

    function WV(t) {
      return BV(_V(t))
    }

    function MV(t) {
      const e = hz(t);
      if (4 >= e.length) return !1;
      const r = e.slice(0, e.length - 4),
        n = UV(r),
        i = UV(n);
      return i[0] === e[r.length] && i[1] === e[r.length + 1] && i[2] === e[r.length + 2] && i[3] === e[r.length + 3] && r
    }

    function CV(t) {
      if ("string" != typeof t || t.length !== J$) return !1;
      let e = hz(t);
      if (25 !== e.length || e[0] !== Q$) return !1;
      const r = e.slice(21);
      e = e.slice(0, 21);
      const n = UV(e),
        i = UV(n).slice(0, 4);
      return r[0] == i[0] && r[1] == i[1] && r[2] == i[2] && r[3] == i[3]
    }

    function RV(t) {
      return AV(BV(_V(vC(t))))
    }

    function NV(t) {
      return gC(BV(_V(vC(t))))
    }

    function jV(t) {
      return wC(BV(_V(vC(t))))
    }

    function _V(t) {
      const e = Nk.ProjectivePoint.fromPrivateKey(new Uint8Array(function(t) {
          return xC(gC(t).padStart(64, "0"))
        }(t))),
        r = e.x,
        n = e.y;
      return xC(`04${r.toString(16).padStart(64,"0")}${n.toString(16).padStart(64,"0")}`)
    }

    function DV(t, e) {
      const r = Nk.sign(gC(t), gC(e)),
        n = r.r.toString(16),
        i = r.s.toString(16),
        o = r.recovery + 27;
      return n.padStart(64, "0") + i.padStart(64, "0") + bC(o)
    }

    function UV(t) {
      return xC(oj("0x" + gC(t)).replace(/^0x/, ""))
    }

    function LV(t) {
      return AV(WV(vC(t)))
    }

    function FV(t, e = !1) {
      return AV(WV(xC(t, e)))
    }

    function $V(t, e = !0) {
      return (e ? "0x" : "") + Cj(wV.from(t, "utf-8")).toString().substring(2)
    }
    const zV = "Invalid tron path provided";

    function HV() {
      const t = OV(),
        e = _V(t),
        r = WV(t);
      return {
        privateKey: gC(t),
        publicKey: gC(e),
        address: {
          base58: AV(r),
          hex: gC(r)
        }
      }
    }

    function GV(t = "", e = ez, r) {
      const n = zF.createRandom(t, e, r);
      return {
        mnemonic: n.mnemonic,
        privateKey: n.privateKey,
        publicKey: n.signingKey.publicKey,
        address: FV(n.privateKey.replace(/^0x/, "")),
        path: n.path
      }
    }

    function KV(t, e = ez, r = "", n = null) {
      if (!(e + "").match(/^m\/44\'\/195\'/)) throw Error(zV);
      const i = zF.fromMnemonic(Kj.fromPhrase(t, r, n), e);
      return {
        mnemonic: i.mnemonic,
        privateKey: i.privateKey,
        publicKey: i.signingKey.publicKey,
        address: FV(i.privateKey.replace(/^0x/, ""))
      }
    }
    const VV = "TRON Signed Message:\n";

    function ZV(t) {
      return "string" == typeof t ? t = dj(t) : Array.isArray(t) && (t = new Uint8Array(t)), Cj(RR([dj(VV), dj(t.length + ""), t]))
    }

    function qV(t, e) {
      e.match(/^0x/) || (e = "0x" + e);
      const r = new eD(e),
        n = ZV(t),
        i = r.sign(n);
      return K$(i)
    }

    function JV(t, e) {
      return e.match(/^0x/) || (e = "0x" + e), AV(xC(nD(ZV(t), e).replace(/^0x/, Y$)))
    }
    const YV = {
      ...c,
      address: h,
      code: u,
      accounts: g,
      base58: d,
      bytes: a,
      crypto: y,
      abi: b,
      message: v,
      Du: vV,
      transaction: m,
      ethersUtils: l
    };
    var QV, XV, tZ, eZ;
    ! function(t) {
      t[t.BANDWIDTH = 0] = "BANDWIDTH", t[t.ENERGY = 1] = "ENERGY", t[t.TRON_POWER = 2] = "TRON_POWER"
    }(QV || (QV = {})),
    function(t) {
      t.ENOUGH_PERMISSION = "ENOUGH_PERMISSION", t.NOT_ENOUGH_PERMISSION = "NOT_ENOUGH_PERMISSION", t.SIGNATURE_FORMAT_ERROR = "SIGNATURE_FORMAT_ERROR", t.COMPUTE_ADDRESS_ERROR = "COMPUTE_ADDRESS_ERROR", t.PERMISSION_ERROR = "PERMISSION_ERROR", t.OTHER_ERROR = "OTHER_ERROR"
    }(XV || (XV = {})),
    function(t) {
      t[t.SUCCESS = 0] = "SUCCESS", t[t.SIGERROR = 1] = "SIGERROR", t[t.CONTRACT_VALIDATE_ERROR = 2] = "CONTRACT_VALIDATE_ERROR", t[t.CONTRACT_EXE_ERROR = 3] = "CONTRACT_EXE_ERROR", t[t.BANDWITH_ERROR = 4] = "BANDWITH_ERROR", t[t.DUP_TRANSACTION_ERROR = 5] = "DUP_TRANSACTION_ERROR", t[t.TAPOS_ERROR = 6] = "TAPOS_ERROR", t[t.TOO_BIG_TRANSACTION_ERROR = 7] = "TOO_BIG_TRANSACTION_ERROR", t[t.TRANSACTION_EXPIRATION_ERROR = 8] = "TRANSACTION_EXPIRATION_ERROR", t[t.SERVER_BUSY = 9] = "SERVER_BUSY", t[t.NO_CONNECTION = 10] = "NO_CONNECTION", t[t.NOT_ENOUGH_EFFECTIVE_CONNECTION = 11] = "NOT_ENOUGH_EFFECTIVE_CONNECTION", t[t.OTHER_ERROR = 20] = "OTHER_ERROR"
    }(tZ || (tZ = {})),
    function(t) {
      t[t.PENDING = 0] = "PENDING", t[t.DISAPPROVED = 1] = "DISAPPROVED", t[t.APPROVED = 2] = "APPROVED", t[t.CANCELED = 3] = "CANCELED"
    }(eZ || (eZ = {}));
    var rZ, nZ, iZ, oZ, sZ, aZ, uZ = Object.getPrototypeOf,
      cZ = Reflect.get,
      fZ = (t, e, r) => {
        if (!e.has(t)) throw TypeError("Cannot " + r)
      },
      lZ = (t, e, r) => {
        if (e.has(t)) throw TypeError("Cannot add the same private member more than once");
        e instanceof WeakSet ? e.add(t) : e.set(t, r)
      },
      hZ = (t, e, r, n) => (fZ(t, e, "write to private field"), n ? n.call(t, r) : e.set(t, r), r),
      dZ = (t, e, r) => (fZ(t, e, "access private method"), r);
    const pZ = class extends Ue {
      constructor(t) {
        super(), lZ(this, iZ), lZ(this, sZ), this.ready = !1, lZ(this, rZ, void 0), lZ(this, nZ, void 0), t && hZ(this, rZ, t), this.on("accountsChanged", t => {
          0 === t.length ? window.postMessage({
            message: {
              action: "disconnect",
              data: {}
            }
          }, "*") : (this.tronWeb.setAddress(t[0]), window.postMessage({
            message: {
              action: "accountsChanged",
              data: {
                address: t[0]
              }
            }
          }, "*"))
        })
      }
      getNetwork() {
        return pZ.NETWORK
      }
      request(t) {
        const {
          method: e,
          params: r
        } = t;
        return "tron_requestAccounts" === e ? dZ(this, sZ, aZ).call(this) : Promise.resolve(null)
      }
      setNode(t) {
        hZ(this, nZ, t), this.tronWeb = new iV({
          fullHost: t
        })
      }
      async signMessage() {
        throw Error("Not implemented signMessage")
      }
      async signMessageV2(t) {
        return await dZ(this, iZ, oZ).call(this, {
          method: "signMessage",
          params: {
            data: t,
            isEthSign: !1
          }
        })
      }
      async sign(t) {
        if ("object" == typeof t) return await dZ(this, iZ, oZ).call(this, {
          method: "signTransaction",
          params: {
            transaction: t,
            raw: !1
          }
        });
        if ("string" == typeof t) return this.signMessageV2(t);
        throw console.error("tx is not an object"), Error("Invalid TX format")
      }
      async signTransactionOffline() {
        console.log("signTransactionOffline CALLED")
      }
      connect() {
        return dZ(this, sZ, aZ).call(this)
      }
    };
    let bZ = pZ;
    rZ = new WeakMap, nZ = new WeakMap, iZ = new WeakSet, oZ = function(t) {
      return ((t, e) => cZ(uZ(t), "request", e))(pZ.prototype, this).call(this, t)
    }, sZ = new WeakSet, aZ = async function() {
      try {
        const t = await dZ(this, iZ, oZ).call(this, {
          method: "requestAccounts",
          params: {}
        });
        if (t) return this.ready = !0, this.tronWeb.trx.signMessageV2 = this.signMessageV2.bind(this), this.tronWeb.trx.sign = this.sign.bind(this), this.tronWeb.setAddress(t[0]), window.postMessage({
          message: {
            action: "connect",
            data: {}
          }
        }, "*"), {
          code: 200
        }
      } catch (t) {
        return console.error(t), {
          code: 4001
        }
      }
    }, bZ.NETWORK = "tron";
    var mZ = (t, e, r) => new Promise((n, i) => {
      var o = t => {
          try {
            a(r.next(t))
          } catch (t) {
            i(t)
          }
        },
        s = t => {
          try {
            a(r.throw(t))
          } catch (t) {
            i(t)
          }
        },
        a = t => t.done ? n(t.value) : Promise.resolve(t.value).then(o, s);
      a((r = r.apply(t, e)).next())
    });
    class yZ extends rr {
      constructor() {
        super(), this.provider = new bZ
      }
      fetchAlreadyConnectedAccount() {
        return mZ(this, null, function*() {
          const [t] = yield this.bm.emit(ir.ETH_ACCOUNTS, {
            networkId: $t.tron
          });
          t && (yield this.provider.connect())
        })
      }
      boot() {
        Rt("Booting Tron")
      }
      setConnectionUrl() {
        return mZ(this, null, function*() {
          const t = yield this.bm.emit(gn.GET_NODE, $t.tron);
          t?.url && this.provider.setNode(t.url)
        })
      }
      start(t) {
        return mZ(this, null, function*() {
          this.bm = t, yield this.setConnectionUrl(), yield this.fetchAlreadyConnectedAccount(), Object.assign(window.trustwallet, {
            tronLink: this.provider
          });
          const {
            isDefaultWallet: e
          } = yield this.bm.emit(Rr.GET_APP_SETTINGS);
          e && (window.tronLink = this.provider, window.tronWeb = this.provider.tronWeb, window.tron = this.provider)
        })
      }
      registerEventListeners() {
        const t = this.bm;
        t.addListener(Er.SITE_DISCONNECTED, () => {
          Rt(Er.SITE_DISCONNECTED + " received"), this.provider.emit("accountsChanged", [])
        }), t.addListener(Er.ACCOUNT_CHANGED, t => {
          var e;
          const {
            address: r,
            network: n
          } = null != (e = t.data.params) ? e : {};
          n === $t.tron && (Rt(Er.ACCOUNT_CHANGED + " received eth"), this.provider.emit("accountsChanged", r ? [r] : []))
        })
      }
    }
    const gZ = ["facebook.com", "instagram.com", "twitter.com", "tiktok.com", "linkedin.com", "snapchat.com"];
    var vZ = Object.defineProperty,
      wZ = Object.getOwnPropertySymbols,
      AZ = {}.hasOwnProperty,
      TZ = {}.propertyIsEnumerable,
      EZ = (t, e, r) => e in t ? vZ(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
      }) : t[e] = r;
    const PZ = function({
      hostname: t = location.hostname
    }) {
      return gZ.some(e => t === e || t.endsWith("." + e))
    }({
      hostname: new URL(window.location.origin).hostname
    });
    (function() {
      return ((t, e, r) => new Promise((e, n) => {
        var i = t => {
            try {
              s(r.next(t))
            } catch (t) {
              n(t)
            }
          },
          o = t => {
            try {
              s(r.throw(t))
            } catch (t) {
              n(t)
            }
          },
          s = t => t.done ? e(t.value) : Promise.resolve(t.value).then(i, o);
        s((r = r.apply(t, null)).next())
      }))(this, 0, function*() {
        if (!window.isSecureContext || PZ) return void Ct.debug("Insecure context, not injecting provider");
        window.trustwallet = ((t, e) => {
          for (var r in e || (e = {})) AZ.call(e, r) && EZ(t, r, e[r]);
          if (wZ)
            for (var r of wZ(e)) TZ.call(e, r) && EZ(t, r, e[r]);
          return t
        })({}, E);
        const t = new yn,
          e = new Cr,
          r = new UM,
          n = new hC,
          i = new yZ,
          o = new Pr,
          s = (new er).register($t.ethereum, t).register($t.cosmos, e).register($t.solana, r).register($t.binance, o).register($t.ton, n).register($t.tron, i).on(T.RESPONSE_READY, t.onResponseReady.bind(t)).on(T.RESPONSE_READY, r.onResponseReady.bind(r)).on(T.RESPONSE_READY, o.onResponseReady.bind(o)).on(T.RESPONSE_READY, o.onResponseReady.bind(n));
        s.loadCache(), s.earlyInject(), s.boot(), s.start(), s.announce(), Rt(" Trust Wallet Injected")
      })
    })().then(() => Ct.debug("inpage started")).catch(Ct.error)
  })()
})();
